"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror";
exports.ids = ["vendor-chunks/@codemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompletionContext: () => (/* binding */ CompletionContext),\n/* harmony export */   acceptCompletion: () => (/* binding */ acceptCompletion),\n/* harmony export */   autocompletion: () => (/* binding */ autocompletion),\n/* harmony export */   clearSnippet: () => (/* binding */ clearSnippet),\n/* harmony export */   closeBrackets: () => (/* binding */ closeBrackets),\n/* harmony export */   closeBracketsKeymap: () => (/* binding */ closeBracketsKeymap),\n/* harmony export */   closeCompletion: () => (/* binding */ closeCompletion),\n/* harmony export */   completeAnyWord: () => (/* binding */ completeAnyWord),\n/* harmony export */   completeFromList: () => (/* binding */ completeFromList),\n/* harmony export */   completionKeymap: () => (/* binding */ completionKeymap),\n/* harmony export */   completionStatus: () => (/* binding */ completionStatus),\n/* harmony export */   currentCompletions: () => (/* binding */ currentCompletions),\n/* harmony export */   deleteBracketPair: () => (/* binding */ deleteBracketPair),\n/* harmony export */   hasNextSnippetField: () => (/* binding */ hasNextSnippetField),\n/* harmony export */   hasPrevSnippetField: () => (/* binding */ hasPrevSnippetField),\n/* harmony export */   ifIn: () => (/* binding */ ifIn),\n/* harmony export */   ifNotIn: () => (/* binding */ ifNotIn),\n/* harmony export */   insertBracket: () => (/* binding */ insertBracket),\n/* harmony export */   insertCompletionText: () => (/* binding */ insertCompletionText),\n/* harmony export */   moveCompletionSelection: () => (/* binding */ moveCompletionSelection),\n/* harmony export */   nextSnippetField: () => (/* binding */ nextSnippetField),\n/* harmony export */   pickedCompletion: () => (/* binding */ pickedCompletion),\n/* harmony export */   prevSnippetField: () => (/* binding */ prevSnippetField),\n/* harmony export */   selectedCompletion: () => (/* binding */ selectedCompletion),\n/* harmony export */   selectedCompletionIndex: () => (/* binding */ selectedCompletionIndex),\n/* harmony export */   setSelectedCompletion: () => (/* binding */ setSelectedCompletion),\n/* harmony export */   snippet: () => (/* binding */ snippet),\n/* harmony export */   snippetCompletion: () => (/* binding */ snippetCompletion),\n/* harmony export */   snippetKeymap: () => (/* binding */ snippetKeymap),\n/* harmony export */   startCompletion: () => (/* binding */ startCompletion)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/ class CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sourcesâ€”in the editor, the extension will create\n    these for you.)\n    */ constructor(/**\n    The editor state that the completion happens in.\n    */ state, /**\n    The position at which the completion is happening.\n    */ pos, /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */ explicit, /**\n    The editor view. May be undefined if the context was created\n    in a situation where there is no such view available, such as\n    in synchronous updates via\n    [`CompletionResult.update`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.update)\n    or when called by test code.\n    */ view){\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        this.view = view;\n        /**\n        @internal\n        */ this.abortListeners = [];\n        /**\n        @internal\n        */ this.abortOnDocChange = false;\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */ tokenBefore(types) {\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n        while(token && types.indexOf(token.name) < 0)token = token.parent;\n        return token ? {\n            from: token.from,\n            to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type\n        } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */ matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : {\n            from: start + found,\n            to: this.pos,\n            text: str.slice(found)\n        };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */ get aborted() {\n        return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    \n    By default, running queries will not be aborted for regular\n    typing or backspacing, on the assumption that they are likely to\n    return a result with a\n    [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that\n    allows the result to be used after all. Passing `onDocChange:\n    true` will cause this query to be aborted for any document\n    change.\n    */ addEventListener(type, listener, options) {\n        if (type == \"abort\" && this.abortListeners) {\n            this.abortListeners.push(listener);\n            if (options && options.onDocChange) this.abortOnDocChange = true;\n        }\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words) flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options){\n        first[label[0]] = true;\n        for(let i = 1; i < label.length; i++)rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [\n        new RegExp(\"^\" + source),\n        new RegExp(source)\n    ];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/ function completeFromList(list) {\n    let options = list.map((o)=>typeof o == \"string\" ? {\n            label: o\n        } : o);\n    let [validFor, match] = options.every((o)=>/^\\w+$/.test(o.label)) ? [\n        /\\w*$/,\n        /\\w+$/\n    ] : prefixMatch(options);\n    return (context)=>{\n        let token = context.matchBefore(match);\n        return token || context.explicit ? {\n            from: token ? token.from : context.pos,\n            options,\n            validFor\n        } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return source(context);\n            if (pos.type.isTop) break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifNotIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return null;\n            if (pos.type.isTop) break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score){\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) {\n    return state.selection.main.from;\n}\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd) return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/ const pickedCompletion = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/ function insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return {\n        ...state.changeByRange((range)=>{\n            if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {\n                range\n            };\n            let lines = state.toText(text);\n            return {\n                changes: {\n                    from: range.from + fromOff,\n                    to: to == main.from ? range.to : range.from + toOff,\n                    insert: lines\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + fromOff + lines.length)\n            };\n        }),\n        scrollIntoView: true,\n        userEvent: \"input.complete\"\n    };\n}\nconst SourceCache = /*@__PURE__*/ new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source)) return source;\n    let known = SourceCache.get(source);\n    if (!known) SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for(let p = 0; p < pattern.length;){\n            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return this;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0) return this.ret(-100 /* Penalty.NotFull */ , []);\n        if (word.length < this.pattern.length) return null;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0), firstSize = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first);\n            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */ ;\n            if (first == chars[0]) ;\n            else if (first == folded[0]) score += -200 /* Penalty.CaseFold */ ;\n            else return null;\n            return this.ret(score, [\n                0,\n                firstSize\n            ]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ , [\n            0,\n            this.pattern.length\n        ]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for(let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;){\n                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len) return null;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for(let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */ ; i < e && byWordTo < len;){\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0) adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    } else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */  : next >= 65 && next <= 90 ? 1 /* Tp.Upper */  : 0 /* Tp.NonWord */  : (ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */  : ch != ch.toUpperCase() ? 2 /* Tp.Lower */  : 0 /* Tp.NonWord */ ;\n            if (!i || type == 1 /* Tp.Upper */  && hasLower || prevType == 0 /* Tp.NonWord */  && type != 0 /* Tp.NonWord */ ) {\n                if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i;\n                else if (byWord.length) wordAdjacent = false;\n            }\n            prevType = type;\n            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 /* Penalty.CaseFold */  - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */ ), [\n            0,\n            adjacentEnd\n        ]);\n        if (direct > -1) return this.ret(-700 /* Penalty.NotStart */  - word.length, [\n            direct,\n            direct + this.pattern.length\n        ]);\n        if (adjacentTo == len) return this.ret(-200 /* Penalty.CaseFold */  + -700 /* Penalty.NotStart */  - word.length, [\n            adjacentStart,\n            adjacentEnd\n        ]);\n        if (byWordTo == len) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0) + -700 /* Penalty.NotStart */  + (wordAdjacent ? 0 : -1100 /* Penalty.Gap */ ), byWord, word);\n        return chars.length == 2 ? null : this.result((any[0] ? -700 /* Penalty.NotStart */  : 0) + -200 /* Penalty.CaseFold */  + -1100 /* Penalty.Gap */ , any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions){\n            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n            if (i && result[i - 1] == pos) result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\nclass StrictMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.matched = [];\n        this.score = 0;\n        this.folded = pattern.toLowerCase();\n    }\n    match(word) {\n        if (word.length < this.pattern.length) return null;\n        let start = word.slice(0, this.pattern.length);\n        let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 /* Penalty.CaseFold */  : null;\n        if (match == null) return null;\n        this.matched = [\n            0,\n            start.length\n        ];\n        this.score = match + (word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ );\n        return this;\n    }\n}\nconst completionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            activateOnTyping: true,\n            activateOnCompletion: ()=>false,\n            activateOnTypingDelay: 100,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: ()=>\"\",\n            optionClass: ()=>\"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            filterStrict: false,\n            compareCompletions: (a, b)=>a.label.localeCompare(b.label),\n            interactionDelay: 75,\n            updateSyncTime: 100\n        }, {\n            defaultKeymap: (a, b)=>a && b,\n            closeOnBlur: (a, b)=>a && b,\n            icons: (a, b)=>a && b,\n            tooltipClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            optionClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            addToOptions: (a, b)=>a.concat(b),\n            filterStrict: (a, b)=>a || b\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space, tooltip) {\n    let rtl = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Info.Width */ , left ? spaceLeft : spaceRight);\n    } else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Info.Width */ , (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */ );\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) {\n            offset = option.bottom - list.top;\n        } else {\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;\n    let scaleX = (list.right - list.left) / tooltip.offsetWidth;\n    return {\n        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,\n        class: \"cm-completionInfo-\" + (narrow ? rtl ? \"left-narrow\" : \"right-narrow\" : left ? \"left\" : \"right\")\n    };\n}\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons) content.push({\n        render (completion) {\n            let icon = document.createElement(\"div\");\n            icon.classList.add(\"cm-completionIcon\");\n            if (completion.type) icon.classList.add(...completion.type.split(/\\s+/g).map((cls)=>\"cm-completionIcon-\" + cls));\n            icon.setAttribute(\"aria-hidden\", \"true\");\n            return icon;\n        },\n        position: 20\n    });\n    content.push({\n        render (completion, _s, _v, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for(let j = 0; j < match.length;){\n                let from = match[j++], to = match[j++];\n                if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render (completion) {\n            if (!completion.detail) return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b)=>a.position - b.position).map((a)=>a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max) return {\n        from: 0,\n        to: total\n    };\n    if (selected < 0) selected = 0;\n    if (selected <= total >> 1) {\n        let off = Math.floor(selected / max);\n        return {\n            from: off * max,\n            to: (off + 1) * max\n        };\n    }\n    let off = Math.floor((total - selected) / max);\n    return {\n        from: total - (off + 1) * max,\n        to: total - off * max\n    };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion){\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: ()=>this.measureInfo(),\n            write: (pos)=>this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e)=>{\n            let { options } = view.state.field(stateField).open;\n            for(let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode){\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e)=>{\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n        });\n        this.showOptions(options, cState.id);\n    }\n    mount() {\n        this.updateSel();\n    }\n    showOptions(options, id) {\n        if (this.list) this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));\n        this.list.addEventListener(\"scroll\", ()=>{\n            if (this.info) this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    update(update) {\n        var _a;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            let { options, selected, disabled } = cState.open;\n            if (!prevState.open || prevState.open.options != options) {\n                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);\n                this.showOptions(options, cState.id);\n            }\n            this.updateSel();\n            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled)) this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!disabled);\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))if (c) this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))if (c) this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info) this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.showOptions(open.options, cState.id);\n        }\n        let newSel = this.updateSelectedOption(open.selected);\n        if (newSel) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info) return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult) return;\n            if (\"then\" in infoResult) {\n                infoResult.then((obj)=>{\n                    if (obj && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(obj, completion);\n                }).catch((e)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\n            } else {\n                this.addInfoPane(infoResult, completion);\n                newSel.setAttribute(\"aria-describedby\", this.info.id);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        wrap.id = \"cm-completionInfo-\" + Math.floor(Math.random() * 0xffff).toString(16);\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        } else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for(let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++){\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            } else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            } else {\n                if (opt.hasAttribute(\"aria-selected\")) {\n                    opt.removeAttribute(\"aria-selected\");\n                    opt.removeAttribute(\"aria-describedby\");\n                }\n            }\n        }\n        if (set) scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info) return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let docElt = this.dom.ownerDocument.documentElement;\n            space = {\n                left: 0,\n                top: 0,\n                right: docElt.clientWidth,\n                bottom: docElt.clientHeight\n            };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style) this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            } else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        ul.addEventListener(\"mousedown\", (e)=>{\n            // Prevent focus change when clicking the scrollbar\n            if (e.target == ul) e.preventDefault();\n        });\n        let curSection = null;\n        for(let i = range.from; i < range.to; i++){\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    } else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls) li.className = cls;\n            for (let source of this.optionContent){\n                let node = source(completion, this.view.state, this.view, match);\n                if (node) li.appendChild(node);\n            }\n        }\n        if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy) this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view)=>new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    let scaleY = parent.height / container.offsetHeight;\n    if (self.top < parent.top) container.scrollTop -= (parent.top - self.top) / scaleY;\n    else if (self.bottom > parent.bottom) container.scrollTop += (self.bottom - parent.bottom) / scaleY;\n}\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null, dynamicSectionScore = null;\n    let addOption = (option)=>{\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections) sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some((s)=>s.name == name)) sections.push(typeof section == \"string\" ? {\n                name\n            } : section);\n        }\n    };\n    let conf = state.facet(completionConfig);\n    for (let a of active)if (a.hasResult()) {\n        let getMatch = a.result.getMatch;\n        if (a.result.filter === false) {\n            for (let option of a.result.options){\n                addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n            }\n        } else {\n            let pattern = state.sliceDoc(a.from, a.to), match;\n            let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);\n            for (let option of a.result.options)if (match = matcher.match(option.label)) {\n                let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];\n                let score = match.score + (option.boost || 0);\n                addOption(new Option(option, a.source, matched, score));\n                if (typeof option.section == \"object\" && option.section.rank === \"dynamic\") {\n                    let { name } = option.section;\n                    if (!dynamicSectionScore) dynamicSectionScore = Object.create(null);\n                    dynamicSectionScore[name] = Math.max(score, dynamicSectionScore[name] || -1e9);\n                }\n            }\n        }\n    }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b)=>{\n            return (a.rank === \"dynamic\" && b.rank === \"dynamic\" ? dynamicSectionScore[b.name] - dynamicSectionScore[a.name] : 0) || (typeof a.rank == \"number\" ? a.rank : 1e9) - (typeof b.rank == \"number\" ? b.rank : 1e9) || (a.name < b.name ? -1 : 1);\n        };\n        for (let s of sections.sort(cmp)){\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options){\n            let { section } = option.completion;\n            if (section) option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = conf.compareCompletions;\n    for (let opt of options.sort((a, b)=>b.score - a.score || compare(a.completion, b.completion))){\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail || prev.type != null && cur.type != null && prev.type != cur.type || prev.apply != cur.apply || prev.boost != cur.boost) result.push(opt);\n        else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled){\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf, didSetActive) {\n        if (prev && !didSetActive && active.some((s)=>s.isPending)) return prev.setDisabled();\n        let options = sortOptions(active, state);\n        if (!options.length) return prev && active.some((a)=>a.isPending) ? prev.setDisabled() : null;\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for(let i = 0; i < options.length; i++)if (options[i].completion == selectedValue) {\n                selected = i;\n                break;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b)=>b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: createTooltip,\n            above: conf.aboveCursor\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, {\n            ...this.tooltip,\n            pos: changes.mapPos(this.tooltip.pos)\n        }, this.timestamp, this.selected, this.disabled);\n    }\n    setDisabled() {\n        return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open){\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map((source)=>{\n            let value = this.active.find((s)=>s.source == source) || new ActiveSource(source, this.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i)=>a == this.active[i])) active = this.active;\n        let open = this.open, didSet = tr.effects.some((e)=>e.is(setActiveEffect));\n        if (open && tr.docChanged) open = open.map(tr.changes);\n        if (tr.selection || active.some((a)=>a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet) open = CompletionDialog.build(active, state, this.id, open, conf, didSet);\n        else if (open && open.disabled && !active.some((a)=>a.isPending)) open = null;\n        if (!open && active.every((a)=>!a.isPending) && active.some((a)=>a.hasResult())) active = active.map((a)=>a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */ ) : a);\n        for (let effect of tr.effects)if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() {\n        return this.open ? this.open.tooltip : null;\n    }\n    get attrs() {\n        return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;\n    }\n}\nfunction sameResults(a, b) {\n    if (a == b) return true;\n    for(let iA = 0, iB = 0;;){\n        while(iA < a.length && !a[iA].hasResult())iA++;\n        while(iB < b.length && !b[iB].hasResult())iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB) return endA == endB;\n        if (a[iA++].result != b[iB++].result) return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nconst noAttrs = {};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUpdateType(tr, conf) {\n    if (tr.isUserEvent(\"input.complete\")) {\n        let completion = tr.annotation(pickedCompletion);\n        if (completion && conf.activateOnCompletion(completion)) return 4 /* UpdateType.Activate */  | 8 /* UpdateType.Reset */ ;\n    }\n    let typing = tr.isUserEvent(\"input.type\");\n    return typing && conf.activateOnTyping ? 4 /* UpdateType.Activate */  | 1 /* UpdateType.Typing */  : typing ? 1 /* UpdateType.Typing */  : tr.isUserEvent(\"delete.backward\") ? 2 /* UpdateType.Backspacing */  : tr.selection ? 8 /* UpdateType.Reset */  : tr.docChanged ? 16 /* UpdateType.ResetIfTouching */  : 0 /* UpdateType.None */ ;\n}\nclass ActiveSource {\n    constructor(source, state, explicit = false){\n        this.source = source;\n        this.state = state;\n        this.explicit = explicit;\n    }\n    hasResult() {\n        return false;\n    }\n    get isPending() {\n        return this.state == 1 /* State.Pending */ ;\n    }\n    update(tr, conf) {\n        let type = getUpdateType(tr, conf), value = this;\n        if (type & 8 /* UpdateType.Reset */  || type & 16 /* UpdateType.ResetIfTouching */  && this.touches(tr)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n        if (type & 4 /* UpdateType.Activate */  && value.state == 0 /* State.Inactive */ ) value = new ActiveSource(this.source, 1 /* State.Pending */ );\n        value = value.updateFor(tr, type);\n        for (let effect of tr.effects){\n            if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1 /* State.Pending */ , effect.value);\n            else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n            else if (effect.is(setActiveEffect)) {\n                for (let active of effect.value)if (active.source == value.source) value = active;\n            }\n        }\n        return value;\n    }\n    updateFor(tr, type) {\n        return this.map(tr.changes);\n    }\n    map(changes) {\n        return this;\n    }\n    touches(tr) {\n        return tr.changes.touchesRange(cur(tr.state));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicit, limit, result, from, to){\n        super(source, 3 /* State.Result */ , explicit);\n        this.limit = limit;\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() {\n        return true;\n    }\n    updateFor(tr, type) {\n        var _a;\n        if (!(type & 3 /* UpdateType.SimpleInteraction */ )) return this.map(tr.changes);\n        let result = this.result;\n        if (result.map && !tr.changes.empty) result = result.map(result, tr.changes);\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if (pos > to || !result || type & 2 /* UpdateType.Backspacing */  && (cur(tr.startState) == this.from || pos < this.limit)) return new ActiveSource(this.source, type & 4 /* UpdateType.Activate */  ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n        let limit = tr.changes.mapPos(this.limit);\n        if (checkValid(result.validFor, tr.state, from, to)) return new ActiveResult(this.source, this.explicit, limit, result, from, to);\n        if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false)))) return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* State.Pending */ , this.explicit);\n    }\n    map(mapping) {\n        if (mapping.empty) return this;\n        let result = this.result.map ? this.result.map(this.result, mapping) : this.result;\n        if (!result) return new ActiveSource(this.source, 0 /* State.Inactive */ );\n        return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n    touches(tr) {\n        return tr.changes.touchesRange(this.from, this.to);\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor) return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (sources, mapping) {\n        return sources.map((s)=>s.map(mapping));\n    }\n});\nconst setSelectedEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst completionState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return CompletionState.start();\n    },\n    update (value, tr) {\n        return value.update(tr);\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, (val)=>val.tooltip),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, (state)=>state.attrs)\n        ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find((a)=>a.source == option.source);\n    if (!(result instanceof ActiveResult)) return false;\n    if (typeof apply == \"string\") view.dispatch({\n        ...insertCompletionText(view.state, apply, result.from, result.to),\n        annotations: pickedCompletion.of(option.completion)\n    });\n    else apply(view, option.completion, result.from, result.to);\n    return true;\n}\nconst createTooltip = /*@__PURE__*/ completionTooltip(completionState, applyCompletion);\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/ function moveCompletionSelection(forward, by = \"option\") {\n    return (view)=>{\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0) selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({\n            effects: setSelectedEffect.of(selected)\n        });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/ const acceptCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/ const startCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState) return false;\n    view.dispatch({\n        effects: startCompletionEffect.of(true)\n    });\n    return true;\n};\n/**\nClose the currently active completion.\n*/ const closeCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some((a)=>a.state != 0 /* State.Inactive */ )) return false;\n    view.dispatch({\n        effects: closeCompletionEffect.of(null)\n    });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context){\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.pendingStart = false;\n        this.composing = 0 /* CompositionState.None */ ;\n        for (let active of view.state.field(completionState).active)if (active.isPending) this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        let conf = update.state.facet(completionConfig);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n        let doesReset = update.transactions.some((tr)=>{\n            let type = getUpdateType(tr, conf);\n            return type & 8 /* UpdateType.Reset */  || (tr.selection || tr.docChanged) && !(type & 3 /* UpdateType.SimpleInteraction */ );\n        });\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners){\n                    try {\n                        handler();\n                    } catch (e) {\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            } else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n        if (update.transactions.some((tr)=>tr.effects.some((e)=>e.is(startCompletionEffect)))) this.pendingStart = true;\n        let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;\n        this.debounceUpdate = cState.active.some((a)=>a.isPending && !this.running.some((q)=>q.active.source == a.source)) ? setTimeout(()=>this.startUpdate(), delay) : -1;\n        if (this.composing != 0 /* CompositionState.None */ ) for (let tr of update.transactions){\n            if (tr.isUserEvent(\"input.type\")) this.composing = 2 /* CompositionState.Changed */ ;\n            else if (this.composing == 2 /* CompositionState.Changed */  && tr.selection) this.composing = 3 /* CompositionState.ChangedAndMoved */ ;\n        }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        this.pendingStart = false;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active){\n            if (active.isPending && !this.running.some((r)=>r.active.source == active.source)) this.startQuery(active);\n        }\n        if (this.running.length && cState.open && cState.open.disabled) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicit, this.view);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then((result)=>{\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, (err)=>{\n            this.view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every((q)=>q.done !== undefined)) this.accept();\n        else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (query.done === undefined) continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);\n                let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));\n                let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : pos);\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = cState.active.find((a)=>a.source == query.active.source);\n            if (current && current.isPending) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */ );\n                    for (let tr of query.updates)active = active.update(tr, conf);\n                    if (!active.isPending) updated.push(active);\n                } else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length || cState.open && cState.open.disabled) this.view.dispatch({\n            effects: setActiveEffect.of(updated)\n        });\n    }\n}, {\n    eventHandlers: {\n        blur (event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget)) setTimeout(()=>this.view.dispatch({\n                        effects: closeCompletionEffect.of(null)\n                    }), 10);\n            }\n        },\n        compositionstart () {\n            this.composing = 1 /* CompositionState.Started */ ;\n        },\n        compositionend () {\n            if (this.composing == 3 /* CompositionState.ChangedAndMoved */ ) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(()=>this.view.dispatch({\n                        effects: startCompletionEffect.of(false)\n                    }), 20);\n            }\n            this.composing = 0 /* CompositionState.None */ ;\n        }\n    }\n});\nconst windows = typeof navigator == \"object\" && /*@__PURE__*/ /Win/.test(navigator.platform);\nconst commitCharacters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    keydown (event, view) {\n        let field = view.state.field(completionState, false);\n        if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey) return false;\n        let option = field.open.options[field.open.selected];\n        let result = field.active.find((a)=>a.source == option.source);\n        let commitChars = option.completion.commitCharacters || result.result.commitCharacters;\n        if (commitChars && commitChars.indexOf(event.key) > -1) applyCompletion(view, option);\n        return false;\n    }\n}));\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\"\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\"\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\"\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\"\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"\\xb7\\xb7\\xb7\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Info.Width */ }px`,\n        boxSizing: \"border-box\",\n        whiteSpace: \"pre-line\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": {\n        right: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-right\": {\n        left: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": {\n        right: `${30 /* Info.Margin */ }px`\n    },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": {\n        left: `${30 /* Info.Margin */ }px`\n    },\n    \"&light .cm-snippetField\": {\n        backgroundColor: \"#00000022\"\n    },\n    \"&dark .cm-snippetField\": {\n        backgroundColor: \"#ffffff22\"\n    },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": {\n            content: \"'Æ’'\"\n        }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": {\n            content: \"'â—‹'\"\n        }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": {\n            content: \"'â—Œ'\"\n        }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC65'\"\n        }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC36'\"\n        }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC61'\"\n        }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": {\n            content: \"'âˆª'\"\n        }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": {\n            content: \"'â–¡'\"\n        }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": {\n            content: \"'\\uD83D\\uDD11ï¸Ž'\"\n        } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": {\n            content: \"'â–¢'\"\n        }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": {\n            content: \"'abc'\",\n            fontSize: \"50%\",\n            verticalAlign: \"middle\"\n        }\n    }\n});\nclass FieldPos {\n    constructor(field, line, from, to){\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to){\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions){\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [\n            pos\n        ];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines){\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for(let i = 0; i < tabs; i++)indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map((pos)=>new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return {\n            text,\n            ranges\n        };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)){\n            while(m = /[#$]\\{(?:(\\d+)(?::([^{}]*))?|((?:\\\\[{}]|[^{}])*))\\}/.exec(line)){\n                let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || \"\", found = -1;\n                let name = rawName.replace(/\\\\[{}]/g, (m)=>m[1]);\n                for(let i = 0; i < fields.length; i++){\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while(i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))i++;\n                    fields.splice(i, 0, {\n                        seq,\n                        name\n                    });\n                    found = i;\n                    for (let pos of positions)if (pos.field >= found) pos.field++;\n                }\n                for (let pos of positions)if (pos.line == lines.length && pos.from > m.index) {\n                    let snip = m[2] ? 3 + (m[1] || \"\").length : 2;\n                    pos.from -= snip;\n                    pos.to -= snip;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);\n            }\n            line = line.replace(/\\\\([{}])/g, (_, brace, index)=>{\n                for (let pos of positions)if (pos.line == lines.length && pos.from > index) {\n                    pos.from--;\n                    pos.to--;\n                }\n                return brace;\n            });\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() {\n            return false;\n        }\n    }\n});\nlet fieldRange = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-snippetField\"\n});\nclass ActiveSnippet {\n    constructor(ranges, active){\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map((r)=>(r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)), true);\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges){\n            let mapped = r.map(changes);\n            if (!mapped) return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every((range)=>this.ranges.some((r)=>r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, changes) {\n        return value && value.map(changes);\n    }\n});\nconst moveToField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst snippetState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return null;\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setActive)) return effect.value;\n            if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged) value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, (val)=>val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter((r)=>r.field == field).map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/ function snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to)=>{\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let { main } = editor.state.selection;\n        let spec = {\n            changes: {\n                from,\n                to: to == main.from ? main.to : to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text)\n            },\n            scrollIntoView: true,\n            annotations: completion ? [\n                pickedCompletion.of(completion),\n                _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent.of(\"input.complete\")\n            ] : undefined\n        };\n        if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n        if (ranges.some((r)=>r.field > 0)) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [\n                setActive.of(active)\n            ];\n            if (editor.state.field(snippetState, false) === undefined) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n                snippetState,\n                addSnippetKeymap,\n                snippetPointerHandler,\n                baseTheme\n            ]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch })=>{\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0) return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some((r)=>r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),\n            scrollIntoView: true\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/ const clearSnippet = ({ state, dispatch })=>{\n    let active = state.field(snippetState, false);\n    if (!active) return false;\n    dispatch(state.update({\n        effects: setActive.of(null)\n    }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/ const nextSnippetField = /*@__PURE__*/ moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/ const prevSnippetField = /*@__PURE__*/ moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/ function hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some((r)=>r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/ function hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    {\n        key: \"Tab\",\n        run: nextSnippetField,\n        shift: prevSnippetField\n    },\n    {\n        key: \"Escape\",\n        run: clearSnippet\n    }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/ const snippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (maps) {\n        return maps.length ? maps[0] : defaultSnippetKeymap;\n    }\n});\nconst addSnippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([\n    snippetKeymap\n], (state)=>state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/ function snippetCompletion(template, completion) {\n    return {\n        ...completion,\n        apply: snippet(template)\n    };\n}\nconst snippetPointerHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    mousedown (event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({\n            x: event.clientX,\n            y: event.clientY\n        })) == null) return false;\n        let match = active.ranges.find((r)=>r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active) return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some((r)=>r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),\n            scrollIntoView: true\n        });\n        return true;\n    }\n});\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\]\\-\\\\]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    } catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/ Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for(let lines = doc.iterLines(), pos = 0; !lines.next().done;){\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while(m = wordRE.exec(value)){\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({\n                    type: \"text\",\n                    label: m[0]\n                });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* C.MaxList */ ) return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* C.MinCacheLen */ ;\n    let cached = big && cache.get(doc);\n    if (cached) return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children){\n            if (ch.length >= 1000 /* C.MinCacheLen */ ) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)){\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            } else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    } else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* C.MaxList */ ) cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/ const completeAnyWord = (context)=>{\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, (s)=>s + \"$\"));\n    if (!token && !context.explicit) return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */ , from);\n    return {\n        from,\n        options,\n        validFor: mapRE(re, (s)=>\"^\" + s)\n    };\n};\nconst defaults = {\n    brackets: [\n        \"(\",\n        \"[\",\n        \"{\",\n        \"'\",\n        '\"'\n    ],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, mapping) {\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/ new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    },\n    update (value, tr) {\n        value = value.map(tr.changes);\n        if (tr.selection) {\n            let line = tr.state.doc.lineAt(tr.selection.main.head);\n            value = value.update({\n                filter: (from)=>from >= line.from && from <= line.to\n            });\n        }\n        for (let effect of tr.effects)if (effect.is(closeBracketEffect)) value = value.update({\n            add: [\n                closedBracket.range(effect.value, effect.value + 1)\n            ]\n        });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/ function closeBrackets() {\n    return [\n        inputHandler,\n        bracketState\n    ];\n}\nconst definedClosing = \"()[]{}<>\\xab\\xbb\\xbb\\xabï¼»ï¼½ï½›ï½\";\nfunction closing(ch) {\n    for(let i = 0; i < definedClosing.length; i += 2)if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr) return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/ const deleteBracketPair = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens){\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0))) return {\n                    changes: {\n                        from: range.head - token.length,\n                        to: range.head + token.length\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length)\n                };\n            }\n        }\n        return {\n            range: dont = range\n        };\n    });\n    if (!dont) dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"delete.backward\"\n    }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/ const closeBracketsKeymap = [\n    {\n        key: \"Backspace\",\n        run: deleteBracketPair\n    }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert bracketsâ€”the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/ function insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens){\n        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\n        if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, (from)=>{\n        if (from == pos) found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: open,\n                    from: range.from\n                },\n                {\n                    insert: close,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length)\n        };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n            changes: {\n                insert: open + close,\n                from: range.head\n            },\n            effects: closeBracketEffect.of(range.head + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length)\n        };\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty && nextChar(state.doc, range.head) == close) return {\n            changes: {\n                from: range.head,\n                to: range.head + close.length,\n                insert: close\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length)\n        };\n        return dont = {\n            range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: token,\n                    from: range.from\n                },\n                {\n                    insert: token,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + token.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length)\n        };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return {\n                    changes: {\n                        insert: token + token,\n                        from: pos\n                    },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n                };\n            } else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return {\n                    changes: {\n                        from: pos,\n                        to: pos + content.length,\n                        insert: content\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + content.length)\n                };\n            }\n        } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {\n            return {\n                changes: {\n                    insert: token + token + token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        } else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {\n                changes: {\n                    insert: token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        }\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p)=>Math.max(m, p.length), 0);\n    for(let i = 0; i < 5; i++){\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while(first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos){\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent) break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return pos;\n    for (let prefix of prefixes){\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return start;\n    }\n    return -1;\n}\n/**\nReturns an extension that enables autocompletion.\n*/ function autocompletion(config = {}) {\n    return [\n        commitCharacters,\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space (and Alt-\\` or Alt-i on macOS): [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/ const completionKeymap = [\n    {\n        key: \"Ctrl-Space\",\n        run: startCompletion\n    },\n    {\n        mac: \"Alt-`\",\n        run: startCompletion\n    },\n    {\n        mac: \"Alt-i\",\n        run: startCompletion\n    },\n    {\n        key: \"Escape\",\n        run: closeCompletion\n    },\n    {\n        key: \"ArrowDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true)\n    },\n    {\n        key: \"ArrowUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false)\n    },\n    {\n        key: \"PageDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true, \"page\")\n    },\n    {\n        key: \"PageUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false, \"page\")\n    },\n    {\n        key: \"Enter\",\n        run: acceptCompletion\n    }\n];\nconst completionKeymapExt = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([\n    completionConfig\n], (state)=>state.facet(completionConfig).defaultKeymap ? [\n        completionKeymap\n    ] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/ function completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some((a)=>a.isPending) ? \"pending\" : cState && cState.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/ new WeakMap;\n/**\nReturns the available completions as an array.\n*/ function currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled) return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions) completionArrayCache.set(open.options, completions = open.options.map((o)=>o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/ function selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/ function selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/ function setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdPO0FBQ3BGO0FBQzlFO0FBRTlEOztBQUVBLEdBQ0EsTUFBTTJCO0lBQ0Y7Ozs7SUFJQSxHQUNBQyxZQUNBOztJQUVBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7O0lBS0EsR0FDQUMsUUFBUSxFQUNSOzs7Ozs7SUFNQSxHQUNBQyxJQUFJLENBQUU7UUFDRixJQUFJLENBQUNILEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1o7O1FBRUEsR0FDQSxJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztJQUM1QjtJQUNBOzs7SUFHQSxHQUNBQyxZQUFZQyxLQUFLLEVBQUU7UUFDZixJQUFJQyxRQUFRWixnRUFBVUEsQ0FBQyxJQUFJLENBQUNJLEtBQUssRUFBRVMsWUFBWSxDQUFDLElBQUksQ0FBQ1IsR0FBRyxFQUFFLENBQUM7UUFDM0QsTUFBT08sU0FBU0QsTUFBTUcsT0FBTyxDQUFDRixNQUFNRyxJQUFJLElBQUksRUFDeENILFFBQVFBLE1BQU1JLE1BQU07UUFDeEIsT0FBT0osUUFBUTtZQUFFSyxNQUFNTCxNQUFNSyxJQUFJO1lBQUVDLElBQUksSUFBSSxDQUFDYixHQUFHO1lBQzNDYyxNQUFNLElBQUksQ0FBQ2YsS0FBSyxDQUFDZ0IsUUFBUSxDQUFDUixNQUFNSyxJQUFJLEVBQUUsSUFBSSxDQUFDWixHQUFHO1lBQzlDZ0IsTUFBTVQsTUFBTVMsSUFBSTtRQUFDLElBQUk7SUFDN0I7SUFDQTs7O0lBR0EsR0FDQUMsWUFBWUMsSUFBSSxF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QUFFO0lBQ2IsSUFBSW9XLGNBQWNGLHFCQUFxQnJnQixHQUFHLENBQUMySSxLQUFLM00sT0FBTztJQUN2RCxJQUFJLENBQUN1a0IsYUFDREYscUJBQXFCcGdCLEdBQUcsQ0FBQzBJLEtBQUszTSxPQUFPLEVBQUV1a0IsY0FBYzVYLEtBQUszTSxPQUFPLENBQUN1QixHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVVLFVBQVU7SUFDM0YsT0FBT3FpQjtBQUNYO0FBQ0E7O0FBRUEsR0FDQSxTQUFTQyxtQkFBbUIxbUIsS0FBSztJQUM3QixJQUFJeUU7SUFDSixJQUFJb0ssT0FBTyxDQUFDcEssS0FBS3pFLE1BQU00TyxLQUFLLENBQUMySSxpQkFBaUIsTUFBSyxNQUFPLFFBQVE5UyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdvSyxJQUFJO0lBQ2xHLE9BQU9BLFFBQVEsQ0FBQ0EsS0FBS3dCLFFBQVEsSUFBSXhCLEtBQUtmLFFBQVEsSUFBSSxJQUFJZSxLQUFLM00sT0FBTyxDQUFDMk0sS0FBS2YsUUFBUSxDQUFDLENBQUMxSixVQUFVLEdBQUc7QUFDbkc7QUFDQTs7O0FBR0EsR0FDQSxTQUFTdWlCLHdCQUF3QjNtQixLQUFLO0lBQ2xDLElBQUl5RTtJQUNKLElBQUlvSyxPQUFPLENBQUNwSyxLQUFLekUsTUFBTTRPLEtBQUssQ0FBQzJJLGlCQUFpQixNQUFLLE1BQU8sUUFBUTlTLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR29LLElBQUk7SUFDbEcsT0FBT0EsUUFBUSxDQUFDQSxLQUFLd0IsUUFBUSxJQUFJeEIsS0FBS2YsUUFBUSxJQUFJLElBQUllLEtBQUtmLFFBQVEsR0FBRztBQUMxRTtBQUNBOzs7QUFHQSxHQUNBLFNBQVM4WSxzQkFBc0JsSSxLQUFLO0lBQ2hDLE9BQU9ySSxrQkFBa0IxRyxFQUFFLENBQUMrTztBQUNoQztBQUU2aEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybmNvZGUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanM/YTEwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uLCBTdGF0ZUVmZmVjdCwgRWRpdG9yU2VsZWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgZnJvbUNvZGVQb2ludCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFByZWMsIFRleHQsIFRyYW5zYWN0aW9uLCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBSYW5nZVNldCwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uLCBsb2dFeGNlcHRpb24sIHNob3dUb29sdGlwLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBnZXRUb29sdGlwLCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5cbi8qKlxuQW4gaW5zdGFuY2Ugb2YgdGhpcyBpcyBwYXNzZWQgdG8gY29tcGxldGlvbiBzb3VyY2UgZnVuY3Rpb25zLlxuKi9cbmNsYXNzIENvbXBsZXRpb25Db250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgIGNvbXBsZXRpb24gc291cmNlc+KAlGluIHRoZSBlZGl0b3IsIHRoZSBleHRlbnNpb24gd2lsbCBjcmVhdGVcbiAgICB0aGVzZSBmb3IgeW91LilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY29tcGxldGlvbiBpcyBoYXBwZW5pbmcuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIGNvbXBsZXRpb24gd2FzIGFjdGl2YXRlZCBleHBsaWNpdGx5LCBvclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xuICAgIG9ubHkgcmV0dXJuIGNvbXBsZXRpb25zIHdoZW4gZWl0aGVyIHRoZXJlIGlzIHBhcnQgb2YgYVxuICAgIGNvbXBsZXRhYmxlIGVudGl0eSBiZWZvcmUgdGhlIGN1cnNvciwgb3IgYGV4cGxpY2l0YCBpcyB0cnVlLlxuICAgICovXG4gICAgZXhwbGljaXQsIFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igdmlldy4gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgY29udGV4dCB3YXMgY3JlYXRlZFxuICAgIGluIGEgc2l0dWF0aW9uIHdoZXJlIHRoZXJlIGlzIG5vIHN1Y2ggdmlldyBhdmFpbGFibGUsIHN1Y2ggYXNcbiAgICBpbiBzeW5jaHJvbm91cyB1cGRhdGVzIHZpYVxuICAgIFtgQ29tcGxldGlvblJlc3VsdC51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uUmVzdWx0LnVwZGF0ZSlcbiAgICBvciB3aGVuIGNhbGxlZCBieSB0ZXN0IGNvZGUuXG4gICAgKi9cbiAgICB2aWV3KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hYm9ydE9uRG9jQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXG4gICAgdG9rZW4gYmVmb3JlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICB0b2tlbkJlZm9yZSh0eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSBzeW50YXhUcmVlKHRoaXMuc3RhdGUpLnJlc29sdmVJbm5lcih0aGlzLnBvcywgLTEpO1xuICAgICAgICB3aGlsZSAodG9rZW4gJiYgdHlwZXMuaW5kZXhPZih0b2tlbi5uYW1lKSA8IDApXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuID8geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdGhpcy5wb3MsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnN0YXRlLnNsaWNlRG9jKHRva2VuLmZyb20sIHRoaXMucG9zKSxcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxuICAgIGN1cnNvci5cbiAgICAqL1xuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIHRoaXMucG9zIC0gMjUwKTtcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgZm91bmQgPSBzdHIuc2VhcmNoKGVuc3VyZUFuY2hvcihleHByLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHsgZnJvbTogc3RhcnQgKyBmb3VuZCwgdG86IHRoaXMucG9zLCB0ZXh0OiBzdHIuc2xpY2UoZm91bmQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFlpZWxkcyB0cnVlIHdoZW4gdGhlIHF1ZXJ5IGhhcyBiZWVuIGFib3J0ZWQuIENhbiBiZSB1c2VmdWwgaW5cbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7IHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7IH1cbiAgICAvKipcbiAgICBBbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFib3J0IGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgdGhlIHF1ZXJ5IGlzXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHJ1bm5pbmcgcXVlcmllcyB3aWxsIG5vdCBiZSBhYm9ydGVkIGZvciByZWd1bGFyXG4gICAgdHlwaW5nIG9yIGJhY2tzcGFjaW5nLCBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZXkgYXJlIGxpa2VseSB0b1xuICAgIHJldHVybiBhIHJlc3VsdCB3aXRoIGFcbiAgICBbYHZhbGlkRm9yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvblJlc3VsdC52YWxpZEZvcikgZmllbGQgdGhhdFxuICAgIGFsbG93cyB0aGUgcmVzdWx0IHRvIGJlIHVzZWQgYWZ0ZXIgYWxsLiBQYXNzaW5nIGBvbkRvY0NoYW5nZTpcbiAgICB0cnVlYCB3aWxsIGNhdXNlIHRoaXMgcXVlcnkgdG8gYmUgYWJvcnRlZCBmb3IgYW55IGRvY3VtZW50XG4gICAgY2hhbmdlLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25Eb2NDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydE9uRG9jQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU2V0KGNoYXJzKSB7XG4gICAgbGV0IGZsYXQgPSBPYmplY3Qua2V5cyhjaGFycykuam9pbihcIlwiKTtcbiAgICBsZXQgd29yZHMgPSAvXFx3Ly50ZXN0KGZsYXQpO1xuICAgIGlmICh3b3JkcylcbiAgICAgICAgZmxhdCA9IGZsYXQucmVwbGFjZSgvXFx3L2csIFwiXCIpO1xuICAgIHJldHVybiBgWyR7d29yZHMgPyBcIlxcXFx3XCIgOiBcIlwifSR7ZmxhdC5yZXBsYWNlKC9bXlxcd1xcc10vZywgXCJcXFxcJCZcIil9XWA7XG59XG5mdW5jdGlvbiBwcmVmaXhNYXRjaChvcHRpb25zKSB7XG4gICAgbGV0IGZpcnN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgeyBsYWJlbCB9IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgZmlyc3RbbGFiZWxbMF1dID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3RbbGFiZWxbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNvdXJjZSA9IHRvU2V0KGZpcnN0KSArIHRvU2V0KHJlc3QpICsgXCIqJFwiO1xuICAgIHJldHVybiBbbmV3IFJlZ0V4cChcIl5cIiArIHNvdXJjZSksIG5ldyBSZWdFeHAoc291cmNlKV07XG59XG4vKipcbkdpdmVuIGEgYSBmaXhlZCBhcnJheSBvZiBvcHRpb25zLCByZXR1cm4gYW4gYXV0b2NvbXBsZXRlciB0aGF0XG5jb21wbGV0ZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21MaXN0KGxpc3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGxpc3QubWFwKG8gPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IG8gfSA6IG8pO1xuICAgIGxldCBbdmFsaWRGb3IsIG1hdGNoXSA9IG9wdGlvbnMuZXZlcnkobyA9PiAvXlxcdyskLy50ZXN0KG8ubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHByZWZpeE1hdGNoKG9wdGlvbnMpO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IGNvbnRleHQuZXhwbGljaXQgPyB7IGZyb206IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zLCBvcHRpb25zLCB2YWxpZEZvciB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgb25seSBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gsIHNjb3JlKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb207IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG4vKipcblRoaXMgYW5ub3RhdGlvbiBpcyBhZGRlZCB0byB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgcHJvZHVjZWQgYnlcbnBpY2tpbmcgYSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IHBpY2tlZENvbXBsZXRpb24gPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggaW5zZXJ0cyBhXG5jb21wbGV0aW9uJ3MgdGV4dCBpbiB0aGUgbWFpbiBzZWxlY3Rpb24gcmFuZ2UsIGFuZCBhbnkgb3RoZXJcbnNlbGVjdGlvbiByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSB0ZXh0IGluIGZyb250IG9mIGl0LlxuKi9cbmZ1bmN0aW9uIGluc2VydENvbXBsZXRpb25UZXh0KHN0YXRlLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIGxldCB7IG1haW4gfSA9IHN0YXRlLnNlbGVjdGlvbiwgZnJvbU9mZiA9IGZyb20gLSBtYWluLmZyb20sIHRvT2ZmID0gdG8gLSBtYWluLmZyb207XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBpZiAocmFuZ2UgIT0gbWFpbiAmJiBmcm9tICE9IHRvICYmXG4gICAgICAgICAgICAgICAgc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSArIGZyb21PZmYsIHJhbmdlLmZyb20gKyB0b09mZikgIT0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGF0ZS50b1RleHQodGV4dCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSArIGZyb21PZmYsIHRvOiB0byA9PSBtYWluLmZyb20gPyByYW5nZS50byA6IHJhbmdlLmZyb20gKyB0b09mZiwgaW5zZXJ0OiBsaW5lcyB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBmcm9tT2ZmICsgbGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIlxuICAgIH07XG59XG5jb25zdCBTb3VyY2VDYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gYXNTb3VyY2Uoc291cmNlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IGtub3duID0gU291cmNlQ2FjaGUuZ2V0KHNvdXJjZSk7XG4gICAgaWYgKCFrbm93bilcbiAgICAgICAgU291cmNlQ2FjaGUuc2V0KHNvdXJjZSwga25vd24gPSBjb21wbGV0ZUZyb21MaXN0KHNvdXJjZSkpO1xuICAgIHJldHVybiBrbm93bjtcbn1cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNsb3NlQ29tcGxldGlvbkVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcblxuLy8gQSBwYXR0ZXJuIG1hdGNoZXIgZm9yIGZ1enp5IGNvbXBsZXRpb24gbWF0Y2hpbmcuIENyZWF0ZSBhbiBpbnN0YW5jZVxuLy8gb25jZSBmb3IgYSBwYXR0ZXJuLCBhbmQgdGhlbiB1c2UgdGhhdCB0byBtYXRjaCBhbnkgbnVtYmVyIG9mXG4vLyBjb21wbGV0aW9ucy5cbmNsYXNzIEZ1enp5TWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICAgIHRoaXMuZm9sZGVkID0gW107XG4gICAgICAgIC8vIEJ1ZmZlcnMgcmV1c2VkIGJ5IGNhbGxzIHRvIGBtYXRjaGAgdG8gdHJhY2sgbWF0Y2hlZCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gcG9zaXRpb25zLlxuICAgICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBbXTtcbiAgICAgICAgdGhpcy5ieVdvcmQgPSBbXTtcbiAgICAgICAgdGhpcy5zY29yZSA9IDA7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdHRlcm4ubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSBjb2RlUG9pbnRBdChwYXR0ZXJuLCBwKSwgc2l6ZSA9IGNvZGVQb2ludFNpemUoY2hhcik7XG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHBhdHRlcm4uc2xpY2UocCwgcCArIHNpemUpLCB1cHBlciA9IHBhcnQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZGVkLnB1c2goY29kZVBvaW50QXQodXBwZXIgPT0gcGFydCA/IHBhcnQudG9Mb3dlckNhc2UoKSA6IHVwcGVyLCAwKSk7XG4gICAgICAgICAgICBwICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3RyYWwgPSBwYXR0ZXJuLmxlbmd0aCAhPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0KHNjb3JlLCBtYXRjaGVkKSB7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gbWF0Y2hlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIE1hdGNoZXMgYSBnaXZlbiB3b3JkIChjb21wbGV0aW9uKSBhZ2FpbnN0IHRoZSBwYXR0ZXJuIChpbnB1dCkuXG4gICAgLy8gV2lsbCByZXR1cm4gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSB3YXMgYSBtYXRjaCBhbmQsXG4gICAgLy8gb24gc3VjY2Vzcywgc2V0IGB0aGlzLnNjb3JlYCB0byB0aGUgc2NvcmUsIGB0aGlzLm1hdGNoZWRgIHRvIGFuXG4gICAgLy8gYXJyYXkgb2YgYGZyb20sIHRvYCBwYWlycyBpbmRpY2F0aW5nIHRoZSBtYXRjaGVkIHBhcnRzIG9mIGB3b3JkYC5cbiAgICAvL1xuICAgIC8vIFRoZSBzY29yZSBpcyBhIG51bWJlciB0aGF0IGlzIG1vcmUgbmVnYXRpdmUgdGhlIHdvcnNlIHRoZSBtYXRjaFxuICAgIC8vIGlzLiBTZWUgYFBlbmFsdHlgIGFib3ZlLlxuICAgIG1hdGNoKHdvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLywgW10pO1xuICAgICAgICBpZiAod29yZC5sZW5ndGggPCB0aGlzLnBhdHRlcm4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB7IGNoYXJzLCBmb2xkZWQsIGFueSwgcHJlY2lzZSwgYnlXb3JkIH0gPSB0aGlzO1xuICAgICAgICAvLyBGb3Igc2luZ2xlLWNoYXJhY3RlciBxdWVyaWVzLCBvbmx5IG1hdGNoIHdoZW4gdGhleSBvY2N1ciByaWdodFxuICAgICAgICAvLyBhdCB0aGUgc3RhcnRcbiAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBjb2RlUG9pbnRBdCh3b3JkLCAwKSwgZmlyc3RTaXplID0gY29kZVBvaW50U2l6ZShmaXJzdCk7XG4gICAgICAgICAgICBsZXQgc2NvcmUgPSBmaXJzdFNpemUgPT0gd29yZC5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi87XG4gICAgICAgICAgICBpZiAoZmlyc3QgPT0gY2hhcnNbMF0pIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ID09IGZvbGRlZFswXSlcbiAgICAgICAgICAgICAgICBzY29yZSArPSAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi87XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoc2NvcmUsIFswLCBmaXJzdFNpemVdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlyZWN0ID0gd29yZC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgICAgIGlmIChkaXJlY3QgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCh3b3JkLmxlbmd0aCA9PSB0aGlzLnBhdHRlcm4ubGVuZ3RoID8gMCA6IC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovLCBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aF0pO1xuICAgICAgICBsZXQgbGVuID0gY2hhcnMubGVuZ3RoLCBhbnlUbyA9IDA7XG4gICAgICAgIGlmIChkaXJlY3QgPCAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApOyBpIDwgZSAmJiBhbnlUbyA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FueVRvXSB8fCBuZXh0ID09IGZvbGRlZFthbnlUb10pXG4gICAgICAgICAgICAgICAgICAgIGFueVthbnlUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIGV4aXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChhbnlUbyA8IGxlbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHRyYWNrcyB0aGUgZXh0ZW50IG9mIHRoZSBwcmVjaXNlIChub24tZm9sZGVkLCBub3RcbiAgICAgICAgLy8gbmVjZXNzYXJpbHkgYWRqYWNlbnQpIG1hdGNoXG4gICAgICAgIGxldCBwcmVjaXNlVG8gPSAwO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGVyZSBpcyBhIG1hdGNoIHRoYXQgaGl0cyBvbmx5IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyBhcHBlYXIgdG8gYmUgc3RhcnRpbmcgd29yZHMuIGBieVdvcmRGb2xkZWRgIGlzIHNldCB0byB0cnVlIHdoZW5cbiAgICAgICAgLy8gYSBjYXNlIGZvbGRlZCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gc3VjaCBhIG1hdGNoXG4gICAgICAgIGxldCBieVdvcmRUbyA9IDAsIGJ5V29yZEZvbGRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBhIHBhcnRpYWwgYWRqYWNlbnQgbWF0Y2gsIHRoZXNlIHRyYWNrIGl0cyBzdGF0ZVxuICAgICAgICBsZXQgYWRqYWNlbnRUbyA9IDAsIGFkamFjZW50U3RhcnQgPSAtMSwgYWRqYWNlbnRFbmQgPSAtMTtcbiAgICAgICAgbGV0IGhhc0xvd2VyID0gL1thLXpdLy50ZXN0KHdvcmQpLCB3b3JkQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICAvLyBHbyBvdmVyIHRoZSBvcHRpb24ncyB0ZXh0LCBzY2FubmluZyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgbWF0Y2hlc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZSA9IE1hdGgubWluKHdvcmQubGVuZ3RoLCAyMDApLCBwcmV2VHlwZSA9IDAgLyogVHAuTm9uV29yZCAqLzsgaSA8IGUgJiYgYnlXb3JkVG8gPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHdvcmQsIGkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlY2lzZVRvIDwgbGVuICYmIG5leHQgPT0gY2hhcnNbcHJlY2lzZVRvXSlcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzZVtwcmVjaXNlVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IGNoYXJzW2FkamFjZW50VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FkamFjZW50VG9dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqYWNlbnRUbyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRFbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkamFjZW50VG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoLCB0eXBlID0gbmV4dCA8IDB4ZmZcbiAgICAgICAgICAgICAgICA/IChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcgfHwgbmV4dCA+PSA5NyAmJiBuZXh0IDw9IDEyMiA/IDIgLyogVHAuTG93ZXIgKi8gOiBuZXh0ID49IDY1ICYmIG5leHQgPD0gOTAgPyAxIC8qIFRwLlVwcGVyICovIDogMCAvKiBUcC5Ob25Xb3JkICovKVxuICAgICAgICAgICAgICAgIDogKChjaCA9IGZyb21Db2RlUG9pbnQobmV4dCkpICE9IGNoLnRvTG93ZXJDYXNlKCkgPyAxIC8qIFRwLlVwcGVyICovIDogY2ggIT0gY2gudG9VcHBlckNhc2UoKSA/IDIgLyogVHAuTG93ZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pO1xuICAgICAgICAgICAgaWYgKCFpIHx8IHR5cGUgPT0gMSAvKiBUcC5VcHBlciAqLyAmJiBoYXNMb3dlciB8fCBwcmV2VHlwZSA9PSAwIC8qIFRwLk5vbldvcmQgKi8gJiYgdHlwZSAhPSAwIC8qIFRwLk5vbldvcmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnNbYnlXb3JkVG9dID09IG5leHQgfHwgKGZvbGRlZFtieVdvcmRUb10gPT0gbmV4dCAmJiAoYnlXb3JkRm9sZGVkID0gdHJ1ZSkpKVxuICAgICAgICAgICAgICAgICAgICBieVdvcmRbYnlXb3JkVG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ5V29yZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdvcmRBZGphY2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaSArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4gJiYgYnlXb3JkWzBdID09IDAgJiYgd29yZEFkamFjZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbiAmJiBhZGphY2VudFN0YXJ0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIC0gd29yZC5sZW5ndGggKyAoYWRqYWNlbnRFbmQgPT0gd29yZC5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8pLCBbMCwgYWRqYWNlbnRFbmRdKTtcbiAgICAgICAgaWYgKGRpcmVjdCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBbZGlyZWN0LCBkaXJlY3QgKyB0aGlzLnBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgIGlmIChhZGphY2VudFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgW2FkamFjZW50U3RhcnQsIGFkamFjZW50RW5kXSk7XG4gICAgICAgIGlmIChieVdvcmRUbyA9PSBsZW4pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyArXG4gICAgICAgICAgICAgICAgKHdvcmRBZGphY2VudCA/IDAgOiAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLyksIGJ5V29yZCwgd29yZCk7XG4gICAgICAgIHJldHVybiBjaGFycy5sZW5ndGggPT0gMiA/IG51bGxcbiAgICAgICAgICAgIDogdGhpcy5yZXN1bHQoKGFueVswXSA/IC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyA6IDApICsgLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTExMDAgLyogUGVuYWx0eS5HYXAgKi8sIGFueSwgd29yZCk7XG4gICAgfVxuICAgIHJlc3VsdChzY29yZSwgcG9zaXRpb25zLCB3b3JkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB0byA9IHBvcyArICh0aGlzLmFzdHJhbCA/IGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQod29yZCwgcG9zKSkgOiAxKTtcbiAgICAgICAgICAgIGlmIChpICYmIHJlc3VsdFtpIC0gMV0gPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpIC0gMV0gPSB0bztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmV0KHNjb3JlIC0gd29yZC5sZW5ndGgsIHJlc3VsdCk7XG4gICAgfVxufVxuY2xhc3MgU3RyaWN0TWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zY29yZSA9IDA7XG4gICAgICAgIHRoaXMuZm9sZGVkID0gcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBtYXRjaCh3b3JkKSB7XG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IHRoaXMucGF0dGVybi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gd29yZC5zbGljZSgwLCB0aGlzLnBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgbGV0IG1hdGNoID0gc3RhcnQgPT0gdGhpcy5wYXR0ZXJuID8gMCA6IHN0YXJ0LnRvTG93ZXJDYXNlKCkgPT0gdGhpcy5mb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiBudWxsO1xuICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBbMCwgc3RhcnQubGVuZ3RoXTtcbiAgICAgICAgdGhpcy5zY29yZSA9IG1hdGNoICsgKHdvcmQubGVuZ3RoID09IHRoaXMucGF0dGVybi5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNvbnN0IGNvbXBsZXRpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGFjdGl2YXRlT25Db21wbGV0aW9uOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgIGFjdGl2YXRlT25UeXBpbmdEZWxheTogMTAwLFxuICAgICAgICAgICAgc2VsZWN0T25PcGVuOiB0cnVlLFxuICAgICAgICAgICAgb3ZlcnJpZGU6IG51bGwsXG4gICAgICAgICAgICBjbG9zZU9uQmx1cjogdHJ1ZSxcbiAgICAgICAgICAgIG1heFJlbmRlcmVkT3B0aW9uczogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdEtleW1hcDogdHJ1ZSxcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKCkgPT4gXCJcIixcbiAgICAgICAgICAgIG9wdGlvbkNsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgYWJvdmVDdXJzb3I6IGZhbHNlLFxuICAgICAgICAgICAgaWNvbnM6IHRydWUsXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IFtdLFxuICAgICAgICAgICAgcG9zaXRpb25JbmZvOiBkZWZhdWx0UG9zaXRpb25JbmZvLFxuICAgICAgICAgICAgZmlsdGVyU3RyaWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbXBhcmVDb21wbGV0aW9uczogKGEsIGIpID0+IGEubGFiZWwubG9jYWxlQ29tcGFyZShiLmxhYmVsKSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGVsYXk6IDc1LFxuICAgICAgICAgICAgdXBkYXRlU3luY1RpbWU6IDEwMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBpY29uczogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpLFxuICAgICAgICAgICAgZmlsdGVyU3RyaWN0OiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGpvaW5DbGFzcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gYSArIFwiIFwiICsgYiA6IGEgOiBiO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBvc2l0aW9uSW5mbyh2aWV3LCBsaXN0LCBvcHRpb24sIGluZm8sIHNwYWNlLCB0b29sdGlwKSB7XG4gICAgbGV0IHJ0bCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uUlRMLCBsZWZ0ID0gcnRsLCBuYXJyb3cgPSBmYWxzZTtcbiAgICBsZXQgc2lkZSA9IFwidG9wXCIsIG9mZnNldCwgbWF4V2lkdGg7XG4gICAgbGV0IHNwYWNlTGVmdCA9IGxpc3QubGVmdCAtIHNwYWNlLmxlZnQsIHNwYWNlUmlnaHQgPSBzcGFjZS5yaWdodCAtIGxpc3QucmlnaHQ7XG4gICAgbGV0IGluZm9XaWR0aCA9IGluZm8ucmlnaHQgLSBpbmZvLmxlZnQsIGluZm9IZWlnaHQgPSBpbmZvLmJvdHRvbSAtIGluZm8udG9wO1xuICAgIGlmIChsZWZ0ICYmIHNwYWNlTGVmdCA8IE1hdGgubWluKGluZm9XaWR0aCwgc3BhY2VSaWdodCkpXG4gICAgICAgIGxlZnQgPSBmYWxzZTtcbiAgICBlbHNlIGlmICghbGVmdCAmJiBzcGFjZVJpZ2h0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZUxlZnQpKVxuICAgICAgICBsZWZ0ID0gdHJ1ZTtcbiAgICBpZiAoaW5mb1dpZHRoIDw9IChsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoc3BhY2UudG9wLCBNYXRoLm1pbihvcHRpb24udG9wLCBzcGFjZS5ib3R0b20gLSBpbmZvSGVpZ2h0KSkgLSBsaXN0LnRvcDtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgbGVmdCA/IHNwYWNlTGVmdCA6IHNwYWNlUmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmFycm93ID0gdHJ1ZTtcbiAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgKHJ0bCA/IGxpc3QucmlnaHQgOiBzcGFjZS5yaWdodCAtIGxpc3QubGVmdCkgLSAzMCAvKiBJbmZvLk1hcmdpbiAqLyk7XG4gICAgICAgIGxldCBzcGFjZUJlbG93ID0gc3BhY2UuYm90dG9tIC0gbGlzdC5ib3R0b207XG4gICAgICAgIGlmIChzcGFjZUJlbG93ID49IGluZm9IZWlnaHQgfHwgc3BhY2VCZWxvdyA+IGxpc3QudG9wKSB7IC8vIEJlbG93IHRoZSBjb21wbGV0aW9uXG4gICAgICAgICAgICBvZmZzZXQgPSBvcHRpb24uYm90dG9tIC0gbGlzdC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIEFib3ZlIGl0XG4gICAgICAgICAgICBzaWRlID0gXCJib3R0b21cIjtcbiAgICAgICAgICAgIG9mZnNldCA9IGxpc3QuYm90dG9tIC0gb3B0aW9uLnRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2NhbGVZID0gKGxpc3QuYm90dG9tIC0gbGlzdC50b3ApIC8gdG9vbHRpcC5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHNjYWxlWCA9IChsaXN0LnJpZ2h0IC0gbGlzdC5sZWZ0KSAvIHRvb2x0aXAub2Zmc2V0V2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6IGAke3NpZGV9OiAke29mZnNldCAvIHNjYWxlWX1weDsgbWF4LXdpZHRoOiAke21heFdpZHRoIC8gc2NhbGVYfXB4YCxcbiAgICAgICAgY2xhc3M6IFwiY20tY29tcGxldGlvbkluZm8tXCIgKyAobmFycm93ID8gKHJ0bCA/IFwibGVmdC1uYXJyb3dcIiA6IFwicmlnaHQtbmFycm93XCIpIDogbGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG9wdGlvbkNvbnRlbnQoY29uZmlnKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBjb25maWcuYWRkVG9PcHRpb25zLnNsaWNlKCk7XG4gICAgaWYgKGNvbmZpZy5pY29ucylcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0aW9uLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGljb24uY2xhc3NMaXN0LmFkZCguLi5jb21wbGV0aW9uLnR5cGUuc3BsaXQoL1xccysvZykubWFwKGNscyA9PiBcImNtLWNvbXBsZXRpb25JY29uLVwiICsgY2xzKSk7XG4gICAgICAgICAgICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IDIwXG4gICAgICAgIH0pO1xuICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uLCBfcywgX3YsIG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGxhYmVsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkxhYmVsXCI7XG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBjb21wbGV0aW9uLmRpc3BsYXlMYWJlbCB8fCBjb21wbGV0aW9uLmxhYmVsLCBvZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaC5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBtYXRjaFtqKytdLCB0byA9IG1hdGNoW2orK107XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBvZmYpXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZiwgZnJvbSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhbiA9IGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKGZyb20sIHRvKSkpO1xuICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjtcbiAgICAgICAgICAgICAgICBvZmYgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmYgPCBsYWJlbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogNTBcbiAgICB9LCB7XG4gICAgICAgIHJlbmRlcihjb21wbGV0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb24uZGV0YWlsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGFpbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZGV0YWlsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiO1xuICAgICAgICAgICAgZGV0YWlsRWx0LnRleHRDb250ZW50ID0gY29tcGxldGlvbi5kZXRhaWw7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlsRWx0O1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogODBcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudC5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uIC0gYi5wb3NpdGlvbikubWFwKGEgPT4gYS5yZW5kZXIpO1xufVxuZnVuY3Rpb24gcmFuZ2VBcm91bmRTZWxlY3RlZCh0b3RhbCwgc2VsZWN0ZWQsIG1heCkge1xuICAgIGlmICh0b3RhbCA8PSBtYXgpXG4gICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0b3RhbCB9O1xuICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgIHNlbGVjdGVkID0gMDtcbiAgICBpZiAoc2VsZWN0ZWQgPD0gKHRvdGFsID4+IDEpKSB7XG4gICAgICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKHNlbGVjdGVkIC8gbWF4KTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2ZmICogbWF4LCB0bzogKG9mZiArIDEpICogbWF4IH07XG4gICAgfVxuICAgIGxldCBvZmYgPSBNYXRoLmZsb29yKCh0b3RhbCAtIHNlbGVjdGVkKSAvIG1heCk7XG4gICAgcmV0dXJuIHsgZnJvbTogdG90YWwgLSAob2ZmICsgMSkgKiBtYXgsIHRvOiB0b3RhbCAtIG9mZiAqIG1heCB9O1xufVxuY2xhc3MgQ29tcGxldGlvblRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlRmllbGQgPSBzdGF0ZUZpZWxkO1xuICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbiA9IGFwcGx5Q29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhY2VJbmZvUmVxID0ge1xuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxuICAgICAgICAgICAgd3JpdGU6IChwb3MpID0+IHRoaXMucGxhY2VJbmZvKHBvcyksXG4gICAgICAgICAgICBrZXk6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gXCJcIjtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkIH0gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ29udGVudCA9IG9wdGlvbkNvbnRlbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25DbGFzcyA9IGNvbmZpZy5vcHRpb25DbGFzcztcbiAgICAgICAgdGhpcy50b29sdGlwQ2xhc3MgPSBjb25maWcudG9vbHRpcENsYXNzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIGNvbmZpZy5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3Modmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCkub3BlbjtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSA9IGUudGFyZ2V0LCBtYXRjaDsgZG9tICYmIGRvbSAhPSB0aGlzLmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiTElcIiAmJiAobWF0Y2ggPSAvLShcXGQrKSQvLmV4ZWMoZG9tLmlkKSkgJiYgK21hdGNoWzFdIDwgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uc1srbWF0Y2hbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIChlKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvb2x0aXAgJiYgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1ciAmJlxuICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2hvd09wdGlvbnMob3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICB9XG4gICAgbW91bnQoKSB7IHRoaXMudXBkYXRlU2VsKCk7IH1cbiAgICBzaG93T3B0aW9ucyhvcHRpb25zLCBpZCkge1xuICAgICAgICBpZiAodGhpcy5saXN0KVxuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm9SZXEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHByZXZTdGF0ZSA9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCk7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcENsYXNzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChjU3RhdGUgIT0gcHJldlN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBzZWxlY3RlZCwgZGlzYWJsZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUub3BlbiB8fCBwcmV2U3RhdGUub3Blbi5vcHRpb25zICE9IG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIHVwZGF0ZS5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd09wdGlvbnMob3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsKCk7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgIT0gKChfYSA9IHByZXZTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZWQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZFwiLCAhIWRpc2FibGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVUb29sdGlwQ2xhc3Moc3RhdGUpIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMudG9vbHRpcENsYXNzKHN0YXRlKTtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmN1cnJlbnRDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmN1cnJlbnRDbGFzcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNscy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbCgpIHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpLCBvcGVuID0gY1N0YXRlLm9wZW47XG4gICAgICAgIGlmIChvcGVuLnNlbGVjdGVkID4gLTEgJiYgb3Blbi5zZWxlY3RlZCA8IHRoaXMucmFuZ2UuZnJvbSB8fCBvcGVuLnNlbGVjdGVkID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wZW4ub3B0aW9ucy5sZW5ndGgsIG9wZW4uc2VsZWN0ZWQsIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcGVuLm9wdGlvbnMsIGNTdGF0ZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24ob3Blbi5zZWxlY3RlZCk7XG4gICAgICAgIGlmIChuZXdTZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24gfSA9IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXTtcbiAgICAgICAgICAgIGxldCB7IGluZm8gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoIWluZm8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGluZm9SZXN1bHQgPSB0eXBlb2YgaW5mbyA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGluZm8pIDogaW5mbyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmICghaW5mb1Jlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoXCJ0aGVuXCIgaW4gaW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIGluZm9SZXN1bHQudGhlbihvYmogPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICYmIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQsIGZhbHNlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKG9iaiwgY29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlLCBcImNvbXBsZXRpb24gaW5mb1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKGluZm9SZXN1bHQsIGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgICAgIG5ld1NlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHRoaXMuaW5mby5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5mb1BhbmUoY29udGVudCwgY29tcGxldGlvbikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lJbmZvKCk7XG4gICAgICAgIGxldCB3cmFwID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm9cIjtcbiAgICAgICAgd3JhcC5pZCA9IFwiY20tY29tcGxldGlvbkluZm8tXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgZG9tLCBkZXN0cm95IH0gPSBjb250ZW50O1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IGRlc3Ryb3kgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh3cmFwKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3B0Lm5vZGVOYW1lICE9IFwiTElcIiB8fCAhb3B0LmlkKSB7XG4gICAgICAgICAgICAgICAgaS0tOyAvLyBBIHNlY3Rpb24gaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0KVxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcodGhpcy5saXN0LCBzZXQpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBtZWFzdXJlSW5mbygpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbYXJpYS1zZWxlY3RlZF1cIik7XG4gICAgICAgIGlmICghc2VsIHx8ICF0aGlzLmluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxpc3RSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBpbmZvUmVjdCA9IHRoaXMuaW5mby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNlbFJlY3QgPSBzZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzcGFjZSA9IHRoaXMuc3BhY2U7XG4gICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgIGxldCBkb2NFbHQgPSB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHNwYWNlID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiBkb2NFbHQuY2xpZW50V2lkdGgsIGJvdHRvbTogZG9jRWx0LmNsaWVudEhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxSZWN0LnRvcCA+IE1hdGgubWluKHNwYWNlLmJvdHRvbSwgbGlzdFJlY3QuYm90dG9tKSAtIDEwIHx8XG4gICAgICAgICAgICBzZWxSZWN0LmJvdHRvbSA8IE1hdGgubWF4KHNwYWNlLnRvcCwgbGlzdFJlY3QudG9wKSArIDEwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykucG9zaXRpb25JbmZvKHRoaXMudmlldywgbGlzdFJlY3QsIHNlbFJlY3QsIGluZm9SZWN0LCBzcGFjZSwgdGhpcy5kb20pO1xuICAgIH1cbiAgICBwbGFjZUluZm8ocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUuY3NzVGV4dCA9IHBvcy5zdHlsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvIFwiICsgKHBvcy5jbGFzcyB8fCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6IC0xZTZweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IGlkO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcbiAgICAgICAgdWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgZm9jdXMgY2hhbmdlIHdoZW4gY2xpY2tpbmcgdGhlIHNjcm9sbGJhclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09IHVsKVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjdXJTZWN0aW9uID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlLmZyb207IGkgPCByYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBjb21wbGV0aW9uLCBtYXRjaCB9ID0gb3B0aW9uc1tpXSwgeyBzZWN0aW9uIH0gPSBjb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9IGN1clNlY3Rpb24gJiYgKGkgPiByYW5nZS5mcm9tIHx8IHJhbmdlLmZyb20gPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyU2VjdGlvbiA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VjdGlvbiAhPSBcInN0cmluZ1wiICYmIHNlY3Rpb24uaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bC5hcHBlbmRDaGlsZChzZWN0aW9uLmhlYWRlcihzZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGVhZGVyID0gdWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNvbXBsZXRpb24tc2VjdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIudGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGkgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgbGkuaWQgPSBpZCArIFwiLVwiICsgaTtcbiAgICAgICAgICAgIGxpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgICAgICAgICBsZXQgY2xzID0gdGhpcy5vcHRpb25DbGFzcyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgbGkuY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHRoaXMub3B0aW9uQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gc291cmNlKGNvbXBsZXRpb24sIHRoaXMudmlldy5zdGF0ZSwgdGhpcy52aWV3LCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGxpLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZS5mcm9tKVxuICAgICAgICAgICAgdWwuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcFwiKTtcbiAgICAgICAgaWYgKHJhbmdlLnRvIDwgb3B0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tXCIpO1xuICAgICAgICByZXR1cm4gdWw7XG4gICAgfVxuICAgIGRlc3Ryb3lJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5pbmZvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvRGVzdHJveSlcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9EZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluZm8ucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wbGV0aW9uVG9vbHRpcChzdGF0ZUZpZWxkLCBhcHBseUNvbXBsZXRpb24pIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IG5ldyBDb21wbGV0aW9uVG9vbHRpcCh2aWV3LCBzdGF0ZUZpZWxkLCBhcHBseUNvbXBsZXRpb24pO1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2VsZiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHNjYWxlWSA9IHBhcmVudC5oZWlnaHQgLyBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgIGlmIChzZWxmLnRvcCA8IHBhcmVudC50b3ApXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgLT0gKHBhcmVudC50b3AgLSBzZWxmLnRvcCkgLyBzY2FsZVk7XG4gICAgZWxzZSBpZiAoc2VsZi5ib3R0b20gPiBwYXJlbnQuYm90dG9tKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wICs9IChzZWxmLmJvdHRvbSAtIHBhcmVudC5ib3R0b20pIC8gc2NhbGVZO1xufVxuXG4vLyBVc2VkIHRvIHBpY2sgYSBwcmVmZXJyZWQgb3B0aW9uIHdoZW4gdHdvIG9wdGlvbnMgd2l0aCB0aGUgc2FtZVxuLy8gbGFiZWwgb2NjdXIgaW4gdGhlIHJlc3VsdC5cbmZ1bmN0aW9uIHNjb3JlKG9wdGlvbikge1xuICAgIHJldHVybiAob3B0aW9uLmJvb3N0IHx8IDApICogMTAwICsgKG9wdGlvbi5hcHBseSA/IDEwIDogMCkgKyAob3B0aW9uLmluZm8gPyA1IDogMCkgK1xuICAgICAgICAob3B0aW9uLnR5cGUgPyAxIDogMCk7XG59XG5mdW5jdGlvbiBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXTtcbiAgICBsZXQgc2VjdGlvbnMgPSBudWxsLCBkeW5hbWljU2VjdGlvblNjb3JlID0gbnVsbDtcbiAgICBsZXQgYWRkT3B0aW9uID0gKG9wdGlvbikgPT4ge1xuICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgICAgbGV0IHsgc2VjdGlvbiB9ID0gb3B0aW9uLmNvbXBsZXRpb247XG4gICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXNlY3Rpb25zKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lO1xuICAgICAgICAgICAgaWYgKCFzZWN0aW9ucy5zb21lKHMgPT4gcy5uYW1lID09IG5hbWUpKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2godHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHsgbmFtZSB9IDogc2VjdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBjb25mID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgZm9yIChsZXQgYSBvZiBhY3RpdmUpXG4gICAgICAgIGlmIChhLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICBsZXQgZ2V0TWF0Y2ggPSBhLnJlc3VsdC5nZXRNYXRjaDtcbiAgICAgICAgICAgIGlmIChhLnJlc3VsdC5maWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW9uKG5ldyBPcHRpb24ob3B0aW9uLCBhLnNvdXJjZSwgZ2V0TWF0Y2ggPyBnZXRNYXRjaChvcHRpb24pIDogW10sIDFlOSAtIG9wdGlvbnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSBzdGF0ZS5zbGljZURvYyhhLmZyb20sIGEudG8pLCBtYXRjaDtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlciA9IGNvbmYuZmlsdGVyU3RyaWN0ID8gbmV3IFN0cmljdE1hdGNoZXIocGF0dGVybikgOiBuZXcgRnV6enlNYXRjaGVyKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSBtYXRjaGVyLm1hdGNoKG9wdGlvbi5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaGVkID0gIW9wdGlvbi5kaXNwbGF5TGFiZWwgPyBtYXRjaC5tYXRjaGVkIDogZ2V0TWF0Y2ggPyBnZXRNYXRjaChvcHRpb24sIG1hdGNoLm1hdGNoZWQpIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2NvcmUgPSBtYXRjaC5zY29yZSArIChvcHRpb24uYm9vc3QgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpb24obmV3IE9wdGlvbihvcHRpb24sIGEuc291cmNlLCBtYXRjaGVkLCBzY29yZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24uc2VjdGlvbiA9PSBcIm9iamVjdFwiICYmIG9wdGlvbi5zZWN0aW9uLnJhbmsgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgbmFtZSB9ID0gb3B0aW9uLnNlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkeW5hbWljU2VjdGlvblNjb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2VjdGlvblNjb3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2VjdGlvblNjb3JlW25hbWVdID0gTWF0aC5tYXgoc2NvcmUsIGR5bmFtaWNTZWN0aW9uU2NvcmVbbmFtZV0gfHwgLTFlOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGlmIChzZWN0aW9ucykge1xuICAgICAgICBsZXQgc2VjdGlvbk9yZGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcG9zID0gMDtcbiAgICAgICAgbGV0IGNtcCA9IChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGEucmFuayA9PT0gXCJkeW5hbWljXCIgJiYgYi5yYW5rID09PSBcImR5bmFtaWNcIiA/IGR5bmFtaWNTZWN0aW9uU2NvcmVbYi5uYW1lXSAtIGR5bmFtaWNTZWN0aW9uU2NvcmVbYS5uYW1lXSA6IDApIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBhLnJhbmsgPT0gXCJudW1iZXJcIiA/IGEucmFuayA6IDFlOSkgLSAodHlwZW9mIGIucmFuayA9PSBcIm51bWJlclwiID8gYi5yYW5rIDogMWU5KSB8fFxuICAgICAgICAgICAgICAgIChhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDEpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBzIG9mIHNlY3Rpb25zLnNvcnQoY21wKSkge1xuICAgICAgICAgICAgcG9zIC09IDFlNTtcbiAgICAgICAgICAgIHNlY3Rpb25PcmRlcltzLm5hbWVdID0gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBsZXQgeyBzZWN0aW9uIH0gPSBvcHRpb24uY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uKVxuICAgICAgICAgICAgICAgIG9wdGlvbi5zY29yZSArPSBzZWN0aW9uT3JkZXJbdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXSwgcHJldiA9IG51bGw7XG4gICAgbGV0IGNvbXBhcmUgPSBjb25mLmNvbXBhcmVDb21wbGV0aW9ucztcbiAgICBmb3IgKGxldCBvcHQgb2Ygb3B0aW9ucy5zb3J0KChhLCBiKSA9PiAoYi5zY29yZSAtIGEuc2NvcmUpIHx8IGNvbXBhcmUoYS5jb21wbGV0aW9uLCBiLmNvbXBsZXRpb24pKSkge1xuICAgICAgICBsZXQgY3VyID0gb3B0LmNvbXBsZXRpb247XG4gICAgICAgIGlmICghcHJldiB8fCBwcmV2LmxhYmVsICE9IGN1ci5sYWJlbCB8fCBwcmV2LmRldGFpbCAhPSBjdXIuZGV0YWlsIHx8XG4gICAgICAgICAgICAocHJldi50eXBlICE9IG51bGwgJiYgY3VyLnR5cGUgIT0gbnVsbCAmJiBwcmV2LnR5cGUgIT0gY3VyLnR5cGUpIHx8XG4gICAgICAgICAgICBwcmV2LmFwcGx5ICE9IGN1ci5hcHBseSB8fCBwcmV2LmJvb3N0ICE9IGN1ci5ib29zdClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9wdCk7XG4gICAgICAgIGVsc2UgaWYgKHNjb3JlKG9wdC5jb21wbGV0aW9uKSA+IHNjb3JlKHByZXYpKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG9wdDtcbiAgICAgICAgcHJldiA9IG9wdC5jb21wbGV0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgQ29tcGxldGlvbkRpYWxvZyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXR0cnMsIHRvb2x0aXAsIHRpbWVzdGFtcCwgc2VsZWN0ZWQsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy50b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgICBzZXRTZWxlY3RlZChzZWxlY3RlZCwgaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkID09IHRoaXMuc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPj0gdGhpcy5vcHRpb25zLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwgdGhpcy50b29sdGlwLCB0aGlzLnRpbWVzdGFtcCwgc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQoYWN0aXZlLCBzdGF0ZSwgaWQsIHByZXYsIGNvbmYsIGRpZFNldEFjdGl2ZSkge1xuICAgICAgICBpZiAocHJldiAmJiAhZGlkU2V0QWN0aXZlICYmIGFjdGl2ZS5zb21lKHMgPT4gcy5pc1BlbmRpbmcpKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYuc2V0RGlzYWJsZWQoKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICYmIGFjdGl2ZS5zb21lKGEgPT4gYS5pc1BlbmRpbmcpID8gcHJldi5zZXREaXNhYmxlZCgpIDogbnVsbDtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuc2VsZWN0T25PcGVuID8gMCA6IC0xO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkICE9IHNlbGVjdGVkICYmIHByZXYuc2VsZWN0ZWQgIT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFZhbHVlID0gcHJldi5vcHRpb25zW3ByZXYuc2VsZWN0ZWRdLmNvbXBsZXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0uY29tcGxldGlvbiA9PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyhvcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwge1xuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXG4gICAgICAgICAgICBjcmVhdGU6IGNyZWF0ZVRvb2x0aXAsXG4gICAgICAgICAgICBhYm92ZTogY29uZi5hYm92ZUN1cnNvcixcbiAgICAgICAgfSwgcHJldiA/IHByZXYudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgc2VsZWN0ZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgdGhpcy5hdHRycywgeyAuLi50aGlzLnRvb2x0aXAsIHBvczogY2hhbmdlcy5tYXBQb3ModGhpcy50b29sdGlwLnBvcykgfSwgdGhpcy50aW1lc3RhbXAsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbiAgICBzZXREaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgdGhpcy5hdHRycywgdGhpcy50b29sdGlwLCB0aGlzLnRpbWVzdGFtcCwgdGhpcy5zZWxlY3RlZCwgdHJ1ZSk7XG4gICAgfVxufVxuY2xhc3MgQ29tcGxldGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmUsIGlkLCBvcGVuKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uU3RhdGUobm9uZSwgXCJjbS1hYy1cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDJlNikudG9TdHJpbmcoMzYpLCBudWxsKTtcbiAgICB9XG4gICAgdXBkYXRlKHRyKSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgY29uZiA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICBsZXQgc291cmNlcyA9IGNvbmYub3ZlcnJpZGUgfHxcbiAgICAgICAgICAgIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiYXV0b2NvbXBsZXRlXCIsIGN1cihzdGF0ZSkpLm1hcChhc1NvdXJjZSk7XG4gICAgICAgIGxldCBhY3RpdmUgPSBzb3VyY2VzLm1hcChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5hY3RpdmUuZmluZChzID0+IHMuc291cmNlID09IHNvdXJjZSkgfHxcbiAgICAgICAgICAgICAgICBuZXcgQWN0aXZlU291cmNlKHNvdXJjZSwgdGhpcy5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgPyAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gOiAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggPT0gdGhpcy5hY3RpdmUubGVuZ3RoICYmIGFjdGl2ZS5ldmVyeSgoYSwgaSkgPT4gYSA9PSB0aGlzLmFjdGl2ZVtpXSkpXG4gICAgICAgICAgICBhY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLm9wZW4sIGRpZFNldCA9IHRyLmVmZmVjdHMuc29tZShlID0+IGUuaXMoc2V0QWN0aXZlRWZmZWN0KSk7XG4gICAgICAgIGlmIChvcGVuICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICBvcGVuID0gb3Blbi5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24gfHwgYWN0aXZlLnNvbWUoYSA9PiBhLmhhc1Jlc3VsdCgpICYmIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGEuZnJvbSwgYS50bykpIHx8XG4gICAgICAgICAgICAhc2FtZVJlc3VsdHMoYWN0aXZlLCB0aGlzLmFjdGl2ZSkgfHwgZGlkU2V0KVxuICAgICAgICAgICAgb3BlbiA9IENvbXBsZXRpb25EaWFsb2cuYnVpbGQoYWN0aXZlLCBzdGF0ZSwgdGhpcy5pZCwgb3BlbiwgY29uZiwgZGlkU2V0KTtcbiAgICAgICAgZWxzZSBpZiAob3BlbiAmJiBvcGVuLmRpc2FibGVkICYmICFhY3RpdmUuc29tZShhID0+IGEuaXNQZW5kaW5nKSlcbiAgICAgICAgICAgIG9wZW4gPSBudWxsO1xuICAgICAgICBpZiAoIW9wZW4gJiYgYWN0aXZlLmV2ZXJ5KGEgPT4gIWEuaXNQZW5kaW5nKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IGEpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuICYmIG9wZW4uc2V0U2VsZWN0ZWQoZWZmZWN0LnZhbHVlLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmFjdGl2ZSAmJiBvcGVuID09IHRoaXMub3BlbiA/IHRoaXMgOiBuZXcgQ29tcGxldGlvblN0YXRlKGFjdGl2ZSwgdGhpcy5pZCwgb3Blbik7XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLnRvb2x0aXAgOiBudWxsOyB9XG4gICAgZ2V0IGF0dHJzKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLmF0dHJzIDogdGhpcy5hY3RpdmUubGVuZ3RoID8gYmFzZUF0dHJzIDogbm9BdHRyczsgfVxufVxuZnVuY3Rpb24gc2FtZVJlc3VsdHMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgd2hpbGUgKGlBIDwgYS5sZW5ndGggJiYgIWFbaUFdLmhhc1Jlc3VsdCgpKVxuICAgICAgICAgICAgaUErKztcbiAgICAgICAgd2hpbGUgKGlCIDwgYi5sZW5ndGggJiYgIWJbaUJdLmhhc1Jlc3VsdCgpKVxuICAgICAgICAgICAgaUIrKztcbiAgICAgICAgbGV0IGVuZEEgPSBpQSA9PSBhLmxlbmd0aCwgZW5kQiA9IGlCID09IGIubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kQSB8fCBlbmRCKVxuICAgICAgICAgICAgcmV0dXJuIGVuZEEgPT0gZW5kQjtcbiAgICAgICAgaWYgKGFbaUErK10ucmVzdWx0ICE9IGJbaUIrK10ucmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGJhc2VBdHRycyA9IHtcbiAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiXG59O1xuY29uc3Qgbm9BdHRycyA9IHt9O1xuZnVuY3Rpb24gbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCkge1xuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCIsXG4gICAgICAgIFwiYXJpYS1oYXNwb3B1cFwiOiBcImxpc3Rib3hcIixcbiAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IGlkXG4gICAgfTtcbiAgICBpZiAoc2VsZWN0ZWQgPiAtMSlcbiAgICAgICAgcmVzdWx0W1wiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCJdID0gaWQgKyBcIi1cIiArIHNlbGVjdGVkO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBub25lID0gW107XG5mdW5jdGlvbiBnZXRVcGRhdGVUeXBlKHRyLCBjb25mKSB7XG4gICAgaWYgKHRyLmlzVXNlckV2ZW50KFwiaW5wdXQuY29tcGxldGVcIikpIHtcbiAgICAgICAgbGV0IGNvbXBsZXRpb24gPSB0ci5hbm5vdGF0aW9uKHBpY2tlZENvbXBsZXRpb24pO1xuICAgICAgICBpZiAoY29tcGxldGlvbiAmJiBjb25mLmFjdGl2YXRlT25Db21wbGV0aW9uKGNvbXBsZXRpb24pKVxuICAgICAgICAgICAgcmV0dXJuIDQgLyogVXBkYXRlVHlwZS5BY3RpdmF0ZSAqLyB8IDggLyogVXBkYXRlVHlwZS5SZXNldCAqLztcbiAgICB9XG4gICAgbGV0IHR5cGluZyA9IHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKTtcbiAgICByZXR1cm4gdHlwaW5nICYmIGNvbmYuYWN0aXZhdGVPblR5cGluZyA/IDQgLyogVXBkYXRlVHlwZS5BY3RpdmF0ZSAqLyB8IDEgLyogVXBkYXRlVHlwZS5UeXBpbmcgKi9cbiAgICAgICAgOiB0eXBpbmcgPyAxIC8qIFVwZGF0ZVR5cGUuVHlwaW5nICovXG4gICAgICAgICAgICA6IHRyLmlzVXNlckV2ZW50KFwiZGVsZXRlLmJhY2t3YXJkXCIpID8gMiAvKiBVcGRhdGVUeXBlLkJhY2tzcGFjaW5nICovXG4gICAgICAgICAgICAgICAgOiB0ci5zZWxlY3Rpb24gPyA4IC8qIFVwZGF0ZVR5cGUuUmVzZXQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiB0ci5kb2NDaGFuZ2VkID8gMTYgLyogVXBkYXRlVHlwZS5SZXNldElmVG91Y2hpbmcgKi8gOiAwIC8qIFVwZGF0ZVR5cGUuTm9uZSAqLztcbn1cbmNsYXNzIEFjdGl2ZVNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBzdGF0ZSwgZXhwbGljaXQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmV4cGxpY2l0ID0gZXhwbGljaXQ7XG4gICAgfVxuICAgIGhhc1Jlc3VsdCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzUGVuZGluZygpIHsgcmV0dXJuIHRoaXMuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovOyB9XG4gICAgdXBkYXRlKHRyLCBjb25mKSB7XG4gICAgICAgIGxldCB0eXBlID0gZ2V0VXBkYXRlVHlwZSh0ciwgY29uZiksIHZhbHVlID0gdGhpcztcbiAgICAgICAgaWYgKCh0eXBlICYgOCAvKiBVcGRhdGVUeXBlLlJlc2V0ICovKSB8fCAodHlwZSAmIDE2IC8qIFVwZGF0ZVR5cGUuUmVzZXRJZlRvdWNoaW5nICovKSAmJiB0aGlzLnRvdWNoZXModHIpKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGlmICgodHlwZSAmIDQgLyogVXBkYXRlVHlwZS5BY3RpdmF0ZSAqLykgJiYgdmFsdWUuc3RhdGUgPT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLylcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGVGb3IodHIsIHR5cGUpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhjbG9zZUNvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZUVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGVmZmVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zb3VyY2UgPT0gdmFsdWUuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB1cGRhdGVGb3IodHIsIHR5cGUpIHsgcmV0dXJuIHRoaXMubWFwKHRyLmNoYW5nZXMpOyB9XG4gICAgbWFwKGNoYW5nZXMpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICB0b3VjaGVzKHRyKSB7XG4gICAgICAgIHJldHVybiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShjdXIodHIuc3RhdGUpKTtcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVSZXN1bHQgZXh0ZW5kcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZXhwbGljaXQsIGxpbWl0LCByZXN1bHQsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgMyAvKiBTdGF0ZS5SZXN1bHQgKi8sIGV4cGxpY2l0KTtcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgdXBkYXRlRm9yKHRyLCB0eXBlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEodHlwZSAmIDMgLyogVXBkYXRlVHlwZS5TaW1wbGVJbnRlcmFjdGlvbiAqLykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgaWYgKHJlc3VsdC5tYXAgJiYgIXRyLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKHJlc3VsdCwgdHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBmcm9tID0gdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tKSwgdG8gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxKTtcbiAgICAgICAgbGV0IHBvcyA9IGN1cih0ci5zdGF0ZSk7XG4gICAgICAgIGlmIChwb3MgPiB0byB8fCAhcmVzdWx0IHx8XG4gICAgICAgICAgICAodHlwZSAmIDIgLyogVXBkYXRlVHlwZS5CYWNrc3BhY2luZyAqLykgJiYgKGN1cih0ci5zdGFydFN0YXRlKSA9PSB0aGlzLmZyb20gfHwgcG9zIDwgdGhpcy5saW1pdCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgdHlwZSAmIDQgLyogVXBkYXRlVHlwZS5BY3RpdmF0ZSAqLyA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBsZXQgbGltaXQgPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmxpbWl0KTtcbiAgICAgICAgaWYgKGNoZWNrVmFsaWQocmVzdWx0LnZhbGlkRm9yLCB0ci5zdGF0ZSwgZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIHRoaXMuZXhwbGljaXQsIGxpbWl0LCByZXN1bHQsIGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHJlc3VsdC51cGRhdGUgJiZcbiAgICAgICAgICAgIChyZXN1bHQgPSByZXN1bHQudXBkYXRlKHJlc3VsdCwgZnJvbSwgdG8sIG5ldyBDb21wbGV0aW9uQ29udGV4dCh0ci5zdGF0ZSwgcG9zLCBmYWxzZSkpKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0LCBsaW1pdCwgcmVzdWx0LCByZXN1bHQuZnJvbSwgKF9hID0gcmVzdWx0LnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIodHIuc3RhdGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgdGhpcy5leHBsaWNpdCk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlc3VsdC5tYXAgPyB0aGlzLnJlc3VsdC5tYXAodGhpcy5yZXN1bHQsIG1hcHBpbmcpIDogdGhpcy5yZXN1bHQ7XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdCwgbWFwcGluZy5tYXBQb3ModGhpcy5saW1pdCksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSk7XG4gICAgfVxuICAgIHRvdWNoZXModHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tWYWxpZCh2YWxpZEZvciwgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgaWYgKCF2YWxpZEZvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIHJldHVybiB0eXBlb2YgdmFsaWRGb3IgPT0gXCJmdW5jdGlvblwiID8gdmFsaWRGb3IodGV4dCwgZnJvbSwgdG8sIHN0YXRlKSA6IGVuc3VyZUFuY2hvcih2YWxpZEZvciwgdHJ1ZSkudGVzdCh0ZXh0KTtcbn1cbmNvbnN0IHNldEFjdGl2ZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKTsgfVxufSk7XG5jb25zdCBzZXRTZWxlY3RlZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gQ29tcGxldGlvblN0YXRlLnN0YXJ0KCk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikgeyByZXR1cm4gdmFsdWUudXBkYXRlKHRyKTsgfSxcbiAgICBwcm92aWRlOiBmID0+IFtcbiAgICAgICAgc2hvd1Rvb2x0aXAuZnJvbShmLCB2YWwgPT4gdmFsLnRvb2x0aXApLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20oZiwgc3RhdGUgPT4gc3RhdGUuYXR0cnMpXG4gICAgXVxufSk7XG5mdW5jdGlvbiBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkgPSBvcHRpb24uY29tcGxldGlvbi5hcHBseSB8fCBvcHRpb24uY29tcGxldGlvbi5sYWJlbDtcbiAgICBsZXQgcmVzdWx0ID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gb3B0aW9uLnNvdXJjZSk7XG4gICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgQWN0aXZlUmVzdWx0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAuLi5pbnNlcnRDb21wbGV0aW9uVGV4dCh2aWV3LnN0YXRlLCBhcHBseSwgcmVzdWx0LmZyb20sIHJlc3VsdC50byksXG4gICAgICAgICAgICBhbm5vdGF0aW9uczogcGlja2VkQ29tcGxldGlvbi5vZihvcHRpb24uY29tcGxldGlvbilcbiAgICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgICBhcHBseSh2aWV3LCBvcHRpb24uY29tcGxldGlvbiwgcmVzdWx0LmZyb20sIHJlc3VsdC50byk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBjcmVhdGVUb29sdGlwID0gLypAX19QVVJFX18qL2NvbXBsZXRpb25Ub29sdGlwKGNvbXBsZXRpb25TdGF0ZSwgYXBwbHlDb21wbGV0aW9uKTtcblxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IG1vdmVzIHRoZSBjb21wbGV0aW9uIHNlbGVjdGlvbiBmb3J3YXJkIG9yXG5iYWNrd2FyZCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuKi9cbmZ1bmN0aW9uIG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZvcndhcmQsIGJ5ID0gXCJvcHRpb25cIikge1xuICAgIHJldHVybiAodmlldykgPT4ge1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XG4gICAgICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RlcCA9IDEsIHRvb2x0aXA7XG4gICAgICAgIGlmIChieSA9PSBcInBhZ2VcIiAmJiAodG9vbHRpcCA9IGdldFRvb2x0aXAodmlldywgY1N0YXRlLm9wZW4udG9vbHRpcCkpKVxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IodG9vbHRpcC5kb20ub2Zmc2V0SGVpZ2h0IC9cbiAgICAgICAgICAgICAgICB0b29sdGlwLmRvbS5xdWVyeVNlbGVjdG9yKFwibGlcIikub2Zmc2V0SGVpZ2h0KSAtIDEpO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGNTdGF0ZS5vcGVuLm9wdGlvbnM7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IGNTdGF0ZS5vcGVuLnNlbGVjdGVkID4gLTEgPyBjU3RhdGUub3Blbi5zZWxlY3RlZCArIHN0ZXAgKiAoZm9yd2FyZCA/IDEgOiAtMSkgOiBmb3J3YXJkID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChzZWxlY3RlZCA8IDApXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkID49IGxlbmd0aClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyBsZW5ndGggLSAxIDogMDtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlbGVjdGVkRWZmZWN0Lm9mKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQWNjZXB0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24uXG4qL1xuY29uc3QgYWNjZXB0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgfHwgIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPCAwIHx8IGNTdGF0ZS5vcGVuLmRpc2FibGVkIHx8XG4gICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYXBwbHlDb21wbGV0aW9uKHZpZXcsIGNTdGF0ZS5vcGVuLm9wdGlvbnNbY1N0YXRlLm9wZW4uc2VsZWN0ZWRdKTtcbn07XG4vKipcbkV4cGxpY2l0bHkgc3RhcnQgYXV0b2NvbXBsZXRpb24uXG4qL1xuY29uc3Qgc3RhcnRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YodHJ1ZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGNsb3NlQ29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUgfHwgIWNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNsYXNzIFJ1bm5pbmdRdWVyeSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgLy8gTm90ZSB0aGF0ICd1bmRlZmluZWQnIG1lYW5zICdub3QgZG9uZSB5ZXQnLCB3aGVyZWFzICdudWxsJyBtZWFuc1xuICAgICAgICAvLyAncXVlcnkgcmV0dXJuZWQgbnVsbCcuXG4gICAgICAgIHRoaXMuZG9uZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jb25zdCBNYXhVcGRhdGVDb3VudCA9IDUwLCBNaW5BYm9ydFRpbWUgPSAxMDAwO1xuY29uc3QgY29tcGxldGlvblBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIHRoaXMucnVubmluZyA9IFtdO1xuICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi87XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlKVxuICAgICAgICAgICAgaWYgKGFjdGl2ZS5pc1BlbmRpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpO1xuICAgICAgICBsZXQgY29uZiA9IHVwZGF0ZS5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuc2VsZWN0aW9uU2V0ICYmICF1cGRhdGUuZG9jQ2hhbmdlZCAmJiB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpID09IGNTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRvZXNSZXNldCA9IHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGdldFVwZGF0ZVR5cGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlICYgOCAvKiBVcGRhdGVUeXBlLlJlc2V0ICovKSB8fCAodHIuc2VsZWN0aW9uIHx8IHRyLmRvY0NoYW5nZWQpICYmICEodHlwZSAmIDMgLyogVXBkYXRlVHlwZS5TaW1wbGVJbnRlcmFjdGlvbiAqLyk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKGRvZXNSZXNldCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNvbnRleHQuYWJvcnRPbkRvY0NoYW5nZSAmJiB1cGRhdGUuZG9jQ2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBEYXRlLm5vdygpIC0gcXVlcnkudGltZSA+IE1pbkFib3J0VGltZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLnB1c2goLi4udXBkYXRlLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VVcGRhdGUgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVXBkYXRlKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5lZmZlY3RzLnNvbWUoZSA9PiBlLmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpKSlcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy5wZW5kaW5nU3RhcnQgPyA1MCA6IGNvbmYuYWN0aXZhdGVPblR5cGluZ0RlbGF5O1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5pc1BlbmRpbmcgJiYgIXRoaXMucnVubmluZy5zb21lKHEgPT4gcS5hY3RpdmUuc291cmNlID09IGEuc291cmNlKSlcbiAgICAgICAgICAgID8gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0VXBkYXRlKCksIGRlbGF5KSA6IC0xO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgIT0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi8pXG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvc2luZyA9PSAyIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZCAqLyAmJiB0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGNTdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUuaXNQZW5kaW5nICYmICF0aGlzLnJ1bm5pbmcuc29tZShyID0+IHIuYWN0aXZlLnNvdXJjZSA9PSBhY3RpdmUuc291cmNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ydW5uaW5nLmxlbmd0aCAmJiBjU3RhdGUub3BlbiAmJiBjU3RhdGUub3Blbi5kaXNhYmxlZClcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWNjZXB0KCksIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS51cGRhdGVTeW5jVGltZSk7XG4gICAgfVxuICAgIHN0YXJ0UXVlcnkoYWN0aXZlKSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIHBvcyA9IGN1cihzdGF0ZSk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IENvbXBsZXRpb25Db250ZXh0KHN0YXRlLCBwb3MsIGFjdGl2ZS5leHBsaWNpdCwgdGhpcy52aWV3KTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSBuZXcgUnVubmluZ1F1ZXJ5KGFjdGl2ZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMucnVubmluZy5wdXNoKHBlbmRpbmcpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoYWN0aXZlLnNvdXJjZShjb250ZXh0KSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nLmNvbnRleHQuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmcuZG9uZSA9IHJlc3VsdCB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBY2NlcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUFjY2VwdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5ldmVyeShxID0+IHEuZG9uZSAhPT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnVwZGF0ZVN5bmNUaW1lKTtcbiAgICB9XG4gICAgLy8gRm9yIGVhY2ggZmluaXNoZWQgcXVlcnkgaW4gdGhpcy5ydW5uaW5nLCB0cnkgdG8gY3JlYXRlIGEgcmVzdWx0XG4gICAgLy8gb3IsIGlmIGFwcHJvcHJpYXRlLCByZXN0YXJ0IHRoZSBxdWVyeS5cbiAgICBhY2NlcHQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VBY2NlcHQgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlQWNjZXB0KTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKSwgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gY3VyKHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoID8gcXVlcnkudXBkYXRlc1swXS5zdGFydFN0YXRlIDogdGhpcy52aWV3LnN0YXRlKTtcbiAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBNYXRoLm1pbihwb3MsIHF1ZXJ5LmRvbmUuZnJvbSArIChxdWVyeS5hY3RpdmUuZXhwbGljaXQgPyAwIDogMSkpO1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlUmVzdWx0KHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIHF1ZXJ5LmFjdGl2ZS5leHBsaWNpdCwgbGltaXQsIHF1ZXJ5LmRvbmUsIHF1ZXJ5LmRvbmUuZnJvbSwgKF9hID0gcXVlcnkuZG9uZS50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9zKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYXkgdGhlIHRyYW5zYWN0aW9ucyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZlxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IGFuZCBzZWUgaWYgdGhhdCBwcmVzZXJ2ZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY1N0YXRlLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gcXVlcnkuYWN0aXZlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBmYWlsZWQuIFNob3VsZCBjbGVhciB0aGUgcGVuZGluZyBzdGF0dXMgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IGJlZW4gcmUtc2V0IGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuYWN0aXZlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY3RpdmUuaXNQZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5wdXNoKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhcmVkIGJ5IHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zLiBSZXN0YXJ0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkLmxlbmd0aCB8fCBjU3RhdGUub3BlbiAmJiBjU3RhdGUub3Blbi5kaXNhYmxlZClcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldEFjdGl2ZUVmZmVjdC5vZih1cGRhdGVkKSB9KTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICBibHVyKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY2xvc2VPbkJsdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhbG9nID0gc3RhdGUub3BlbiAmJiBnZXRUb29sdGlwKHRoaXMudmlldywgc3RhdGUub3Blbi50b29sdGlwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpYWxvZyB8fCAhZGlhbG9nLmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSksIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25zdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMSAvKiBDb21wb3NpdGlvblN0YXRlLlN0YXJ0ZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9uZW5kKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID09IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgY29tcG9zaXRpb25lbmQgZXZlbnRzIHN5bmNocm9ub3VzbHksIHBvc3NpYmx5XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBpbnNpZGUgYW4gdXBkYXRlLCBzbyBkaXNwYXRjaCBhc3luY2hyb25vdXNseSB0byBhdm9pZCByZWVudHJhbmN5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzdGFydENvbXBsZXRpb25FZmZlY3Qub2YoZmFsc2UpIH0pLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCB3aW5kb3dzID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBjb21taXRDaGFyYWN0ZXJzID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBrZXlkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghZmllbGQgfHwgIWZpZWxkLm9wZW4gfHwgZmllbGQub3Blbi5kaXNhYmxlZCB8fCBmaWVsZC5vcGVuLnNlbGVjdGVkIDwgMCB8fFxuICAgICAgICAgICAgZXZlbnQua2V5Lmxlbmd0aCA+IDEgfHwgZXZlbnQuY3RybEtleSAmJiAhKHdpbmRvd3MgJiYgZXZlbnQuYWx0S2V5KSB8fCBldmVudC5tZXRhS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb3B0aW9uID0gZmllbGQub3Blbi5vcHRpb25zW2ZpZWxkLm9wZW4uc2VsZWN0ZWRdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmllbGQuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBvcHRpb24uc291cmNlKTtcbiAgICAgICAgbGV0IGNvbW1pdENoYXJzID0gb3B0aW9uLmNvbXBsZXRpb24uY29tbWl0Q2hhcmFjdGVycyB8fCByZXN1bHQucmVzdWx0LmNvbW1pdENoYXJhY3RlcnM7XG4gICAgICAgIGlmIChjb21taXRDaGFycyAmJiBjb21taXRDaGFycy5pbmRleE9mKGV2ZW50LmtleSkgPiAtMSlcbiAgICAgICAgICAgIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb24pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSkpO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXAuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xuICAgICAgICBcIiYgPiB1bFwiOiB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlbiBhdXRvXCIsXG4gICAgICAgICAgICBtYXhXaWR0aF9mYWxsYmFjazogXCI3MDBweFwiLFxuICAgICAgICAgICAgbWF4V2lkdGg6IFwibWluKDcwMHB4LCA5NXZ3KVwiLFxuICAgICAgICAgICAgbWluV2lkdGg6IFwiMjUwcHhcIixcbiAgICAgICAgICAgIG1heEhlaWdodDogXCIxMGVtXCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBcIiYgPiBsaSwgJiA+IGNvbXBsZXRpb24tc2VjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogXCIxcHggM3B4XCIsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogMS4yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImID4gbGlcIjoge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IFwiZWxsaXBzaXNcIixcbiAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImID4gY29tcGxldGlvbi1zZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImxpc3QtaXRlbVwiLFxuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgc2lsdmVyXCIsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMTdjXCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3NzdcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMzQ3XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzQ0NFwiLFxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wOmJlZm9yZSwgLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZUJvdHRvbTphZnRlclwiOiB7XG4gICAgICAgIGNvbnRlbnQ6ICdcIsK3wrfCt1wiJyxcbiAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC5jbS1jb21wbGV0aW9uSW5mb1wiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiM3B4IDlweFwiLFxuICAgICAgICB3aWR0aDogXCJtYXgtY29udGVudFwiLFxuICAgICAgICBtYXhXaWR0aDogYCR7NDAwIC8qIEluZm8uV2lkdGggKi99cHhgLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS1saW5lXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnRcIjogeyByaWdodDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodFwiOiB7IGxlZnQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHQtbmFycm93XCI6IHsgbGVmdDogYCR7MzAgLyogSW5mby5NYXJnaW4gKi99cHhgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmMjJcIiB9LFxuICAgIFwiLmNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiBcIjEuMTVlbVwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjRweCBkb3R0ZWQgIzg4OFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTWF0Y2hlZFRleHRcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkRldGFpbFwiOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiMC41ZW1cIixcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjkwJVwiLFxuICAgICAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICAgICAgb3BhY2l0eTogXCIwLjZcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWZ1bmN0aW9uLCAuY20tY29tcGxldGlvbkljb24tbWV0aG9kXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInxpInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tY2xhc3NcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4snXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24taW50ZXJmYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4peMJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXZhcmlhYmxlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RpSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jb25zdGFudFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkLYnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdHlwZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkaEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZW51bVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KIqidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1wcm9wZXJ0eVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KWoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1rZXl3b3JkXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J+UkVxcdUZFMEUnXCIgfSAvLyBEaXNhYmxlIGVtb2ppIHJlbmRlcmluZ1xuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tbmFtZXNwYWNlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4paiJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXRleHRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIidhYmMnXCIsIGZvbnRTaXplOiBcIjUwJVwiLCB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiIH1cbiAgICB9XG59KTtcblxuY2xhc3MgRmllbGRQb3Mge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBsaW5lLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG5jbGFzcyBGaWVsZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIGxldCB0byA9IGNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICByZXR1cm4gZnJvbSA9PSBudWxsIHx8IHRvID09IG51bGwgPyBudWxsIDogbmV3IEZpZWxkUmFuZ2UodGhpcy5maWVsZCwgZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNsYXNzIFNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVzLCBmaWVsZFBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgICAgIHRoaXMuZmllbGRQb3NpdGlvbnMgPSBmaWVsZFBvc2l0aW9ucztcbiAgICB9XG4gICAgaW5zdGFudGlhdGUoc3RhdGUsIHBvcykge1xuICAgICAgICBsZXQgdGV4dCA9IFtdLCBsaW5lU3RhcnQgPSBbcG9zXTtcbiAgICAgICAgbGV0IGxpbmVPYmogPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJhc2VJbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZU9iai50ZXh0KVswXTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLmxpbmVzKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gYmFzZUluZGVudCwgdGFicyA9IC9eXFx0Ki8uZXhlYyhsaW5lKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQucHVzaChwb3MgKyBpbmRlbnQubGVuZ3RoIC0gdGFicyk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGluZGVudCArIGxpbmUuc2xpY2UodGFicyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0LnB1c2gobGluZSk7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLmZpZWxkUG9zaXRpb25zLm1hcChwb3MgPT4gbmV3IEZpZWxkUmFuZ2UocG9zLmZpZWxkLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLmZyb20sIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MudG8pKTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dCwgcmFuZ2VzIH07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh0ZW1wbGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBsaW5lcyA9IFtdLCBwb3NpdGlvbnMgPSBbXSwgbTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZW1wbGF0ZS5zcGxpdCgvXFxyXFxuP3xcXG4vKSkge1xuICAgICAgICAgICAgd2hpbGUgKG0gPSAvWyMkXVxceyg/OihcXGQrKSg/OjooW157fV0qKSk/fCgoPzpcXFxcW3t9XXxbXnt9XSkqKSlcXH0vLmV4ZWMobGluZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VxID0gbVsxXSA/ICttWzFdIDogbnVsbCwgcmF3TmFtZSA9IG1bMl0gfHwgbVszXSB8fCBcIlwiLCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gcmF3TmFtZS5yZXBsYWNlKC9cXFxcW3t9XS9nLCBtID0+IG1bMV0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXEgIT0gbnVsbCA/IGZpZWxkc1tpXS5zZXEgPT0gc2VxIDogbmFtZSA/IGZpZWxkc1tpXS5uYW1lID09IG5hbWUgOiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZmllbGRzLmxlbmd0aCAmJiAoc2VxID09IG51bGwgfHwgKGZpZWxkc1tpXS5zZXEgIT0gbnVsbCAmJiBmaWVsZHNbaV0uc2VxIDwgc2VxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoaSwgMCwgeyBzZXEsIG5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MuZmllbGQgPj0gZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZpZWxkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MubGluZSA9PSBsaW5lcy5sZW5ndGggJiYgcG9zLmZyb20gPiBtLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc25pcCA9IG1bMl0gPyAzICsgKG1bMV0gfHwgXCJcIikubGVuZ3RoIDogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tIC09IHNuaXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MudG8gLT0gc25pcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBGaWVsZFBvcyhmb3VuZCwgbGluZXMubGVuZ3RoLCBtLmluZGV4LCBtLmluZGV4ICsgbmFtZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBtLmluZGV4KSArIHJhd05hbWUgKyBsaW5lLnNsaWNlKG0uaW5kZXggKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9cXFxcKFt7fV0pL2csIChfLCBicmFjZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmxpbmUgPT0gbGluZXMubGVuZ3RoICYmIHBvcy5mcm9tID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5mcm9tLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MudG8tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBicmFjZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNuaXBwZXQobGluZXMsIHBvc2l0aW9ucyk7XG4gICAgfVxufVxubGV0IGZpZWxkTWFya2VyID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKCkge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH0gfSk7XG5sZXQgZmllbGRSYW5nZSA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zbmlwcGV0RmllbGRcIiB9KTtcbmNsYXNzIEFjdGl2ZVNuaXBwZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlcywgYWN0aXZlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5kZWNvID0gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLm1hcChyID0+IChyLmZyb20gPT0gci50byA/IGZpZWxkTWFya2VyIDogZmllbGRSYW5nZSkucmFuZ2Uoci5mcm9tLCByLnRvKSksIHRydWUpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSByLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghbWFwcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCB0aGlzLmFjdGl2ZSk7XG4gICAgfVxuICAgIHNlbGVjdGlvbkluc2lkZUZpZWxkKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLnJhbmdlcy5ldmVyeShyYW5nZSA9PiB0aGlzLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA9PSB0aGlzLmFjdGl2ZSAmJiByLmZyb20gPD0gcmFuZ2UuZnJvbSAmJiByLnRvID49IHJhbmdlLnRvKSk7XG4gICAgfVxufVxuY29uc3Qgc2V0QWN0aXZlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBjaGFuZ2VzKSB7IHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5tYXAoY2hhbmdlcyk7IH1cbn0pO1xuY29uc3QgbW92ZVRvRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzbmlwcGV0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRBY3RpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKG1vdmVUb0ZpZWxkKSAmJiB2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNuaXBwZXQodmFsdWUucmFuZ2VzLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0ci5zZWxlY3Rpb24gJiYgIXZhbHVlLnNlbGVjdGlvbkluc2lkZUZpZWxkKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHZhbCA9PiB2YWwgPyB2YWwuZGVjbyA6IERlY29yYXRpb24ubm9uZSlcbn0pO1xuZnVuY3Rpb24gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCBmaWVsZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5maWx0ZXIociA9PiByLmZpZWxkID09IGZpZWxkKS5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpO1xufVxuLyoqXG5Db252ZXJ0IGEgc25pcHBldCB0ZW1wbGF0ZSB0byBhIGZ1bmN0aW9uIHRoYXQgY2FuXG5bYXBwbHldKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb24uYXBwbHkpIGl0LiBTbmlwcGV0cyBhcmUgd3JpdHRlblxudXNpbmcgc3ludGF4IGxpa2UgdGhpczpcblxuICAgIFwiZm9yIChsZXQgJHtpbmRleH0gPSAwOyAke2luZGV4fSA8ICR7ZW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIlxuXG5FYWNoIGAke31gIHBsYWNlaG9sZGVyICh5b3UgbWF5IGFsc28gdXNlIGAje31gKSBpbmRpY2F0ZXMgYSBmaWVsZFxudGhhdCB0aGUgdXNlciBjYW4gZmlsbCBpbi4gSXRzIG5hbWUsIGlmIGFueSwgd2lsbCBiZSB0aGUgZGVmYXVsdFxuY29udGVudCBmb3IgdGhlIGZpZWxkLlxuXG5XaGVuIHRoZSBzbmlwcGV0IGlzIGFjdGl2YXRlZCBieSBjYWxsaW5nIHRoZSByZXR1cm5lZCBmdW5jdGlvbixcbnRoZSBjb2RlIGlzIGluc2VydGVkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gTmV3bGluZXMgaW4gdGhlXG50ZW1wbGF0ZSBhcmUgaW5kZW50ZWQgYnkgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBzdGFydCBsaW5lLCBwbHVzXG5vbmUgW2luZGVudCB1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIHBlciB0YWIgY2hhcmFjdGVyIGFmdGVyXG50aGUgbmV3bGluZS5cblxuT24gYWN0aXZhdGlvbiwgKGFsbCBpbnN0YW5jZXMgb2YpIHRoZSBmaXJzdCBmaWVsZCBhcmUgc2VsZWN0ZWQuXG5UaGUgdXNlciBjYW4gbW92ZSBiZXR3ZWVuIGZpZWxkcyB3aXRoIFRhYiBhbmQgU2hpZnQtVGFiIGFzIGxvbmcgYXNcbnRoZSBmaWVsZHMgYXJlIGFjdGl2ZS4gTW92aW5nIHRvIHRoZSBsYXN0IGZpZWxkIG9yIG1vdmluZyB0aGVcbmN1cnNvciBvdXQgb2YgdGhlIGN1cnJlbnQgZmllbGQgZGVhY3RpdmF0ZXMgdGhlIGZpZWxkcy5cblxuVGhlIG9yZGVyIG9mIGZpZWxkcyBkZWZhdWx0cyB0byB0ZXh0dWFsIG9yZGVyLCBidXQgeW91IGNhbiBhZGRcbm51bWJlcnMgdG8gcGxhY2Vob2xkZXJzIChgJHsxfWAgb3IgYCR7MTpkZWZhdWx0VGV4dH1gKSB0byBwcm92aWRlXG5hIGN1c3RvbSBvcmRlci5cblxuVG8gaW5jbHVkZSBhIGxpdGVyYWwgYHtgIG9yIGB9YCBpbiB5b3VyIHRlbXBsYXRlLCBwdXQgYSBiYWNrc2xhc2hcbmluIGZyb250IG9mIGl0LiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIGJyYWNlIHdpbGwgbm90IGJlXG5pbnRlcnByZXRlZCBhcyBpbmRpY2F0aW5nIGEgcGxhY2Vob2xkZXIuXG4qL1xuZnVuY3Rpb24gc25pcHBldCh0ZW1wbGF0ZSkge1xuICAgIGxldCBzbmlwcGV0ID0gU25pcHBldC5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIChlZGl0b3IsIGNvbXBsZXRpb24sIGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGxldCB7IHRleHQsIHJhbmdlcyB9ID0gc25pcHBldC5pbnN0YW50aWF0ZShlZGl0b3Iuc3RhdGUsIGZyb20pO1xuICAgICAgICBsZXQgeyBtYWluIH0gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgc3BlYyA9IHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbSwgdG86IHRvID09IG1haW4uZnJvbSA/IG1haW4udG8gOiB0bywgaW5zZXJ0OiBUZXh0Lm9mKHRleHQpIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBjb21wbGV0aW9uID8gW3BpY2tlZENvbXBsZXRpb24ub2YoY29tcGxldGlvbiksIFRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihcImlucHV0LmNvbXBsZXRlXCIpXSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMuc2VsZWN0aW9uID0gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCAwKTtcbiAgICAgICAgaWYgKHJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IDApKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCAwKTtcbiAgICAgICAgICAgIGxldCBlZmZlY3RzID0gc3BlYy5lZmZlY3RzID0gW3NldEFjdGl2ZS5vZihhY3RpdmUpXTtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtzbmlwcGV0U3RhdGUsIGFkZFNuaXBwZXRLZXltYXAsIHNuaXBwZXRQb2ludGVySGFuZGxlciwgYmFzZVRoZW1lXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaChlZGl0b3Iuc3RhdGUudXBkYXRlKHNwZWMpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZUZpZWxkKGRpcikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IGRpciA8IDAgJiYgYWN0aXZlLmFjdGl2ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbmV4dCA9IGFjdGl2ZS5hY3RpdmUgKyBkaXIsIGxhc3QgPSBkaXIgPiAwICYmICFhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IG5leHQgKyBkaXIpO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBuZXh0KSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihsYXN0ID8gbnVsbCA6IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG5leHQpKSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQSBjb21tYW5kIHRoYXQgY2xlYXJzIHRoZSBhY3RpdmUgc25pcHBldCwgaWYgYW55LlxuKi9cbmNvbnN0IGNsZWFyU25pcHBldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgZWZmZWN0czogc2V0QWN0aXZlLm9mKG51bGwpIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdG8gdGhlIG5leHQgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IG5leHRTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKDEpO1xuLyoqXG5Nb3ZlIHRvIHRoZSBwcmV2aW91cyBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgcHJldlNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoLTEpO1xuLyoqXG5DaGVjayBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgc25pcHBldCB3aXRoIGEgbmV4dCBmaWVsZCBmb3JcbmBuZXh0U25pcHBldEZpZWxkYCB0byBtb3ZlIHRvLlxuKi9cbmZ1bmN0aW9uIGhhc05leHRTbmlwcGV0RmllbGQoc3RhdGUpIHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuICEhKGFjdGl2ZSAmJiBhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUgKyAxKSk7XG59XG4vKipcblJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgc25pcHBldCBhbmQgYSBwcmV2aW91cyBmaWVsZFxuZm9yIGBwcmV2U25pcHBldEZpZWxkYCB0byBtb3ZlIHRvLlxuKi9cbmZ1bmN0aW9uIGhhc1ByZXZTbmlwcGV0RmllbGQoc3RhdGUpIHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuICEhKGFjdGl2ZSAmJiBhY3RpdmUuYWN0aXZlID4gMCk7XG59XG5jb25zdCBkZWZhdWx0U25pcHBldEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJUYWJcIiwgcnVuOiBuZXh0U25pcHBldEZpZWxkLCBzaGlmdDogcHJldlNuaXBwZXRGaWVsZCB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsZWFyU25pcHBldCB9XG5dO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZSBrZXkgYmluZGluZ3MgdXNlZCBieVxuc25pcHBldHMuIFRoZSBkZWZhdWx0IGJpbmRzIFRhYiB0b1xuW2BuZXh0U25pcHBldEZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubmV4dFNuaXBwZXRGaWVsZCksIFNoaWZ0LVRhYiB0b1xuW2BwcmV2U25pcHBldEZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUucHJldlNuaXBwZXRGaWVsZCksIGFuZCBFc2NhcGVcbnRvIFtgY2xlYXJTbmlwcGV0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xlYXJTbmlwcGV0KS5cbiovXG5jb25zdCBzbmlwcGV0S2V5bWFwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShtYXBzKSB7IHJldHVybiBtYXBzLmxlbmd0aCA/IG1hcHNbMF0gOiBkZWZhdWx0U25pcHBldEtleW1hcDsgfVxufSk7XG5jb25zdCBhZGRTbmlwcGV0S2V5bWFwID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyova2V5bWFwLmNvbXB1dGUoW3NuaXBwZXRLZXltYXBdLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChzbmlwcGV0S2V5bWFwKSkpO1xuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIGZyb20gYSBzbmlwcGV0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZVxucHJvcGVydGllcyBmcm9tIGBjb21wbGV0aW9uYCwgcGx1cyBhbiBgYXBwbHlgIGZ1bmN0aW9uIHRoYXRcbmFwcGxpZXMgdGhlIHNuaXBwZXQuXG4qL1xuZnVuY3Rpb24gc25pcHBldENvbXBsZXRpb24odGVtcGxhdGUsIGNvbXBsZXRpb24pIHtcbiAgICByZXR1cm4geyAuLi5jb21wbGV0aW9uLCBhcHBseTogc25pcHBldCh0ZW1wbGF0ZSkgfTtcbn1cbmNvbnN0IHNuaXBwZXRQb2ludGVySGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIG1vdXNlZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSwgcG9zO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCAocG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaCA9IGFjdGl2ZS5yYW5nZXMuZmluZChyID0+IHIuZnJvbSA8PSBwb3MgJiYgci50byA+PSBwb3MpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YoYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IG1hdGNoLmZpZWxkKVxuICAgICAgICAgICAgICAgID8gbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpIDogbnVsbCksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHdvcmRSRSh3b3JkQ2hhcnMpIHtcbiAgICBsZXQgZXNjYXBlZCA9IHdvcmRDaGFycy5yZXBsYWNlKC9bXFxdXFwtXFxcXF0vZywgXCJcXFxcJCZcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fJHtlc2NhcGVkfV0rYCwgXCJ1Z1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFx3JHtlc2NhcGVkfV1gLCBcImdcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUkUocmUsIGYpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmKHJlLnNvdXJjZSksIHJlLnVuaWNvZGUgPyBcInVcIiA6IFwiXCIpO1xufVxuY29uc3Qgd29yZENhY2hlcyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gd29yZENhY2hlKHdvcmRDaGFycykge1xuICAgIHJldHVybiB3b3JkQ2FjaGVzW3dvcmRDaGFyc10gfHwgKHdvcmRDYWNoZXNbd29yZENoYXJzXSA9IG5ldyBXZWFrTWFwKTtcbn1cbmZ1bmN0aW9uIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpIHtcbiAgICBmb3IgKGxldCBsaW5lcyA9IGRvYy5pdGVyTGluZXMoKSwgcG9zID0gMDsgIWxpbmVzLm5leHQoKS5kb25lOykge1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gbGluZXMsIG07XG4gICAgICAgIHdvcmRSRS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobSA9IHdvcmRSRS5leGVjKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFzZWVuW21bMF1dICYmIHBvcyArIG0uaW5kZXggIT0gaWdub3JlQXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCBsYWJlbDogbVswXSB9KTtcbiAgICAgICAgICAgICAgICBzZWVuW21bMF1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB2YWx1ZS5sZW5ndGggKyAxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RXb3Jkcyhkb2MsIGNhY2hlLCB3b3JkUkUsIHRvLCBpZ25vcmVBdCkge1xuICAgIGxldCBiaWcgPSBkb2MubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLztcbiAgICBsZXQgY2FjaGVkID0gYmlnICYmIGNhY2hlLmdldChkb2MpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZG9jLmNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaC5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb2xsZWN0V29yZHMoY2gsIGNhY2hlLCB3b3JkUkUsIHRvIC0gcG9zLCBpZ25vcmVBdCAtIHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW2MubGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2MubGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVXb3JkcyhjaCwgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0IC0gcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBjaC5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KTtcbiAgICB9XG4gICAgaWYgKGJpZyAmJiByZXN1bHQubGVuZ3RoIDwgMjAwMCAvKiBDLk1heExpc3QgKi8pXG4gICAgICAgIGNhY2hlLnNldChkb2MsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuQSBjb21wbGV0aW9uIHNvdXJjZSB0aGF0IHdpbGwgc2NhbiB0aGUgZG9jdW1lbnQgZm9yIHdvcmRzICh1c2luZyBhXG5bY2hhcmFjdGVyIGNhdGVnb3JpemVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikpLCBhbmRcbnJldHVybiB0aG9zZSBhcyBjb21wbGV0aW9ucy5cbiovXG5jb25zdCBjb21wbGV0ZUFueVdvcmQgPSBjb250ZXh0ID0+IHtcbiAgICBsZXQgd29yZENoYXJzID0gY29udGV4dC5zdGF0ZS5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBjb250ZXh0LnBvcykuam9pbihcIlwiKTtcbiAgICBsZXQgcmUgPSB3b3JkUkUod29yZENoYXJzKTtcbiAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hcFJFKHJlLCBzID0+IHMgKyBcIiRcIikpO1xuICAgIGlmICghdG9rZW4gJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmcm9tID0gdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3M7XG4gICAgbGV0IG9wdGlvbnMgPSBjb2xsZWN0V29yZHMoY29udGV4dC5zdGF0ZS5kb2MsIHdvcmRDYWNoZSh3b3JkQ2hhcnMpLCByZSwgNTAwMDAgLyogQy5SYW5nZSAqLywgZnJvbSk7XG4gICAgcmV0dXJuIHsgZnJvbSwgb3B0aW9ucywgdmFsaWRGb3I6IG1hcFJFKHJlLCBzID0+IFwiXlwiICsgcykgfTtcbn07XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIiddLFxuICAgIGJlZm9yZTogXCIpXX06Oz5cIixcbiAgICBzdHJpbmdQcmVmaXhlczogW11cbn07XG5jb25zdCBjbG9zZUJyYWNrZXRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IG1hcHBpbmcubWFwUG9zKHZhbHVlLCAtMSwgTWFwTW9kZS5UcmFja0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PSBudWxsID8gdW5kZWZpbmVkIDogbWFwcGVkO1xuICAgIH1cbn0pO1xuY29uc3QgY2xvc2VkQnJhY2tldCA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbn07XG5jbG9zZWRCcmFja2V0LnN0YXJ0U2lkZSA9IDE7XG5jbG9zZWRCcmFja2V0LmVuZFNpZGUgPSAtMTtcbmNvbnN0IGJyYWNrZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ci5zdGF0ZS5kb2MubGluZUF0KHRyLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBmaWx0ZXI6IGZyb20gPT4gZnJvbSA+PSBsaW5lLmZyb20gJiYgZnJvbSA8PSBsaW5lLnRvIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUJyYWNrZXRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgYWRkOiBbY2xvc2VkQnJhY2tldC5yYW5nZShlZmZlY3QudmFsdWUsIGVmZmVjdC52YWx1ZSArIDEpXSB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIGJyYWNrZXQtY2xvc2luZyBiZWhhdmlvci4gV2hlbiBhIGNsb3NlYWJsZVxuYnJhY2tldCBpcyB0eXBlZCwgaXRzIGNsb3NpbmcgYnJhY2tldCBpcyBpbW1lZGlhdGVseSBpbnNlcnRlZFxuYWZ0ZXIgdGhlIGN1cnNvci4gV2hlbiBjbG9zaW5nIGEgYnJhY2tldCBkaXJlY3RseSBpbiBmcm9udCBvZiBhXG5jbG9zaW5nIGJyYWNrZXQgaW5zZXJ0ZWQgYnkgdGhlIGV4dGVuc2lvbiwgdGhlIGN1cnNvciBtb3ZlcyBvdmVyXG50aGF0IGJyYWNrZXQuXG4qL1xuZnVuY3Rpb24gY2xvc2VCcmFja2V0cygpIHtcbiAgICByZXR1cm4gW2lucHV0SGFuZGxlciwgYnJhY2tldFN0YXRlXTtcbn1cbmNvbnN0IGRlZmluZWRDbG9zaW5nID0gXCIoKVtde308PsKrwrvCu8Kr77y777y9772b772dXCI7XG5mdW5jdGlvbiBjbG9zaW5nKGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZpbmVkQ2xvc2luZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGRlZmluZWRDbG9zaW5nLmNoYXJDb2RlQXQoaSkgPT0gY2gpXG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZENsb3NpbmcuY2hhckF0KGkgKyAxKTtcbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjaCA8IDEyOCA/IGNoIDogY2ggKyAxKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgcmV0dXJuIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY2xvc2VCcmFja2V0c1wiLCBwb3MpWzBdIHx8IGRlZmF1bHRzO1xufVxuY29uc3QgYW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCBpbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGluc2VydC5sZW5ndGggPiAyIHx8IGluc2VydC5sZW5ndGggPT0gMiAmJiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KGluc2VydCwgMCkpID09IDEgfHxcbiAgICAgICAgZnJvbSAhPSBzZWwuZnJvbSB8fCB0byAhPSBzZWwudG8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHIgPSBpbnNlcnRCcmFja2V0KHZpZXcuc3RhdGUsIGluc2VydCk7XG4gICAgaWYgKCF0cilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBpbXBsZW1lbnRzIGRlbGV0aW5nIGEgcGFpciBvZiBtYXRjaGluZyBicmFja2V0cyB3aGVuXG50aGUgY3Vyc29yIGlzIGJldHdlZW4gdGhlbS5cbiovXG5jb25zdCBkZWxldGVCcmFja2V0UGFpciA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwcmV2Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NpbmcoY29kZVBvaW50QXQodG9rZW4sIDApKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoLCB0bzogcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKCFkb250KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5iYWNrd2FyZFwiIH0pKTtcbiAgICByZXR1cm4gIWRvbnQ7XG59O1xuLyoqXG5DbG9zZS1icmFja2V0cyByZWxhdGVkIGtleSBiaW5kaW5ncy4gQmluZHMgQmFja3NwYWNlIHRvXG5bYGRlbGV0ZUJyYWNrZXRQYWlyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuZGVsZXRlQnJhY2tldFBhaXIpLlxuKi9cbmNvbnN0IGNsb3NlQnJhY2tldHNLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQnJhY2tldFBhaXIgfVxuXTtcbi8qKlxuSW1wbGVtZW50cyB0aGUgZXh0ZW5zaW9uJ3MgYmVoYXZpb3Igb24gdGV4dCBpbnNlcnRpb24uIElmIHRoZVxuZ2l2ZW4gc3RyaW5nIGNvdW50cyBhcyBhIGJyYWNrZXQgaW4gdGhlIGxhbmd1YWdlIGFyb3VuZCB0aGVcbnNlbGVjdGlvbiwgYW5kIHJlcGxhY2luZyB0aGUgc2VsZWN0aW9uIHdpdGggaXQgcmVxdWlyZXMgY3VzdG9tXG5iZWhhdmlvciAoaW5zZXJ0aW5nIGEgY2xvc2luZyB2ZXJzaW9uIG9yIHNraXBwaW5nIHBhc3QgYVxucHJldmlvdXNseS1jbG9zZWQgYnJhY2tldCksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRpbmcgdGhhdCBjdXN0b20gYmVoYXZpb3IuIChZb3Ugb25seSBuZWVkIHRoaXMgaWYgeW91IHdhbnRcbnRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGJyYWNrZXRz4oCUdGhlXG5bYGNsb3NlQnJhY2tldHNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUJyYWNrZXRzKSBleHRlbnNpb24gd2lsbFxudGFrZSBjYXJlIG9mIHJ1bm5pbmcgdGhpcyBmb3IgdXNlciBpbnB1dC4pXG4qL1xuZnVuY3Rpb24gaW5zZXJ0QnJhY2tldChzdGF0ZSwgYnJhY2tldCkge1xuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBmb3IgKGxldCB0b2sgb2YgdG9rZW5zKSB7XG4gICAgICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nKGNvZGVQb2ludEF0KHRvaywgMCkpO1xuICAgICAgICBpZiAoYnJhY2tldCA9PSB0b2spXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VkID09IHRvayA/IGhhbmRsZVNhbWUoc3RhdGUsIHRvaywgdG9rZW5zLmluZGV4T2YodG9rICsgdG9rICsgdG9rKSA+IC0xLCBjb25mKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlT3BlbihzdGF0ZSwgdG9rLCBjbG9zZWQsIGNvbmYuYmVmb3JlIHx8IGRlZmF1bHRzLmJlZm9yZSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IGNsb3NlZCAmJiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNsb3NlKHN0YXRlLCB0b2ssIGNsb3NlZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBzdGF0ZS5maWVsZChicmFja2V0U3RhdGUpLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgZnJvbSA9PiB7XG4gICAgICAgIGlmIChmcm9tID09IHBvcylcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBuZXh0Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBuZXh0ID0gZG9jLnNsaWNlU3RyaW5nKHBvcywgcG9zICsgMik7XG4gICAgcmV0dXJuIG5leHQuc2xpY2UoMCwgY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChuZXh0LCAwKSkpO1xufVxuZnVuY3Rpb24gcHJldkNoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgcHJldiA9IGRvYy5zbGljZVN0cmluZyhwb3MgLSAyLCBwb3MpO1xuICAgIHJldHVybiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KHByZXYsIDApKSA9PSBwcmV2Lmxlbmd0aCA/IHByZXYgOiBwcmV2LnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gaGFuZGxlT3BlbihzdGF0ZSwgb3BlbiwgY2xvc2UsIGNsb3NlQmVmb3JlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IG9wZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IGNsb3NlLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyBvcGVuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyBvcGVuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgIGlmICghbmV4dCB8fCAvXFxzLy50ZXN0KG5leHQpIHx8IGNsb3NlQmVmb3JlLmluZGV4T2YobmV4dCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiBvcGVuICsgY2xvc2UsIGZyb206IHJhbmdlLmhlYWQgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xvc2Uoc3RhdGUsIF9vcGVuLCBjbG9zZSkge1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuaGVhZCwgdG86IHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgsIGluc2VydDogY2xvc2UgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgY2xvc2UubGVuZ3RoKSB9O1xuICAgICAgICByZXR1cm4gZG9udCA9IHsgcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuLy8gSGFuZGxlcyBjYXNlcyB3aGVyZSB0aGUgb3BlbiBhbmQgY2xvc2UgdG9rZW4gYXJlIHRoZSBzYW1lLCBhbmRcbi8vIHBvc3NpYmx5IHRyaXBsZSBxdW90ZXMgKGFzIGluIGBcIlwiXCJhYmNcIlwiXCJgLXN0eWxlIHF1b3RpbmcpLlxuZnVuY3Rpb24gaGFuZGxlU2FtZShzdGF0ZSwgdG9rZW4sIGFsbG93VHJpcGxlLCBjb25maWcpIHtcbiAgICBsZXQgc3RyaW5nUHJlZml4ZXMgPSBjb25maWcuc3RyaW5nUHJlZml4ZXMgfHwgZGVmYXVsdHMuc3RyaW5nUHJlZml4ZXM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS5mcm9tIH0sIHsgaW5zZXJ0OiB0b2tlbiwgZnJvbTogcmFuZ2UudG8gfV0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLnRvICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIHRva2VuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIG5leHQgPSBuZXh0Q2hhcihzdGF0ZS5kb2MsIHBvcyksIHN0YXJ0O1xuICAgICAgICBpZiAobmV4dCA9PSB0b2tlbikge1xuICAgICAgICAgICAgaWYgKG5vZGVTdGFydChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIGxldCBpc1RyaXBsZSA9IGFsbG93VHJpcGxlICYmIHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgdG9rZW4ubGVuZ3RoICogMykgPT0gdG9rZW4gKyB0b2tlbiArIHRva2VuO1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gaXNUcmlwbGUgPyB0b2tlbiArIHRva2VuICsgdG9rZW4gOiB0b2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHBvcywgdG86IHBvcyArIGNvbnRlbnQubGVuZ3RoLCBpbnNlcnQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgY29udGVudC5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgcG9zKSA9PSB0b2tlbiArIHRva2VuICYmXG4gICAgICAgICAgICAoc3RhcnQgPSBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBzdHJpbmdQcmVmaXhlcykpID4gLTEgJiZcbiAgICAgICAgICAgIG5vZGVTdGFydChzdGF0ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiArIHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKShuZXh0KSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgc3RyaW5nUHJlZml4ZXMpID4gLTEgJiYgIXByb2JhYmx5SW5TdHJpbmcoc3RhdGUsIHBvcywgdG9rZW4sIHN0cmluZ1ByZWZpeGVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBub2RlU3RhcnQoc3RhdGUsIHBvcykge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyArIDEpO1xuICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiB0cmVlLmZyb20gPT0gcG9zO1xufVxuZnVuY3Rpb24gcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCBxdW90ZVRva2VuLCBwcmVmaXhlcykge1xuICAgIGxldCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIGxldCBtYXhQcmVmaXggPSBwcmVmaXhlcy5yZWR1Y2UoKG0sIHApID0+IE1hdGgubWF4KG0sIHAubGVuZ3RoKSwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBNYXRoLm1pbihub2RlLnRvLCBub2RlLmZyb20gKyBxdW90ZVRva2VuLmxlbmd0aCArIG1heFByZWZpeCkpO1xuICAgICAgICBsZXQgcXVvdGVQb3MgPSBzdGFydC5pbmRleE9mKHF1b3RlVG9rZW4pO1xuICAgICAgICBpZiAoIXF1b3RlUG9zIHx8IHF1b3RlUG9zID4gLTEgJiYgcHJlZml4ZXMuaW5kZXhPZihzdGFydC5zbGljZSgwLCBxdW90ZVBvcykpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdCAmJiBmaXJzdC5mcm9tID09IG5vZGUuZnJvbSAmJiBmaXJzdC50byAtIGZpcnN0LmZyb20gPiBxdW90ZVRva2VuLmxlbmd0aCArIHF1b3RlUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKGZpcnN0LnRvIC0gcXVvdGVUb2tlbi5sZW5ndGgsIGZpcnN0LnRvKSA9PSBxdW90ZVRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdC5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUudG8gPT0gcG9zICYmIG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHByZWZpeGVzKSB7XG4gICAgbGV0IGNoYXJDYXQgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBpZiAoY2hhckNhdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBmb3IgKGxldCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBwb3MpID09IHByZWZpeCAmJiBjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHN0YXJ0IC0gMSwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhdXRvY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBhdXRvY29tcGxldGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbW1pdENoYXJhY3RlcnMsXG4gICAgICAgIGNvbXBsZXRpb25TdGF0ZSxcbiAgICAgICAgY29tcGxldGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjb21wbGV0aW9uUGx1Z2luLFxuICAgICAgICBjb21wbGV0aW9uS2V5bWFwRXh0LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xufVxuLyoqXG5CYXNpYyBrZXliaW5kaW5ncyBmb3IgYXV0b2NvbXBsZXRpb24uXG5cbiAtIEN0cmwtU3BhY2UgKGFuZCBBbHQtXFxgIG9yIEFsdC1pIG9uIG1hY09TKTogW2BzdGFydENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zdGFydENvbXBsZXRpb24pXG4gLSBFc2NhcGU6IFtgY2xvc2VDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VDb21wbGV0aW9uKVxuIC0gQXJyb3dEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlKWBcbiAtIEFycm93VXA6IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKGZhbHNlKWBcbiAtIFBhZ2VEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlLCBcInBhZ2VcIilgXG4gLSBQYWdlVXA6IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKGZhbHNlLCBcInBhZ2VcIilgXG4gLSBFbnRlcjogW2BhY2NlcHRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYWNjZXB0Q29tcGxldGlvbilcbiovXG5jb25zdCBjb21wbGV0aW9uS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU3BhY2VcIiwgcnVuOiBzdGFydENvbXBsZXRpb24gfSxcbiAgICB7IG1hYzogXCJBbHQtYFwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsgbWFjOiBcIkFsdC1pXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKHRydWUpIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSkgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UsIFwicGFnZVwiKSB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogYWNjZXB0Q29tcGxldGlvbiB9XG5dO1xuY29uc3QgY29tcGxldGlvbktleW1hcEV4dCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlTihbY29tcGxldGlvbkNvbmZpZ10sIHN0YXRlID0+IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmRlZmF1bHRLZXltYXAgPyBbY29tcGxldGlvbktleW1hcF0gOiBbXSkpO1xuLyoqXG5HZXQgdGhlIGN1cnJlbnQgY29tcGxldGlvbiBzdGF0dXMuIFdoZW4gY29tcGxldGlvbnMgYXJlIGF2YWlsYWJsZSxcbnRoaXMgd2lsbCByZXR1cm4gYFwiYWN0aXZlXCJgLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBwZW5kaW5nIChpbiB0aGVcbnByb2Nlc3Mgb2YgYmVpbmcgcXVlcmllZCksIHRoaXMgcmV0dXJucyBgXCJwZW5kaW5nXCJgLiBPdGhlcndpc2UsIGl0XG5yZXR1cm5zIGBudWxsYC5cbiovXG5mdW5jdGlvbiBjb21wbGV0aW9uU3RhdHVzKHN0YXRlKSB7XG4gICAgbGV0IGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5pc1BlbmRpbmcpID8gXCJwZW5kaW5nXCJcbiAgICAgICAgOiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IFwiYWN0aXZlXCIgOiBudWxsO1xufVxuY29uc3QgY29tcGxldGlvbkFycmF5Q2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXA7XG4vKipcblJldHVybnMgdGhlIGF2YWlsYWJsZSBjb21wbGV0aW9ucyBhcyBhbiBhcnJheS5cbiovXG5mdW5jdGlvbiBjdXJyZW50Q29tcGxldGlvbnMoc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgaWYgKCFvcGVuIHx8IG9wZW4uZGlzYWJsZWQpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBjb21wbGV0aW9uQXJyYXlDYWNoZS5nZXQob3Blbi5vcHRpb25zKTtcbiAgICBpZiAoIWNvbXBsZXRpb25zKVxuICAgICAgICBjb21wbGV0aW9uQXJyYXlDYWNoZS5zZXQob3Blbi5vcHRpb25zLCBjb21wbGV0aW9ucyA9IG9wZW4ub3B0aW9ucy5tYXAobyA9PiBvLmNvbXBsZXRpb24pKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG4vKipcblJldHVybiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24sIGlmIGFueS5cbiovXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb24oc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gJiYgIW9wZW4uZGlzYWJsZWQgJiYgb3Blbi5zZWxlY3RlZCA+PSAwID8gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdLmNvbXBsZXRpb24gOiBudWxsO1xufVxuLyoqXG5SZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcG9zaXRpb24gaW4gdGhlIGFjdGl2ZSBjb21wbGV0aW9uXG5saXN0LCBvciBudWxsIGlmIG5vIGNvbXBsZXRpb25zIGFyZSBhY3RpdmUuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgoc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gJiYgIW9wZW4uZGlzYWJsZWQgJiYgb3Blbi5zZWxlY3RlZCA+PSAwID8gb3Blbi5zZWxlY3RlZCA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhbiBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBjaGFuZ2VcbnRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBzZXRTZWxlY3RlZENvbXBsZXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gc2V0U2VsZWN0ZWRFZmZlY3Qub2YoaW5kZXgpO1xufVxuXG5leHBvcnQgeyBDb21wbGV0aW9uQ29udGV4dCwgYWNjZXB0Q29tcGxldGlvbiwgYXV0b2NvbXBsZXRpb24sIGNsZWFyU25pcHBldCwgY2xvc2VCcmFja2V0cywgY2xvc2VCcmFja2V0c0tleW1hcCwgY2xvc2VDb21wbGV0aW9uLCBjb21wbGV0ZUFueVdvcmQsIGNvbXBsZXRlRnJvbUxpc3QsIGNvbXBsZXRpb25LZXltYXAsIGNvbXBsZXRpb25TdGF0dXMsIGN1cnJlbnRDb21wbGV0aW9ucywgZGVsZXRlQnJhY2tldFBhaXIsIGhhc05leHRTbmlwcGV0RmllbGQsIGhhc1ByZXZTbmlwcGV0RmllbGQsIGlmSW4sIGlmTm90SW4sIGluc2VydEJyYWNrZXQsIGluc2VydENvbXBsZXRpb25UZXh0LCBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbiwgbmV4dFNuaXBwZXRGaWVsZCwgcGlja2VkQ29tcGxldGlvbiwgcHJldlNuaXBwZXRGaWVsZCwgc2VsZWN0ZWRDb21wbGV0aW9uLCBzZWxlY3RlZENvbXBsZXRpb25JbmRleCwgc2V0U2VsZWN0ZWRDb21wbGV0aW9uLCBzbmlwcGV0LCBzbmlwcGV0Q29tcGxldGlvbiwgc25pcHBldEtleW1hcCwgc3RhcnRDb21wbGV0aW9uIH07XG4iXSwibmFtZXMiOlsiQW5ub3RhdGlvbiIsIlN0YXRlRWZmZWN0IiwiRWRpdG9yU2VsZWN0aW9uIiwiY29kZVBvaW50QXQiLCJjb2RlUG9pbnRTaXplIiwiZnJvbUNvZGVQb2ludCIsIkZhY2V0IiwiY29tYmluZUNvbmZpZyIsIlN0YXRlRmllbGQiLCJQcmVjIiwiVGV4dCIsIlRyYW5zYWN0aW9uIiwiTWFwTW9kZSIsIlJhbmdlVmFsdWUiLCJSYW5nZVNldCIsIkNoYXJDYXRlZ29yeSIsIkRpcmVjdGlvbiIsImxvZ0V4Y2VwdGlvbiIsInNob3dUb29sdGlwIiwiRWRpdG9yVmlldyIsIlZpZXdQbHVnaW4iLCJnZXRUb29sdGlwIiwiRGVjb3JhdGlvbiIsIldpZGdldFR5cGUiLCJrZXltYXAiLCJzeW50YXhUcmVlIiwiaW5kZW50VW5pdCIsIkNvbXBsZXRpb25Db250ZXh0IiwiY29uc3RydWN0b3IiLCJzdGF0ZSIsInBvcyIsImV4cGxpY2l0IiwidmlldyIsImFib3J0TGlzdGVuZXJzIiwiYWJvcnRPbkRvY0NoYW5nZSIsInRva2VuQmVmb3JlIiwidHlwZXMiLCJ0b2tlbiIsInJlc29sdmVJbm5lciIsImluZGV4T2YiLCJuYW1lIiwicGFyZW50IiwiZnJvbSIsInRvIiwidGV4dCIsInNsaWNlRG9jIiwidHlwZSIsIm1hdGNoQmVmb3JlIiwiZXhwciIsImxpbmUiLCJkb2MiLCJsaW5lQXQiLCJzdGFydCIsIk1hdGgiLCJtYXgiLCJzdHIiLCJzbGljZSIsImZvdW5kIiwic2VhcmNoIiwiZW5zdXJlQW5jaG9yIiwiYWJvcnRlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lciIsIm9wdGlvbnMiLCJwdXNoIiwib25Eb2NDaGFuZ2UiLCJ0b1NldCIsImNoYXJzIiwiZmxhdCIsIk9iamVjdCIsImtleXMiLCJqb2luIiwid29yZHMiLCJ0ZXN0IiwicmVwbGFjZSIsInByZWZpeE1hdGNoIiwiZmlyc3QiLCJjcmVhdGUiLCJyZXN0IiwibGFiZWwiLCJpIiwibGVuZ3RoIiwic291cmNlIiwiUmVnRXhwIiwiY29tcGxldGVGcm9tTGlzdCIsImxpc3QiLCJtYXAiLCJvIiwidmFsaWRGb3IiLCJtYXRjaCIsImV2ZXJ5IiwiY29udGV4dCIsImlmSW4iLCJub2RlcyIsImlzVG9wIiwiaWZOb3RJbiIsIk9wdGlvbiIsImNvbXBsZXRpb24iLCJzY29yZSIsImN1ciIsInNlbGVjdGlvbiIsIm1haW4iLCJfYSIsImFkZFN0YXJ0IiwiYWRkRW5kIiwiZmxhZ3MiLCJpZ25vcmVDYXNlIiwicGlja2VkQ29tcGxldGlvbiIsImRlZmluZSIsImluc2VydENvbXBsZXRpb25UZXh0IiwiZnJvbU9mZiIsInRvT2ZmIiwiY2hhbmdlQnlSYW5nZSIsInJhbmdlIiwibGluZXMiLCJ0b1RleHQiLCJjaGFuZ2VzIiwiaW5zZXJ0IiwiY3Vyc29yIiwic2Nyb2xsSW50b1ZpZXciLCJ1c2VyRXZlbnQiLCJTb3VyY2VDYWNoZSIsIldlYWtNYXAiLCJhc1NvdXJjZSIsIkFycmF5IiwiaXNBcnJheSIsImtub3duIiwiZ2V0Iiwic2V0Iiwic3RhcnRDb21wbGV0aW9uRWZmZWN0IiwiY2xvc2VDb21wbGV0aW9uRWZmZWN0IiwiRnV6enlNYXRjaGVyIiwicGF0dGVybiIsImZvbGRlZCIsImFueSIsInByZWNpc2UiLCJieVdvcmQiLCJtYXRjaGVkIiwicCIsImNoYXIiLCJzaXplIiwicGFydCIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImFzdHJhbCIsInJldCIsIndvcmQiLCJmaXJzdFNpemUiLCJkaXJlY3QiLCJsZW4iLCJhbnlUbyIsImUiLCJtaW4iLCJuZXh0IiwicHJlY2lzZVRvIiwiYnlXb3JkVG8iLCJieVdvcmRGb2xkZWQiLCJhZGphY2VudFRvIiwiYWRqYWNlbnRTdGFydCIsImFkamFjZW50RW5kIiwiaGFzTG93ZXIiLCJ3b3JkQWRqYWNlbnQiLCJwcmV2VHlwZSIsImNoIiwicmVzdWx0IiwicG9zaXRpb25zIiwiU3RyaWN0TWF0Y2hlciIsImNvbXBsZXRpb25Db25maWciLCJjb21iaW5lIiwiY29uZmlncyIsImFjdGl2YXRlT25UeXBpbmciLCJhY3RpdmF0ZU9uQ29tcGxldGlvbiIsImFjdGl2YXRlT25UeXBpbmdEZWxheSIsInNlbGVjdE9uT3BlbiIsIm92ZXJyaWRlIiwiY2xvc2VPbkJsdXIiLCJtYXhSZW5kZXJlZE9wdGlvbnMiLCJkZWZhdWx0S2V5bWFwIiwidG9vbHRpcENsYXNzIiwib3B0aW9uQ2xhc3MiLCJhYm92ZUN1cnNvciIsImljb25zIiwiYWRkVG9PcHRpb25zIiwicG9zaXRpb25JbmZvIiwiZGVmYXVsdFBvc2l0aW9uSW5mbyIsImZpbHRlclN0cmljdCIsImNvbXBhcmVDb21wbGV0aW9ucyIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImludGVyYWN0aW9uRGVsYXkiLCJ1cGRhdGVTeW5jVGltZSIsImMiLCJqb2luQ2xhc3MiLCJjb25jYXQiLCJvcHRpb24iLCJpbmZvIiwic3BhY2UiLCJ0b29sdGlwIiwicnRsIiwidGV4dERpcmVjdGlvbiIsIlJUTCIsImxlZnQiLCJuYXJyb3ciLCJzaWRlIiwib2Zmc2V0IiwibWF4V2lkdGgiLCJzcGFjZUxlZnQiLCJzcGFjZVJpZ2h0IiwicmlnaHQiLCJpbmZvV2lkdGgiLCJpbmZvSGVpZ2h0IiwiYm90dG9tIiwidG9wIiwic3BhY2VCZWxvdyIsInNjYWxlWSIsIm9mZnNldEhlaWdodCIsInNjYWxlWCIsIm9mZnNldFdpZHRoIiwic3R5bGUiLCJjbGFzcyIsIm9wdGlvbkNvbnRlbnQiLCJjb25maWciLCJjb250ZW50IiwicmVuZGVyIiwiaWNvbiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsInNwbGl0IiwiY2xzIiwic2V0QXR0cmlidXRlIiwicG9zaXRpb24iLCJfcyIsIl92IiwibGFiZWxFbHQiLCJjbGFzc05hbWUiLCJkaXNwbGF5TGFiZWwiLCJvZmYiLCJqIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsInNwYW4iLCJkZXRhaWwiLCJkZXRhaWxFbHQiLCJ0ZXh0Q29udGVudCIsInNvcnQiLCJyYW5nZUFyb3VuZFNlbGVjdGVkIiwidG90YWwiLCJzZWxlY3RlZCIsImZsb29yIiwiQ29tcGxldGlvblRvb2x0aXAiLCJzdGF0ZUZpZWxkIiwiYXBwbHlDb21wbGV0aW9uIiwiaW5mb0Rlc3Ryb3kiLCJwbGFjZUluZm9SZXEiLCJyZWFkIiwibWVhc3VyZUluZm8iLCJ3cml0ZSIsInBsYWNlSW5mbyIsImtleSIsImN1cnJlbnRDbGFzcyIsImNTdGF0ZSIsImZpZWxkIiwib3BlbiIsImZhY2V0IiwiZG9tIiwidXBkYXRlVG9vbHRpcENsYXNzIiwidGFyZ2V0IiwicGFyZW50Tm9kZSIsIm5vZGVOYW1lIiwiZXhlYyIsImlkIiwicHJldmVudERlZmF1bHQiLCJyZWxhdGVkVGFyZ2V0IiwiY29udGVudERPTSIsImRpc3BhdGNoIiwiZWZmZWN0cyIsIm9mIiwic2hvd09wdGlvbnMiLCJtb3VudCIsInVwZGF0ZVNlbCIsInJlbW92ZSIsImNyZWF0ZUxpc3RCb3giLCJyZXF1ZXN0TWVhc3VyZSIsInVwZGF0ZSIsInByZXZTdGF0ZSIsInN0YXJ0U3RhdGUiLCJkaXNhYmxlZCIsInRvZ2dsZSIsInBvc2l0aW9uZWQiLCJuZXdTZWwiLCJ1cGRhdGVTZWxlY3RlZE9wdGlvbiIsImRlc3Ryb3lJbmZvIiwiaW5mb1Jlc3VsdCIsInRoZW4iLCJvYmoiLCJhZGRJbmZvUGFuZSIsImNhdGNoIiwid3JhcCIsInJhbmRvbSIsInRvU3RyaW5nIiwibm9kZVR5cGUiLCJkZXN0cm95Iiwib3B0IiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwic2VsIiwicXVlcnlTZWxlY3RvciIsImxpc3RSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaW5mb1JlY3QiLCJzZWxSZWN0IiwiZG9jRWx0Iiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiY3NzVGV4dCIsInVsIiwicGhyYXNlIiwiY3VyU2VjdGlvbiIsInNlY3Rpb24iLCJoZWFkZXIiLCJsaSIsIm5vZGUiLCJjb21wbGV0aW9uVG9vbHRpcCIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJzZWxmIiwiaGVpZ2h0Iiwic2Nyb2xsVG9wIiwiYm9vc3QiLCJhcHBseSIsInNvcnRPcHRpb25zIiwiYWN0aXZlIiwic2VjdGlvbnMiLCJkeW5hbWljU2VjdGlvblNjb3JlIiwiYWRkT3B0aW9uIiwic29tZSIsInMiLCJjb25mIiwiaGFzUmVzdWx0IiwiZ2V0TWF0Y2giLCJmaWx0ZXIiLCJtYXRjaGVyIiwicmFuayIsInNlY3Rpb25PcmRlciIsImNtcCIsInByZXYiLCJjb21wYXJlIiwiQ29tcGxldGlvbkRpYWxvZyIsImF0dHJzIiwidGltZXN0YW1wIiwic2V0U2VsZWN0ZWQiLCJtYWtlQXR0cnMiLCJidWlsZCIsImRpZFNldEFjdGl2ZSIsImlzUGVuZGluZyIsInNldERpc2FibGVkIiwic2VsZWN0ZWRWYWx1ZSIsInJlZHVjZSIsImNyZWF0ZVRvb2x0aXAiLCJhYm92ZSIsIkRhdGUiLCJub3ciLCJtYXBQb3MiLCJDb21wbGV0aW9uU3RhdGUiLCJub25lIiwidHIiLCJzb3VyY2VzIiwibGFuZ3VhZ2VEYXRhQXQiLCJ2YWx1ZSIsImZpbmQiLCJBY3RpdmVTb3VyY2UiLCJkaWRTZXQiLCJpcyIsInNldEFjdGl2ZUVmZmVjdCIsImRvY0NoYW5nZWQiLCJ0b3VjaGVzUmFuZ2UiLCJzYW1lUmVzdWx0cyIsImVmZmVjdCIsInNldFNlbGVjdGVkRWZmZWN0IiwiYmFzZUF0dHJzIiwibm9BdHRycyIsImlBIiwiaUIiLCJlbmRBIiwiZW5kQiIsImdldFVwZGF0ZVR5cGUiLCJpc1VzZXJFdmVudCIsImFubm90YXRpb24iLCJ0eXBpbmciLCJ0b3VjaGVzIiwidXBkYXRlRm9yIiwiQWN0aXZlUmVzdWx0IiwibGltaXQiLCJlbXB0eSIsImNoZWNrVmFsaWQiLCJtYXBwaW5nIiwiY29tcGxldGlvblN0YXRlIiwicHJvdmlkZSIsImYiLCJ2YWwiLCJjb250ZW50QXR0cmlidXRlcyIsImFubm90YXRpb25zIiwibW92ZUNvbXBsZXRpb25TZWxlY3Rpb24iLCJmb3J3YXJkIiwiYnkiLCJzdGVwIiwiYWNjZXB0Q29tcGxldGlvbiIsInJlYWRPbmx5Iiwic3RhcnRDb21wbGV0aW9uIiwiY2xvc2VDb21wbGV0aW9uIiwiUnVubmluZ1F1ZXJ5IiwidGltZSIsInVwZGF0ZXMiLCJkb25lIiwidW5kZWZpbmVkIiwiTWF4VXBkYXRlQ291bnQiLCJNaW5BYm9ydFRpbWUiLCJjb21wbGV0aW9uUGx1Z2luIiwiZnJvbUNsYXNzIiwiZGVib3VuY2VVcGRhdGUiLCJydW5uaW5nIiwiZGVib3VuY2VBY2NlcHQiLCJwZW5kaW5nU3RhcnQiLCJjb21wb3NpbmciLCJzdGFydFF1ZXJ5Iiwic2VsZWN0aW9uU2V0IiwiZG9lc1Jlc2V0IiwidHJhbnNhY3Rpb25zIiwicXVlcnkiLCJoYW5kbGVyIiwic3BsaWNlIiwiY2xlYXJUaW1lb3V0IiwiZGVsYXkiLCJxIiwic2V0VGltZW91dCIsInN0YXJ0VXBkYXRlIiwiciIsImFjY2VwdCIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNjaGVkdWxlQWNjZXB0IiwiZXJyIiwidXBkYXRlZCIsImN1cnJlbnQiLCJldmVudEhhbmRsZXJzIiwiYmx1ciIsImV2ZW50IiwiZGlhbG9nIiwiY29udGFpbnMiLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb25lbmQiLCJ3aW5kb3dzIiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJjb21taXRDaGFyYWN0ZXJzIiwiaGlnaGVzdCIsImRvbUV2ZW50SGFuZGxlcnMiLCJrZXlkb3duIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJjb21taXRDaGFycyIsImJhc2VUaGVtZSIsImZvbnRGYW1pbHkiLCJ3aGl0ZVNwYWNlIiwib3ZlcmZsb3ciLCJtYXhXaWR0aF9mYWxsYmFjayIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwibGlzdFN0eWxlIiwibWFyZ2luIiwicGFkZGluZyIsImxpbmVIZWlnaHQiLCJvdmVyZmxvd1giLCJ0ZXh0T3ZlcmZsb3ciLCJkaXNwbGF5IiwiYm9yZGVyQm90dG9tIiwicGFkZGluZ0xlZnQiLCJvcGFjaXR5IiwiYmFja2dyb3VuZCIsImNvbG9yIiwidGV4dEFsaWduIiwid2lkdGgiLCJib3hTaXppbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJ2ZXJ0aWNhbEFsaWduIiwiYm9yZGVyTGVmdCIsInRleHREZWNvcmF0aW9uIiwibWFyZ2luTGVmdCIsImZvbnRTdHlsZSIsImZvbnRTaXplIiwicGFkZGluZ1JpZ2h0IiwiRmllbGRQb3MiLCJGaWVsZFJhbmdlIiwiVHJhY2tEZWwiLCJTbmlwcGV0IiwiZmllbGRQb3NpdGlvbnMiLCJpbnN0YW50aWF0ZSIsImxpbmVTdGFydCIsImxpbmVPYmoiLCJiYXNlSW5kZW50IiwiaW5kZW50IiwidGFicyIsInJhbmdlcyIsInBhcnNlIiwidGVtcGxhdGUiLCJmaWVsZHMiLCJtIiwic2VxIiwicmF3TmFtZSIsImluZGV4Iiwic25pcCIsIl8iLCJicmFjZSIsImZpZWxkTWFya2VyIiwid2lkZ2V0IiwidG9ET00iLCJpZ25vcmVFdmVudCIsImZpZWxkUmFuZ2UiLCJtYXJrIiwiQWN0aXZlU25pcHBldCIsImRlY28iLCJtYXBwZWQiLCJzZWxlY3Rpb25JbnNpZGVGaWVsZCIsInNldEFjdGl2ZSIsIm1vdmVUb0ZpZWxkIiwic25pcHBldFN0YXRlIiwiZGVjb3JhdGlvbnMiLCJmaWVsZFNlbGVjdGlvbiIsInNuaXBwZXQiLCJlZGl0b3IiLCJzcGVjIiwiYXBwZW5kQ29uZmlnIiwiYWRkU25pcHBldEtleW1hcCIsInNuaXBwZXRQb2ludGVySGFuZGxlciIsIm1vdmVGaWVsZCIsImRpciIsImxhc3QiLCJjbGVhclNuaXBwZXQiLCJuZXh0U25pcHBldEZpZWxkIiwicHJldlNuaXBwZXRGaWVsZCIsImhhc05leHRTbmlwcGV0RmllbGQiLCJoYXNQcmV2U25pcHBldEZpZWxkIiwiZGVmYXVsdFNuaXBwZXRLZXltYXAiLCJydW4iLCJzaGlmdCIsInNuaXBwZXRLZXltYXAiLCJtYXBzIiwiY29tcHV0ZSIsInNuaXBwZXRDb21wbGV0aW9uIiwibW91c2Vkb3duIiwicG9zQXRDb29yZHMiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwid29yZFJFIiwid29yZENoYXJzIiwiZXNjYXBlZCIsIm1hcFJFIiwicmUiLCJ1bmljb2RlIiwid29yZENhY2hlcyIsIndvcmRDYWNoZSIsInN0b3JlV29yZHMiLCJzZWVuIiwiaWdub3JlQXQiLCJpdGVyTGluZXMiLCJsYXN0SW5kZXgiLCJjb2xsZWN0V29yZHMiLCJjYWNoZSIsImJpZyIsImNhY2hlZCIsImNoaWxkcmVuIiwiY29tcGxldGVBbnlXb3JkIiwiZGVmYXVsdHMiLCJicmFja2V0cyIsImJlZm9yZSIsInN0cmluZ1ByZWZpeGVzIiwiY2xvc2VCcmFja2V0RWZmZWN0IiwiVHJhY2tBZnRlciIsImNsb3NlZEJyYWNrZXQiLCJzdGFydFNpZGUiLCJlbmRTaWRlIiwiYnJhY2tldFN0YXRlIiwiaGVhZCIsImNsb3NlQnJhY2tldHMiLCJpbnB1dEhhbmRsZXIiLCJkZWZpbmVkQ2xvc2luZyIsImNsb3NpbmciLCJjaGFyQ29kZUF0IiwiY2hhckF0IiwiYW5kcm9pZCIsInVzZXJBZ2VudCIsImNvbXBvc2l0aW9uU3RhcnRlZCIsImluc2VydEJyYWNrZXQiLCJkZWxldGVCcmFja2V0UGFpciIsInRva2VucyIsImRvbnQiLCJwcmV2Q2hhciIsIm5leHRDaGFyIiwiY2xvc2VCcmFja2V0c0tleW1hcCIsImJyYWNrZXQiLCJ0b2siLCJjbG9zZWQiLCJoYW5kbGVTYW1lIiwiaGFuZGxlT3BlbiIsImNsb3NlZEJyYWNrZXRBdCIsImhhbmRsZUNsb3NlIiwiYmV0d2VlbiIsInNsaWNlU3RyaW5nIiwiY2xvc2UiLCJjbG9zZUJlZm9yZSIsImFuY2hvciIsIl9vcGVuIiwiYWxsb3dUcmlwbGUiLCJub2RlU3RhcnQiLCJpc1RyaXBsZSIsImNhblN0YXJ0U3RyaW5nQXQiLCJjaGFyQ2F0ZWdvcml6ZXIiLCJXb3JkIiwicHJvYmFibHlJblN0cmluZyIsInRyZWUiLCJxdW90ZVRva2VuIiwicHJlZml4ZXMiLCJtYXhQcmVmaXgiLCJxdW90ZVBvcyIsImNoYXJDYXQiLCJwcmVmaXgiLCJhdXRvY29tcGxldGlvbiIsImNvbXBsZXRpb25LZXltYXBFeHQiLCJjb21wbGV0aW9uS2V5bWFwIiwibWFjIiwiY29tcHV0ZU4iLCJjb21wbGV0aW9uU3RhdHVzIiwiY29tcGxldGlvbkFycmF5Q2FjaGUiLCJjdXJyZW50Q29tcGxldGlvbnMiLCJjb21wbGV0aW9ucyIsInNlbGVjdGVkQ29tcGxldGlvbiIsInNlbGVjdGVkQ29tcGxldGlvbkluZGV4Iiwic2V0U2VsZWN0ZWRDb21wbGV0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCursorAbove: () => (/* binding */ addCursorAbove),\n/* harmony export */   addCursorBelow: () => (/* binding */ addCursorBelow),\n/* harmony export */   blockComment: () => (/* binding */ blockComment),\n/* harmony export */   blockUncomment: () => (/* binding */ blockUncomment),\n/* harmony export */   copyLineDown: () => (/* binding */ copyLineDown),\n/* harmony export */   copyLineUp: () => (/* binding */ copyLineUp),\n/* harmony export */   cursorCharBackward: () => (/* binding */ cursorCharBackward),\n/* harmony export */   cursorCharBackwardLogical: () => (/* binding */ cursorCharBackwardLogical),\n/* harmony export */   cursorCharForward: () => (/* binding */ cursorCharForward),\n/* harmony export */   cursorCharForwardLogical: () => (/* binding */ cursorCharForwardLogical),\n/* harmony export */   cursorCharLeft: () => (/* binding */ cursorCharLeft),\n/* harmony export */   cursorCharRight: () => (/* binding */ cursorCharRight),\n/* harmony export */   cursorDocEnd: () => (/* binding */ cursorDocEnd),\n/* harmony export */   cursorDocStart: () => (/* binding */ cursorDocStart),\n/* harmony export */   cursorGroupBackward: () => (/* binding */ cursorGroupBackward),\n/* harmony export */   cursorGroupForward: () => (/* binding */ cursorGroupForward),\n/* harmony export */   cursorGroupForwardWin: () => (/* binding */ cursorGroupForwardWin),\n/* harmony export */   cursorGroupLeft: () => (/* binding */ cursorGroupLeft),\n/* harmony export */   cursorGroupRight: () => (/* binding */ cursorGroupRight),\n/* harmony export */   cursorLineBoundaryBackward: () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   cursorLineBoundaryForward: () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   cursorLineBoundaryLeft: () => (/* binding */ cursorLineBoundaryLeft),\n/* harmony export */   cursorLineBoundaryRight: () => (/* binding */ cursorLineBoundaryRight),\n/* harmony export */   cursorLineDown: () => (/* binding */ cursorLineDown),\n/* harmony export */   cursorLineEnd: () => (/* binding */ cursorLineEnd),\n/* harmony export */   cursorLineStart: () => (/* binding */ cursorLineStart),\n/* harmony export */   cursorLineUp: () => (/* binding */ cursorLineUp),\n/* harmony export */   cursorMatchingBracket: () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   cursorPageDown: () => (/* binding */ cursorPageDown),\n/* harmony export */   cursorPageUp: () => (/* binding */ cursorPageUp),\n/* harmony export */   cursorSubwordBackward: () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   cursorSubwordForward: () => (/* binding */ cursorSubwordForward),\n/* harmony export */   cursorSyntaxLeft: () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   cursorSyntaxRight: () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   defaultKeymap: () => (/* binding */ defaultKeymap),\n/* harmony export */   deleteCharBackward: () => (/* binding */ deleteCharBackward),\n/* harmony export */   deleteCharBackwardStrict: () => (/* binding */ deleteCharBackwardStrict),\n/* harmony export */   deleteCharForward: () => (/* binding */ deleteCharForward),\n/* harmony export */   deleteGroupBackward: () => (/* binding */ deleteGroupBackward),\n/* harmony export */   deleteGroupForward: () => (/* binding */ deleteGroupForward),\n/* harmony export */   deleteGroupForwardWin: () => (/* binding */ deleteGroupForwardWin),\n/* harmony export */   deleteLine: () => (/* binding */ deleteLine),\n/* harmony export */   deleteLineBoundaryBackward: () => (/* binding */ deleteLineBoundaryBackward),\n/* harmony export */   deleteLineBoundaryForward: () => (/* binding */ deleteLineBoundaryForward),\n/* harmony export */   deleteToLineEnd: () => (/* binding */ deleteToLineEnd),\n/* harmony export */   deleteToLineStart: () => (/* binding */ deleteToLineStart),\n/* harmony export */   deleteTrailingWhitespace: () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   emacsStyleKeymap: () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   historyField: () => (/* binding */ historyField),\n/* harmony export */   historyKeymap: () => (/* binding */ historyKeymap),\n/* harmony export */   indentLess: () => (/* binding */ indentLess),\n/* harmony export */   indentMore: () => (/* binding */ indentMore),\n/* harmony export */   indentSelection: () => (/* binding */ indentSelection),\n/* harmony export */   indentWithTab: () => (/* binding */ indentWithTab),\n/* harmony export */   insertBlankLine: () => (/* binding */ insertBlankLine),\n/* harmony export */   insertNewline: () => (/* binding */ insertNewline),\n/* harmony export */   insertNewlineAndIndent: () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   insertNewlineKeepIndent: () => (/* binding */ insertNewlineKeepIndent),\n/* harmony export */   insertTab: () => (/* binding */ insertTab),\n/* harmony export */   invertedEffects: () => (/* binding */ invertedEffects),\n/* harmony export */   isolateHistory: () => (/* binding */ isolateHistory),\n/* harmony export */   lineComment: () => (/* binding */ lineComment),\n/* harmony export */   lineUncomment: () => (/* binding */ lineUncomment),\n/* harmony export */   moveLineDown: () => (/* binding */ moveLineDown),\n/* harmony export */   moveLineUp: () => (/* binding */ moveLineUp),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoSelection: () => (/* binding */ redoSelection),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectCharBackward: () => (/* binding */ selectCharBackward),\n/* harmony export */   selectCharBackwardLogical: () => (/* binding */ selectCharBackwardLogical),\n/* harmony export */   selectCharForward: () => (/* binding */ selectCharForward),\n/* harmony export */   selectCharForwardLogical: () => (/* binding */ selectCharForwardLogical),\n/* harmony export */   selectCharLeft: () => (/* binding */ selectCharLeft),\n/* harmony export */   selectCharRight: () => (/* binding */ selectCharRight),\n/* harmony export */   selectDocEnd: () => (/* binding */ selectDocEnd),\n/* harmony export */   selectDocStart: () => (/* binding */ selectDocStart),\n/* harmony export */   selectGroupBackward: () => (/* binding */ selectGroupBackward),\n/* harmony export */   selectGroupForward: () => (/* binding */ selectGroupForward),\n/* harmony export */   selectGroupForwardWin: () => (/* binding */ selectGroupForwardWin),\n/* harmony export */   selectGroupLeft: () => (/* binding */ selectGroupLeft),\n/* harmony export */   selectGroupRight: () => (/* binding */ selectGroupRight),\n/* harmony export */   selectLine: () => (/* binding */ selectLine),\n/* harmony export */   selectLineBoundaryBackward: () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   selectLineBoundaryForward: () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   selectLineBoundaryLeft: () => (/* binding */ selectLineBoundaryLeft),\n/* harmony export */   selectLineBoundaryRight: () => (/* binding */ selectLineBoundaryRight),\n/* harmony export */   selectLineDown: () => (/* binding */ selectLineDown),\n/* harmony export */   selectLineEnd: () => (/* binding */ selectLineEnd),\n/* harmony export */   selectLineStart: () => (/* binding */ selectLineStart),\n/* harmony export */   selectLineUp: () => (/* binding */ selectLineUp),\n/* harmony export */   selectMatchingBracket: () => (/* binding */ selectMatchingBracket),\n/* harmony export */   selectPageDown: () => (/* binding */ selectPageDown),\n/* harmony export */   selectPageUp: () => (/* binding */ selectPageUp),\n/* harmony export */   selectParentSyntax: () => (/* binding */ selectParentSyntax),\n/* harmony export */   selectSubwordBackward: () => (/* binding */ selectSubwordBackward),\n/* harmony export */   selectSubwordForward: () => (/* binding */ selectSubwordForward),\n/* harmony export */   selectSyntaxLeft: () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   selectSyntaxRight: () => (/* binding */ selectSyntaxRight),\n/* harmony export */   simplifySelection: () => (/* binding */ simplifySelection),\n/* harmony export */   splitLine: () => (/* binding */ splitLine),\n/* harmony export */   standardKeymap: () => (/* binding */ standardKeymap),\n/* harmony export */   temporarilySetTabFocusMode: () => (/* binding */ temporarilySetTabFocusMode),\n/* harmony export */   toggleBlockComment: () => (/* binding */ toggleBlockComment),\n/* harmony export */   toggleBlockCommentByLine: () => (/* binding */ toggleBlockCommentByLine),\n/* harmony export */   toggleComment: () => (/* binding */ toggleComment),\n/* harmony export */   toggleLineComment: () => (/* binding */ toggleLineComment),\n/* harmony export */   toggleTabFocusMode: () => (/* binding */ toggleTabFocusMode),\n/* harmony export */   transposeChars: () => (/* binding */ transposeChars),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoSelection: () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/ const toggleComment = (target)=>{\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let tr = f(option, state);\n        if (!tr) return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleLineComment = /*@__PURE__*/ command(changeLineComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using line comments.\n*/ const lineComment = /*@__PURE__*/ command(changeLineComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using line comments.\n*/ const lineUncomment = /*@__PURE__*/ command(changeLineComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleBlockComment = /*@__PURE__*/ command(changeBlockComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using block comments.\n*/ const blockComment = /*@__PURE__*/ command(changeBlockComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using block comments.\n*/ const blockUncomment = /*@__PURE__*/ command(changeBlockComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/ const toggleBlockCommentByLine = /*@__PURE__*/ command((o, s)=>changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */ );\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos, 1);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/ function findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return {\n            open: {\n                pos: from - spaceBefore,\n                margin: spaceBefore && 1\n            },\n            close: {\n                pos: to + spaceAfter,\n                margin: spaceAfter && 1\n            }\n        };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    } else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n        return {\n            open: {\n                pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n            },\n            close: {\n                pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n            }\n        };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges){\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        if (toLine.from > fromLine.from && toLine.from == r.to) toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;\n        else ranges.push({\n            from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n            to: toLine.to\n        });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map((r)=>getConfig(state, r.from).block);\n    if (!tokens.every((c)=>c)) return null;\n    let comments = ranges.map((r, i)=>findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */  && !comments.every((c)=>c)) {\n        return {\n            changes: state.changes(ranges.map((range, i)=>{\n                if (comments[i]) return [];\n                return [\n                    {\n                        from: range.from,\n                        insert: tokens[i].open + \" \"\n                    },\n                    {\n                        from: range.to,\n                        insert: \" \" + tokens[i].close\n                    }\n                ];\n            }))\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && comments.some((c)=>c)) {\n        let changes = [];\n        for(let i = 0, comment; i < comments.length; i++)if (comment = comments[i]) {\n            let token = tokens[i], { open, close } = comment;\n            changes.push({\n                from: open.pos - token.open.length,\n                to: open.pos + open.margin\n            }, {\n                from: close.pos - close.margin,\n                to: close.pos + token.close.length\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges){\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token) continue;\n        for(let pos = from; pos <= to;){\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent) minIndent = indent;\n                lines.push({\n                    line,\n                    comment,\n                    token,\n                    indent,\n                    empty,\n                    single: false\n                });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9) {\n            for(let i = startI; i < lines.length; i++)if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n        }\n        if (lines.length == startI + 1) lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */  && lines.some((l)=>l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)if (single || !empty) changes.push({\n            from: line.from + indent,\n            insert: token + \" \"\n        });\n        let changeSet = state.changes(changes);\n        return {\n            changes: changeSet,\n            selection: state.selection.map(changeSet, 1)\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && lines.some((l)=>l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)if (comment >= 0) {\n            let from = line.from + comment, to = from + token.length;\n            if (line.text[to - line.from] == \" \") to++;\n            changes.push({\n                from,\n                to\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\nconst fromHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/ const isolateHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/ const invertedEffects = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent)=>isAdjacent\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b)=>(tr, adj)=>a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nconst historyField_ = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return HistoryState.empty;\n    },\n    update (state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */  ? state.undone : state.done;\n            if (item) other = updateBranch(other, other.length, config.minDepth, item);\n            else other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */  ? fromHist.rest : other, from == 0 /* BranchName.Done */  ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n        if (event) state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n        return state;\n    },\n    toJSON (value) {\n        return {\n            done: value.done.map((e)=>e.toJSON()),\n            undone: value.undone.map((e)=>e.toJSON())\n        };\n    },\n    fromJSON (json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/ function history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n            beforeinput (e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command) return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/ const historyField = historyField_;\nfunction cmd(side, selection) {\n    return function({ state, dispatch }) {\n        if (!selection && state.readOnly) return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState) return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr) return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/ const undo = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/ const redo = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , false);\n/**\nUndo a change or selection change.\n*/ const undoSelection = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , true);\n/**\nRedo a change or selection change.\n*/ const redoSelection = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , true);\nfunction depth(side) {\n    return function(state) {\n        let histState = state.field(historyField_, false);\n        if (!histState) return 0;\n        let branch = side == 0 /* BranchName.Done */  ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/ const undoDepth = /*@__PURE__*/ depth(0 /* BranchName.Done */ );\n/**\nThe amount of redoable change events available in a given state.\n*/ const redoDepth = /*@__PURE__*/ depth(1 /* BranchName.Undone */ );\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(// The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, // The effects associated with this event\n    effects, // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, // The selection before this event\n    startSelection, // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter){\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map((s)=>s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)){\n            let result = invert(tr);\n            if (result.length) effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty) return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t)=>ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t)=>{\n        for(let i = 0; i < ranges.length;){\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to) isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i)=>r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [\n            HistEvent.selection([\n                selection\n            ])\n        ];\n    } else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length) return branch;\n    let length = branch.length, selections = none;\n    while(length){\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) {\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        } else {\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [\n        HistEvent.selection(selections)\n    ] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s)=>s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes) return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined){\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event\n        userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        } else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, onlySelection) {\n        let branch = side == 0 /* BranchName.Done */  ? this.done : this.undone;\n        if (branch.length == 0) return null;\n        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;\n        if (onlySelection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({\n                    side,\n                    rest: popSelection(branch),\n                    selection\n                }),\n                userEvent: side == 0 /* BranchName.Done */  ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        } else if (!event.changes) {\n            return null;\n        } else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({\n                    side,\n                    rest,\n                    selection\n                }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */  ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/ new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/ const historyKeymap = [\n    {\n        key: \"Mod-z\",\n        run: undo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-y\",\n        mac: \"Mod-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        linux: \"Ctrl-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-u\",\n        run: undoSelection,\n        preventDefault: true\n    },\n    {\n        key: \"Alt-u\",\n        mac: \"Mod-Shift-u\",\n        run: redoSelection,\n        preventDefault: true\n    }\n];\nfunction updateSel(sel, by) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({\n        selection,\n        scrollIntoView: true,\n        userEvent: \"select\"\n    });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection, true)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/ const cursorCharLeft = (view)=>cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/ const cursorCharRight = (view)=>cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/ const cursorCharForward = (view)=>cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/ const cursorCharBackward = (view)=>cursorByChar(view, false);\nfunction byCharLogical(state, range, forward) {\n    let pos = range.head, line = state.doc.lineAt(pos);\n    if (pos == (forward ? line.to : line.from)) pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);\n    else pos = line.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos, forward ? -1 : 1);\n}\nfunction moveByCharLogical(target, forward) {\n    return moveSel(target, (range)=>range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one character forward, in logical\n(non-text-direction-aware) string index order.\n*/ const cursorCharForwardLogical = (target)=>moveByCharLogical(target, true);\n/**\nMove the selection one character backward, in logical string index\norder.\n*/ const cursorCharBackwardLogical = (target)=>moveByCharLogical(target, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/ const cursorGroupLeft = (view)=>cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/ const cursorGroupRight = (view)=>cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/ const cursorGroupForward = (view)=>cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/ const cursorGroupBackward = (view)=>cursorByGroup(view, false);\nfunction toGroupStart(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start), initial = cat != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space;\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (nextCat != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) return initial && nextCat == cat;\n        initial = false;\n        return true;\n    };\n}\n/**\nMove the cursor one group forward in the default Windows style,\nwhere it moves to the start of the next group.\n*/ const cursorGroupForwardWin = (view)=>{\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, true, (start)=>toGroupStart(view, range.head, start)) : rangeEnd(range, true));\n};\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/ new Intl.Segmenter(undefined, {\n    granularity: \"word\"\n}) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next)=>{\n        if (done) return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n        if (cat != nextCat) return false;\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper) return false;\n                sawLower = true;\n            } else if (sawLower) {\n                if (forward) return false;\n                done = true;\n            } else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, (start)=>{\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, (range)=>range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/ const cursorSubwordForward = (view)=>cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/ const cursorSubwordBackward = (view)=>cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp)) return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for(let at = start.head;;){\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next) break;\n        if (interestingNode(state, next, bracketProp)) pos = next;\n        else at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;\n    else newPos = forward ? pos.to : pos.from;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/ const cursorSyntaxLeft = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/ const cursorSyntaxRight = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, (range)=>{\n        if (!range.empty) return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/ const cursorLineUp = (view)=>cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/ const cursorLineDown = (view)=>cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)){\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    } else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return {\n        marginTop,\n        marginBottom,\n        selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5)\n    };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, (range)=>{\n        return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection)) return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n            y: \"start\",\n            yMargin: startPos.top - scrollTop\n        });\n    }\n    view.dispatch(setSel(state, selection), {\n        effects: effect\n    });\n    return true;\n}\n/**\nMove the selection one page up.\n*/ const cursorPageUp = (view)=>cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/ const cursorPageDown = (view)=>cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/ const cursorLineBoundaryForward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/ const cursorLineBoundaryBackward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/ const cursorLineBoundaryLeft = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/ const cursorLineBoundaryRight = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/ const cursorLineStart = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/ const cursorLineEnd = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, (range)=>{\n        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1);\n        if (!matching || !matching.end) return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n    if (!found) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/ const cursorMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/ const selectMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, true);\nfunction extendSel(target, how) {\n    let selection = updateSel(target.state.selection, (range)=>{\n        let head = how(range);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(target.state.selection)) return false;\n    target.dispatch(setSel(target.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, (range)=>view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/ const selectCharLeft = (view)=>selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/ const selectCharRight = (view)=>selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/ const selectCharForward = (view)=>selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/ const selectCharBackward = (view)=>selectByChar(view, false);\n/**\nMove the selection head one character forward by logical\n(non-direction aware) string index order.\n*/ const selectCharForwardLogical = (target)=>extendSel(target, (range)=>byCharLogical(target.state, range, true));\n/**\nMove the selection head one character backward by logical string\nindex order.\n*/ const selectCharBackwardLogical = (target)=>extendSel(target, (range)=>byCharLogical(target.state, range, false));\nfunction selectByGroup(view, forward) {\n    return extendSel(view, (range)=>view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/ const selectGroupLeft = (view)=>selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/ const selectGroupRight = (view)=>selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/ const selectGroupForward = (view)=>selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/ const selectGroupBackward = (view)=>selectByGroup(view, false);\n/**\nMove the selection head one group forward in the default Windows\nstyle, skipping to the start of the next group.\n*/ const selectGroupForwardWin = (view)=>{\n    return extendSel(view, (range)=>view.moveByChar(range, true, (start)=>toGroupStart(view, range.head, start)));\n};\nfunction selectBySubword(view, forward) {\n    return extendSel(view, (range)=>moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/ const selectSubwordForward = (view)=>selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/ const selectSubwordBackward = (view)=>selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/ const selectSyntaxLeft = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/ const selectSyntaxRight = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/ const selectLineUp = (view)=>selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/ const selectLineDown = (view)=>selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/ const selectPageUp = (view)=>selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/ const selectPageDown = (view)=>selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/ const selectLineBoundaryForward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/ const selectLineBoundaryBackward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/ const selectLineBoundaryLeft = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/ const selectLineBoundaryRight = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/ const selectLineStart = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/ const selectLineEnd = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/ const cursorDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: 0\n    }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/ const cursorDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.doc.length\n    }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/ const selectDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: 0\n    }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/ const selectDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: state.doc.length\n    }));\n    return true;\n};\n/**\nSelect the entire document.\n*/ const selectAll = ({ state, dispatch })=>{\n    dispatch(state.update({\n        selection: {\n            anchor: 0,\n            head: state.doc.length\n        },\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/ const selectLine = ({ state, dispatch })=>{\n    let ranges = selectedLineBlocks(state).map(({ from, to })=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/ const selectParentSyntax = ({ state, dispatch })=>{\n    let selection = updateSel(state.selection, (range)=>{\n        let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state), stack = tree.resolveStack(range.from, 1);\n        if (range.empty) {\n            let stackBefore = tree.resolveStack(range.from, -1);\n            if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;\n        }\n        for(let cur = stack; cur; cur = cur.next){\n            let { node } = cur;\n            if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(node.to, node.from);\n        }\n        return range;\n    });\n    if (selection.eq(state.selection)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction addCursorVertically(view, forward) {\n    let { state } = view, sel = state.selection, ranges = state.selection.ranges.slice();\n    for (let range of state.selection.ranges){\n        let line = state.doc.lineAt(range.head);\n        if (forward ? line.to < view.state.doc.length : line.from > 0) for(let cur = range;;){\n            let next = view.moveVertically(cur, forward);\n            if (next.head < line.from || next.head > line.to) {\n                if (!ranges.some((r)=>r.head == next.head)) ranges.push(next);\n                break;\n            } else if (next.head == cur.head) {\n                break;\n            } else {\n                cur = next;\n            }\n        }\n    }\n    if (ranges.length == sel.ranges.length) return false;\n    view.dispatch(setSel(state, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, ranges.length - 1)));\n    return true;\n}\n/**\nExpand the selection by adding a cursor above the heads of\ncurrently selected ranges.\n*/ const addCursorAbove = (view)=>addCursorVertically(view, false);\n/**\nExpand the selection by adding a cursor below the heads of\ncurrently selected ranges.\n*/ const addCursorBelow = (view)=>addCursorVertically(view, true);\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/ const simplifySelection = ({ state, dispatch })=>{\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        cur.main\n    ]);\n    else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)\n    ]);\n    if (!selection) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly) return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange((range)=>{\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(range);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            } else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        } else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? {\n            range\n        } : {\n            changes: {\n                from,\n                to\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from, from < range.head ? -1 : 1)\n        };\n    });\n    if (changes.changes.empty) return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map((f)=>f(target)))ranges.between(pos, pos, (from, to)=>{\n        if (from < pos && to > pos) pos = forward ? to : from;\n    });\n    return pos;\n}\nconst deleteByChar = (target, forward, byIndentUnit)=>deleteBy(target, (range)=>{\n        let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n        if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n            if (before[before.length - 1] == \"\t\") return pos - 1;\n            let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n            for(let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)pos--;\n            targetPos = pos;\n        } else {\n            targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n            if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n            else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, targetPos - line.from, false, false) + line.from;\n        }\n        return targetPos;\n    });\n/**\nDelete the selection, or, for cursor selections, the character or\nindentation unit before the cursor.\n*/ const deleteCharBackward = (view)=>deleteByChar(view, false, true);\n/**\nDelete the selection or the character before the cursor. Does not\nimplement any extended behavior like deleting whole indentation\nunits in one go.\n*/ const deleteCharBackwardStrict = (view)=>deleteByChar(view, false, false);\n/**\nDelete the selection or the character after the cursor.\n*/ const deleteCharForward = (view)=>deleteByChar(view, true, false);\nconst deleteByGroup = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.head, { state } = target, line = state.doc.lineAt(pos);\n        let categorize = state.charCategorizer(pos);\n        for(let cat = null;;){\n            if (pos == (forward ? line.to : line.from)) {\n                if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n                break;\n            }\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n            let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n            let nextCat = categorize(nextChar);\n            if (cat != null && nextCat != cat) break;\n            if (nextChar != \" \" || pos != range.head) cat = nextCat;\n            pos = next;\n        }\n        return pos;\n    });\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/ const deleteGroupBackward = (target)=>deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/ const deleteGroupForward = (target)=>deleteByGroup(target, true);\n/**\nVariant of [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\nthat uses the Windows convention of also deleting the whitespace\nafter a word.\n*/ const deleteGroupForwardWin = (view)=>deleteBy(view, (range)=>view.moveByChar(range, true, (start)=>toGroupStart(view, range.head, start)).head);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/ const deleteToLineEnd = (view)=>deleteBy(view, (range)=>{\n        let lineEnd = view.lineBlockAt(range.head).to;\n        return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/ const deleteToLineStart = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.lineBlockAt(range.head).from;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/ const deleteLineBoundaryBackward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, false).head;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/ const deleteLineBoundaryForward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, true).head;\n        return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/ const deleteTrailingWhitespace = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = [];\n    for(let pos = 0, prev = \"\", iter = state.doc.iter();;){\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1) changes.push({\n                from: pos - (prev.length - trailing),\n                to: pos\n            });\n            if (iter.done) break;\n            prev = \"\";\n        } else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        userEvent: \"delete\"\n    }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/ const splitLine = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\n                    \"\",\n                    \"\"\n                ])\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n        };\n    });\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/ const transposeChars = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n            range\n        };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n        return {\n            changes: {\n                from,\n                to,\n                insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n        };\n    });\n    if (changes.changes.empty) return false;\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"move.character\"\n    }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges){\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        } else {\n            blocks.push({\n                from: startLine.from,\n                to: endLine.to,\n                ranges: [\n                    range\n                ]\n            });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward ? block.to == state.doc.length : block.from == 0) continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({\n                from: block.to,\n                to: nextLine.to\n            }, {\n                from: block.from,\n                insert: nextLine.text + state.lineBreak\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        } else {\n            changes.push({\n                from: nextLine.from,\n                to: block.from\n            }, {\n                from: block.to,\n                insert: state.lineBreak + nextLine.text\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/ const moveLineUp = ({ state, dispatch })=>moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/ const moveLineDown = ({ state, dispatch })=>moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward) changes.push({\n            from: block.from,\n            insert: state.doc.slice(block.from, block.to) + state.lineBreak\n        });\n        else changes.push({\n            from: block.to,\n            insert: state.lineBreak + state.doc.slice(block.from, block.to)\n        });\n    }\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        userEvent: \"input.copyline\"\n    }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/ const copyLineUp = ({ state, dispatch })=>copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/ const copyLineDown = ({ state, dispatch })=>copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/ const deleteLine = (view)=>{\n    if (view.state.readOnly) return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to })=>{\n        if (from > 0) from--;\n        else if (to < state.doc.length) to++;\n        return {\n            from,\n            to\n        };\n    }));\n    let selection = updateSel(state.selection, (range)=>{\n        let dist = undefined;\n        if (view.lineWrapping) {\n            let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (pos) dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;\n        }\n        return view.moveVertically(range, true, dist);\n    }).map(changes);\n    view.dispatch({\n        changes,\n        selection,\n        scrollIntoView: true,\n        userEvent: \"delete.line\"\n    });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/ const insertNewline = ({ state, dispatch })=>{\n    dispatch(state.update(state.replaceSelection(state.lineBreak), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nReplace the selection with a newline and the same amount of\nindentation as the line above.\n*/ const insertNewlineKeepIndent = ({ state, dispatch })=>{\n    dispatch(state.update(state.changeByRange((range)=>{\n        let indent = /^\\s*/.exec(state.doc.lineAt(range.from).text)[0];\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: state.lineBreak + indent\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + indent.length + 1)\n        };\n    }), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n        from: pos,\n        to: pos\n    };\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n        from: before.to,\n        to: after.from\n    };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/ const insertNewlineAndIndent = /*@__PURE__*/ newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/ const insertBlankLine = /*@__PURE__*/ newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let changes = state.changeByRange((range)=>{\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n                simulateBreak: from,\n                simulateDoubleBreak: !!explode\n            });\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n            if (indent == null) indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while(to < line.to && /\\s/.test(line.text[to - line.from]))to++;\n            if (explode) ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n            let insert = [\n                \"\",\n                (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)\n            ];\n            if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n            return {\n                changes: {\n                    from,\n                    to,\n                    insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert)\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n            };\n        });\n        dispatch(state.update(changes, {\n            scrollIntoView: true,\n            userEvent: \"input\"\n        }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange((range)=>{\n        let changes = [];\n        for(let pos = range.from; pos <= range.to;){\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return {\n            changes,\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n        };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/ const indentSelection = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let updated = Object.create(null);\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        overrideIndentation: (start)=>{\n            let found = updated[start];\n            return found == null ? -1 : found;\n        }\n    });\n    let changes = changeBySelectedLine(state, (line, changes, range)=>{\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n        if (indent == null) return;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    });\n    if (!changes.changes.empty) dispatch(state.update(changes, {\n        userEvent: \"indent\"\n    }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/ const indentMore = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        changes.push({\n            from: line.from,\n            insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n        });\n    }), {\n        userEvent: \"input.indent\"\n    }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/ const indentLess = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space) return;\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n        while(keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))keep++;\n        changes.push({\n            from: line.from + keep,\n            to: line.from + space.length,\n            insert: insert.slice(keep)\n        });\n    }), {\n        userEvent: \"delete.dedent\"\n    }));\n    return true;\n};\n/**\nEnables or disables\n[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this\nprevents the editor's key bindings from capturing Tab or\nShift-Tab, making it possible for the user to move focus out of\nthe editor with the keyboard.\n*/ const toggleTabFocusMode = (view)=>{\n    view.setTabFocusMode();\n    return true;\n};\n/**\nTemporarily enables [tab-focus\nmode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until\nanother key is pressed.\n*/ const temporarilySetTabFocusMode = (view)=>{\n    view.setTabFocusMode(2000);\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/ const insertTab = ({ state, dispatch })=>{\n    if (state.selection.ranges.some((r)=>!r.empty)) return indentMore({\n        state,\n        dispatch\n    });\n    dispatch(state.update(state.replaceSelection(\"\t\"), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/ const emacsStyleKeymap = [\n    {\n        key: \"Ctrl-b\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Ctrl-f\",\n        run: cursorCharRight,\n        shift: selectCharRight\n    },\n    {\n        key: \"Ctrl-p\",\n        run: cursorLineUp,\n        shift: selectLineUp\n    },\n    {\n        key: \"Ctrl-n\",\n        run: cursorLineDown,\n        shift: selectLineDown\n    },\n    {\n        key: \"Ctrl-a\",\n        run: cursorLineStart,\n        shift: selectLineStart\n    },\n    {\n        key: \"Ctrl-e\",\n        run: cursorLineEnd,\n        shift: selectLineEnd\n    },\n    {\n        key: \"Ctrl-d\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Ctrl-h\",\n        run: deleteCharBackward\n    },\n    {\n        key: \"Ctrl-k\",\n        run: deleteToLineEnd\n    },\n    {\n        key: \"Ctrl-Alt-h\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Ctrl-o\",\n        run: splitLine\n    },\n    {\n        key: \"Ctrl-t\",\n        run: transposeChars\n    },\n    {\n        key: \"Ctrl-v\",\n        run: cursorPageDown\n    }\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/ const standardKeymap = /*@__PURE__*/ [\n    {\n        key: \"ArrowLeft\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowLeft\",\n        mac: \"Alt-ArrowLeft\",\n        run: cursorGroupLeft,\n        shift: selectGroupLeft,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowLeft\",\n        run: cursorLineBoundaryLeft,\n        shift: selectLineBoundaryLeft,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowRight\",\n        run: cursorCharRight,\n        shift: selectCharRight,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowRight\",\n        mac: \"Alt-ArrowRight\",\n        run: cursorGroupRight,\n        shift: selectGroupRight,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowRight\",\n        run: cursorLineBoundaryRight,\n        shift: selectLineBoundaryRight,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowUp\",\n        run: cursorLineUp,\n        shift: selectLineUp,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowUp\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        mac: \"Ctrl-ArrowUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"ArrowDown\",\n        run: cursorLineDown,\n        shift: selectLineDown,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowDown\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        mac: \"Ctrl-ArrowDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"PageUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"PageDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"Home\",\n        run: cursorLineBoundaryBackward,\n        shift: selectLineBoundaryBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Home\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        key: \"End\",\n        run: cursorLineBoundaryForward,\n        shift: selectLineBoundaryForward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-End\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        key: \"Enter\",\n        run: insertNewlineAndIndent,\n        shift: insertNewlineAndIndent\n    },\n    {\n        key: \"Mod-a\",\n        run: selectAll\n    },\n    {\n        key: \"Backspace\",\n        run: deleteCharBackward,\n        shift: deleteCharBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Delete\",\n        run: deleteCharForward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Backspace\",\n        mac: \"Alt-Backspace\",\n        run: deleteGroupBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Delete\",\n        mac: \"Alt-Delete\",\n        run: deleteGroupForward,\n        preventDefault: true\n    },\n    {\n        mac: \"Mod-Backspace\",\n        run: deleteLineBoundaryBackward,\n        preventDefault: true\n    },\n    {\n        mac: \"Mod-Delete\",\n        run: deleteLineBoundaryForward,\n        preventDefault: true\n    }\n].concat(/*@__PURE__*/ emacsStyleKeymap.map((b)=>({\n        mac: b.key,\n        run: b.run,\n        shift: b.shift\n    })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Ctrl-Alt-ArrowUp (Cmd-Alt-ArrowUp on macOS): [`addCursorAbove`](https://codemirror.net/6/docs/ref/#commands.addCursorAbove).\n- Ctrl-Alt-ArrowDown (Cmd-Alt-ArrowDown on macOS): [`addCursorBelow`](https://codemirror.net/6/docs/ref/#commands.addCursorBelow).\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).\n*/ const defaultKeymap = /*@__PURE__*/ [\n    {\n        key: \"Alt-ArrowLeft\",\n        mac: \"Ctrl-ArrowLeft\",\n        run: cursorSyntaxLeft,\n        shift: selectSyntaxLeft\n    },\n    {\n        key: \"Alt-ArrowRight\",\n        mac: \"Ctrl-ArrowRight\",\n        run: cursorSyntaxRight,\n        shift: selectSyntaxRight\n    },\n    {\n        key: \"Alt-ArrowUp\",\n        run: moveLineUp\n    },\n    {\n        key: \"Shift-Alt-ArrowUp\",\n        run: copyLineUp\n    },\n    {\n        key: \"Alt-ArrowDown\",\n        run: moveLineDown\n    },\n    {\n        key: \"Shift-Alt-ArrowDown\",\n        run: copyLineDown\n    },\n    {\n        key: \"Mod-Alt-ArrowUp\",\n        run: addCursorAbove\n    },\n    {\n        key: \"Mod-Alt-ArrowDown\",\n        run: addCursorBelow\n    },\n    {\n        key: \"Escape\",\n        run: simplifySelection\n    },\n    {\n        key: \"Mod-Enter\",\n        run: insertBlankLine\n    },\n    {\n        key: \"Alt-l\",\n        mac: \"Ctrl-l\",\n        run: selectLine\n    },\n    {\n        key: \"Mod-i\",\n        run: selectParentSyntax,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-[\",\n        run: indentLess\n    },\n    {\n        key: \"Mod-]\",\n        run: indentMore\n    },\n    {\n        key: \"Mod-Alt-\\\\\",\n        run: indentSelection\n    },\n    {\n        key: \"Shift-Mod-k\",\n        run: deleteLine\n    },\n    {\n        key: \"Shift-Mod-\\\\\",\n        run: cursorMatchingBracket\n    },\n    {\n        key: \"Mod-/\",\n        run: toggleComment\n    },\n    {\n        key: \"Alt-A\",\n        run: toggleBlockComment\n    },\n    {\n        key: \"Ctrl-m\",\n        mac: \"Shift-Alt-m\",\n        run: toggleTabFocusMode\n    }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/ const indentWithTab = {\n    key: \"Tab\",\n    run: indentMore,\n    shift: indentLess\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc007QUFDN0k7QUFDZ0Y7QUFDaEc7QUFFekM7OztBQUdBLEdBQ0EsTUFBTXVCLGdCQUFnQkMsQ0FBQUE7SUFDbEIsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBR0QsUUFBUUUsT0FBT0QsTUFBTUUsR0FBRyxDQUFDQyxNQUFNLENBQUNILE1BQU1JLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLEdBQUdDLFNBQVNDLFVBQVVULE9BQU9DLEtBQUssRUFBRUMsS0FBS0ssSUFBSTtJQUN0SCxPQUFPQyxPQUFPTixJQUFJLEdBQUdRLGtCQUFrQlYsVUFBVVEsT0FBT0csS0FBSyxHQUFHQyx5QkFBeUJaLFVBQVU7QUFDdkc7QUFDQSxTQUFTYSxRQUFRQyxDQUFDLEVBQUVDLE1BQU07SUFDdEIsT0FBTyxDQUFDLEVBQUVkLEtBQUssRUFBRWUsUUFBUSxFQUFFO1FBQ3ZCLElBQUlmLE1BQU1nQixRQUFRLEVBQ2QsT0FBTztRQUNYLElBQUlDLEtBQUtKLEVBQUVDLFFBQVFkO1FBQ25CLElBQUksQ0FBQ2lCLElBQ0QsT0FBTztRQUNYRixTQUFTZixNQUFNa0IsTUFBTSxDQUFDRDtRQUN0QixPQUFPO0lBQ1g7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsTUFBTVIsb0JBQW9CLFdBQVcsR0FBRUcsUUFBUU8sbUJBQW1CLEVBQUUsd0JBQXdCO0FBQzVGOztBQUVBLEdBQ0EsTUFBTUMsY0FBYyxXQUFXLEdBQUVSLFFBQVFPLG1CQUFtQixFQUFFLHlCQUF5QjtBQUN2Rjs7QUFFQSxHQUNBLE1BQU1FLGdCQUFnQixXQUFXLEdBQUVULFFBQVFP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QjtDQUNoRSxDQUFDblQsTUFBTSxDQUFDeVQ7QUFDVDs7Ozs7QUFLQSxHQUNBLE1BQU1FLGdCQUFnQjtJQUFFdlIsS0FBSztJQUFPQyxLQUFLMlE7SUFBWVEsT0FBT1A7QUFBVztBQUU4OEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybmNvZGUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcz9iZjJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFubm90YXRpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBUcmFuc2FjdGlvbiwgQ2hhbmdlU2V0LCBDaGFuZ2VEZXNjLCBFZGl0b3JTZWxlY3Rpb24sIFN0YXRlRWZmZWN0LCBUZXh0LCBmaW5kQ2x1c3RlckJyZWFrLCBjb3VudENvbHVtbiwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldywgRGlyZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBJbmRlbnRDb250ZXh0LCBnZXRJbmRlbnRhdGlvbiwgaW5kZW50U3RyaW5nLCBtYXRjaEJyYWNrZXRzLCBzeW50YXhUcmVlLCBnZXRJbmRlbnRVbml0LCBpbmRlbnRVbml0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgdXNlIGxpbmUgY29tbWVudHNcbmlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxpbmcgYmFjayB0byBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCB0b2dnbGVDb21tZW50ID0gdGFyZ2V0ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tKSwgY29uZmlnID0gZ2V0Q29uZmlnKHRhcmdldC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICByZXR1cm4gY29uZmlnLmxpbmUgPyB0b2dnbGVMaW5lQ29tbWVudCh0YXJnZXQpIDogY29uZmlnLmJsb2NrID8gdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lKHRhcmdldCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBjb21tYW5kKGYsIG9wdGlvbikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGYob3B0aW9uLCBzdGF0ZSk7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh0cikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cblRoZSBsaW5lIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlTGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZVVuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuVGhlIGJsb2NrIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgbGluZXMgYXJvdW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZ1xuYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lID0gLypAX19QVVJFX18qL2NvbW1hbmQoKG8sIHMpID0+IGNoYW5nZUJsb2NrQ29tbWVudChvLCBzLCBzZWxlY3RlZExpbmVSYW5nZXMocykpLCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbmZ1bmN0aW9uIGdldENvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IGRhdGEgPSBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImNvbW1lbnRUb2tlbnNcIiwgcG9zLCAxKTtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPyBkYXRhWzBdIDoge307XG59XG5jb25zdCBTZWFyY2hNYXJnaW4gPSA1MDtcbi8qKlxuRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gcmFuZ2UgaXMgYmxvY2stY29tbWVudGVkIGluIHRoZSBnaXZlblxuc3RhdGUuXG4qL1xuZnVuY3Rpb24gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgeyBvcGVuLCBjbG9zZSB9LCBmcm9tLCB0bykge1xuICAgIGxldCB0ZXh0QmVmb3JlID0gc3RhdGUuc2xpY2VEb2MoZnJvbSAtIFNlYXJjaE1hcmdpbiwgZnJvbSk7XG4gICAgbGV0IHRleHRBZnRlciA9IHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIFNlYXJjaE1hcmdpbik7XG4gICAgbGV0IHNwYWNlQmVmb3JlID0gL1xccyokLy5leGVjKHRleHRCZWZvcmUpWzBdLmxlbmd0aCwgc3BhY2VBZnRlciA9IC9eXFxzKi8uZXhlYyh0ZXh0QWZ0ZXIpWzBdLmxlbmd0aDtcbiAgICBsZXQgYmVmb3JlT2ZmID0gdGV4dEJlZm9yZS5sZW5ndGggLSBzcGFjZUJlZm9yZTtcbiAgICBpZiAodGV4dEJlZm9yZS5zbGljZShiZWZvcmVPZmYgLSBvcGVuLmxlbmd0aCwgYmVmb3JlT2ZmKSA9PSBvcGVuICYmXG4gICAgICAgIHRleHRBZnRlci5zbGljZShzcGFjZUFmdGVyLCBzcGFjZUFmdGVyICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSAtIHNwYWNlQmVmb3JlLCBtYXJnaW46IHNwYWNlQmVmb3JlICYmIDEgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gKyBzcGFjZUFmdGVyLCBtYXJnaW46IHNwYWNlQWZ0ZXIgJiYgMSB9IH07XG4gICAgfVxuICAgIGxldCBzdGFydFRleHQsIGVuZFRleHQ7XG4gICAgaWYgKHRvIC0gZnJvbSA8PSAyICogU2VhcmNoTWFyZ2luKSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGFydFRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgU2VhcmNoTWFyZ2luKTtcbiAgICAgICAgZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKHRvIC0gU2VhcmNoTWFyZ2luLCB0byk7XG4gICAgfVxuICAgIGxldCBzdGFydFNwYWNlID0gL15cXHMqLy5leGVjKHN0YXJ0VGV4dClbMF0ubGVuZ3RoLCBlbmRTcGFjZSA9IC9cXHMqJC8uZXhlYyhlbmRUZXh0KVswXS5sZW5ndGg7XG4gICAgbGV0IGVuZE9mZiA9IGVuZFRleHQubGVuZ3RoIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0VGV4dC5zbGljZShzdGFydFNwYWNlLCBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpID09IG9wZW4gJiZcbiAgICAgICAgZW5kVGV4dC5zbGljZShlbmRPZmYsIGVuZE9mZiArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gKyBzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KHN0YXJ0VGV4dC5jaGFyQXQoc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSkgPyAxIDogMCB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChlbmRUZXh0LmNoYXJBdChlbmRPZmYgLSAxKSkgPyAxIDogMCB9IH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lUmFuZ2VzKHN0YXRlKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHIgb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgZnJvbUxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHIuZnJvbSk7XG4gICAgICAgIGxldCB0b0xpbmUgPSByLnRvIDw9IGZyb21MaW5lLnRvID8gZnJvbUxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHIudG8pO1xuICAgICAgICBpZiAodG9MaW5lLmZyb20gPiBmcm9tTGluZS5mcm9tICYmIHRvTGluZS5mcm9tID09IHIudG8pXG4gICAgICAgICAgICB0b0xpbmUgPSByLnRvID09IGZyb21MaW5lLnRvICsgMSA/IGZyb21MaW5lIDogc3RhdGUuZG9jLmxpbmVBdChyLnRvIC0gMSk7XG4gICAgICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdLnRvID4gZnJvbUxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJhbmdlc1tsYXN0XS50byA9IHRvTGluZS50bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBmcm9tTGluZS5mcm9tICsgL15cXHMqLy5leGVjKGZyb21MaW5lLnRleHQpWzBdLmxlbmd0aCwgdG86IHRvTGluZS50byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGJsb2NrIGNvbW1lbnRzIGluXG4vLyBsYW5ndWFnZXMgdGhhdCBzdXBwb3J0IHRoZW0uXG5mdW5jdGlvbiBjaGFuZ2VCbG9ja0NvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCB0b2tlbnMgPSByYW5nZXMubWFwKHIgPT4gZ2V0Q29uZmlnKHN0YXRlLCByLmZyb20pLmJsb2NrKTtcbiAgICBpZiAoIXRva2Vucy5ldmVyeShjID0+IGMpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY29tbWVudHMgPSByYW5nZXMubWFwKChyLCBpKSA9PiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB0b2tlbnNbaV0sIHIuZnJvbSwgci50bykpO1xuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiAhY29tbWVudHMuZXZlcnkoYyA9PiBjKSkge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBzdGF0ZS5jaGFuZ2VzKHJhbmdlcy5tYXAoKHJhbmdlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IHJhbmdlLmZyb20sIGluc2VydDogdG9rZW5zW2ldLm9wZW4gKyBcIiBcIiB9LCB7IGZyb206IHJhbmdlLnRvLCBpbnNlcnQ6IFwiIFwiICsgdG9rZW5zW2ldLmNsb3NlIH1dO1xuICAgICAgICAgICAgfSkpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBjb21tZW50cy5zb21lKGMgPT4gYykpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvbW1lbnQ7IGkgPCBjb21tZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID0gY29tbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV0sIHsgb3BlbiwgY2xvc2UgfSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogb3Blbi5wb3MgLSB0b2tlbi5vcGVuLmxlbmd0aCwgdG86IG9wZW4ucG9zICsgb3Blbi5tYXJnaW4gfSwgeyBmcm9tOiBjbG9zZS5wb3MgLSBjbG9zZS5tYXJnaW4sIHRvOiBjbG9zZS5wb3MgKyB0b2tlbi5jbG9zZS5sZW5ndGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBsaW5lIGNvbW1lbnRzLlxuZnVuY3Rpb24gY2hhbmdlTGluZUNvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxldCBwcmV2TGluZSA9IC0xO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IGxpbmVzLmxlbmd0aCwgbWluSW5kZW50ID0gMWU5O1xuICAgICAgICBsZXQgdG9rZW4gPSBnZXRDb25maWcoc3RhdGUsIGZyb20pLmxpbmU7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gcHJldkxpbmUgJiYgKGZyb20gPT0gdG8gfHwgdG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcHJldkxpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgZW1wdHkgPSBpbmRlbnQgPT0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBsaW5lLnRleHQuc2xpY2UoaW5kZW50LCBpbmRlbnQgKyB0b2tlbi5sZW5ndGgpID09IHRva2VuID8gaW5kZW50IDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGluZGVudCA8IGxpbmUudGV4dC5sZW5ndGggJiYgaW5kZW50IDwgbWluSW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBtaW5JbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGxpbmUsIGNvbW1lbnQsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbkluZGVudCA8IDFlOSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEk7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0uaW5kZW50IDwgbGluZXNbaV0ubGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0uaW5kZW50ID0gbWluSW5kZW50O1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IHN0YXJ0SSArIDEpXG4gICAgICAgICAgICBsaW5lc1tzdGFydEldLnNpbmdsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50IDwgMCAmJiAoIWwuZW1wdHkgfHwgbC5zaW5nbGUpKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGUgfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChzaW5nbGUgfHwgIWVtcHR5KVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSArIGluZGVudCwgaW5zZXJ0OiB0b2tlbiArIFwiIFwiIH0pO1xuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogY2hhbmdlU2V0LCBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5tYXAoY2hhbmdlU2V0LCAxKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA+PSAwKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIGNvbW1lbnQsIHRva2VuIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoY29tbWVudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBsaW5lLmZyb20gKyBjb21tZW50LCB0byA9IGZyb20gKyB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0gPT0gXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGZyb21IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGFubm90YXRpb24gdGhhdCB3aWxsIHByZXZlbnQgdGhhdCB0cmFuc2FjdGlvbiBmcm9tXG5iZWluZyBjb21iaW5lZCB3aXRoIG90aGVyIHRyYW5zYWN0aW9ucyBpbiB0aGUgdW5kbyBoaXN0b3J5LiBHaXZlblxuYFwiYmVmb3JlXCJgLCBpdCdsbCBwcmV2ZW50IG1lcmdpbmcgd2l0aCBwcmV2aW91cyB0cmFuc2FjdGlvbnMuIFdpdGhcbmBcImFmdGVyXCJgLCBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucyB3b24ndCBiZSBjb21iaW5lZCB3aXRoIHRoaXNcbm9uZS4gV2l0aCBgXCJmdWxsXCJgLCB0aGUgdHJhbnNhY3Rpb24gaXMgaXNvbGF0ZWQgb24gYm90aCBzaWRlcy5cbiovXG5jb25zdCBpc29sYXRlSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UaGlzIGZhY2V0IHByb3ZpZGVzIGEgd2F5IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyB0aGF0LCBnaXZlbiBhXG50cmFuc2FjdGlvbiwgcHJvdmlkZSBhIHNldCBvZiBlZmZlY3RzIHRoYXQgdGhlIGhpc3Rvcnkgc2hvdWxkXG5zdG9yZSB3aGVuIGludmVydGluZyB0aGUgdHJhbnNhY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgdG9cbmludGVncmF0ZSBzb21lIGtpbmRzIG9mIGVmZmVjdHMgaW4gdGhlIGhpc3RvcnksIHNvIHRoYXQgdGhleSBjYW5cbmJlIHVuZG9uZSAoYW5kIHJlZG9uZSBhZ2FpbikuXG4qL1xuY29uc3QgaW52ZXJ0ZWRFZmZlY3RzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaGlzdG9yeUNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBtaW5EZXB0aDogMTAwLFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogNTAwLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChfdCwgaXNBZGphY2VudCkgPT4gaXNBZGphY2VudCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWluRGVwdGg6IE1hdGgubWF4LFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogTWF0aC5taW4sXG4gICAgICAgICAgICBqb2luVG9FdmVudDogKGEsIGIpID0+ICh0ciwgYWRqKSA9PiBhKHRyLCBhZGopIHx8IGIodHIsIGFkailcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBoaXN0b3J5RmllbGRfID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBIaXN0b3J5U3RhdGUuZW1wdHk7XG4gICAgfSxcbiAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChoaXN0b3J5Q29uZmlnKTtcbiAgICAgICAgbGV0IGZyb21IaXN0ID0gdHIuYW5ub3RhdGlvbihmcm9tSGlzdG9yeSk7XG4gICAgICAgIGlmIChmcm9tSGlzdCkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyLCBmcm9tSGlzdC5zZWxlY3Rpb24pLCBmcm9tID0gZnJvbUhpc3Quc2lkZTtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBzdGF0ZS51bmRvbmUgOiBzdGF0ZS5kb25lO1xuICAgICAgICAgICAgaWYgKGl0ZW0pXG4gICAgICAgICAgICAgICAgb3RoZXIgPSB1cGRhdGVCcmFuY2gob3RoZXIsIG90aGVyLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBpdGVtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdGhlciA9IGFkZFNlbGVjdGlvbihvdGhlciwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGZyb21IaXN0LnJlc3QgOiBvdGhlciwgZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IG90aGVyIDogZnJvbUhpc3QucmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzb2xhdGUgPSB0ci5hbm5vdGF0aW9uKGlzb2xhdGVIaXN0b3J5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImJlZm9yZVwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIGlmICh0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuICF0ci5jaGFuZ2VzLmVtcHR5ID8gc3RhdGUuYWRkTWFwcGluZyh0ci5jaGFuZ2VzLmRlc2MpIDogc3RhdGU7XG4gICAgICAgIGxldCBldmVudCA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIpO1xuICAgICAgICBsZXQgdGltZSA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udGltZSksIHVzZXJFdmVudCA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50KVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZFNlbGVjdGlvbih0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBjb25maWcubmV3R3JvdXBEZWxheSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJhZnRlclwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIHRvSlNPTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBkb25lOiB2YWx1ZS5kb25lLm1hcChlID0+IGUudG9KU09OKCkpLCB1bmRvbmU6IHZhbHVlLnVuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShqc29uLmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTiksIGpzb24udW5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pKTtcbiAgICB9XG59KTtcbi8qKlxuQ3JlYXRlIGEgaGlzdG9yeSBleHRlbnNpb24gd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaGlzdG9yeUZpZWxkXyxcbiAgICAgICAgaGlzdG9yeUNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBFZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgICAgICAgYmVmb3JlaW5wdXQoZSwgdmlldykge1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBdO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdXNlZCB0byBzdG9yZSB0aGUgaGlzdG9yeSBkYXRhLiBTaG91bGQgcHJvYmFibHlcbm9ubHkgYmUgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG5bc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgb3JcbltkZXNlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgc3RhdGUgb2JqZWN0cyBpbiBhIHdheVxudGhhdCBwcmVzZXJ2ZXMgaGlzdG9yeS5cbiovXG5jb25zdCBoaXN0b3J5RmllbGQgPSBoaXN0b3J5RmllbGRfO1xuZnVuY3Rpb24gY21kKHNpZGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkge1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiAmJiBzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGhpc3RvcnlTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0b3J5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGhpc3RvcnlTdGF0ZS5wb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbik7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuVW5kbyBhIHNpbmdsZSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cFxud2FzIGF2YWlsYWJsZS5cbiovXG5jb25zdCB1bmRvID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgZmFsc2UpO1xuLyoqXG5SZWRvIGEgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXAgd2FzXG5hdmFpbGFibGUuXG4qL1xuY29uc3QgcmVkbyA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgZmFsc2UpO1xuLyoqXG5VbmRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgdW5kb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIHRydWUpO1xuLyoqXG5SZWRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgcmVkb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgdHJ1ZSk7XG5mdW5jdGlvbiBkZXB0aChzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBsZXQgaGlzdFN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGhpc3RTdGF0ZS5kb25lIDogaGlzdFN0YXRlLnVuZG9uZTtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5sZW5ndGggLSAoYnJhbmNoLmxlbmd0aCAmJiAhYnJhbmNoWzBdLmNoYW5nZXMgPyAxIDogMCk7XG4gICAgfTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiB1bmRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHVuZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyk7XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCByZWRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLyk7XG4vLyBIaXN0b3J5IGV2ZW50cyBzdG9yZSBncm91cHMgb2YgY2hhbmdlcyBvciBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZVxuLy8gdW5kb25lL3JlZG9uZSB0b2dldGhlci5cbmNsYXNzIEhpc3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGNoYW5nZXMgaW4gdGhpcyBldmVudC4gTm9ybWFsIGV2ZW50cyBob2xkIGF0IGxlYXN0IG9uZVxuICAgIC8vIGNoYW5nZSBvciBlZmZlY3QuIEJ1dCBpdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHN0b3JlIHNlbGVjdGlvblxuICAgIC8vIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZSwgaW4gd2hpY2ggY2FzZSBhIHNwZWNpYWwgdHlwZSBvZlxuICAgIC8vIGluc3RhbmNlIGlzIGNyZWF0ZWQgd2hpY2ggZG9lc24ndCBob2xkIGFueSBjaGFuZ2VzLCB3aXRoXG4gICAgLy8gY2hhbmdlcyA9PSBzdGFydFNlbGVjdGlvbiA9PSB1bmRlZmluZWRcbiAgICBjaGFuZ2VzLCBcbiAgICAvLyBUaGUgZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxuICAgIGVmZmVjdHMsIFxuICAgIC8vIEFjY3VtdWxhdGVkIG1hcHBpbmcgKGZyb20gYWRkVG9IaXN0b3J5PT1mYWxzZSkgdGhhdCBzaG91bGQgYmVcbiAgICAvLyBhcHBsaWVkIHRvIGV2ZW50cyBiZWxvdyB0aGlzIG9uZS5cbiAgICBtYXBwZWQsIFxuICAgIC8vIFRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoaXMgZXZlbnRcbiAgICBzdGFydFNlbGVjdGlvbiwgXG4gICAgLy8gU3RvcmVzIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHRoaXMgZXZlbnQsIHRvIGJlIHVzZWQgZm9yXG4gICAgLy8gc2VsZWN0aW9uIHVuZG8vcmVkby5cbiAgICBzZWxlY3Rpb25zQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5tYXBwZWQgPSBtYXBwZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBzdGFydFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zQWZ0ZXIgPSBzZWxlY3Rpb25zQWZ0ZXI7XG4gICAgfVxuICAgIHNldFNlbEFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRoaXMuY2hhbmdlcywgdGhpcy5lZmZlY3RzLCB0aGlzLm1hcHBlZCwgdGhpcy5zdGFydFNlbGVjdGlvbiwgYWZ0ZXIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogKF9hID0gdGhpcy5jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCksXG4gICAgICAgICAgICBtYXBwZWQ6IChfYiA9IHRoaXMubWFwcGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9KU09OKCksXG4gICAgICAgICAgICBzdGFydFNlbGVjdGlvbjogKF9jID0gdGhpcy5zdGFydFNlbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSlNPTigpLFxuICAgICAgICAgICAgc2VsZWN0aW9uc0FmdGVyOiB0aGlzLnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLnRvSlNPTigpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudChqc29uLmNoYW5nZXMgJiYgQ2hhbmdlU2V0LmZyb21KU09OKGpzb24uY2hhbmdlcyksIFtdLCBqc29uLm1hcHBlZCAmJiBDaGFuZ2VEZXNjLmZyb21KU09OKGpzb24ubWFwcGVkKSwganNvbi5zdGFydFNlbGVjdGlvbiAmJiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zdGFydFNlbGVjdGlvbiksIGpzb24uc2VsZWN0aW9uc0FmdGVyLm1hcChFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04pKTtcbiAgICB9XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjaGVjayBgYWRkVG9IaXN0b3J5YCBhbmQgc3VjaCwgaXQgYXNzdW1lcyB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gaXRlbS4gUmV0dXJucyBudWxsIHdoZW5cbiAgICAvLyB0aGVyZSBhcmUgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBzdGF0aWMgZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBub25lO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnQgb2YgdHIuc3RhcnRTdGF0ZS5mYWNldChpbnZlcnRlZEVmZmVjdHMpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW52ZXJ0KHRyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMgPSBlZmZlY3RzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGggJiYgdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0ci5jaGFuZ2VzLmludmVydCh0ci5zdGFydFN0YXRlLmRvYyksIGVmZmVjdHMsIHVuZGVmaW5lZCwgc2VsZWN0aW9uIHx8IHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCBub25lKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGVjdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHVuZGVmaW5lZCwgbm9uZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHNlbGVjdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUJyYW5jaChicmFuY2gsIHRvLCBtYXhMZW4sIG5ld0V2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gdG8gKyAxID4gbWF4TGVuICsgMjAgPyB0byAtIG1heExlbiAtIDEgOiAwO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2Uoc3RhcnQsIHRvKTtcbiAgICBuZXdCcmFuY2gucHVzaChuZXdFdmVudCk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnQoYSwgYikge1xuICAgIGxldCByYW5nZXMgPSBbXSwgaXNBZGphY2VudCA9IGZhbHNlO1xuICAgIGEuaXRlckNoYW5nZWRSYW5nZXMoKGYsIHQpID0+IHJhbmdlcy5wdXNoKGYsIHQpKTtcbiAgICBiLml0ZXJDaGFuZ2VkUmFuZ2VzKChfZiwgX3QsIGYsIHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaSsrXSwgdG8gPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIGlmICh0ID49IGZyb20gJiYgZiA8PSB0bylcbiAgICAgICAgICAgICAgICBpc0FkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0FkamFjZW50O1xufVxuZnVuY3Rpb24gZXFTZWxlY3Rpb25TaGFwZShhLCBiKSB7XG4gICAgcmV0dXJuIGEucmFuZ2VzLmxlbmd0aCA9PSBiLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgYS5yYW5nZXMuZmlsdGVyKChyLCBpKSA9PiByLmVtcHR5ICE9IGIucmFuZ2VzW2ldLmVtcHR5KS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBjb25jKGEsIGIpIHtcbiAgICByZXR1cm4gIWEubGVuZ3RoID8gYiA6ICFiLmxlbmd0aCA/IGEgOiBhLmNvbmNhdChiKTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNvbnN0IE1heFNlbGVjdGlvbnNQZXJFdmVudCA9IDIwMDtcbmZ1bmN0aW9uIGFkZFNlbGVjdGlvbihicmFuY2gsIHNlbGVjdGlvbikge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW0hpc3RFdmVudC5zZWxlY3Rpb24oW3NlbGVjdGlvbl0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0RXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgc2VscyA9IGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSBNYXhTZWxlY3Rpb25zUGVyRXZlbnQpKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoICYmIHNlbHNbc2Vscy5sZW5ndGggLSAxXS5lcShzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgc2Vscy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB1cGRhdGVCcmFuY2goYnJhbmNoLCBicmFuY2gubGVuZ3RoIC0gMSwgMWU5LCBsYXN0RXZlbnQuc2V0U2VsQWZ0ZXIoc2VscykpO1xuICAgIH1cbn1cbi8vIEFzc3VtZXMgdGhlIHRvcCBpdGVtIGhhcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb25BZnRlciB2YWx1ZXNcbmZ1bmN0aW9uIHBvcFNlbGVjdGlvbihicmFuY2gpIHtcbiAgICBsZXQgbGFzdCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZSgpO1xuICAgIG5ld0JyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0gPSBsYXN0LnNldFNlbEFmdGVyKGxhc3Quc2VsZWN0aW9uc0FmdGVyLnNsaWNlKDAsIGxhc3Quc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuLy8gQWRkIGEgbWFwcGluZyB0byB0aGUgdG9wIGV2ZW50IGluIHRoZSBnaXZlbiBicmFuY2guIElmIHRoaXMgbWFwc1xuLy8gYXdheSBhbGwgdGhlIGNoYW5nZXMgYW5kIGVmZmVjdHMgaW4gdGhhdCBpdGVtLCBkcm9wIGl0IGFuZFxuLy8gcHJvcGFnYXRlIHRoZSBtYXBwaW5nIHRvIHRoZSBuZXh0IGl0ZW0uXG5mdW5jdGlvbiBhZGRNYXBwaW5nVG9CcmFuY2goYnJhbmNoLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKVxuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIGxldCBsZW5ndGggPSBicmFuY2gubGVuZ3RoLCBzZWxlY3Rpb25zID0gbm9uZTtcbiAgICB3aGlsZSAobGVuZ3RoKSB7XG4gICAgICAgIGxldCBldmVudCA9IG1hcEV2ZW50KGJyYW5jaFtsZW5ndGggLSAxXSwgbWFwcGluZywgc2VsZWN0aW9ucyk7XG4gICAgICAgIGlmIChldmVudC5jaGFuZ2VzICYmICFldmVudC5jaGFuZ2VzLmVtcHR5IHx8IGV2ZW50LmVmZmVjdHMubGVuZ3RoKSB7IC8vIEV2ZW50IHN1cnZpdmVkIG1hcHBpbmdcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBicmFuY2guc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSAxXSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRHJvcCB0aGlzIGV2ZW50LCBzaW5jZSB0aGVyZSdzIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBsZWZ0XG4gICAgICAgICAgICBtYXBwaW5nID0gZXZlbnQubWFwcGVkO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IFtIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpXSA6IG5vbmU7XG59XG5mdW5jdGlvbiBtYXBFdmVudChldmVudCwgbWFwcGluZywgZXh0cmFTZWxlY3Rpb25zKSB7XG4gICAgbGV0IHNlbGVjdGlvbnMgPSBjb25jKGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggPyBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy5tYXAobWFwcGluZykpIDogbm9uZSwgZXh0cmFTZWxlY3Rpb25zKTtcbiAgICAvLyBDaGFuZ2UtbGVzcyBldmVudHMgZG9uJ3Qgc3RvcmUgbWFwcGluZ3MgKHRoZXkgYXJlIGFsd2F5cyB0aGUgbGFzdCBldmVudCBpbiBhIGJyYW5jaClcbiAgICBpZiAoIWV2ZW50LmNoYW5nZXMpXG4gICAgICAgIHJldHVybiBIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIGxldCBtYXBwZWRDaGFuZ2VzID0gZXZlbnQuY2hhbmdlcy5tYXAobWFwcGluZyksIGJlZm9yZSA9IG1hcHBpbmcubWFwRGVzYyhldmVudC5jaGFuZ2VzLCB0cnVlKTtcbiAgICBsZXQgZnVsbE1hcHBpbmcgPSBldmVudC5tYXBwZWQgPyBldmVudC5tYXBwZWQuY29tcG9zZURlc2MoYmVmb3JlKSA6IGJlZm9yZTtcbiAgICByZXR1cm4gbmV3IEhpc3RFdmVudChtYXBwZWRDaGFuZ2VzLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIG1hcHBpbmcpLCBmdWxsTWFwcGluZywgZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGJlZm9yZSksIHNlbGVjdGlvbnMpO1xufVxuY29uc3Qgam9pbmFibGVVc2VyRXZlbnQgPSAvXihpbnB1dFxcLnR5cGV8ZGVsZXRlKSgkfFxcLikvO1xuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZUaW1lID0gMCwgcHJldlVzZXJFdmVudCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZVc2VyRXZlbnQgPSBwcmV2VXNlckV2ZW50O1xuICAgIH1cbiAgICBpc29sYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2VGltZSA/IG5ldyBIaXN0b3J5U3RhdGUodGhpcy5kb25lLCB0aGlzLnVuZG9uZSkgOiB0aGlzO1xuICAgIH1cbiAgICBhZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpIHtcbiAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmRvbmUsIGxhc3RFdmVudCA9IGRvbmVbZG9uZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RFdmVudCAmJiBsYXN0RXZlbnQuY2hhbmdlcyAmJiAhbGFzdEV2ZW50LmNoYW5nZXMuZW1wdHkgJiYgZXZlbnQuY2hhbmdlcyAmJlxuICAgICAgICAgICAgKCF1c2VyRXZlbnQgfHwgam9pbmFibGVVc2VyRXZlbnQudGVzdCh1c2VyRXZlbnQpKSAmJlxuICAgICAgICAgICAgKCghbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IGNvbmZpZy5uZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLmpvaW5Ub0V2ZW50KHRyLCBpc0FkamFjZW50KGxhc3RFdmVudC5jaGFuZ2VzLCBldmVudC5jaGFuZ2VzKSkpIHx8XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbXBvc2UgKGJ1dCBub3QgY29tcG9zZS5zdGFydCkgZXZlbnRzLCBhbHdheXMgam9pbiB3aXRoIHByZXZpb3VzIGV2ZW50XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ID09IFwiaW5wdXQudHlwZS5jb21wb3NlXCIpKSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgY29uZmlnLm1pbkRlcHRoLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhldmVudC5lZmZlY3RzLCBsYXN0RXZlbnQuY2hhbmdlcyksIGxhc3RFdmVudC5lZmZlY3RzKSwgbGFzdEV2ZW50Lm1hcHBlZCwgbGFzdEV2ZW50LnN0YXJ0U2VsZWN0aW9uLCBub25lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShkb25lLCBub25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRTZWxlY3Rpb24oc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIG5ld0dyb3VwRGVsYXkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbmUubGVuZ3RoID8gdGhpcy5kb25lW3RoaXMuZG9uZS5sZW5ndGggLSAxXS5zZWxlY3Rpb25zQWZ0ZXIgOiBub25lO1xuICAgICAgICBpZiAobGFzdC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IG5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgIHVzZXJFdmVudCA9PSB0aGlzLnByZXZVc2VyRXZlbnQgJiYgdXNlckV2ZW50ICYmIC9ec2VsZWN0KCR8XFwuKS8udGVzdCh1c2VyRXZlbnQpICYmXG4gICAgICAgICAgICBlcVNlbGVjdGlvblNoYXBlKGxhc3RbbGFzdC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRTZWxlY3Rpb24odGhpcy5kb25lLCBzZWxlY3Rpb24pLCB0aGlzLnVuZG9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLmRvbmUsIG1hcHBpbmcpLCBhZGRNYXBwaW5nVG9CcmFuY2godGhpcy51bmRvbmUsIG1hcHBpbmcpLCB0aGlzLnByZXZUaW1lLCB0aGlzLnByZXZVc2VyRXZlbnQpO1xuICAgIH1cbiAgICBwb3Aoc2lkZSwgc3RhdGUsIG9ubHlTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJyYW5jaCA9IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyB0aGlzLmRvbmUgOiB0aGlzLnVuZG9uZTtcbiAgICAgICAgaWYgKGJyYW5jaC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbMF0gfHwgc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAob25seVNlbGVjdGlvbiAmJiBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnNlbGVjdGlvbnNBZnRlcltldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdDogcG9wU2VsZWN0aW9uKGJyYW5jaCksIHNlbGVjdGlvbiB9KSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInNlbGVjdC51bmRvXCIgOiBcInNlbGVjdC5yZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFldmVudC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN0ID0gYnJhbmNoLmxlbmd0aCA9PSAxID8gbm9uZSA6IGJyYW5jaC5zbGljZSgwLCBicmFuY2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQubWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3QgPSBhZGRNYXBwaW5nVG9CcmFuY2gocmVzdCwgZXZlbnQubWFwcGVkKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGV2ZW50LmNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zdGFydFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBldmVudC5lZmZlY3RzLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3QsIHNlbGVjdGlvbiB9KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwidW5kb1wiIDogXCJyZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuSGlzdG9yeVN0YXRlLmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBIaXN0b3J5U3RhdGUobm9uZSwgbm9uZSk7XG4vKipcbkRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgdW5kbyBoaXN0b3J5LlxuXG4tIE1vZC16OiBbYHVuZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG8pLlxuLSBNb2QteSAoTW9kLVNoaWZ0LXogb24gbWFjT1MpICsgQ3RybC1TaGlmdC16IG9uIExpbnV4OiBbYHJlZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG8pLlxuLSBNb2QtdTogW2B1bmRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvU2VsZWN0aW9uKS5cbi0gQWx0LXUgKE1vZC1TaGlmdC11IG9uIG1hY09TKTogW2ByZWRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5yZWRvU2VsZWN0aW9uKS5cbiovXG5jb25zdCBoaXN0b3J5S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIk1vZC16XCIsIHJ1bjogdW5kbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QteVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbGludXg6IFwiQ3RybC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtdVwiLCBydW46IHVuZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQWx0LXVcIiwgbWFjOiBcIk1vZC1TaGlmdC11XCIsIHJ1bjogcmVkb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfVxuXTtcblxuZnVuY3Rpb24gdXBkYXRlU2VsKHNlbCwgYnkpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLm1hcChieSksIHNlbC5tYWluSW5kZXgpO1xufVxuZnVuY3Rpb24gc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pO1xufVxuZnVuY3Rpb24gbW92ZVNlbCh7IHN0YXRlLCBkaXNwYXRjaCB9LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgaG93KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbiwgdHJ1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gcmFuZ2UudG8gOiByYW5nZS5mcm9tKTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbmZ1bmN0aW9uIGx0ckF0Q3Vyc29yKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSA9PSBEaXJlY3Rpb24uTFRSO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCAod2hpY2ggaXMgYmFja3dhcmQgaW5cbmxlZnQtdG8tcmlnaHQgdGV4dCwgZm9yd2FyZCBpbiByaWdodC10by1sZWZ0IHRleHQpLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckNoYXJSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JDaGFyRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBieUNoYXJMb2dpY2FsKHN0YXRlLCByYW5nZSwgZm9yd2FyZCkge1xuICAgIGxldCBwb3MgPSByYW5nZS5oZWFkLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgIGlmIChwb3MgPT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSlcbiAgICAgICAgcG9zID0gZm9yd2FyZCA/IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGxpbmUudG8gKyAxKSA6IE1hdGgubWF4KDAsIGxpbmUuZnJvbSAtIDEpO1xuICAgIGVsc2VcbiAgICAgICAgcG9zID0gbGluZS5mcm9tICsgZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbmZ1bmN0aW9uIG1vdmVCeUNoYXJMb2dpY2FsKHRhcmdldCwgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHRhcmdldCwgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyBieUNoYXJMb2dpY2FsKHRhcmdldC5zdGF0ZSwgcmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZCwgaW4gbG9naWNhbFxuKG5vbi10ZXh0LWRpcmVjdGlvbi1hd2FyZSkgc3RyaW5nIGluZGV4IG9yZGVyLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkTG9naWNhbCA9IHRhcmdldCA9PiBtb3ZlQnlDaGFyTG9naWNhbCh0YXJnZXQsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBiYWNrd2FyZCwgaW4gbG9naWNhbCBzdHJpbmcgaW5kZXhcbm9yZGVyLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJCYWNrd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gbW92ZUJ5Q2hhckxvZ2ljYWwodGFyZ2V0LCBmYWxzZSk7XG5mdW5jdGlvbiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBsZWZ0IGFjcm9zcyBvbmUgZ3JvdXAgb2Ygd29yZCBvclxubm9uLXdvcmQgKGJ1dCBhbHNvIG5vbi1zcGFjZSkgY2hhcmFjdGVycy5cbiovXG5jb25zdCBjdXJzb3JHcm91cExlZnQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiB0b0dyb3VwU3RhcnQodmlldywgcG9zLCBzdGFydCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShzdGFydCksIGluaXRpYWwgPSBjYXQgIT0gQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgIHJldHVybiAobmV4dCkgPT4ge1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCk7XG4gICAgICAgIGlmIChuZXh0Q2F0ICE9IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsICYmIG5leHRDYXQgPT0gY2F0O1xuICAgICAgICBpbml0aWFsID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvbmUgZ3JvdXAgZm9yd2FyZCBpbiB0aGUgZGVmYXVsdCBXaW5kb3dzIHN0eWxlLFxud2hlcmUgaXQgbW92ZXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwRm9yd2FyZFdpbiA9IHZpZXcgPT4ge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5XG4gICAgICAgID8gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCB0cnVlLCBzdGFydCA9PiB0b0dyb3VwU3RhcnQodmlldywgcmFuZ2UuaGVhZCwgc3RhcnQpKVxuICAgICAgICA6IHJhbmdlRW5kKHJhbmdlLCB0cnVlKSk7XG59O1xuY29uc3Qgc2VnbWVudGVyID0gdHlwZW9mIEludGwgIT0gXCJ1bmRlZmluZWRcIiAmJiBJbnRsLlNlZ21lbnRlciA/XG4gICAgLypAX19QVVJFX18qL25ldyAoSW50bC5TZWdtZW50ZXIpKHVuZGVmaW5lZCwgeyBncmFudWxhcml0eTogXCJ3b3JkXCIgfSkgOiBudWxsO1xuZnVuY3Rpb24gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuZnJvbSk7XG4gICAgbGV0IGNhdCA9IENoYXJDYXRlZ29yeS5TcGFjZSwgcG9zID0gcmFuZ2UuZnJvbSwgc3RlcHMgPSAwO1xuICAgIGxldCBkb25lID0gZmFsc2UsIHNhd1VwcGVyID0gZmFsc2UsIHNhd0xvd2VyID0gZmFsc2U7XG4gICAgbGV0IHN0ZXAgPSAobmV4dCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9zICs9IGZvcndhcmQgPyBuZXh0Lmxlbmd0aCA6IC1uZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpLCBhaGVhZDtcbiAgICAgICAgaWYgKG5leHRDYXQgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiYgbmV4dC5jaGFyQ29kZUF0KDApIDwgMTI4ICYmIC9bXFxXX10vLnRlc3QobmV4dCkpXG4gICAgICAgICAgICBuZXh0Q2F0ID0gLTE7IC8vIFRyZWF0IHdvcmQgcHVuY3R1YXRpb24gc3BlY2lhbGx5XG4gICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LlNwYWNlKVxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgaWYgKGNhdCAhPSBuZXh0Q2F0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICBpZiAobmV4dC50b0xvd2VyQ2FzZSgpID09IG5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcndhcmQgJiYgc2F3VXBwZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBzYXdMb3dlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYXdMb3dlcikge1xuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3VXBwZXIgJiYgZm9yd2FyZCAmJiBjYXRlZ29yaXplKGFoZWFkID0gdmlldy5zdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIDEpKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZCAmJlxuICAgICAgICAgICAgICAgICAgICBhaGVhZC50b0xvd2VyQ2FzZSgpID09IGFoZWFkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2F3VXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ZXBzKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgbGV0IGVuZCA9IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCwgc3RhcnQgPT4ge1xuICAgICAgICBzdGVwKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSk7XG4gICAgaWYgKHNlZ21lbnRlciAmJiBjYXQgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiYgZW5kLmZyb20gPT0gcmFuZ2UuZnJvbSArIHN0ZXBzICogKGZvcndhcmQgPyAxIDogLTEpKSB7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4ocmFuZ2UuaGVhZCwgZW5kLmhlYWQpLCB0byA9IE1hdGgubWF4KHJhbmdlLmhlYWQsIGVuZC5oZWFkKTtcbiAgICAgICAgbGV0IHNraXBwZWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMSAmJiAvW1xcdTRFMDAtXFx1ZmZmZl0vLnRlc3Qoc2tpcHBlZCkpIHtcbiAgICAgICAgICAgIGxldCBzZWdtZW50cyA9IEFycmF5LmZyb20oc2VnbWVudGVyLnNlZ21lbnQoc2tpcHBlZCkpO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCArIHNlZ21lbnRzWzFdLmluZGV4LCAtMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZW5kLmhlYWQgKyBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5pbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yU3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yU3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gaW50ZXJlc3RpbmdOb2RlKHN0YXRlLCBub2RlLCBicmFja2V0UHJvcCkge1xuICAgIGlmIChub2RlLnR5cGUucHJvcChicmFja2V0UHJvcCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBsZW4gPSBub2RlLnRvIC0gbm9kZS5mcm9tO1xuICAgIHJldHVybiBsZW4gJiYgKGxlbiA+IDIgfHwgL1teXFxzLC47Ol0vLnRlc3Qoc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBub2RlLnRvKSkpIHx8IG5vZGUuZmlyc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIG1vdmVCeVN5bnRheChzdGF0ZSwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICBsZXQgcG9zID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHN0YXJ0LmhlYWQpO1xuICAgIGxldCBicmFja2V0UHJvcCA9IGZvcndhcmQgPyBOb2RlUHJvcC5jbG9zZWRCeSA6IE5vZGVQcm9wLm9wZW5lZEJ5O1xuICAgIC8vIFNjYW4gZm9yd2FyZCB0aHJvdWdoIGNoaWxkIG5vZGVzIHRvIHNlZSBpZiB0aGVyZSdzIGFuIGludGVyZXN0aW5nXG4gICAgLy8gbm9kZSBhaGVhZC5cbiAgICBmb3IgKGxldCBhdCA9IHN0YXJ0LmhlYWQ7Oykge1xuICAgICAgICBsZXQgbmV4dCA9IGZvcndhcmQgPyBwb3MuY2hpbGRBZnRlcihhdCkgOiBwb3MuY2hpbGRCZWZvcmUoYXQpO1xuICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbmV4dCwgYnJhY2tldFByb3ApKVxuICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXQgPSBmb3J3YXJkID8gbmV4dC50byA6IG5leHQuZnJvbTtcbiAgICB9XG4gICAgbGV0IGJyYWNrZXQgPSBwb3MudHlwZS5wcm9wKGJyYWNrZXRQcm9wKSwgbWF0Y2gsIG5ld1BvcztcbiAgICBpZiAoYnJhY2tldCAmJiAobWF0Y2ggPSBmb3J3YXJkID8gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLmZyb20sIDEpIDogbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLnRvLCAtMSkpICYmIG1hdGNoLm1hdGNoZWQpXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBtYXRjaC5lbmQudG8gOiBtYXRjaC5lbmQuZnJvbTtcbiAgICBlbHNlXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBwb3MudG8gOiBwb3MuZnJvbTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXdQb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBjdXJzb3JTeW50YXhMZWZ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JTeW50YXhSaWdodCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBjdXJzb3JCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCk7XG4gICAgICAgIGxldCBtb3ZlZCA9IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICByZXR1cm4gbW92ZWQuaGVhZCAhPSByYW5nZS5oZWFkID8gbW92ZWQgOiB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZm9yd2FyZCk7XG4gICAgfSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBjdXJzb3JMaW5lVXAgPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSBkb3duLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVEb3duID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBwYWdlSW5mbyh2aWV3KSB7XG4gICAgbGV0IHNlbGZTY3JvbGwgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQgPCB2aWV3LnNjcm9sbERPTS5zY3JvbGxIZWlnaHQgLSAyO1xuICAgIGxldCBtYXJnaW5Ub3AgPSAwLCBtYXJnaW5Cb3R0b20gPSAwLCBoZWlnaHQ7XG4gICAgaWYgKHNlbGZTY3JvbGwpIHtcbiAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHZpZXcuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zKSkge1xuICAgICAgICAgICAgbGV0IG1hcmdpbnMgPSBzb3VyY2Uodmlldyk7XG4gICAgICAgICAgICBpZiAobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLnRvcClcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBNYXRoLm1heChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMudG9wLCBtYXJnaW5Ub3ApO1xuICAgICAgICAgICAgaWYgKG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy5ib3R0b20pXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gTWF0aC5tYXgobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLmJvdHRvbSwgbWFyZ2luQm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgICBoZWlnaHQgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQgLSBtYXJnaW5Ub3AgLSBtYXJnaW5Cb3R0b207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZWlnaHQgPSAodmlldy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4geyBtYXJnaW5Ub3AsIG1hcmdpbkJvdHRvbSwgc2VsZlNjcm9sbCxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCh2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0LCBoZWlnaHQgLSA1KSB9O1xufVxuZnVuY3Rpb24gY3Vyc29yQnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICBsZXQgcGFnZSA9IHBhZ2VJbmZvKHZpZXcpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2UuaGVpZ2h0KVxuICAgICAgICAgICAgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdDtcbiAgICBpZiAocGFnZS5zZWxmU2Nyb2xsKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGxldCBzY3JvbGxSZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSBzY3JvbGxSZWN0LnRvcCArIHBhZ2UubWFyZ2luVG9wLCBzY3JvbGxCb3R0b20gPSBzY3JvbGxSZWN0LmJvdHRvbSAtIHBhZ2UubWFyZ2luQm90dG9tO1xuICAgICAgICBpZiAoc3RhcnRQb3MgJiYgc3RhcnRQb3MudG9wID4gc2Nyb2xsVG9wICYmIHN0YXJ0UG9zLmJvdHRvbSA8IHNjcm9sbEJvdHRvbSlcbiAgICAgICAgICAgIGVmZmVjdCA9IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uLm1haW4uaGVhZCwgeyB5OiBcInN0YXJ0XCIsIHlNYXJnaW46IHN0YXJ0UG9zLnRvcCAtIHNjcm9sbFRvcCB9KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbiksIHsgZWZmZWN0czogZWZmZWN0IH0pO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgdXAuXG4qL1xuY29uc3QgY3Vyc29yUGFnZVVwID0gdmlldyA9PiBjdXJzb3JCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBjdXJzb3JQYWdlRG93biA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHN0YXJ0LmhlYWQpLCBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkKTtcbiAgICBpZiAobW92ZWQuaGVhZCA9PSBzdGFydC5oZWFkICYmIG1vdmVkLmhlYWQgIT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSlcbiAgICAgICAgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgZmFsc2UpO1xuICAgIGlmICghZm9yd2FyZCAmJiBtb3ZlZC5oZWFkID09IGxpbmUuZnJvbSAmJiBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgc3BhY2UgPSAvXlxccyovLmV4ZWModmlldy5zdGF0ZS5zbGljZURvYyhsaW5lLmZyb20sIE1hdGgubWluKGxpbmUuZnJvbSArIDEwMCwgbGluZS50bykpKVswXS5sZW5ndGg7XG4gICAgICAgIGlmIChzcGFjZSAmJiBzdGFydC5oZWFkICE9IGxpbmUuZnJvbSArIHNwYWNlKVxuICAgICAgICAgICAgbW92ZWQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUuZnJvbSArIHNwYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVkO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgbGluZSB3cmFwIHBvaW50LCBvciB0byB0aGUgZW5kIG9mXG50aGUgbGluZSBpZiB0aGVyZSBpc24ndCBvbmUgbGVmdCBvbiB0aGlzIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHByZXZpb3VzIGxpbmUgd3JhcCBwb2ludCwgb3IgZmFpbGluZyB0aGF0IHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBsaW5lIGlzIGluZGVudGVkLCBhbmQgdGhlIGN1cnNvclxuaXNuJ3QgYWxyZWFkeSBhdCB0aGUgZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiwgdGhpcyB3aWxsIG1vdmUgdG8gdGhlXG5lbmQgb2YgdGhlIGluZGVudGF0aW9uIGluc3RlYWQgb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgd3JhcCBwb2ludCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVTdGFydCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbSwgMSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lRW5kID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bywgLTEpKTtcbmZ1bmN0aW9uIHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZXh0ZW5kKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2UsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IG1hdGNoaW5nID0gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgLTEpXG4gICAgICAgICAgICB8fCBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkLCAxKVxuICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxKSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkIDwgc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEpKTtcbiAgICAgICAgaWYgKCFtYXRjaGluZyB8fCAhbWF0Y2hpbmcuZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGxldCBoZWFkID0gbWF0Y2hpbmcuc3RhcnQuZnJvbSA9PSByYW5nZS5oZWFkID8gbWF0Y2hpbmcuZW5kLnRvIDogbWF0Y2hpbmcuZW5kLmZyb207XG4gICAgICAgIHJldHVybiBleHRlbmQgPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkKSA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoaGVhZCk7XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIGl0IGlzIGN1cnJlbnRseVxub24sIGlmIGFueS5cbiovXG5jb25zdCBjdXJzb3JNYXRjaGluZ0JyYWNrZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbkV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgdGhlIHNlbGVjdGlvblxuaGVhZCBpcyBjdXJyZW50bHkgb24sIGlmIGFueS5cbiovXG5jb25zdCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbmZ1bmN0aW9uIGV4dGVuZFNlbCh0YXJnZXQsIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwodGFyZ2V0LnN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgaGVhZCA9IGhvdyhyYW5nZSk7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkLmhlYWQsIGhlYWQuZ29hbENvbHVtbiwgaGVhZC5iaWRpTGV2ZWwgfHwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHRhcmdldC5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdGFyZ2V0LmRpc3BhdGNoKHNldFNlbCh0YXJnZXQuc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0QnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0LCB3aGlsZSBsZWF2aW5nXG50aGUgYW5jaG9yIGluIHBsYWNlLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhclJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZCBieSBsb2dpY2FsXG4obm9uLWRpcmVjdGlvbiBhd2FyZSkgc3RyaW5nIGluZGV4IG9yZGVyLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJGb3J3YXJkTG9naWNhbCA9IHRhcmdldCA9PiBleHRlbmRTZWwodGFyZ2V0LCByYW5nZSA9PiBieUNoYXJMb2dpY2FsKHRhcmdldC5zdGF0ZSwgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBiYWNrd2FyZCBieSBsb2dpY2FsIHN0cmluZ1xuaW5kZXggb3JkZXIuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckJhY2t3YXJkTG9naWNhbCA9IHRhcmdldCA9PiBleHRlbmRTZWwodGFyZ2V0LCByYW5nZSA9PiBieUNoYXJMb2dpY2FsKHRhcmdldC5zdGF0ZSwgcmFuZ2UsIGZhbHNlKSk7XG5mdW5jdGlvbiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIFtncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIHRvXG50aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RHcm91cExlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RHcm91cFJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBmb3J3YXJkIGluIHRoZSBkZWZhdWx0IFdpbmRvd3NcbnN0eWxlLCBza2lwcGluZyB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgZ3JvdXAuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBGb3J3YXJkV2luID0gdmlldyA9PiB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIHRydWUsIHN0YXJ0ID0+IHRvR3JvdXBTdGFydCh2aWV3LCByYW5nZS5oZWFkLCBzdGFydCkpKTtcbn07XG5mdW5jdGlvbiBzZWxlY3RCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheExlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVVcCA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBzZWxlY3RMaW5lRG93biA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gc2VsZWN0QnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2VJbmZvKHZpZXcpLmhlaWdodCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSB1cC5cbiovXG5jb25zdCBzZWxlY3RQYWdlVXAgPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0UGFnZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBwcmV2aW91cyBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBib3VuZGFyeSB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZVN0YXJ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lRW5kID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IGN1cnNvckRvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiAwIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLmRvYy5sZW5ndGggfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiAwIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdERvY0VuZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgZW50aXJlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogMCwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9LCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRXhwYW5kIHRoZSBzZWxlY3Rpb24gdG8gY292ZXIgZW50aXJlIGxpbmVzLlxuKi9cbmNvbnN0IHNlbGVjdExpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCByYW5nZXMgPSBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgTWF0aC5taW4odG8gKyAxLCBzdGF0ZS5kb2MubGVuZ3RoKSkpO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSBuZXh0IHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGVcbnNlbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmsgaW5zb2ZhciBhcyB0aGUgbGFuZ3VhZ2Vcbltwcm92aWRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZSkgeW91IHVzZSBidWlsZHMgdXAgYSBmdWxsXG5zeW50YXggdHJlZS5cbiovXG5jb25zdCBzZWxlY3RQYXJlbnRTeW50YXggPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSksIHN0YWNrID0gdHJlZS5yZXNvbHZlU3RhY2socmFuZ2UuZnJvbSwgMSk7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHN0YWNrQmVmb3JlID0gdHJlZS5yZXNvbHZlU3RhY2socmFuZ2UuZnJvbSwgLTEpO1xuICAgICAgICAgICAgaWYgKHN0YWNrQmVmb3JlLm5vZGUuZnJvbSA+PSBzdGFjay5ub2RlLmZyb20gJiYgc3RhY2tCZWZvcmUubm9kZS50byA8PSBzdGFjay5ub2RlLnRvKVxuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2tCZWZvcmU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhY2s7IGN1cjsgY3VyID0gY3VyLm5leHQpIHtcbiAgICAgICAgICAgIGxldCB7IG5vZGUgfSA9IGN1cjtcbiAgICAgICAgICAgIGlmICgoKG5vZGUuZnJvbSA8IHJhbmdlLmZyb20gJiYgbm9kZS50byA+PSByYW5nZS50bykgfHxcbiAgICAgICAgICAgICAgICAobm9kZS50byA+IHJhbmdlLnRvICYmIG5vZGUuZnJvbSA8PSByYW5nZS5mcm9tKSkgJiZcbiAgICAgICAgICAgICAgICBjdXIubmV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKG5vZGUudG8sIG5vZGUuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gYWRkQ3Vyc29yVmVydGljYWxseSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zbGljZSgpO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmhlYWQpO1xuICAgICAgICBpZiAoZm9yd2FyZCA/IGxpbmUudG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiBsaW5lLmZyb20gPiAwKVxuICAgICAgICAgICAgZm9yIChsZXQgY3VyID0gcmFuZ2U7Oykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdmlldy5tb3ZlVmVydGljYWxseShjdXIsIGZvcndhcmQpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmhlYWQgPCBsaW5lLmZyb20gfHwgbmV4dC5oZWFkID4gbGluZS50bykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmdlcy5zb21lKHIgPT4gci5oZWFkID09IG5leHQuaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQuaGVhZCA9PSBjdXIuaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgcmFuZ2VzLmxlbmd0aCAtIDEpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIGJ5IGFkZGluZyBhIGN1cnNvciBhYm92ZSB0aGUgaGVhZHMgb2ZcbmN1cnJlbnRseSBzZWxlY3RlZCByYW5nZXMuXG4qL1xuY29uc3QgYWRkQ3Vyc29yQWJvdmUgPSB2aWV3ID0+IGFkZEN1cnNvclZlcnRpY2FsbHkodmlldywgZmFsc2UpO1xuLyoqXG5FeHBhbmQgdGhlIHNlbGVjdGlvbiBieSBhZGRpbmcgYSBjdXJzb3IgYmVsb3cgdGhlIGhlYWRzIG9mXG5jdXJyZW50bHkgc2VsZWN0ZWQgcmFuZ2VzLlxuKi9cbmNvbnN0IGFkZEN1cnNvckJlbG93ID0gdmlldyA9PiBhZGRDdXJzb3JWZXJ0aWNhbGx5KHZpZXcsIHRydWUpO1xuLyoqXG5TaW1wbGlmeSB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdoZW4gbXVsdGlwbGUgcmFuZ2VzIGFyZSBzZWxlY3RlZCxcbnJlZHVjZSBpdCB0byBpdHMgbWFpbiByYW5nZS4gT3RoZXJ3aXNlLCBpZiB0aGUgc2VsZWN0aW9uIGlzXG5ub24tZW1wdHksIGNvbnZlcnQgaXQgdG8gYSBjdXJzb3Igc2VsZWN0aW9uLlxuKi9cbmNvbnN0IHNpbXBsaWZ5U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgY3VyID0gc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3Rpb24gPSBudWxsO1xuICAgIGlmIChjdXIucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW2N1ci5tYWluXSk7XG4gICAgZWxzZSBpZiAoIWN1ci5tYWluLmVtcHR5KVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGN1ci5tYWluLmhlYWQpXSk7XG4gICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlbGV0ZUJ5KHRhcmdldCwgYnkpIHtcbiAgICBpZiAodGFyZ2V0LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGV2ZW50ID0gXCJkZWxldGUuc2VsZWN0aW9uXCIsIHsgc3RhdGUgfSA9IHRhcmdldDtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XG4gICAgICAgICAgICBsZXQgdG93YXJkcyA9IGJ5KHJhbmdlKTtcbiAgICAgICAgICAgIGlmICh0b3dhcmRzIDwgZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuYmFja3dhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvd2FyZHMgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5mb3J3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb20gPSBNYXRoLm1pbihmcm9tLCB0b3dhcmRzKTtcbiAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIHRvd2FyZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHNraXBBdG9taWModGFyZ2V0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgICAgICB0byA9IHNraXBBdG9taWModGFyZ2V0LCB0bywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdG8gPyB7IHJhbmdlIH0gOiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8gfSwgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSwgZnJvbSA8IHJhbmdlLmhlYWQgPyAtMSA6IDEpIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBldmVudCxcbiAgICAgICAgZWZmZWN0czogZXZlbnQgPT0gXCJkZWxldGUuc2VsZWN0aW9uXCIgPyBFZGl0b3JWaWV3LmFubm91bmNlLm9mKHN0YXRlLnBocmFzZShcIlNlbGVjdGlvbiBkZWxldGVkXCIpKSA6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNraXBBdG9taWModGFyZ2V0LCBwb3MsIGZvcndhcmQpIHtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRWRpdG9yVmlldylcbiAgICAgICAgZm9yIChsZXQgcmFuZ2VzIG9mIHRhcmdldC5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LmF0b21pY1JhbmdlcykubWFwKGYgPT4gZih0YXJnZXQpKSlcbiAgICAgICAgICAgIHJhbmdlcy5iZXR3ZWVuKHBvcywgcG9zLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHBvcyAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZm9yd2FyZCA/IHRvIDogZnJvbTtcbiAgICAgICAgICAgIH0pO1xuICAgIHJldHVybiBwb3M7XG59XG5jb25zdCBkZWxldGVCeUNoYXIgPSAodGFyZ2V0LCBmb3J3YXJkLCBieUluZGVudFVuaXQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgcmFuZ2UgPT4ge1xuICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJlZm9yZSwgdGFyZ2V0UG9zO1xuICAgIGlmIChieUluZGVudFVuaXQgJiYgIWZvcndhcmQgJiYgcG9zID4gbGluZS5mcm9tICYmIHBvcyA8IGxpbmUuZnJvbSArIDIwMCAmJlxuICAgICAgICAhL1teIFxcdF0vLnRlc3QoYmVmb3JlID0gbGluZS50ZXh0LnNsaWNlKDAsIHBvcyAtIGxpbmUuZnJvbSkpKSB7XG4gICAgICAgIGlmIChiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdID09IFwiXFx0XCIpXG4gICAgICAgICAgICByZXR1cm4gcG9zIC0gMTtcbiAgICAgICAgbGV0IGNvbCA9IGNvdW50Q29sdW1uKGJlZm9yZSwgc3RhdGUudGFiU2l6ZSksIGRyb3AgPSBjb2wgJSBnZXRJbmRlbnRVbml0KHN0YXRlKSB8fCBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcm9wICYmIGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMSAtIGldID09IFwiIFwiOyBpKyspXG4gICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgdGFyZ2V0UG9zID0gcG9zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0UG9zID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGlmICh0YXJnZXRQb3MgPT0gcG9zICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICB0YXJnZXRQb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgZWxzZSBpZiAoIWZvcndhcmQgJiYgL1tcXHVmZTAwLVxcdWZlMGZdLy50ZXN0KGxpbmUudGV4dC5zbGljZSh0YXJnZXRQb3MgLSBsaW5lLmZyb20sIHBvcyAtIGxpbmUuZnJvbSkpKVxuICAgICAgICAgICAgdGFyZ2V0UG9zID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHRhcmdldFBvcyAtIGxpbmUuZnJvbSwgZmFsc2UsIGZhbHNlKSArIGxpbmUuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFBvcztcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGZvciBjdXJzb3Igc2VsZWN0aW9ucywgdGhlIGNoYXJhY3RlciBvclxuaW5kZW50YXRpb24gdW5pdCBiZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCBmYWxzZSwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBjdXJzb3IuIERvZXMgbm90XG5pbXBsZW1lbnQgYW55IGV4dGVuZGVkIGJlaGF2aW9yIGxpa2UgZGVsZXRpbmcgd2hvbGUgaW5kZW50YXRpb25cbnVuaXRzIGluIG9uZSBnby5cbiovXG5jb25zdCBkZWxldGVDaGFyQmFja3dhcmRTdHJpY3QgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCBmYWxzZSwgZmFsc2UpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckZvcndhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCB0cnVlLCBmYWxzZSk7XG5jb25zdCBkZWxldGVCeUdyb3VwID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCByYW5nZSA9PiB7XG4gICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGZvciAobGV0IGNhdCA9IG51bGw7Oykge1xuICAgICAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gcmFuZ2UuaGVhZCAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IG5leHRDaGFyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHBvcywgbmV4dCkgLSBsaW5lLmZyb20sIE1hdGgubWF4KHBvcywgbmV4dCkgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dENoYXIpO1xuICAgICAgICBpZiAoY2F0ICE9IG51bGwgJiYgbmV4dENhdCAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRDaGFyICE9IFwiIFwiIHx8IHBvcyAhPSByYW5nZS5oZWFkKVxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBiYWNrd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0XG5bZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUdyb3VwKSwgb25seSBza2lwcGluZyBncm91cHMgb2ZcbndoaXRlc3BhY2Ugd2hlbiB0aGV5IGNvbnNpc3Qgb2YgYSBzaW5nbGUgc3BhY2UuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBCYWNrd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgZmFsc2UpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBmb3J3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHQgZ3JvdXAuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBGb3J3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCB0cnVlKTtcbi8qKlxuVmFyaWFudCBvZiBbYGRlbGV0ZUdyb3VwRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBGb3J3YXJkKVxudGhhdCB1c2VzIHRoZSBXaW5kb3dzIGNvbnZlbnRpb24gb2YgYWxzbyBkZWxldGluZyB0aGUgd2hpdGVzcGFjZVxuYWZ0ZXIgYSB3b3JkLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZFdpbiA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCB0cnVlLCBzdGFydCA9PiB0b0dyb3VwU3RhcnQodmlldywgcmFuZ2UuaGVhZCwgc3RhcnQpKS5oZWFkKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIGVuZCBvZiB0aGUgbGluZS4gSWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhdCB0aGUgZW5kIG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGRlbGV0ZVRvTGluZUVuZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lRW5kID0gdmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bztcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA8IGxpbmVFbmQgPyBsaW5lRW5kIDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCByYW5nZS5oZWFkICsgMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBiZWZvcmUgaXQuXG4qL1xuY29uc3QgZGVsZXRlVG9MaW5lU3RhcnQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tO1xuICAgIHJldHVybiByYW5nZS5oZWFkID4gbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5tYXgoMCwgcmFuZ2UuaGVhZCAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZSBvciB0aGUgbmV4dCBsaW5lIHdyYXAgYmVmb3JlIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZhbHNlKS5oZWFkO1xuICAgIHJldHVybiByYW5nZS5oZWFkID4gbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5tYXgoMCwgcmFuZ2UuaGVhZCAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUgb3IgdGhlIG5leHQgbGluZSB3cmFwIGFmdGVyIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSkuaGVhZDtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA8IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgcmFuZ2UuaGVhZCArIDEpO1xufSk7XG4vKipcbkRlbGV0ZSBhbGwgd2hpdGVzcGFjZSBkaXJlY3RseSBiZWZvcmUgYSBsaW5lIGVuZCBmcm9tIHRoZVxuZG9jdW1lbnQuXG4qL1xuY29uc3QgZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIHByZXYgPSBcIlwiLCBpdGVyID0gc3RhdGUuZG9jLml0ZXIoKTs7KSB7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlci5saW5lQnJlYWsgfHwgaXRlci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmcgPSBwcmV2LnNlYXJjaCgvXFxzKyQvKTtcbiAgICAgICAgICAgIGlmICh0cmFpbGluZyA+IC0xKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcyAtIChwcmV2Lmxlbmd0aCAtIHRyYWlsaW5nKSwgdG86IHBvcyB9KTtcbiAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwcmV2ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBpdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBpdGVyLnZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHVzZXJFdmVudDogXCJkZWxldGVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIGVhY2ggc2VsZWN0aW9uIHJhbmdlIHdpdGggYSBsaW5lIGJyZWFrLCBsZWF2aW5nIHRoZSBjdXJzb3Jcbm9uIHRoZSBsaW5lIGJlZm9yZSB0aGUgYnJlYWsuXG4qL1xuY29uc3Qgc3BsaXRMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIlwiLCBcIlwiXSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20pIH07XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkZsaXAgdGhlIGNoYXJhY3RlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3Vyc29yKHMpLlxuKi9cbmNvbnN0IHRyYW5zcG9zZUNoYXJzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8IHJhbmdlLmZyb20gPT0gMCB8fCByYW5nZS5mcm9tID09IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSBwb3MgPT0gbGluZS5mcm9tID8gcG9zIC0gMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZhbHNlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gcG9zID09IGxpbmUudG8gPyBwb3MgKyAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgdHJ1ZSkgKyBsaW5lLmZyb207XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKHBvcywgdG8pLmFwcGVuZChzdGF0ZS5kb2Muc2xpY2UoZnJvbSwgcG9zKSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcIm1vdmUuY2hhcmFjdGVyXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkge1xuICAgIGxldCBibG9ja3MgPSBbXSwgdXB0byA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSksIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKTtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiByYW5nZS50byA9PSBlbmRMaW5lLmZyb20pXG4gICAgICAgICAgICBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byAtIDEpO1xuICAgICAgICBpZiAodXB0byA+PSBzdGFydExpbmUubnVtYmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2LnRvID0gZW5kTGluZS50bztcbiAgICAgICAgICAgIHByZXYucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goeyBmcm9tOiBzdGFydExpbmUuZnJvbSwgdG86IGVuZExpbmUudG8sIHJhbmdlczogW3JhbmdlXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB1cHRvID0gZW5kTGluZS5udW1iZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tzO1xufVxuZnVuY3Rpb24gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZCA/IGJsb2NrLnRvID09IHN0YXRlLmRvYy5sZW5ndGggOiBibG9jay5mcm9tID09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IG5leHRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmb3J3YXJkID8gYmxvY2sudG8gKyAxIDogYmxvY2suZnJvbSAtIDEpO1xuICAgICAgICBsZXQgc2l6ZSA9IG5leHRMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgdG86IG5leHRMaW5lLnRvIH0sIHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBuZXh0TGluZS50ZXh0ICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuYW5jaG9yICsgc2l6ZSksIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuaGVhZCArIHNpemUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0TGluZS5mcm9tLCB0bzogYmxvY2suZnJvbSB9LCB7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIG5leHRMaW5lLnRleHQgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5hbmNob3IgLSBzaXplLCByLmhlYWQgLSBzaXplKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbkluZGV4KSxcbiAgICAgICAgdXNlckV2ZW50OiBcIm1vdmUubGluZVwiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyB1cCBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyBkb3duIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0LmNvcHlsaW5lXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSB0b3AgY29weS5cbiovXG5jb25zdCBjb3B5TGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSBib3R0b20gY29weS5cbiovXG5jb25zdCBjb3B5TGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlcyhzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICB9KSk7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGRpc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKSwgcG9zID0gdmlldy5jb29yZHNBdFBvcyhyYW5nZS5oZWFkLCByYW5nZS5hc3NvYyB8fCAxKTtcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgZGlzdCA9IChibG9jay5ib3R0b20gKyB2aWV3LmRvY3VtZW50VG9wKSAtIHBvcy5ib3R0b20gKyB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgdHJ1ZSwgZGlzdCk7XG4gICAgfSkubWFwKGNoYW5nZXMpO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBjaGFuZ2VzLCBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmxpbmVcIiB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZS5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihzdGF0ZS5saW5lQnJlYWspLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgYW5kIHRoZSBzYW1lIGFtb3VudCBvZlxuaW5kZW50YXRpb24gYXMgdGhlIGxpbmUgYWJvdmUuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUtlZXBJbmRlbnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IC9eXFxzKi8uZXhlYyhzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLnRleHQpWzBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgaW5kZW50IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgaW5kZW50Lmxlbmd0aCArIDEpXG4gICAgICAgIH07XG4gICAgfSksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgcG9zKSB7XG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcyB9O1xuICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyk7XG4gICAgbGV0IGJlZm9yZSA9IGNvbnRleHQuY2hpbGRCZWZvcmUocG9zKSwgYWZ0ZXIgPSBjb250ZXh0LmNoaWxkQWZ0ZXIocG9zKSwgY2xvc2VkQnk7XG4gICAgaWYgKGJlZm9yZSAmJiBhZnRlciAmJiBiZWZvcmUudG8gPD0gcG9zICYmIGFmdGVyLmZyb20gPj0gcG9zICYmXG4gICAgICAgIChjbG9zZWRCeSA9IGJlZm9yZS50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSAmJiBjbG9zZWRCeS5pbmRleE9mKGFmdGVyLm5hbWUpID4gLTEgJiZcbiAgICAgICAgc3RhdGUuZG9jLmxpbmVBdChiZWZvcmUudG8pLmZyb20gPT0gc3RhdGUuZG9jLmxpbmVBdChhZnRlci5mcm9tKS5mcm9tICYmXG4gICAgICAgICEvXFxTLy50ZXN0KHN0YXRlLnNsaWNlRG9jKGJlZm9yZS50bywgYWZ0ZXIuZnJvbSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBiZWZvcmUudG8sIHRvOiBhZnRlci5mcm9tIH07XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBhbmQgaW5kZW50IHRoZSBuZXdseSBjcmVhdGVkXG5saW5lKHMpLiBJZiB0aGUgY3VycmVudCBsaW5lIGNvbnNpc3RzIG9ubHkgb2Ygd2hpdGVzcGFjZSwgdGhpc1xud2lsbCBhbHNvIGRlbGV0ZSB0aGF0IHdoaXRlc3BhY2UuIFdoZW4gdGhlIGN1cnNvciBpcyBiZXR3ZWVuXG5tYXRjaGluZyBicmFja2V0cywgYW4gYWRkaXRpb25hbCBuZXdsaW5lIHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXJcbnRoZSBjdXJzb3IuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUFuZEluZGVudCA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgYmxhbmssIGluZGVudGVkIGxpbmUgYmVsb3cgdGhlIGN1cnJlbnQgbGluZS5cbiovXG5jb25zdCBpbnNlcnRCbGFua0xpbmUgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudCh0cnVlKTtcbmZ1bmN0aW9uIG5ld2xpbmVBbmRJbmRlbnQoYXRFb2YpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGxldCBleHBsb2RlID0gIWF0RW9mICYmIGZyb20gPT0gdG8gJiYgaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGF0RW9mKVxuICAgICAgICAgICAgICAgIGZyb20gPSB0byA9ICh0byA8PSBsaW5lLnRvID8gbGluZSA6IHN0YXRlLmRvYy5saW5lQXQodG8pKS50bztcbiAgICAgICAgICAgIGxldCBjeCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IHNpbXVsYXRlQnJlYWs6IGZyb20sIHNpbXVsYXRlRG91YmxlQnJlYWs6ICEhZXhwbG9kZSB9KTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gY291bnRDb2x1bW4oL15cXHMqLy5leGVjKHN0YXRlLmRvYy5saW5lQXQoZnJvbSkudGV4dClbMF0sIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgd2hpbGUgKHRvIDwgbGluZS50byAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0pKVxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gZXhwbG9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID4gbGluZS5mcm9tICYmIGZyb20gPCBsaW5lLmZyb20gKyAxMDAgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGZyb20pKSlcbiAgICAgICAgICAgICAgICBmcm9tID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IFtcIlwiLCBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCldO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goaW5kZW50U3RyaW5nKHN0YXRlLCBjeC5saW5lSW5kZW50KGxpbmUuZnJvbSwgLTEpKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IFRleHQub2YoaW5zZXJ0KSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyAxICsgaW5zZXJ0WzFdLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmZyb207IHBvcyA8PSByYW5nZS50bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gYXRMaW5lICYmIChyYW5nZS5lbXB0eSB8fCByYW5nZS50byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBmKGxpbmUsIGNoYW5nZXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICBhdExpbmUgPSBsaW5lLm51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0gfHwgcmFuZ2UuZnJvbSA8IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXG5saW5lcy5cbiovXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBzdGF0ZS5mYWNldChpbmRlbnRVbml0KSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcbnNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGlmICghc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihzcGFjZSwgc3RhdGUudGFiU2l6ZSksIGtlZXAgPSAwO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gaW5kZW50U3RyaW5nKHN0YXRlLCBNYXRoLm1heCgwLCBjb2wgLSBnZXRJbmRlbnRVbml0KHN0YXRlKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkVuYWJsZXMgb3IgZGlzYWJsZXNcblt0YWItZm9jdXMgbW9kZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2V0VGFiRm9jdXNNb2RlKS4gV2hpbGUgb24sIHRoaXNcbnByZXZlbnRzIHRoZSBlZGl0b3IncyBrZXkgYmluZGluZ3MgZnJvbSBjYXB0dXJpbmcgVGFiIG9yXG5TaGlmdC1UYWIsIG1ha2luZyBpdCBwb3NzaWJsZSBmb3IgdGhlIHVzZXIgdG8gbW92ZSBmb2N1cyBvdXQgb2ZcbnRoZSBlZGl0b3Igd2l0aCB0aGUga2V5Ym9hcmQuXG4qL1xuY29uc3QgdG9nZ2xlVGFiRm9jdXNNb2RlID0gdmlldyA9PiB7XG4gICAgdmlldy5zZXRUYWJGb2N1c01vZGUoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblRlbXBvcmFyaWx5IGVuYWJsZXMgW3RhYi1mb2N1c1xubW9kZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2V0VGFiRm9jdXNNb2RlKSBmb3IgdHdvIHNlY29uZHMgb3IgdW50aWxcbmFub3RoZXIga2V5IGlzIHByZXNzZWQuXG4qL1xuY29uc3QgdGVtcG9yYXJpbHlTZXRUYWJGb2N1c01vZGUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LnNldFRhYkZvY3VzTW9kZSgyMDAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkluc2VydCBhIHRhYiBjaGFyYWN0ZXIgYXQgdGhlIGN1cnNvciBvciwgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLFxudXNlIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgdG8gaW5kZW50IHRoZSBlbnRpcmVcbnNlbGVjdGlvbi5cbiovXG5jb25zdCBpbnNlcnRUYWIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXG4gICAgICAgIHJldHVybiBpbmRlbnRNb3JlKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLW86IFtgc3BsaXRMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdExpbmUpXG4gLSBDdHJsLXQ6IFtgdHJhbnNwb3NlQ2hhcnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRyYW5zcG9zZUNoYXJzKVxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcbiAtIEFsdC12OiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKVxuKi9cbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1iXCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJDdHJsLWZcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcbiAgICB7IGtleTogXCJDdHJsLW5cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1hXCIsIHJ1bjogY3Vyc29yTGluZVN0YXJ0LCBzaGlmdDogc2VsZWN0TGluZVN0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWRcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtaFwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuXTtcbi8qKlxuQW4gYXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNsb3NlbHkgc3RpY2tpbmcgdG8gcGxhdGZvcm0tc3RhbmRhcmQgb3JcbndpZGVseSB1c2VkIGJpbmRpbmdzLiAoVGhpcyBpbmNsdWRlcyB0aGUgYmluZGluZ3MgZnJvbVxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxucHJvcGVydHkgY2hhbmdlZCB0byBgbWFjYC4pXG5cbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEFycm93UmlnaHQ6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0xlZnQgKEFsdC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSAoW2BzZWxlY3RHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dMZWZ0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93UmlnaHQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBBcnJvd0Rvd246IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZURvd246IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBIb21lOiBbYGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUhvbWUgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtRW5kIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gRW50ZXIgYW5kIFNoaWZ0LUVudGVyOiBbYGluc2VydE5ld2xpbmVBbmRJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydE5ld2xpbmVBbmRJbmRlbnQpXG4gLSBDdHJsLWEgKENtZC1hIG9uIG1hY09TKTogW2BzZWxlY3RBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEFsbClcbiAtIEJhY2tzcGFjZTogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcbiAtIERlbGV0ZTogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLUJhY2tzcGFjZSAoQWx0LUJhY2tzcGFjZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtRGVsZXRlIChBbHQtRGVsZXRlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcbiAtIENtZC1CYWNrc3BhY2UgKG1hY09TKTogW2BkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQpLlxuIC0gQ21kLURlbGV0ZSAobWFjT1MpOiBbYGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQpLlxuKi9cbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd0xlZnRcIiwgbWFjOiBcIkFsdC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JHcm91cExlZnQsIHNoaWZ0OiBzZWxlY3RHcm91cExlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93UmlnaHRcIiwgbWFjOiBcIkFsdC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yR3JvdXBSaWdodCwgc2hpZnQ6IHNlbGVjdEdyb3VwUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93VXBcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiSG9tZVwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUhvbWVcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBrZXk6IFwiRW5kXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVuZFwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgc2hpZnQ6IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgfSxcbiAgICB7IGtleTogXCJNb2QtYVwiLCBydW46IHNlbGVjdEFsbCB9LFxuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCwgc2hpZnQ6IGRlbGV0ZUNoYXJCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQmFja3NwYWNlXCIsIG1hYzogXCJBbHQtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtRGVsZXRlXCIsIG1hYzogXCJBbHQtRGVsZXRlXCIsIHJ1bjogZGVsZXRlR3JvdXBGb3J3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIk1vZC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJNb2QtRGVsZXRlXCIsIHJ1bjogZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfVxuXS5jb25jYXQoLypAX19QVVJFX18qL2VtYWNzU3R5bGVLZXltYXAubWFwKGIgPT4gKHsgbWFjOiBiLmtleSwgcnVuOiBiLnJ1biwgc2hpZnQ6IGIuc2hpZnQgfSkpKTtcbi8qKlxuVGhlIGRlZmF1bHQga2V5bWFwLiBJbmNsdWRlcyBhbGwgYmluZGluZ3MgZnJvbVxuW2BzdGFuZGFyZEtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3RhbmRhcmRLZXltYXApIHBsdXMgdGhlIGZvbGxvd2luZzpcblxuLSBBbHQtQXJyb3dMZWZ0IChDdHJsLUFycm93TGVmdCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yU3ludGF4TGVmdCkgKFtgc2VsZWN0U3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4TGVmdCkgd2l0aCBTaGlmdClcbi0gQWx0LUFycm93UmlnaHQgKEN0cmwtQXJyb3dSaWdodCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheFJpZ2h0KSAoW2BzZWxlY3RTeW50YXhSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4UmlnaHQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1VwOiBbYG1vdmVMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lVXApXG4tIEFsdC1BcnJvd0Rvd246IFtgbW92ZUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZURvd24pXG4tIFNoaWZ0LUFsdC1BcnJvd1VwOiBbYGNvcHlMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmNvcHlMaW5lVXApXG4tIFNoaWZ0LUFsdC1BcnJvd0Rvd246IFtgY29weUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZURvd24pXG4tIEN0cmwtQWx0LUFycm93VXAgKENtZC1BbHQtQXJyb3dVcCBvbiBtYWNPUyk6IFtgYWRkQ3Vyc29yQWJvdmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmFkZEN1cnNvckFib3ZlKS5cbi0gQ3RybC1BbHQtQXJyb3dEb3duIChDbWQtQWx0LUFycm93RG93biBvbiBtYWNPUyk6IFtgYWRkQ3Vyc29yQmVsb3dgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmFkZEN1cnNvckJlbG93KS5cbi0gRXNjYXBlOiBbYHNpbXBsaWZ5U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zaW1wbGlmeVNlbGVjdGlvbilcbi0gQ3RybC1FbnRlciAoQ21kLUVudGVyIG9uIG1hY09TKTogW2BpbnNlcnRCbGFua0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydEJsYW5rTGluZSlcbi0gQWx0LWwgKEN0cmwtbCBvbiBtYWNPUyk6IFtgc2VsZWN0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZSlcbi0gQ3RybC1pIChDbWQtaSBvbiBtYWNPUyk6IFtgc2VsZWN0UGFyZW50U3ludGF4YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYXJlbnRTeW50YXgpXG4tIEN0cmwtWyAoQ21kLVsgb24gbWFjT1MpOiBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpXG4tIEN0cmwtXSAoQ21kLV0gb24gbWFjT1MpOiBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpXG4tIEN0cmwtQWx0LVxcXFwgKENtZC1BbHQtXFxcXCBvbiBtYWNPUyk6IFtgaW5kZW50U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRTZWxlY3Rpb24pXG4tIFNoaWZ0LUN0cmwtayAoU2hpZnQtQ21kLWsgb24gbWFjT1MpOiBbYGRlbGV0ZUxpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmUpXG4tIFNoaWZ0LUN0cmwtXFxcXCAoU2hpZnQtQ21kLVxcXFwgb24gbWFjT1MpOiBbYGN1cnNvck1hdGNoaW5nQnJhY2tldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTWF0Y2hpbmdCcmFja2V0KVxuLSBDdHJsLS8gKENtZC0vIG9uIG1hY09TKTogW2B0b2dnbGVDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVDb21tZW50KS5cbi0gU2hpZnQtQWx0LWE6IFtgdG9nZ2xlQmxvY2tDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVCbG9ja0NvbW1lbnQpLlxuLSBDdHJsLW0gKEFsdC1TaGlmdC1tIG9uIG1hY09TKTogW2B0b2dnbGVUYWJGb2N1c01vZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZVRhYkZvY3VzTW9kZSkuXG4qL1xuY29uc3QgZGVmYXVsdEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQWx0LUFycm93TGVmdFwiLCBtYWM6IFwiQ3RybC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JTeW50YXhMZWZ0LCBzaGlmdDogc2VsZWN0U3ludGF4TGVmdCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJDdHJsLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JTeW50YXhSaWdodCwgc2hpZnQ6IHNlbGVjdFN5bnRheFJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93VXBcIiwgcnVuOiBtb3ZlTGluZVVwIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93VXBcIiwgcnVuOiBjb3B5TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93RG93blwiLCBydW46IG1vdmVMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd0Rvd25cIiwgcnVuOiBjb3B5TGluZURvd24gfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LUFycm93VXBcIiwgcnVuOiBhZGRDdXJzb3JBYm92ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogYWRkQ3Vyc29yQmVsb3cgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBzaW1wbGlmeVNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIk1vZC1FbnRlclwiLCBydW46IGluc2VydEJsYW5rTGluZSB9LFxuICAgIHsga2V5OiBcIkFsdC1sXCIsIG1hYzogXCJDdHJsLWxcIiwgcnVuOiBzZWxlY3RMaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWlcIiwgcnVuOiBzZWxlY3RQYXJlbnRTeW50YXgsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLVtcIiwgcnVuOiBpbmRlbnRMZXNzIH0sXG4gICAgeyBrZXk6IFwiTW9kLV1cIiwgcnVuOiBpbmRlbnRNb3JlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1cXFxcXCIsIHJ1bjogaW5kZW50U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLWtcIiwgcnVuOiBkZWxldGVMaW5lIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLVxcXFxcIiwgcnVuOiBjdXJzb3JNYXRjaGluZ0JyYWNrZXQgfSxcbiAgICB7IGtleTogXCJNb2QtL1wiLCBydW46IHRvZ2dsZUNvbW1lbnQgfSxcbiAgICB7IGtleTogXCJBbHQtQVwiLCBydW46IHRvZ2dsZUJsb2NrQ29tbWVudCB9LFxuICAgIHsga2V5OiBcIkN0cmwtbVwiLCBtYWM6IFwiU2hpZnQtQWx0LW1cIiwgcnVuOiB0b2dnbGVUYWJGb2N1c01vZGUgfSxcbl0uY29uY2F0KHN0YW5kYXJkS2V5bWFwKTtcbi8qKlxuQSBiaW5kaW5nIHRoYXQgYmluZHMgVGFiIHRvIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgYW5kXG5TaGlmdC1UYWIgdG8gW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKS5cblBsZWFzZSBzZWUgdGhlIFtUYWIgZXhhbXBsZV0oLi4vLi4vZXhhbXBsZXMvdGFiLykgYmVmb3JlIHVzaW5nXG50aGlzLlxuKi9cbmNvbnN0IGluZGVudFdpdGhUYWIgPSB7IGtleTogXCJUYWJcIiwgcnVuOiBpbmRlbnRNb3JlLCBzaGlmdDogaW5kZW50TGVzcyB9O1xuXG5leHBvcnQgeyBhZGRDdXJzb3JBYm92ZSwgYWRkQ3Vyc29yQmVsb3csIGJsb2NrQ29tbWVudCwgYmxvY2tVbmNvbW1lbnQsIGNvcHlMaW5lRG93biwgY29weUxpbmVVcCwgY3Vyc29yQ2hhckJhY2t3YXJkLCBjdXJzb3JDaGFyQmFja3dhcmRMb2dpY2FsLCBjdXJzb3JDaGFyRm9yd2FyZCwgY3Vyc29yQ2hhckZvcndhcmRMb2dpY2FsLCBjdXJzb3JDaGFyTGVmdCwgY3Vyc29yQ2hhclJpZ2h0LCBjdXJzb3JEb2NFbmQsIGN1cnNvckRvY1N0YXJ0LCBjdXJzb3JHcm91cEJhY2t3YXJkLCBjdXJzb3JHcm91cEZvcndhcmQsIGN1cnNvckdyb3VwRm9yd2FyZFdpbiwgY3Vyc29yR3JvdXBMZWZ0LCBjdXJzb3JHcm91cFJpZ2h0LCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIGN1cnNvckxpbmVEb3duLCBjdXJzb3JMaW5lRW5kLCBjdXJzb3JMaW5lU3RhcnQsIGN1cnNvckxpbmVVcCwgY3Vyc29yTWF0Y2hpbmdCcmFja2V0LCBjdXJzb3JQYWdlRG93biwgY3Vyc29yUGFnZVVwLCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQsIGN1cnNvclN1YndvcmRGb3J3YXJkLCBjdXJzb3JTeW50YXhMZWZ0LCBjdXJzb3JTeW50YXhSaWdodCwgZGVmYXVsdEtleW1hcCwgZGVsZXRlQ2hhckJhY2t3YXJkLCBkZWxldGVDaGFyQmFja3dhcmRTdHJpY3QsIGRlbGV0ZUNoYXJGb3J3YXJkLCBkZWxldGVHcm91cEJhY2t3YXJkLCBkZWxldGVHcm91cEZvcndhcmQsIGRlbGV0ZUdyb3VwRm9yd2FyZFdpbiwgZGVsZXRlTGluZSwgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQsIGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQsIGRlbGV0ZVRvTGluZUVuZCwgZGVsZXRlVG9MaW5lU3RhcnQsIGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSwgZW1hY3NTdHlsZUtleW1hcCwgaGlzdG9yeSwgaGlzdG9yeUZpZWxkLCBoaXN0b3J5S2V5bWFwLCBpbmRlbnRMZXNzLCBpbmRlbnRNb3JlLCBpbmRlbnRTZWxlY3Rpb24sIGluZGVudFdpdGhUYWIsIGluc2VydEJsYW5rTGluZSwgaW5zZXJ0TmV3bGluZSwgaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgaW5zZXJ0TmV3bGluZUtlZXBJbmRlbnQsIGluc2VydFRhYiwgaW52ZXJ0ZWRFZmZlY3RzLCBpc29sYXRlSGlzdG9yeSwgbGluZUNvbW1lbnQsIGxpbmVVbmNvbW1lbnQsIG1vdmVMaW5lRG93biwgbW92ZUxpbmVVcCwgcmVkbywgcmVkb0RlcHRoLCByZWRvU2VsZWN0aW9uLCBzZWxlY3RBbGwsIHNlbGVjdENoYXJCYWNrd2FyZCwgc2VsZWN0Q2hhckJhY2t3YXJkTG9naWNhbCwgc2VsZWN0Q2hhckZvcndhcmQsIHNlbGVjdENoYXJGb3J3YXJkTG9naWNhbCwgc2VsZWN0Q2hhckxlZnQsIHNlbGVjdENoYXJSaWdodCwgc2VsZWN0RG9jRW5kLCBzZWxlY3REb2NTdGFydCwgc2VsZWN0R3JvdXBCYWNrd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkLCBzZWxlY3RHcm91cEZvcndhcmRXaW4sIHNlbGVjdEdyb3VwTGVmdCwgc2VsZWN0R3JvdXBSaWdodCwgc2VsZWN0TGluZSwgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHNlbGVjdExpbmVCb3VuZGFyeUxlZnQsIHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBzZWxlY3RMaW5lRG93biwgc2VsZWN0TGluZUVuZCwgc2VsZWN0TGluZVN0YXJ0LCBzZWxlY3RMaW5lVXAsIHNlbGVjdE1hdGNoaW5nQnJhY2tldCwgc2VsZWN0UGFnZURvd24sIHNlbGVjdFBhZ2VVcCwgc2VsZWN0UGFyZW50U3ludGF4LCBzZWxlY3RTdWJ3b3JkQmFja3dhcmQsIHNlbGVjdFN1YndvcmRGb3J3YXJkLCBzZWxlY3RTeW50YXhMZWZ0LCBzZWxlY3RTeW50YXhSaWdodCwgc2ltcGxpZnlTZWxlY3Rpb24sIHNwbGl0TGluZSwgc3RhbmRhcmRLZXltYXAsIHRlbXBvcmFyaWx5U2V0VGFiRm9jdXNNb2RlLCB0b2dnbGVCbG9ja0NvbW1lbnQsIHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSwgdG9nZ2xlQ29tbWVudCwgdG9nZ2xlTGluZUNvbW1lbnQsIHRvZ2dsZVRhYkZvY3VzTW9kZSwgdHJhbnNwb3NlQ2hhcnMsIHVuZG8sIHVuZG9EZXB0aCwgdW5kb1NlbGVjdGlvbiB9O1xuIl0sIm5hbWVzIjpbIkFubm90YXRpb24iLCJGYWNldCIsImNvbWJpbmVDb25maWciLCJTdGF0ZUZpZWxkIiwiVHJhbnNhY3Rpb24iLCJDaGFuZ2VTZXQiLCJDaGFuZ2VEZXNjIiwiRWRpdG9yU2VsZWN0aW9uIiwiU3RhdGVFZmZlY3QiLCJUZXh0IiwiZmluZENsdXN0ZXJCcmVhayIsImNvdW50Q29sdW1uIiwiQ2hhckNhdGVnb3J5IiwiRWRpdG9yVmlldyIsIkRpcmVjdGlvbiIsIkluZGVudENvbnRleHQiLCJnZXRJbmRlbnRhdGlvbiIsImluZGVudFN0cmluZyIsIm1hdGNoQnJhY2tldHMiLCJzeW50YXhUcmVlIiwiZ2V0SW5kZW50VW5pdCIsImluZGVudFVuaXQiLCJOb2RlUHJvcCIsInRvZ2dsZUNvbW1lbnQiLCJ0YXJnZXQiLCJzdGF0ZSIsImxpbmUiLCJkb2MiLCJsaW5lQXQiLCJzZWxlY3Rpb24iLCJtYWluIiwiZnJvbSIsImNvbmZpZyIsImdldENvbmZpZyIsInRvZ2dsZUxpbmVDb21tZW50IiwiYmxvY2siLCJ0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUiLCJjb21tYW5kIiwiZiIsIm9wdGlvbiIsImRpc3BhdGNoIiwicmVhZE9ubHkiLCJ0ciIsInVwZGF0ZSIsImNoYW5nZUxpbmVDb21tZW50IiwibGluZUNvbW1lbnQiLCJsaW5lVW5jb21tZW50IiwidG9nZ2xlQmxvY2tDb21tZW50IiwiY2hhbmdlQmxvY2tDb21tZW50IiwiYmxvY2tDb21tZW50IiwiYmxvY2tVbmNvbW1lbnQiLCJvIiwicyIsInNlbGVjdGVkTGluZVJhbmdlcyIsInBvcyIsImRhdGEiLCJsYW5ndWFnZURhdGFBdCIsImxlbmd0aCIsIlNlYXJjaE1hcmdpbiIsImZpbmRCbG9ja0NvbW1lbnQiLCJvcGVuIiwiY2xvc2UiLCJ0byIsInRleHRCZWZvcmUiLCJzbGljZURvYyIsInRleHRBZnRlciIsInNwYWNlQmVmb3JlIiwiZXhlYyIsInNwYWNlQWZ0ZXIiLCJiZWZvcmVPZmYiLCJzbGljZSIsIm1hcmdpbiIsInN0YXJ0VGV4dCIsImVuZFRleHQiLCJzdGFydFNwYWNlIiwiZW5kU3BhY2UiLCJlbmRPZmYiLCJ0ZXN0IiwiY2hhckF0IiwicmFuZ2VzIiwiciIsImZyb21MaW5lIiwidG9MaW5lIiwibGFzdCIsInB1c2giLCJ0ZXh0IiwidG9rZW5zIiwibWFwIiwiZXZlcnkiLCJjIiwiY29tbWVudHMiLCJpIiwiY2hhbmdlcyIsInJhbmdlIiwiaW5zZXJ0Iiwic29tZSIsImNvbW1lbnQiLCJ0b2tlbiIsImxpbmVzIiwicHJldkxpbmUiLCJzdGFydEkiLCJtaW5JbmRlbnQiLCJpbmRlbnQiLCJlbXB0eSIsInNpbmdsZSIsImwiLCJjaGFuZ2VTZXQiLCJmcm9tSGlzdG9yeSIsImRlZmluZSIsImlzb2xhdGVIaXN0b3J5IiwiaW52ZXJ0ZWRFZmZlY3RzIiwiaGlzdG9yeUNvbmZpZyIsImNvbWJpbmUiLCJjb25maWdzIiwibWluRGVwdGgiLCJuZXdHcm91cERlbGF5Iiwiam9pblRvRXZlbnQiLCJfdCIsImlzQWRqYWNlbnQiLCJNYXRoIiwibWF4IiwibWluIiwiYSIsImIiLCJhZGoiLCJoaXN0b3J5RmllbGRfIiwiY3JlYXRlIiwiSGlzdG9yeVN0YXRlIiwiZmFjZXQiLCJmcm9tSGlzdCIsImFubm90YXRpb24iLCJpdGVtIiwiSGlzdEV2ZW50IiwiZnJvbVRyYW5zYWN0aW9uIiwic2lkZSIsIm90aGVyIiwidW5kb25lIiwiZG9uZSIsInVwZGF0ZUJyYW5jaCIsImFkZFNlbGVjdGlvbiIsInN0YXJ0U3RhdGUiLCJyZXN0IiwiaXNvbGF0ZSIsImFkZFRvSGlzdG9yeSIsImFkZE1hcHBpbmciLCJkZXNjIiwiZXZlbnQiLCJ0aW1lIiwidXNlckV2ZW50IiwiYWRkQ2hhbmdlcyIsInRvSlNPTiIsInZhbHVlIiwiZSIsImZyb21KU09OIiwianNvbiIsImhpc3RvcnkiLCJvZiIsImRvbUV2ZW50SGFuZGxlcnMiLCJiZWZvcmVpbnB1dCIsInZpZXciLCJpbnB1dFR5cGUiLCJ1bmRvIiwicmVkbyIsInByZXZlbnREZWZhdWx0IiwiaGlzdG9yeUZpZWxkIiwiY21kIiwiaGlzdG9yeVN0YXRlIiwiZmllbGQiLCJwb3AiLCJ1bmRvU2VsZWN0aW9uIiwicmVkb1NlbGVjdGlvbiIsImRlcHRoIiwiaGlzdFN0YXRlIiwiYnJhbmNoIiwidW5kb0RlcHRoIiwicmVkb0RlcHRoIiwiY29uc3RydWN0b3IiLCJlZmZlY3RzIiwibWFwcGVkIiwic3RhcnRTZWxlY3Rpb24iLCJzZWxlY3Rpb25zQWZ0ZXIiLCJzZXRTZWxBZnRlciIsImFmdGVyIiwiX2EiLCJfYiIsIl9jIiwibm9uZSIsImludmVydCIsInJlc3VsdCIsImNvbmNhdCIsInVuZGVmaW5lZCIsInNlbGVjdGlvbnMiLCJtYXhMZW4iLCJuZXdFdmVudCIsInN0YXJ0IiwibmV3QnJhbmNoIiwiaXRlckNoYW5nZWRSYW5nZXMiLCJ0IiwiX2YiLCJlcVNlbGVjdGlvblNoYXBlIiwiZmlsdGVyIiwiY29uYyIsIk1heFNlbGVjdGlvbnNQZXJFdmVudCIsImxhc3RFdmVudCIsInNlbHMiLCJlcSIsInBvcFNlbGVjdGlvbiIsImFkZE1hcHBpbmdUb0JyYW5jaCIsIm1hcHBpbmciLCJtYXBFdmVudCIsImV4dHJhU2VsZWN0aW9ucyIsIm1hcHBlZENoYW5nZXMiLCJiZWZvcmUiLCJtYXBEZXNjIiwiZnVsbE1hcHBpbmciLCJjb21wb3NlRGVzYyIsIm1hcEVmZmVjdHMiLCJqb2luYWJsZVVzZXJFdmVudCIsInByZXZUaW1lIiwicHJldlVzZXJFdmVudCIsImNvbXBvc2UiLCJvbmx5U2VsZWN0aW9uIiwiYW5ub3RhdGlvbnMiLCJzY3JvbGxJbnRvVmlldyIsImhpc3RvcnlLZXltYXAiLCJrZXkiLCJydW4iLCJtYWMiLCJsaW51eCIsInVwZGF0ZVNlbCIsInNlbCIsImJ5IiwibWFpbkluZGV4Iiwic2V0U2VsIiwibW92ZVNlbCIsImhvdyIsInJhbmdlRW5kIiwiZm9yd2FyZCIsImN1cnNvciIsImN1cnNvckJ5Q2hhciIsIm1vdmVCeUNoYXIiLCJsdHJBdEN1cnNvciIsInRleHREaXJlY3Rpb25BdCIsImhlYWQiLCJMVFIiLCJjdXJzb3JDaGFyTGVmdCIsImN1cnNvckNoYXJSaWdodCIsImN1cnNvckNoYXJGb3J3YXJkIiwiY3Vyc29yQ2hhckJhY2t3YXJkIiwiYnlDaGFyTG9naWNhbCIsIm1vdmVCeUNoYXJMb2dpY2FsIiwiY3Vyc29yQ2hhckZvcndhcmRMb2dpY2FsIiwiY3Vyc29yQ2hhckJhY2t3YXJkTG9naWNhbCIsImN1cnNvckJ5R3JvdXAiLCJtb3ZlQnlHcm91cCIsImN1cnNvckdyb3VwTGVmdCIsImN1cnNvckdyb3VwUmlnaHQiLCJjdXJzb3JHcm91cEZvcndhcmQiLCJjdXJzb3JHcm91cEJhY2t3YXJkIiwidG9Hcm91cFN0YXJ0IiwiY2F0ZWdvcml6ZSIsImNoYXJDYXRlZ29yaXplciIsImNhdCIsImluaXRpYWwiLCJTcGFjZSIsIm5leHQiLCJuZXh0Q2F0IiwiY3Vyc29yR3JvdXBGb3J3YXJkV2luIiwic2VnbWVudGVyIiwiSW50bCIsIlNlZ21lbnRlciIsImdyYW51bGFyaXR5IiwibW92ZUJ5U3Vid29yZCIsInN0ZXBzIiwic2F3VXBwZXIiLCJzYXdMb3dlciIsInN0ZXAiLCJhaGVhZCIsIldvcmQiLCJjaGFyQ29kZUF0IiwidG9Mb3dlckNhc2UiLCJlbmQiLCJza2lwcGVkIiwic2VnbWVudHMiLCJBcnJheSIsInNlZ21lbnQiLCJpbmRleCIsImN1cnNvckJ5U3Vid29yZCIsImN1cnNvclN1YndvcmRGb3J3YXJkIiwiY3Vyc29yU3Vid29yZEJhY2t3YXJkIiwiaW50ZXJlc3RpbmdOb2RlIiwibm9kZSIsImJyYWNrZXRQcm9wIiwidHlwZSIsInByb3AiLCJsZW4iLCJmaXJzdENoaWxkIiwibW92ZUJ5U3ludGF4IiwicmVzb2x2ZUlubmVyIiwiY2xvc2VkQnkiLCJvcGVuZWRCeSIsImF0IiwiY2hpbGRBZnRlciIsImNoaWxkQmVmb3JlIiwiYnJhY2tldCIsIm1hdGNoIiwibmV3UG9zIiwibWF0Y2hlZCIsImN1cnNvclN5bnRheExlZnQiLCJjdXJzb3JTeW50YXhSaWdodCIsImN1cnNvckJ5TGluZSIsIm1vdmVkIiwibW92ZVZlcnRpY2FsbHkiLCJtb3ZlVG9MaW5lQm91bmRhcnkiLCJjdXJzb3JMaW5lVXAiLCJjdXJzb3JMaW5lRG93biIsInBhZ2VJbmZvIiwic2VsZlNjcm9sbCIsInNjcm9sbERPTSIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsImhlaWdodCIsInNvdXJjZSIsInNjcm9sbE1hcmdpbnMiLCJtYXJnaW5zIiwidG9wIiwiYm90dG9tIiwiZG9tIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiaW5uZXJIZWlnaHQiLCJkZWZhdWx0TGluZUhlaWdodCIsImN1cnNvckJ5UGFnZSIsInBhZ2UiLCJlZmZlY3QiLCJzdGFydFBvcyIsImNvb3Jkc0F0UG9zIiwic2Nyb2xsUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbFRvcCIsInNjcm9sbEJvdHRvbSIsInkiLCJ5TWFyZ2luIiwiY3Vyc29yUGFnZVVwIiwiY3Vyc29yUGFnZURvd24iLCJtb3ZlQnlMaW5lQm91bmRhcnkiLCJsaW5lQmxvY2tBdCIsInNwYWNlIiwiY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCIsImN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkIiwiY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCIsImN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0IiwiY3Vyc29yTGluZVN0YXJ0IiwiY3Vyc29yTGluZUVuZCIsInRvTWF0Y2hpbmdCcmFja2V0IiwiZXh0ZW5kIiwiZm91bmQiLCJtYXRjaGluZyIsImFuY2hvciIsImN1cnNvck1hdGNoaW5nQnJhY2tldCIsInNlbGVjdE1hdGNoaW5nQnJhY2tldCIsImV4dGVuZFNlbCIsImdvYWxDb2x1bW4iLCJiaWRpTGV2ZWwiLCJzZWxlY3RCeUNoYXIiLCJzZWxlY3RDaGFyTGVmdCIsInNlbGVjdENoYXJSaWdodCIsInNlbGVjdENoYXJGb3J3YXJkIiwic2VsZWN0Q2hhckJhY2t3YXJkIiwic2VsZWN0Q2hhckZvcndhcmRMb2dpY2FsIiwic2VsZWN0Q2hhckJhY2t3YXJkTG9naWNhbCIsInNlbGVjdEJ5R3JvdXAiLCJzZWxlY3RHcm91cExlZnQiLCJzZWxlY3RHcm91cFJpZ2h0Iiwic2VsZWN0R3JvdXBGb3J3YXJkIiwic2VsZWN0R3JvdXBCYWNrd2FyZCIsInNlbGVjdEdyb3VwRm9yd2FyZFdpbiIsInNlbGVjdEJ5U3Vid29yZCIsInNlbGVjdFN1YndvcmRGb3J3YXJkIiwic2VsZWN0U3Vid29yZEJhY2t3YXJkIiwic2VsZWN0U3ludGF4TGVmdCIsInNlbGVjdFN5bnRheFJpZ2h0Iiwic2VsZWN0QnlMaW5lIiwic2VsZWN0TGluZVVwIiwic2VsZWN0TGluZURvd24iLCJzZWxlY3RCeVBhZ2UiLCJzZWxlY3RQYWdlVXAiLCJzZWxlY3RQYWdlRG93biIsInNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQiLCJzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCIsInNlbGVjdExpbmVCb3VuZGFyeUxlZnQiLCJzZWxlY3RMaW5lQm91bmRhcnlSaWdodCIsInNlbGVjdExpbmVTdGFydCIsInNlbGVjdExpbmVFbmQiLCJjdXJzb3JEb2NTdGFydCIsImN1cnNvckRvY0VuZCIsInNlbGVjdERvY1N0YXJ0Iiwic2VsZWN0RG9jRW5kIiwic2VsZWN0QWxsIiwic2VsZWN0TGluZSIsInNlbGVjdGVkTGluZUJsb2NrcyIsInNlbGVjdFBhcmVudFN5bnRheCIsInRyZWUiLCJzdGFjayIsInJlc29sdmVTdGFjayIsInN0YWNrQmVmb3JlIiwiY3VyIiwiYWRkQ3Vyc29yVmVydGljYWxseSIsImFkZEN1cnNvckFib3ZlIiwiYWRkQ3Vyc29yQmVsb3ciLCJzaW1wbGlmeVNlbGVjdGlvbiIsImRlbGV0ZUJ5IiwiY2hhbmdlQnlSYW5nZSIsInRvd2FyZHMiLCJza2lwQXRvbWljIiwiYW5ub3VuY2UiLCJwaHJhc2UiLCJhdG9taWNSYW5nZXMiLCJiZXR3ZWVuIiwiZGVsZXRlQnlDaGFyIiwiYnlJbmRlbnRVbml0IiwidGFyZ2V0UG9zIiwiY29sIiwidGFiU2l6ZSIsImRyb3AiLCJudW1iZXIiLCJkZWxldGVDaGFyQmFja3dhcmQiLCJkZWxldGVDaGFyQmFja3dhcmRTdHJpY3QiLCJkZWxldGVDaGFyRm9yd2FyZCIsImRlbGV0ZUJ5R3JvdXAiLCJuZXh0Q2hhciIsImRlbGV0ZUdyb3VwQmFja3dhcmQiLCJkZWxldGVHcm91cEZvcndhcmQiLCJkZWxldGVHcm91cEZvcndhcmRXaW4iLCJkZWxldGVUb0xpbmVFbmQiLCJsaW5lRW5kIiwiZGVsZXRlVG9MaW5lU3RhcnQiLCJsaW5lU3RhcnQiLCJkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCIsImRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQiLCJkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UiLCJwcmV2IiwiaXRlciIsImxpbmVCcmVhayIsInRyYWlsaW5nIiwic2VhcmNoIiwic3BsaXRMaW5lIiwidHJhbnNwb3NlQ2hhcnMiLCJhcHBlbmQiLCJibG9ja3MiLCJ1cHRvIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsIm1vdmVMaW5lIiwibmV4dExpbmUiLCJzaXplIiwibW92ZUxpbmVVcCIsIm1vdmVMaW5lRG93biIsImNvcHlMaW5lIiwiY29weUxpbmVVcCIsImNvcHlMaW5lRG93biIsImRlbGV0ZUxpbmUiLCJkaXN0IiwibGluZVdyYXBwaW5nIiwiYXNzb2MiLCJkb2N1bWVudFRvcCIsImluc2VydE5ld2xpbmUiLCJyZXBsYWNlU2VsZWN0aW9uIiwiaW5zZXJ0TmV3bGluZUtlZXBJbmRlbnQiLCJpc0JldHdlZW5CcmFja2V0cyIsImNvbnRleHQiLCJpbmRleE9mIiwibmFtZSIsImluc2VydE5ld2xpbmVBbmRJbmRlbnQiLCJuZXdsaW5lQW5kSW5kZW50IiwiaW5zZXJ0QmxhbmtMaW5lIiwiYXRFb2YiLCJleHBsb2RlIiwiY3giLCJzaW11bGF0ZUJyZWFrIiwic2ltdWxhdGVEb3VibGVCcmVhayIsImxpbmVJbmRlbnQiLCJjaGFuZ2VCeVNlbGVjdGVkTGluZSIsImF0TGluZSIsIm1hcFBvcyIsImluZGVudFNlbGVjdGlvbiIsInVwZGF0ZWQiLCJPYmplY3QiLCJvdmVycmlkZUluZGVudGF0aW9uIiwibm9ybSIsImluZGVudE1vcmUiLCJpbmRlbnRMZXNzIiwia2VlcCIsInRvZ2dsZVRhYkZvY3VzTW9kZSIsInNldFRhYkZvY3VzTW9kZSIsInRlbXBvcmFyaWx5U2V0VGFiRm9jdXNNb2RlIiwiaW5zZXJ0VGFiIiwiZW1hY3NTdHlsZUtleW1hcCIsInNoaWZ0Iiwic3RhbmRhcmRLZXltYXAiLCJkZWZhdWx0S2V5bWFwIiwiaW5kZW50V2l0aFRhYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/commands/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lang-css/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/lang-css/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   css: () => (/* binding */ css),\n/* harmony export */   cssCompletionSource: () => (/* binding */ cssCompletionSource),\n/* harmony export */   cssLanguage: () => (/* binding */ cssLanguage),\n/* harmony export */   defineCSSCompletionSource: () => (/* binding */ defineCSSCompletionSource)\n/* harmony export */ });\n/* harmony import */ var _lezer_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/css */ \"(ssr)/./node_modules/@lezer/css/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\nlet _properties = null;\nfunction properties() {\n    if (!_properties && typeof document == \"object\" && document.body) {\n        let { style } = document.body, names = [], seen = new Set;\n        for(let prop in style)if (prop != \"cssText\" && prop != \"cssFloat\") {\n            if (typeof style[prop] == \"string\") {\n                if (/[A-Z]/.test(prop)) prop = prop.replace(/[A-Z]/g, (ch)=>\"-\" + ch.toLowerCase());\n                if (!seen.has(prop)) {\n                    names.push(prop);\n                    seen.add(prop);\n                }\n            }\n        }\n        _properties = names.sort().map((name)=>({\n                type: \"property\",\n                label: name,\n                apply: name + \": \"\n            }));\n    }\n    return _properties || [];\n}\nconst pseudoClasses = /*@__PURE__*/ [\n    \"active\",\n    \"after\",\n    \"any-link\",\n    \"autofill\",\n    \"backdrop\",\n    \"before\",\n    \"checked\",\n    \"cue\",\n    \"default\",\n    \"defined\",\n    \"disabled\",\n    \"empty\",\n    \"enabled\",\n    \"file-selector-button\",\n    \"first\",\n    \"first-child\",\n    \"first-letter\",\n    \"first-line\",\n    \"first-of-type\",\n    \"focus\",\n    \"focus-visible\",\n    \"focus-within\",\n    \"fullscreen\",\n    \"has\",\n    \"host\",\n    \"host-context\",\n    \"hover\",\n    \"in-range\",\n    \"indeterminate\",\n    \"invalid\",\n    \"is\",\n    \"lang\",\n    \"last-child\",\n    \"last-of-type\",\n    \"left\",\n    \"link\",\n    \"marker\",\n    \"modal\",\n    \"not\",\n    \"nth-child\",\n    \"nth-last-child\",\n    \"nth-last-of-type\",\n    \"nth-of-type\",\n    \"only-child\",\n    \"only-of-type\",\n    \"optional\",\n    \"out-of-range\",\n    \"part\",\n    \"placeholder\",\n    \"placeholder-shown\",\n    \"read-only\",\n    \"read-write\",\n    \"required\",\n    \"right\",\n    \"root\",\n    \"scope\",\n    \"selection\",\n    \"slotted\",\n    \"target\",\n    \"target-text\",\n    \"valid\",\n    \"visited\",\n    \"where\"\n].map((name)=>({\n        type: \"class\",\n        label: name\n    }));\nconst values = /*@__PURE__*/ [\n    \"above\",\n    \"absolute\",\n    \"activeborder\",\n    \"additive\",\n    \"activecaption\",\n    \"after-white-space\",\n    \"ahead\",\n    \"alias\",\n    \"all\",\n    \"all-scroll\",\n    \"alphabetic\",\n    \"alternate\",\n    \"always\",\n    \"antialiased\",\n    \"appworkspace\",\n    \"asterisks\",\n    \"attr\",\n    \"auto\",\n    \"auto-flow\",\n    \"avoid\",\n    \"avoid-column\",\n    \"avoid-page\",\n    \"avoid-region\",\n    \"axis-pan\",\n    \"background\",\n    \"backwards\",\n    \"baseline\",\n    \"below\",\n    \"bidi-override\",\n    \"blink\",\n    \"block\",\n    \"block-axis\",\n    \"bold\",\n    \"bolder\",\n    \"border\",\n    \"border-box\",\n    \"both\",\n    \"bottom\",\n    \"break\",\n    \"break-all\",\n    \"break-word\",\n    \"bullets\",\n    \"button\",\n    \"button-bevel\",\n    \"buttonface\",\n    \"buttonhighlight\",\n    \"buttonshadow\",\n    \"buttontext\",\n    \"calc\",\n    \"capitalize\",\n    \"caps-lock-indicator\",\n    \"caption\",\n    \"captiontext\",\n    \"caret\",\n    \"cell\",\n    \"center\",\n    \"checkbox\",\n    \"circle\",\n    \"cjk-decimal\",\n    \"clear\",\n    \"clip\",\n    \"close-quote\",\n    \"col-resize\",\n    \"collapse\",\n    \"color\",\n    \"color-burn\",\n    \"color-dodge\",\n    \"column\",\n    \"column-reverse\",\n    \"compact\",\n    \"condensed\",\n    \"contain\",\n    \"content\",\n    \"contents\",\n    \"content-box\",\n    \"context-menu\",\n    \"continuous\",\n    \"copy\",\n    \"counter\",\n    \"counters\",\n    \"cover\",\n    \"crop\",\n    \"cross\",\n    \"crosshair\",\n    \"currentcolor\",\n    \"cursive\",\n    \"cyclic\",\n    \"darken\",\n    \"dashed\",\n    \"decimal\",\n    \"decimal-leading-zero\",\n    \"default\",\n    \"default-button\",\n    \"dense\",\n    \"destination-atop\",\n    \"destination-in\",\n    \"destination-out\",\n    \"destination-over\",\n    \"difference\",\n    \"disc\",\n    \"discard\",\n    \"disclosure-closed\",\n    \"disclosure-open\",\n    \"document\",\n    \"dot-dash\",\n    \"dot-dot-dash\",\n    \"dotted\",\n    \"double\",\n    \"down\",\n    \"e-resize\",\n    \"ease\",\n    \"ease-in\",\n    \"ease-in-out\",\n    \"ease-out\",\n    \"element\",\n    \"ellipse\",\n    \"ellipsis\",\n    \"embed\",\n    \"end\",\n    \"ethiopic-abegede-gez\",\n    \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-gez\",\n    \"ew-resize\",\n    \"exclusion\",\n    \"expanded\",\n    \"extends\",\n    \"extra-condensed\",\n    \"extra-expanded\",\n    \"fantasy\",\n    \"fast\",\n    \"fill\",\n    \"fill-box\",\n    \"fixed\",\n    \"flat\",\n    \"flex\",\n    \"flex-end\",\n    \"flex-start\",\n    \"footnotes\",\n    \"forwards\",\n    \"from\",\n    \"geometricPrecision\",\n    \"graytext\",\n    \"grid\",\n    \"groove\",\n    \"hand\",\n    \"hard-light\",\n    \"help\",\n    \"hidden\",\n    \"hide\",\n    \"higher\",\n    \"highlight\",\n    \"highlighttext\",\n    \"horizontal\",\n    \"hsl\",\n    \"hsla\",\n    \"hue\",\n    \"icon\",\n    \"ignore\",\n    \"inactiveborder\",\n    \"inactivecaption\",\n    \"inactivecaptiontext\",\n    \"infinite\",\n    \"infobackground\",\n    \"infotext\",\n    \"inherit\",\n    \"initial\",\n    \"inline\",\n    \"inline-axis\",\n    \"inline-block\",\n    \"inline-flex\",\n    \"inline-grid\",\n    \"inline-table\",\n    \"inset\",\n    \"inside\",\n    \"intrinsic\",\n    \"invert\",\n    \"italic\",\n    \"justify\",\n    \"keep-all\",\n    \"landscape\",\n    \"large\",\n    \"larger\",\n    \"left\",\n    \"level\",\n    \"lighter\",\n    \"lighten\",\n    \"line-through\",\n    \"linear\",\n    \"linear-gradient\",\n    \"lines\",\n    \"list-item\",\n    \"listbox\",\n    \"listitem\",\n    \"local\",\n    \"logical\",\n    \"loud\",\n    \"lower\",\n    \"lower-hexadecimal\",\n    \"lower-latin\",\n    \"lower-norwegian\",\n    \"lowercase\",\n    \"ltr\",\n    \"luminosity\",\n    \"manipulation\",\n    \"match\",\n    \"matrix\",\n    \"matrix3d\",\n    \"medium\",\n    \"menu\",\n    \"menutext\",\n    \"message-box\",\n    \"middle\",\n    \"min-intrinsic\",\n    \"mix\",\n    \"monospace\",\n    \"move\",\n    \"multiple\",\n    \"multiple_mask_images\",\n    \"multiply\",\n    \"n-resize\",\n    \"narrower\",\n    \"ne-resize\",\n    \"nesw-resize\",\n    \"no-close-quote\",\n    \"no-drop\",\n    \"no-open-quote\",\n    \"no-repeat\",\n    \"none\",\n    \"normal\",\n    \"not-allowed\",\n    \"nowrap\",\n    \"ns-resize\",\n    \"numbers\",\n    \"numeric\",\n    \"nw-resize\",\n    \"nwse-resize\",\n    \"oblique\",\n    \"opacity\",\n    \"open-quote\",\n    \"optimizeLegibility\",\n    \"optimizeSpeed\",\n    \"outset\",\n    \"outside\",\n    \"outside-shape\",\n    \"overlay\",\n    \"overline\",\n    \"padding\",\n    \"padding-box\",\n    \"painted\",\n    \"page\",\n    \"paused\",\n    \"perspective\",\n    \"pinch-zoom\",\n    \"plus-darker\",\n    \"plus-lighter\",\n    \"pointer\",\n    \"polygon\",\n    \"portrait\",\n    \"pre\",\n    \"pre-line\",\n    \"pre-wrap\",\n    \"preserve-3d\",\n    \"progress\",\n    \"push-button\",\n    \"radial-gradient\",\n    \"radio\",\n    \"read-only\",\n    \"read-write\",\n    \"read-write-plaintext-only\",\n    \"rectangle\",\n    \"region\",\n    \"relative\",\n    \"repeat\",\n    \"repeating-linear-gradient\",\n    \"repeating-radial-gradient\",\n    \"repeat-x\",\n    \"repeat-y\",\n    \"reset\",\n    \"reverse\",\n    \"rgb\",\n    \"rgba\",\n    \"ridge\",\n    \"right\",\n    \"rotate\",\n    \"rotate3d\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"round\",\n    \"row\",\n    \"row-resize\",\n    \"row-reverse\",\n    \"rtl\",\n    \"run-in\",\n    \"running\",\n    \"s-resize\",\n    \"sans-serif\",\n    \"saturation\",\n    \"scale\",\n    \"scale3d\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n    \"screen\",\n    \"scroll\",\n    \"scrollbar\",\n    \"scroll-position\",\n    \"se-resize\",\n    \"self-start\",\n    \"self-end\",\n    \"semi-condensed\",\n    \"semi-expanded\",\n    \"separate\",\n    \"serif\",\n    \"show\",\n    \"single\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"skip-white-space\",\n    \"slide\",\n    \"slider-horizontal\",\n    \"slider-vertical\",\n    \"sliderthumb-horizontal\",\n    \"sliderthumb-vertical\",\n    \"slow\",\n    \"small\",\n    \"small-caps\",\n    \"small-caption\",\n    \"smaller\",\n    \"soft-light\",\n    \"solid\",\n    \"source-atop\",\n    \"source-in\",\n    \"source-out\",\n    \"source-over\",\n    \"space\",\n    \"space-around\",\n    \"space-between\",\n    \"space-evenly\",\n    \"spell-out\",\n    \"square\",\n    \"start\",\n    \"static\",\n    \"status-bar\",\n    \"stretch\",\n    \"stroke\",\n    \"stroke-box\",\n    \"sub\",\n    \"subpixel-antialiased\",\n    \"svg_masks\",\n    \"super\",\n    \"sw-resize\",\n    \"symbolic\",\n    \"symbols\",\n    \"system-ui\",\n    \"table\",\n    \"table-caption\",\n    \"table-cell\",\n    \"table-column\",\n    \"table-column-group\",\n    \"table-footer-group\",\n    \"table-header-group\",\n    \"table-row\",\n    \"table-row-group\",\n    \"text\",\n    \"text-bottom\",\n    \"text-top\",\n    \"textarea\",\n    \"textfield\",\n    \"thick\",\n    \"thin\",\n    \"threeddarkshadow\",\n    \"threedface\",\n    \"threedhighlight\",\n    \"threedlightshadow\",\n    \"threedshadow\",\n    \"to\",\n    \"top\",\n    \"transform\",\n    \"translate\",\n    \"translate3d\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"transparent\",\n    \"ultra-condensed\",\n    \"ultra-expanded\",\n    \"underline\",\n    \"unidirectional-pan\",\n    \"unset\",\n    \"up\",\n    \"upper-latin\",\n    \"uppercase\",\n    \"url\",\n    \"var\",\n    \"vertical\",\n    \"vertical-text\",\n    \"view-box\",\n    \"visible\",\n    \"visibleFill\",\n    \"visiblePainted\",\n    \"visibleStroke\",\n    \"visual\",\n    \"w-resize\",\n    \"wait\",\n    \"wave\",\n    \"wider\",\n    \"window\",\n    \"windowframe\",\n    \"windowtext\",\n    \"words\",\n    \"wrap\",\n    \"wrap-reverse\",\n    \"x-large\",\n    \"x-small\",\n    \"xor\",\n    \"xx-large\",\n    \"xx-small\"\n].map((name)=>({\n        type: \"keyword\",\n        label: name\n    })).concat(/*@__PURE__*/ [\n    \"aliceblue\",\n    \"antiquewhite\",\n    \"aqua\",\n    \"aquamarine\",\n    \"azure\",\n    \"beige\",\n    \"bisque\",\n    \"black\",\n    \"blanchedalmond\",\n    \"blue\",\n    \"blueviolet\",\n    \"brown\",\n    \"burlywood\",\n    \"cadetblue\",\n    \"chartreuse\",\n    \"chocolate\",\n    \"coral\",\n    \"cornflowerblue\",\n    \"cornsilk\",\n    \"crimson\",\n    \"cyan\",\n    \"darkblue\",\n    \"darkcyan\",\n    \"darkgoldenrod\",\n    \"darkgray\",\n    \"darkgreen\",\n    \"darkkhaki\",\n    \"darkmagenta\",\n    \"darkolivegreen\",\n    \"darkorange\",\n    \"darkorchid\",\n    \"darkred\",\n    \"darksalmon\",\n    \"darkseagreen\",\n    \"darkslateblue\",\n    \"darkslategray\",\n    \"darkturquoise\",\n    \"darkviolet\",\n    \"deeppink\",\n    \"deepskyblue\",\n    \"dimgray\",\n    \"dodgerblue\",\n    \"firebrick\",\n    \"floralwhite\",\n    \"forestgreen\",\n    \"fuchsia\",\n    \"gainsboro\",\n    \"ghostwhite\",\n    \"gold\",\n    \"goldenrod\",\n    \"gray\",\n    \"grey\",\n    \"green\",\n    \"greenyellow\",\n    \"honeydew\",\n    \"hotpink\",\n    \"indianred\",\n    \"indigo\",\n    \"ivory\",\n    \"khaki\",\n    \"lavender\",\n    \"lavenderblush\",\n    \"lawngreen\",\n    \"lemonchiffon\",\n    \"lightblue\",\n    \"lightcoral\",\n    \"lightcyan\",\n    \"lightgoldenrodyellow\",\n    \"lightgray\",\n    \"lightgreen\",\n    \"lightpink\",\n    \"lightsalmon\",\n    \"lightseagreen\",\n    \"lightskyblue\",\n    \"lightslategray\",\n    \"lightsteelblue\",\n    \"lightyellow\",\n    \"lime\",\n    \"limegreen\",\n    \"linen\",\n    \"magenta\",\n    \"maroon\",\n    \"mediumaquamarine\",\n    \"mediumblue\",\n    \"mediumorchid\",\n    \"mediumpurple\",\n    \"mediumseagreen\",\n    \"mediumslateblue\",\n    \"mediumspringgreen\",\n    \"mediumturquoise\",\n    \"mediumvioletred\",\n    \"midnightblue\",\n    \"mintcream\",\n    \"mistyrose\",\n    \"moccasin\",\n    \"navajowhite\",\n    \"navy\",\n    \"oldlace\",\n    \"olive\",\n    \"olivedrab\",\n    \"orange\",\n    \"orangered\",\n    \"orchid\",\n    \"palegoldenrod\",\n    \"palegreen\",\n    \"paleturquoise\",\n    \"palevioletred\",\n    \"papayawhip\",\n    \"peachpuff\",\n    \"peru\",\n    \"pink\",\n    \"plum\",\n    \"powderblue\",\n    \"purple\",\n    \"rebeccapurple\",\n    \"red\",\n    \"rosybrown\",\n    \"royalblue\",\n    \"saddlebrown\",\n    \"salmon\",\n    \"sandybrown\",\n    \"seagreen\",\n    \"seashell\",\n    \"sienna\",\n    \"silver\",\n    \"skyblue\",\n    \"slateblue\",\n    \"slategray\",\n    \"snow\",\n    \"springgreen\",\n    \"steelblue\",\n    \"tan\",\n    \"teal\",\n    \"thistle\",\n    \"tomato\",\n    \"turquoise\",\n    \"violet\",\n    \"wheat\",\n    \"white\",\n    \"whitesmoke\",\n    \"yellow\",\n    \"yellowgreen\"\n].map((name)=>({\n        type: \"constant\",\n        label: name\n    })));\nconst tags = /*@__PURE__*/ [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"b\",\n    \"bdi\",\n    \"bdo\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"header\",\n    \"hgroup\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"main\",\n    \"meter\",\n    \"nav\",\n    \"ol\",\n    \"output\",\n    \"p\",\n    \"pre\",\n    \"ruby\",\n    \"section\",\n    \"select\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"template\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"tr\",\n    \"u\",\n    \"ul\"\n].map((name)=>({\n        type: \"type\",\n        label: name\n    }));\nconst atRules = /*@__PURE__*/ [\n    \"@charset\",\n    \"@color-profile\",\n    \"@container\",\n    \"@counter-style\",\n    \"@font-face\",\n    \"@font-feature-values\",\n    \"@font-palette-values\",\n    \"@import\",\n    \"@keyframes\",\n    \"@layer\",\n    \"@media\",\n    \"@namespace\",\n    \"@page\",\n    \"@position-try\",\n    \"@property\",\n    \"@scope\",\n    \"@starting-style\",\n    \"@supports\",\n    \"@view-transition\"\n].map((label)=>({\n        type: \"keyword\",\n        label\n    }));\nconst identifier = /^(\\w[\\w-]*|-\\w[\\w-]*|)$/, variable = /^-(-[\\w-]*)?$/;\nfunction isVarArg(node, doc) {\n    var _a;\n    if (node.name == \"(\" || node.type.isError) node = node.parent || node;\n    if (node.name != \"ArgList\") return false;\n    let callee = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.firstChild;\n    if ((callee === null || callee === void 0 ? void 0 : callee.name) != \"Callee\") return false;\n    return doc.sliceString(callee.from, callee.to) == \"var\";\n}\nconst VariablesByNode = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst declSelector = [\n    \"Declaration\"\n];\nfunction astTop(node) {\n    for(let cur = node;;){\n        if (cur.type.isTop) return cur;\n        if (!(cur = cur.parent)) return node;\n    }\n}\nfunction variableNames(doc, node, isVariable) {\n    if (node.to - node.from > 4096) {\n        let known = VariablesByNode.get(node);\n        if (known) return known;\n        let result = [], seen = new Set, cursor = node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous);\n        if (cursor.firstChild()) do {\n            for (let option of variableNames(doc, cursor.node, isVariable))if (!seen.has(option.label)) {\n                seen.add(option.label);\n                result.push(option);\n            }\n        }while (cursor.nextSibling());\n        VariablesByNode.set(node, result);\n        return result;\n    } else {\n        let result = [], seen = new Set;\n        node.cursor().iterate((node)=>{\n            var _a;\n            if (isVariable(node) && node.matchContext(declSelector) && ((_a = node.node.nextSibling) === null || _a === void 0 ? void 0 : _a.name) == \":\") {\n                let name = doc.sliceString(node.from, node.to);\n                if (!seen.has(name)) {\n                    seen.add(name);\n                    result.push({\n                        label: name,\n                        type: \"variable\"\n                    });\n                }\n            }\n        });\n        return result;\n    }\n}\n/**\nCreate a completion source for a CSS dialect, providing a\npredicate for determining what kind of syntax node can act as a\ncompletable variable. This is used by language modes like Sass and\nLess to reuse this package's completion logic.\n*/ const defineCSSCompletionSource = (isVariable)=>(context)=>{\n        let { state, pos } = context, node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state).resolveInner(pos, -1);\n        let isDash = node.type.isError && node.from == node.to - 1 && state.doc.sliceString(node.from, node.to) == \"-\";\n        if (node.name == \"PropertyName\" || (isDash || node.name == \"TagName\") && /^(Block|Styles)$/.test(node.resolve(node.to).name)) return {\n            from: node.from,\n            options: properties(),\n            validFor: identifier\n        };\n        if (node.name == \"ValueName\") return {\n            from: node.from,\n            options: values,\n            validFor: identifier\n        };\n        if (node.name == \"PseudoClassName\") return {\n            from: node.from,\n            options: pseudoClasses,\n            validFor: identifier\n        };\n        if (isVariable(node) || (context.explicit || isDash) && isVarArg(node, state.doc)) return {\n            from: isVariable(node) || isDash ? node.from : pos,\n            options: variableNames(state.doc, astTop(node), isVariable),\n            validFor: variable\n        };\n        if (node.name == \"TagName\") {\n            for(let { parent } = node; parent; parent = parent.parent)if (parent.name == \"Block\") return {\n                from: node.from,\n                options: properties(),\n                validFor: identifier\n            };\n            return {\n                from: node.from,\n                options: tags,\n                validFor: identifier\n            };\n        }\n        if (node.name == \"AtKeyword\") return {\n            from: node.from,\n            options: atRules,\n            validFor: identifier\n        };\n        if (!context.explicit) return null;\n        let above = node.resolve(pos), before = above.childBefore(pos);\n        if (before && before.name == \":\" && above.name == \"PseudoClassSelector\") return {\n            from: pos,\n            options: pseudoClasses,\n            validFor: identifier\n        };\n        if (before && before.name == \":\" && above.name == \"Declaration\" || above.name == \"ArgList\") return {\n            from: pos,\n            options: values,\n            validFor: identifier\n        };\n        if (above.name == \"Block\" || above.name == \"Styles\") return {\n            from: pos,\n            options: properties(),\n            validFor: identifier\n        };\n        return null;\n    };\n/**\nCSS property, variable, and value keyword completion source.\n*/ const cssCompletionSource = /*@__PURE__*/ defineCSSCompletionSource((n)=>n.name == \"VariableName\");\n/**\nA language provider based on the [Lezer CSS\nparser](https://github.com/lezer-parser/css), extended with\nhighlighting and indentation information.\n*/ const cssLanguage = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LRLanguage.define({\n    name: \"css\",\n    parser: /*@__PURE__*/ _lezer_css__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentNodeProp.add({\n                Declaration: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.continuedIndent)()\n            }),\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldNodeProp.add({\n                \"Block KeyframeList\": _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldInside\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: {\n            block: {\n                open: \"/*\",\n                close: \"*/\"\n            }\n        },\n        indentOnInput: /^\\s*\\}$/,\n        wordChars: \"-\"\n    }\n});\n/**\nLanguage support for CSS.\n*/ function css() {\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageSupport(cssLanguage, cssLanguage.data.of({\n        autocomplete: cssCompletionSource\n    }));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1jc3MvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW9DO0FBQ3NHO0FBQ3BGO0FBRXRELElBQUlVLGNBQWM7QUFDbEIsU0FBU0M7SUFDTCxJQUFJLENBQUNELGVBQWUsT0FBT0UsWUFBWSxZQUFZQSxTQUFTQyxJQUFJLEVBQUU7UUFDOUQsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBR0YsU0FBU0MsSUFBSSxFQUFFRSxRQUFRLEVBQUUsRUFBRUMsT0FBTyxJQUFJQztRQUN0RCxJQUFLLElBQUlDLFFBQVFKLE1BQ2IsSUFBSUksUUFBUSxhQUFhQSxRQUFRLFlBQVk7WUFDekMsSUFBSSxPQUFPSixLQUFLLENBQUNJLEtBQUssSUFBSSxVQUFVO2dCQUNoQyxJQUFJLFFBQVFDLElBQUksQ0FBQ0QsT0FDYkEsT0FBT0EsS0FBS0UsT0FBTyxDQUFDLFVBQVVDLENBQUFBLEtBQU0sTUFBTUEsR0FBR0MsV0FBVztnQkFDNUQsSUFBSSxDQUFDTixLQUFLTyxHQUFHLENBQUNMLE9BQU87b0JBQ2pCSCxNQUFNUyxJQUFJLENBQUNOO29CQUNYRixLQUFLUyxHQUFHLENBQUNQO2dCQUNiO1lBQ0o7UUFDSjtRQUNKUixjQUFjSyxNQUFNVyxJQUFJLEdBQUdDLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUztnQkFBRUMsTUFBTTtnQkFBWUMsT0FBT0Y7Z0JBQU1HLE9BQU9ILE9BQU87WUFBSztJQUNoRztJQUNBLE9BQU9sQixlQUFlLEVBQUU7QUFDNUI7QUFDQSxNQUFNc0IsZ0JBQWdCLFdBQVcsR0FBRTtJQUMvQjtJQUFVO0lBQVM7SUFBWTtJQUFZO0lBQVk7SUFDdkQ7SUFBVztJQUFPO0lBQVc7SUFBVztJQUFZO0lBQ3BEO0lBQVc7SUFBd0I7SUFBUztJQUM1QztJQUFnQjtJQUFjO0lBQWlCO0lBQy9DO0lBQWlCO0lBQWdCO0lBQWM7SUFBTztJQUN0RDtJQUFnQjtJQUFTO0lBQVk7SUFBaUI7SUFD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O0FBQ3BHO0FBRTRFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm5jb2RlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmctY3NzL2Rpc3QvaW5kZXguanM/ZTViOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZXIgfSBmcm9tICdAbGV6ZXIvY3NzJztcbmltcG9ydCB7IHN5bnRheFRyZWUsIExSTGFuZ3VhZ2UsIGluZGVudE5vZGVQcm9wLCBjb250aW51ZWRJbmRlbnQsIGZvbGROb2RlUHJvcCwgZm9sZEluc2lkZSwgTGFuZ3VhZ2VTdXBwb3J0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgTm9kZVdlYWtNYXAsIEl0ZXJNb2RlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBfcHJvcGVydGllcyA9IG51bGw7XG5mdW5jdGlvbiBwcm9wZXJ0aWVzKCkge1xuICAgIGlmICghX3Byb3BlcnRpZXMgJiYgdHlwZW9mIGRvY3VtZW50ID09IFwib2JqZWN0XCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgeyBzdHlsZSB9ID0gZG9jdW1lbnQuYm9keSwgbmFtZXMgPSBbXSwgc2VlbiA9IG5ldyBTZXQ7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc3R5bGUpXG4gICAgICAgICAgICBpZiAocHJvcCAhPSBcImNzc1RleHRcIiAmJiBwcm9wICE9IFwiY3NzRmxvYXRcIikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVbcHJvcF0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoL1tBLVpdLy50ZXN0KHByb3ApKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3AucmVwbGFjZSgvW0EtWl0vZywgY2ggPT4gXCItXCIgKyBjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4uYWRkKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBfcHJvcGVydGllcyA9IG5hbWVzLnNvcnQoKS5tYXAobmFtZSA9PiAoeyB0eXBlOiBcInByb3BlcnR5XCIsIGxhYmVsOiBuYW1lLCBhcHBseTogbmFtZSArIFwiOiBcIiB9KSk7XG4gICAgfVxuICAgIHJldHVybiBfcHJvcGVydGllcyB8fCBbXTtcbn1cbmNvbnN0IHBzZXVkb0NsYXNzZXMgPSAvKkBfX1BVUkVfXyovW1xuICAgIFwiYWN0aXZlXCIsIFwiYWZ0ZXJcIiwgXCJhbnktbGlua1wiLCBcImF1dG9maWxsXCIsIFwiYmFja2Ryb3BcIiwgXCJiZWZvcmVcIixcbiAgICBcImNoZWNrZWRcIiwgXCJjdWVcIiwgXCJkZWZhdWx0XCIsIFwiZGVmaW5lZFwiLCBcImRpc2FibGVkXCIsIFwiZW1wdHlcIixcbiAgICBcImVuYWJsZWRcIiwgXCJmaWxlLXNlbGVjdG9yLWJ1dHRvblwiLCBcImZpcnN0XCIsIFwiZmlyc3QtY2hpbGRcIixcbiAgICBcImZpcnN0LWxldHRlclwiLCBcImZpcnN0LWxpbmVcIiwgXCJmaXJzdC1vZi10eXBlXCIsIFwiZm9jdXNcIixcbiAgICBcImZvY3VzLXZpc2libGVcIiwgXCJmb2N1cy13aXRoaW5cIiwgXCJmdWxsc2NyZWVuXCIsIFwiaGFzXCIsIFwiaG9zdFwiLFxuICAgIFwiaG9zdC1jb250ZXh0XCIsIFwiaG92ZXJcIiwgXCJpbi1yYW5nZVwiLCBcImluZGV0ZXJtaW5hdGVcIiwgXCJpbnZhbGlkXCIsXG4gICAgXCJpc1wiLCBcImxhbmdcIiwgXCJsYXN0LWNoaWxkXCIsIFwibGFzdC1vZi10eXBlXCIsIFwibGVmdFwiLCBcImxpbmtcIiwgXCJtYXJrZXJcIixcbiAgICBcIm1vZGFsXCIsIFwibm90XCIsIFwibnRoLWNoaWxkXCIsIFwibnRoLWxhc3QtY2hpbGRcIiwgXCJudGgtbGFzdC1vZi10eXBlXCIsXG4gICAgXCJudGgtb2YtdHlwZVwiLCBcIm9ubHktY2hpbGRcIiwgXCJvbmx5LW9mLXR5cGVcIiwgXCJvcHRpb25hbFwiLCBcIm91dC1vZi1yYW5nZVwiLFxuICAgIFwicGFydFwiLCBcInBsYWNlaG9sZGVyXCIsIFwicGxhY2Vob2xkZXItc2hvd25cIiwgXCJyZWFkLW9ubHlcIiwgXCJyZWFkLXdyaXRlXCIsXG4gICAgXCJyZXF1aXJlZFwiLCBcInJpZ2h0XCIsIFwicm9vdFwiLCBcInNjb3BlXCIsIFwic2VsZWN0aW9uXCIsIFwic2xvdHRlZFwiLCBcInRhcmdldFwiLFxuICAgIFwidGFyZ2V0LXRleHRcIiwgXCJ2YWxpZFwiLCBcInZpc2l0ZWRcIiwgXCJ3aGVyZVwiXG5dLm1hcChuYW1lID0+ICh7IHR5cGU6IFwiY2xhc3NcIiwgbGFiZWw6IG5hbWUgfSkpO1xuY29uc3QgdmFsdWVzID0gLypAX19QVVJFX18qL1tcbiAgICBcImFib3ZlXCIsIFwiYWJzb2x1dGVcIiwgXCJhY3RpdmVib3JkZXJcIiwgXCJhZGRpdGl2ZVwiLCBcImFjdGl2ZWNhcHRpb25cIiwgXCJhZnRlci13aGl0ZS1zcGFjZVwiLFxuICAgIFwiYWhlYWRcIiwgXCJhbGlhc1wiLCBcImFsbFwiLCBcImFsbC1zY3JvbGxcIiwgXCJhbHBoYWJldGljXCIsIFwiYWx0ZXJuYXRlXCIsIFwiYWx3YXlzXCIsXG4gICAgXCJhbnRpYWxpYXNlZFwiLCBcImFwcHdvcmtzcGFjZVwiLCBcImFzdGVyaXNrc1wiLCBcImF0dHJcIiwgXCJhdXRvXCIsIFwiYXV0by1mbG93XCIsIFwiYXZvaWRcIiwgXCJhdm9pZC1jb2x1bW5cIixcbiAgICBcImF2b2lkLXBhZ2VcIiwgXCJhdm9pZC1yZWdpb25cIiwgXCJheGlzLXBhblwiLCBcImJhY2tncm91bmRcIiwgXCJiYWNrd2FyZHNcIiwgXCJiYXNlbGluZVwiLCBcImJlbG93XCIsXG4gICAgXCJiaWRpLW92ZXJyaWRlXCIsIFwiYmxpbmtcIiwgXCJibG9ja1wiLCBcImJsb2NrLWF4aXNcIiwgXCJib2xkXCIsIFwiYm9sZGVyXCIsIFwiYm9yZGVyXCIsIFwiYm9yZGVyLWJveFwiLFxuICAgIFwiYm90aFwiLCBcImJvdHRvbVwiLCBcImJyZWFrXCIsIFwiYnJlYWstYWxsXCIsIFwiYnJlYWstd29yZFwiLCBcImJ1bGxldHNcIiwgXCJidXR0b25cIiwgXCJidXR0b24tYmV2ZWxcIixcbiAgICBcImJ1dHRvbmZhY2VcIiwgXCJidXR0b25oaWdobGlnaHRcIiwgXCJidXR0b25zaGFkb3dcIiwgXCJidXR0b250ZXh0XCIsIFwiY2FsY1wiLCBcImNhcGl0YWxpemVcIixcbiAgICBcImNhcHMtbG9jay1pbmRpY2F0b3JcIiwgXCJjYXB0aW9uXCIsIFwiY2FwdGlvbnRleHRcIiwgXCJjYXJldFwiLCBcImNlbGxcIiwgXCJjZW50ZXJcIiwgXCJjaGVja2JveFwiLCBcImNpcmNsZVwiLFxuICAgIFwiY2prLWRlY2ltYWxcIiwgXCJjbGVhclwiLCBcImNsaXBcIiwgXCJjbG9zZS1xdW90ZVwiLCBcImNvbC1yZXNpemVcIiwgXCJjb2xsYXBzZVwiLCBcImNvbG9yXCIsIFwiY29sb3ItYnVyblwiLFxuICAgIFwiY29sb3ItZG9kZ2VcIiwgXCJjb2x1bW5cIiwgXCJjb2x1bW4tcmV2ZXJzZVwiLCBcImNvbXBhY3RcIiwgXCJjb25kZW5zZWRcIiwgXCJjb250YWluXCIsIFwiY29udGVudFwiLFxuICAgIFwiY29udGVudHNcIiwgXCJjb250ZW50LWJveFwiLCBcImNvbnRleHQtbWVudVwiLCBcImNvbnRpbnVvdXNcIiwgXCJjb3B5XCIsIFwiY291bnRlclwiLCBcImNvdW50ZXJzXCIsIFwiY292ZXJcIixcbiAgICBcImNyb3BcIiwgXCJjcm9zc1wiLCBcImNyb3NzaGFpclwiLCBcImN1cnJlbnRjb2xvclwiLCBcImN1cnNpdmVcIiwgXCJjeWNsaWNcIiwgXCJkYXJrZW5cIiwgXCJkYXNoZWRcIiwgXCJkZWNpbWFsXCIsXG4gICAgXCJkZWNpbWFsLWxlYWRpbmctemVyb1wiLCBcImRlZmF1bHRcIiwgXCJkZWZhdWx0LWJ1dHRvblwiLCBcImRlbnNlXCIsIFwiZGVzdGluYXRpb24tYXRvcFwiLCBcImRlc3RpbmF0aW9uLWluXCIsXG4gICAgXCJkZXN0aW5hdGlvbi1vdXRcIiwgXCJkZXN0aW5hdGlvbi1vdmVyXCIsIFwiZGlmZmVyZW5jZVwiLCBcImRpc2NcIiwgXCJkaXNjYXJkXCIsIFwiZGlzY2xvc3VyZS1jbG9zZWRcIixcbiAgICBcImRpc2Nsb3N1cmUtb3BlblwiLCBcImRvY3VtZW50XCIsIFwiZG90LWRhc2hcIiwgXCJkb3QtZG90LWRhc2hcIiwgXCJkb3R0ZWRcIiwgXCJkb3VibGVcIiwgXCJkb3duXCIsIFwiZS1yZXNpemVcIixcbiAgICBcImVhc2VcIiwgXCJlYXNlLWluXCIsIFwiZWFzZS1pbi1vdXRcIiwgXCJlYXNlLW91dFwiLCBcImVsZW1lbnRcIiwgXCJlbGxpcHNlXCIsIFwiZWxsaXBzaXNcIiwgXCJlbWJlZFwiLCBcImVuZFwiLFxuICAgIFwiZXRoaW9waWMtYWJlZ2VkZS1nZXpcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1hYS1lclwiLCBcImV0aGlvcGljLWhhbGVoYW1lLWdlelwiLCBcImV3LXJlc2l6ZVwiLCBcImV4Y2x1c2lvblwiLFxuICAgIFwiZXhwYW5kZWRcIiwgXCJleHRlbmRzXCIsIFwiZXh0cmEtY29uZGVuc2VkXCIsIFwiZXh0cmEtZXhwYW5kZWRcIiwgXCJmYW50YXN5XCIsIFwiZmFzdFwiLCBcImZpbGxcIiwgXCJmaWxsLWJveFwiLFxuICAgIFwiZml4ZWRcIiwgXCJmbGF0XCIsIFwiZmxleFwiLCBcImZsZXgtZW5kXCIsIFwiZmxleC1zdGFydFwiLCBcImZvb3Rub3Rlc1wiLCBcImZvcndhcmRzXCIsIFwiZnJvbVwiLFxuICAgIFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsIFwiZ3JheXRleHRcIiwgXCJncmlkXCIsIFwiZ3Jvb3ZlXCIsIFwiaGFuZFwiLCBcImhhcmQtbGlnaHRcIiwgXCJoZWxwXCIsIFwiaGlkZGVuXCIsIFwiaGlkZVwiLFxuICAgIFwiaGlnaGVyXCIsIFwiaGlnaGxpZ2h0XCIsIFwiaGlnaGxpZ2h0dGV4dFwiLCBcImhvcml6b250YWxcIiwgXCJoc2xcIiwgXCJoc2xhXCIsIFwiaHVlXCIsIFwiaWNvblwiLCBcImlnbm9yZVwiLFxuICAgIFwiaW5hY3RpdmVib3JkZXJcIiwgXCJpbmFjdGl2ZWNhcHRpb25cIiwgXCJpbmFjdGl2ZWNhcHRpb250ZXh0XCIsIFwiaW5maW5pdGVcIiwgXCJpbmZvYmFja2dyb3VuZFwiLCBcImluZm90ZXh0XCIsXG4gICAgXCJpbmhlcml0XCIsIFwiaW5pdGlhbFwiLCBcImlubGluZVwiLCBcImlubGluZS1heGlzXCIsIFwiaW5saW5lLWJsb2NrXCIsIFwiaW5saW5lLWZsZXhcIiwgXCJpbmxpbmUtZ3JpZFwiLFxuICAgIFwiaW5saW5lLXRhYmxlXCIsIFwiaW5zZXRcIiwgXCJpbnNpZGVcIiwgXCJpbnRyaW5zaWNcIiwgXCJpbnZlcnRcIiwgXCJpdGFsaWNcIiwgXCJqdXN0aWZ5XCIsIFwia2VlcC1hbGxcIixcbiAgICBcImxhbmRzY2FwZVwiLCBcImxhcmdlXCIsIFwibGFyZ2VyXCIsIFwibGVmdFwiLCBcImxldmVsXCIsIFwibGlnaHRlclwiLCBcImxpZ2h0ZW5cIiwgXCJsaW5lLXRocm91Z2hcIiwgXCJsaW5lYXJcIixcbiAgICBcImxpbmVhci1ncmFkaWVudFwiLCBcImxpbmVzXCIsIFwibGlzdC1pdGVtXCIsIFwibGlzdGJveFwiLCBcImxpc3RpdGVtXCIsIFwibG9jYWxcIiwgXCJsb2dpY2FsXCIsIFwibG91ZFwiLCBcImxvd2VyXCIsXG4gICAgXCJsb3dlci1oZXhhZGVjaW1hbFwiLCBcImxvd2VyLWxhdGluXCIsIFwibG93ZXItbm9yd2VnaWFuXCIsIFwibG93ZXJjYXNlXCIsIFwibHRyXCIsIFwibHVtaW5vc2l0eVwiLCBcIm1hbmlwdWxhdGlvblwiLFxuICAgIFwibWF0Y2hcIiwgXCJtYXRyaXhcIiwgXCJtYXRyaXgzZFwiLCBcIm1lZGl1bVwiLCBcIm1lbnVcIiwgXCJtZW51dGV4dFwiLCBcIm1lc3NhZ2UtYm94XCIsIFwibWlkZGxlXCIsIFwibWluLWludHJpbnNpY1wiLFxuICAgIFwibWl4XCIsIFwibW9ub3NwYWNlXCIsIFwibW92ZVwiLCBcIm11bHRpcGxlXCIsIFwibXVsdGlwbGVfbWFza19pbWFnZXNcIiwgXCJtdWx0aXBseVwiLCBcIm4tcmVzaXplXCIsIFwibmFycm93ZXJcIixcbiAgICBcIm5lLXJlc2l6ZVwiLCBcIm5lc3ctcmVzaXplXCIsIFwibm8tY2xvc2UtcXVvdGVcIiwgXCJuby1kcm9wXCIsIFwibm8tb3Blbi1xdW90ZVwiLCBcIm5vLXJlcGVhdFwiLCBcIm5vbmVcIixcbiAgICBcIm5vcm1hbFwiLCBcIm5vdC1hbGxvd2VkXCIsIFwibm93cmFwXCIsIFwibnMtcmVzaXplXCIsIFwibnVtYmVyc1wiLCBcIm51bWVyaWNcIiwgXCJudy1yZXNpemVcIiwgXCJud3NlLXJlc2l6ZVwiLFxuICAgIFwib2JsaXF1ZVwiLCBcIm9wYWNpdHlcIiwgXCJvcGVuLXF1b3RlXCIsIFwib3B0aW1pemVMZWdpYmlsaXR5XCIsIFwib3B0aW1pemVTcGVlZFwiLCBcIm91dHNldFwiLCBcIm91dHNpZGVcIixcbiAgICBcIm91dHNpZGUtc2hhcGVcIiwgXCJvdmVybGF5XCIsIFwib3ZlcmxpbmVcIiwgXCJwYWRkaW5nXCIsIFwicGFkZGluZy1ib3hcIiwgXCJwYWludGVkXCIsIFwicGFnZVwiLCBcInBhdXNlZFwiLFxuICAgIFwicGVyc3BlY3RpdmVcIiwgXCJwaW5jaC16b29tXCIsIFwicGx1cy1kYXJrZXJcIiwgXCJwbHVzLWxpZ2h0ZXJcIiwgXCJwb2ludGVyXCIsIFwicG9seWdvblwiLCBcInBvcnRyYWl0XCIsXG4gICAgXCJwcmVcIiwgXCJwcmUtbGluZVwiLCBcInByZS13cmFwXCIsIFwicHJlc2VydmUtM2RcIiwgXCJwcm9ncmVzc1wiLCBcInB1c2gtYnV0dG9uXCIsIFwicmFkaWFsLWdyYWRpZW50XCIsIFwicmFkaW9cIixcbiAgICBcInJlYWQtb25seVwiLCBcInJlYWQtd3JpdGVcIiwgXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsIFwicmVjdGFuZ2xlXCIsIFwicmVnaW9uXCIsIFwicmVsYXRpdmVcIiwgXCJyZXBlYXRcIixcbiAgICBcInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnRcIiwgXCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBcInJlc2V0XCIsIFwicmV2ZXJzZVwiLFxuICAgIFwicmdiXCIsIFwicmdiYVwiLCBcInJpZGdlXCIsIFwicmlnaHRcIiwgXCJyb3RhdGVcIiwgXCJyb3RhdGUzZFwiLCBcInJvdGF0ZVhcIiwgXCJyb3RhdGVZXCIsIFwicm90YXRlWlwiLCBcInJvdW5kXCIsXG4gICAgXCJyb3dcIiwgXCJyb3ctcmVzaXplXCIsIFwicm93LXJldmVyc2VcIiwgXCJydGxcIiwgXCJydW4taW5cIiwgXCJydW5uaW5nXCIsIFwicy1yZXNpemVcIiwgXCJzYW5zLXNlcmlmXCIsIFwic2F0dXJhdGlvblwiLFxuICAgIFwic2NhbGVcIiwgXCJzY2FsZTNkXCIsIFwic2NhbGVYXCIsIFwic2NhbGVZXCIsIFwic2NhbGVaXCIsIFwic2NyZWVuXCIsIFwic2Nyb2xsXCIsIFwic2Nyb2xsYmFyXCIsIFwic2Nyb2xsLXBvc2l0aW9uXCIsXG4gICAgXCJzZS1yZXNpemVcIiwgXCJzZWxmLXN0YXJ0XCIsIFwic2VsZi1lbmRcIiwgXCJzZW1pLWNvbmRlbnNlZFwiLCBcInNlbWktZXhwYW5kZWRcIiwgXCJzZXBhcmF0ZVwiLCBcInNlcmlmXCIsIFwic2hvd1wiLFxuICAgIFwic2luZ2xlXCIsIFwic2tld1wiLCBcInNrZXdYXCIsIFwic2tld1lcIiwgXCJza2lwLXdoaXRlLXNwYWNlXCIsIFwic2xpZGVcIiwgXCJzbGlkZXItaG9yaXpvbnRhbFwiLFxuICAgIFwic2xpZGVyLXZlcnRpY2FsXCIsIFwic2xpZGVydGh1bWItaG9yaXpvbnRhbFwiLCBcInNsaWRlcnRodW1iLXZlcnRpY2FsXCIsIFwic2xvd1wiLCBcInNtYWxsXCIsIFwic21hbGwtY2Fwc1wiLFxuICAgIFwic21hbGwtY2FwdGlvblwiLCBcInNtYWxsZXJcIiwgXCJzb2Z0LWxpZ2h0XCIsIFwic29saWRcIiwgXCJzb3VyY2UtYXRvcFwiLCBcInNvdXJjZS1pblwiLCBcInNvdXJjZS1vdXRcIixcbiAgICBcInNvdXJjZS1vdmVyXCIsIFwic3BhY2VcIiwgXCJzcGFjZS1hcm91bmRcIiwgXCJzcGFjZS1iZXR3ZWVuXCIsIFwic3BhY2UtZXZlbmx5XCIsIFwic3BlbGwtb3V0XCIsIFwic3F1YXJlXCIsIFwic3RhcnRcIixcbiAgICBcInN0YXRpY1wiLCBcInN0YXR1cy1iYXJcIiwgXCJzdHJldGNoXCIsIFwic3Ryb2tlXCIsIFwic3Ryb2tlLWJveFwiLCBcInN1YlwiLCBcInN1YnBpeGVsLWFudGlhbGlhc2VkXCIsIFwic3ZnX21hc2tzXCIsXG4gICAgXCJzdXBlclwiLCBcInN3LXJlc2l6ZVwiLCBcInN5bWJvbGljXCIsIFwic3ltYm9sc1wiLCBcInN5c3RlbS11aVwiLCBcInRhYmxlXCIsIFwidGFibGUtY2FwdGlvblwiLCBcInRhYmxlLWNlbGxcIixcbiAgICBcInRhYmxlLWNvbHVtblwiLCBcInRhYmxlLWNvbHVtbi1ncm91cFwiLCBcInRhYmxlLWZvb3Rlci1ncm91cFwiLCBcInRhYmxlLWhlYWRlci1ncm91cFwiLCBcInRhYmxlLXJvd1wiLFxuICAgIFwidGFibGUtcm93LWdyb3VwXCIsIFwidGV4dFwiLCBcInRleHQtYm90dG9tXCIsIFwidGV4dC10b3BcIiwgXCJ0ZXh0YXJlYVwiLCBcInRleHRmaWVsZFwiLCBcInRoaWNrXCIsIFwidGhpblwiLFxuICAgIFwidGhyZWVkZGFya3NoYWRvd1wiLCBcInRocmVlZGZhY2VcIiwgXCJ0aHJlZWRoaWdobGlnaHRcIiwgXCJ0aHJlZWRsaWdodHNoYWRvd1wiLCBcInRocmVlZHNoYWRvd1wiLCBcInRvXCIsIFwidG9wXCIsXG4gICAgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGVcIiwgXCJ0cmFuc2xhdGUzZFwiLCBcInRyYW5zbGF0ZVhcIiwgXCJ0cmFuc2xhdGVZXCIsIFwidHJhbnNsYXRlWlwiLCBcInRyYW5zcGFyZW50XCIsXG4gICAgXCJ1bHRyYS1jb25kZW5zZWRcIiwgXCJ1bHRyYS1leHBhbmRlZFwiLCBcInVuZGVybGluZVwiLCBcInVuaWRpcmVjdGlvbmFsLXBhblwiLCBcInVuc2V0XCIsIFwidXBcIiwgXCJ1cHBlci1sYXRpblwiLFxuICAgIFwidXBwZXJjYXNlXCIsIFwidXJsXCIsIFwidmFyXCIsIFwidmVydGljYWxcIiwgXCJ2ZXJ0aWNhbC10ZXh0XCIsIFwidmlldy1ib3hcIiwgXCJ2aXNpYmxlXCIsIFwidmlzaWJsZUZpbGxcIixcbiAgICBcInZpc2libGVQYWludGVkXCIsIFwidmlzaWJsZVN0cm9rZVwiLCBcInZpc3VhbFwiLCBcInctcmVzaXplXCIsIFwid2FpdFwiLCBcIndhdmVcIiwgXCJ3aWRlclwiLCBcIndpbmRvd1wiLCBcIndpbmRvd2ZyYW1lXCIsXG4gICAgXCJ3aW5kb3d0ZXh0XCIsIFwid29yZHNcIiwgXCJ3cmFwXCIsIFwid3JhcC1yZXZlcnNlXCIsIFwieC1sYXJnZVwiLCBcIngtc21hbGxcIiwgXCJ4b3JcIiwgXCJ4eC1sYXJnZVwiLCBcInh4LXNtYWxsXCJcbl0ubWFwKG5hbWUgPT4gKHsgdHlwZTogXCJrZXl3b3JkXCIsIGxhYmVsOiBuYW1lIH0pKS5jb25jYXQoLypAX19QVVJFX18qL1tcbiAgICBcImFsaWNlYmx1ZVwiLCBcImFudGlxdWV3aGl0ZVwiLCBcImFxdWFcIiwgXCJhcXVhbWFyaW5lXCIsIFwiYXp1cmVcIiwgXCJiZWlnZVwiLFxuICAgIFwiYmlzcXVlXCIsIFwiYmxhY2tcIiwgXCJibGFuY2hlZGFsbW9uZFwiLCBcImJsdWVcIiwgXCJibHVldmlvbGV0XCIsIFwiYnJvd25cIixcbiAgICBcImJ1cmx5d29vZFwiLCBcImNhZGV0Ymx1ZVwiLCBcImNoYXJ0cmV1c2VcIiwgXCJjaG9jb2xhdGVcIiwgXCJjb3JhbFwiLCBcImNvcm5mbG93ZXJibHVlXCIsXG4gICAgXCJjb3Juc2lsa1wiLCBcImNyaW1zb25cIiwgXCJjeWFuXCIsIFwiZGFya2JsdWVcIiwgXCJkYXJrY3lhblwiLCBcImRhcmtnb2xkZW5yb2RcIixcbiAgICBcImRhcmtncmF5XCIsIFwiZGFya2dyZWVuXCIsIFwiZGFya2toYWtpXCIsIFwiZGFya21hZ2VudGFcIiwgXCJkYXJrb2xpdmVncmVlblwiLFxuICAgIFwiZGFya29yYW5nZVwiLCBcImRhcmtvcmNoaWRcIiwgXCJkYXJrcmVkXCIsIFwiZGFya3NhbG1vblwiLCBcImRhcmtzZWFncmVlblwiLFxuICAgIFwiZGFya3NsYXRlYmx1ZVwiLCBcImRhcmtzbGF0ZWdyYXlcIiwgXCJkYXJrdHVycXVvaXNlXCIsIFwiZGFya3Zpb2xldFwiLFxuICAgIFwiZGVlcHBpbmtcIiwgXCJkZWVwc2t5Ymx1ZVwiLCBcImRpbWdyYXlcIiwgXCJkb2RnZXJibHVlXCIsIFwiZmlyZWJyaWNrXCIsXG4gICAgXCJmbG9yYWx3aGl0ZVwiLCBcImZvcmVzdGdyZWVuXCIsIFwiZnVjaHNpYVwiLCBcImdhaW5zYm9yb1wiLCBcImdob3N0d2hpdGVcIixcbiAgICBcImdvbGRcIiwgXCJnb2xkZW5yb2RcIiwgXCJncmF5XCIsIFwiZ3JleVwiLCBcImdyZWVuXCIsIFwiZ3JlZW55ZWxsb3dcIiwgXCJob25leWRld1wiLFxuICAgIFwiaG90cGlua1wiLCBcImluZGlhbnJlZFwiLCBcImluZGlnb1wiLCBcIml2b3J5XCIsIFwia2hha2lcIiwgXCJsYXZlbmRlclwiLFxuICAgIFwibGF2ZW5kZXJibHVzaFwiLCBcImxhd25ncmVlblwiLCBcImxlbW9uY2hpZmZvblwiLCBcImxpZ2h0Ymx1ZVwiLCBcImxpZ2h0Y29yYWxcIixcbiAgICBcImxpZ2h0Y3lhblwiLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCIsIFwibGlnaHRncmF5XCIsIFwibGlnaHRncmVlblwiLCBcImxpZ2h0cGlua1wiLFxuICAgIFwibGlnaHRzYWxtb25cIiwgXCJsaWdodHNlYWdyZWVuXCIsIFwibGlnaHRza3libHVlXCIsIFwibGlnaHRzbGF0ZWdyYXlcIixcbiAgICBcImxpZ2h0c3RlZWxibHVlXCIsIFwibGlnaHR5ZWxsb3dcIiwgXCJsaW1lXCIsIFwibGltZWdyZWVuXCIsIFwibGluZW5cIiwgXCJtYWdlbnRhXCIsXG4gICAgXCJtYXJvb25cIiwgXCJtZWRpdW1hcXVhbWFyaW5lXCIsIFwibWVkaXVtYmx1ZVwiLCBcIm1lZGl1bW9yY2hpZFwiLCBcIm1lZGl1bXB1cnBsZVwiLFxuICAgIFwibWVkaXVtc2VhZ3JlZW5cIiwgXCJtZWRpdW1zbGF0ZWJsdWVcIiwgXCJtZWRpdW1zcHJpbmdncmVlblwiLCBcIm1lZGl1bXR1cnF1b2lzZVwiLFxuICAgIFwibWVkaXVtdmlvbGV0cmVkXCIsIFwibWlkbmlnaHRibHVlXCIsIFwibWludGNyZWFtXCIsIFwibWlzdHlyb3NlXCIsIFwibW9jY2FzaW5cIixcbiAgICBcIm5hdmFqb3doaXRlXCIsIFwibmF2eVwiLCBcIm9sZGxhY2VcIiwgXCJvbGl2ZVwiLCBcIm9saXZlZHJhYlwiLCBcIm9yYW5nZVwiLCBcIm9yYW5nZXJlZFwiLFxuICAgIFwib3JjaGlkXCIsIFwicGFsZWdvbGRlbnJvZFwiLCBcInBhbGVncmVlblwiLCBcInBhbGV0dXJxdW9pc2VcIiwgXCJwYWxldmlvbGV0cmVkXCIsXG4gICAgXCJwYXBheWF3aGlwXCIsIFwicGVhY2hwdWZmXCIsIFwicGVydVwiLCBcInBpbmtcIiwgXCJwbHVtXCIsIFwicG93ZGVyYmx1ZVwiLFxuICAgIFwicHVycGxlXCIsIFwicmViZWNjYXB1cnBsZVwiLCBcInJlZFwiLCBcInJvc3licm93blwiLCBcInJveWFsYmx1ZVwiLCBcInNhZGRsZWJyb3duXCIsXG4gICAgXCJzYWxtb25cIiwgXCJzYW5keWJyb3duXCIsIFwic2VhZ3JlZW5cIiwgXCJzZWFzaGVsbFwiLCBcInNpZW5uYVwiLCBcInNpbHZlclwiLCBcInNreWJsdWVcIixcbiAgICBcInNsYXRlYmx1ZVwiLCBcInNsYXRlZ3JheVwiLCBcInNub3dcIiwgXCJzcHJpbmdncmVlblwiLCBcInN0ZWVsYmx1ZVwiLCBcInRhblwiLFxuICAgIFwidGVhbFwiLCBcInRoaXN0bGVcIiwgXCJ0b21hdG9cIiwgXCJ0dXJxdW9pc2VcIiwgXCJ2aW9sZXRcIiwgXCJ3aGVhdFwiLCBcIndoaXRlXCIsXG4gICAgXCJ3aGl0ZXNtb2tlXCIsIFwieWVsbG93XCIsIFwieWVsbG93Z3JlZW5cIlxuXS5tYXAobmFtZSA9PiAoeyB0eXBlOiBcImNvbnN0YW50XCIsIGxhYmVsOiBuYW1lIH0pKSk7XG5jb25zdCB0YWdzID0gLypAX19QVVJFX18qL1tcbiAgICBcImFcIiwgXCJhYmJyXCIsIFwiYWRkcmVzc1wiLCBcImFydGljbGVcIiwgXCJhc2lkZVwiLCBcImJcIiwgXCJiZGlcIiwgXCJiZG9cIiwgXCJibG9ja3F1b3RlXCIsIFwiYm9keVwiLFxuICAgIFwiYnJcIiwgXCJidXR0b25cIiwgXCJjYW52YXNcIiwgXCJjYXB0aW9uXCIsIFwiY2l0ZVwiLCBcImNvZGVcIiwgXCJjb2xcIiwgXCJjb2xncm91cFwiLCBcImRkXCIsIFwiZGVsXCIsXG4gICAgXCJkZXRhaWxzXCIsIFwiZGZuXCIsIFwiZGlhbG9nXCIsIFwiZGl2XCIsIFwiZGxcIiwgXCJkdFwiLCBcImVtXCIsIFwiZmlnY2FwdGlvblwiLCBcImZpZ3VyZVwiLCBcImZvb3RlclwiLFxuICAgIFwiZm9ybVwiLCBcImhlYWRlclwiLCBcImhncm91cFwiLCBcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiLCBcImhyXCIsIFwiaHRtbFwiLCBcImlcIiwgXCJpZnJhbWVcIixcbiAgICBcImltZ1wiLCBcImlucHV0XCIsIFwiaW5zXCIsIFwia2JkXCIsIFwibGFiZWxcIiwgXCJsZWdlbmRcIiwgXCJsaVwiLCBcIm1haW5cIiwgXCJtZXRlclwiLCBcIm5hdlwiLCBcIm9sXCIsIFwib3V0cHV0XCIsXG4gICAgXCJwXCIsIFwicHJlXCIsIFwicnVieVwiLCBcInNlY3Rpb25cIiwgXCJzZWxlY3RcIiwgXCJzbWFsbFwiLCBcInNvdXJjZVwiLCBcInNwYW5cIiwgXCJzdHJvbmdcIiwgXCJzdWJcIiwgXCJzdW1tYXJ5XCIsXG4gICAgXCJzdXBcIiwgXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidGRcIiwgXCJ0ZW1wbGF0ZVwiLCBcInRleHRhcmVhXCIsIFwidGZvb3RcIiwgXCJ0aFwiLCBcInRoZWFkXCIsIFwidHJcIiwgXCJ1XCIsIFwidWxcIlxuXS5tYXAobmFtZSA9PiAoeyB0eXBlOiBcInR5cGVcIiwgbGFiZWw6IG5hbWUgfSkpO1xuY29uc3QgYXRSdWxlcyA9IC8qQF9fUFVSRV9fKi9bXG4gICAgXCJAY2hhcnNldFwiLCBcIkBjb2xvci1wcm9maWxlXCIsIFwiQGNvbnRhaW5lclwiLCBcIkBjb3VudGVyLXN0eWxlXCIsIFwiQGZvbnQtZmFjZVwiLCBcIkBmb250LWZlYXR1cmUtdmFsdWVzXCIsXG4gICAgXCJAZm9udC1wYWxldHRlLXZhbHVlc1wiLCBcIkBpbXBvcnRcIiwgXCJAa2V5ZnJhbWVzXCIsIFwiQGxheWVyXCIsIFwiQG1lZGlhXCIsIFwiQG5hbWVzcGFjZVwiLCBcIkBwYWdlXCIsXG4gICAgXCJAcG9zaXRpb24tdHJ5XCIsIFwiQHByb3BlcnR5XCIsIFwiQHNjb3BlXCIsIFwiQHN0YXJ0aW5nLXN0eWxlXCIsIFwiQHN1cHBvcnRzXCIsIFwiQHZpZXctdHJhbnNpdGlvblwiXG5dLm1hcChsYWJlbCA9PiAoeyB0eXBlOiBcImtleXdvcmRcIiwgbGFiZWwgfSkpO1xuY29uc3QgaWRlbnRpZmllciA9IC9eKFxcd1tcXHctXSp8LVxcd1tcXHctXSp8KSQvLCB2YXJpYWJsZSA9IC9eLSgtW1xcdy1dKik/JC87XG5mdW5jdGlvbiBpc1ZhckFyZyhub2RlLCBkb2MpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG5vZGUubmFtZSA9PSBcIihcIiB8fCBub2RlLnR5cGUuaXNFcnJvcilcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50IHx8IG5vZGU7XG4gICAgaWYgKG5vZGUubmFtZSAhPSBcIkFyZ0xpc3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjYWxsZWUgPSAoX2EgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpcnN0Q2hpbGQ7XG4gICAgaWYgKChjYWxsZWUgPT09IG51bGwgfHwgY2FsbGVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsZWUubmFtZSkgIT0gXCJDYWxsZWVcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBkb2Muc2xpY2VTdHJpbmcoY2FsbGVlLmZyb20sIGNhbGxlZS50bykgPT0gXCJ2YXJcIjtcbn1cbmNvbnN0IFZhcmlhYmxlc0J5Tm9kZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVdlYWtNYXAoKTtcbmNvbnN0IGRlY2xTZWxlY3RvciA9IFtcIkRlY2xhcmF0aW9uXCJdO1xuZnVuY3Rpb24gYXN0VG9wKG5vZGUpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOzspIHtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzVG9wKVxuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgaWYgKCEoY3VyID0gY3VyLnBhcmVudCkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YXJpYWJsZU5hbWVzKGRvYywgbm9kZSwgaXNWYXJpYWJsZSkge1xuICAgIGlmIChub2RlLnRvIC0gbm9kZS5mcm9tID4gNDA5Nikge1xuICAgICAgICBsZXQga25vd24gPSBWYXJpYWJsZXNCeU5vZGUuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoa25vd24pXG4gICAgICAgICAgICByZXR1cm4ga25vd247XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgc2VlbiA9IG5ldyBTZXQsIGN1cnNvciA9IG5vZGUuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpO1xuICAgICAgICBpZiAoY3Vyc29yLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgdmFyaWFibGVOYW1lcyhkb2MsIGN1cnNvci5ub2RlLCBpc1ZhcmlhYmxlKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhvcHRpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuLmFkZChvcHRpb24ubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICBWYXJpYWJsZXNCeU5vZGUuc2V0KG5vZGUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBuZXcgU2V0O1xuICAgICAgICBub2RlLmN1cnNvcigpLml0ZXJhdGUobm9kZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShub2RlKSAmJiBub2RlLm1hdGNoQ29udGV4dChkZWNsU2VsZWN0b3IpICYmICgoX2EgPSBub2RlLm5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZG9jLnNsaWNlU3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWVuLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBsYWJlbDogbmFtZSwgdHlwZTogXCJ2YXJpYWJsZVwiIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIHNvdXJjZSBmb3IgYSBDU1MgZGlhbGVjdCwgcHJvdmlkaW5nIGFcbnByZWRpY2F0ZSBmb3IgZGV0ZXJtaW5pbmcgd2hhdCBraW5kIG9mIHN5bnRheCBub2RlIGNhbiBhY3QgYXMgYVxuY29tcGxldGFibGUgdmFyaWFibGUuIFRoaXMgaXMgdXNlZCBieSBsYW5ndWFnZSBtb2RlcyBsaWtlIFNhc3MgYW5kXG5MZXNzIHRvIHJldXNlIHRoaXMgcGFja2FnZSdzIGNvbXBsZXRpb24gbG9naWMuXG4qL1xuY29uc3QgZGVmaW5lQ1NTQ29tcGxldGlvblNvdXJjZSA9IChpc1ZhcmlhYmxlKSA9PiBjb250ZXh0ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSwgcG9zIH0gPSBjb250ZXh0LCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIGxldCBpc0Rhc2ggPSBub2RlLnR5cGUuaXNFcnJvciAmJiBub2RlLmZyb20gPT0gbm9kZS50byAtIDEgJiYgc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50bykgPT0gXCItXCI7XG4gICAgaWYgKG5vZGUubmFtZSA9PSBcIlByb3BlcnR5TmFtZVwiIHx8XG4gICAgICAgIChpc0Rhc2ggfHwgbm9kZS5uYW1lID09IFwiVGFnTmFtZVwiKSAmJiAvXihCbG9ja3xTdHlsZXMpJC8udGVzdChub2RlLnJlc29sdmUobm9kZS50bykubmFtZSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IG5vZGUuZnJvbSwgb3B0aW9uczogcHJvcGVydGllcygpLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgIGlmIChub2RlLm5hbWUgPT0gXCJWYWx1ZU5hbWVcIilcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogbm9kZS5mcm9tLCBvcHRpb25zOiB2YWx1ZXMsIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgaWYgKG5vZGUubmFtZSA9PSBcIlBzZXVkb0NsYXNzTmFtZVwiKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBub2RlLmZyb20sIG9wdGlvbnM6IHBzZXVkb0NsYXNzZXMsIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgaWYgKGlzVmFyaWFibGUobm9kZSkgfHwgKGNvbnRleHQuZXhwbGljaXQgfHwgaXNEYXNoKSAmJiBpc1ZhckFyZyhub2RlLCBzdGF0ZS5kb2MpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBpc1ZhcmlhYmxlKG5vZGUpIHx8IGlzRGFzaCA/IG5vZGUuZnJvbSA6IHBvcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IHZhcmlhYmxlTmFtZXMoc3RhdGUuZG9jLCBhc3RUb3Aobm9kZSksIGlzVmFyaWFibGUpLFxuICAgICAgICAgICAgdmFsaWRGb3I6IHZhcmlhYmxlIH07XG4gICAgaWYgKG5vZGUubmFtZSA9PSBcIlRhZ05hbWVcIikge1xuICAgICAgICBmb3IgKGxldCB7IHBhcmVudCB9ID0gbm9kZTsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KVxuICAgICAgICAgICAgaWYgKHBhcmVudC5uYW1lID09IFwiQmxvY2tcIilcbiAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiBub2RlLmZyb20sIG9wdGlvbnM6IHByb3BlcnRpZXMoKSwgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogbm9kZS5mcm9tLCBvcHRpb25zOiB0YWdzLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgIH1cbiAgICBpZiAobm9kZS5uYW1lID09IFwiQXRLZXl3b3JkXCIpXG4gICAgICAgIHJldHVybiB7IGZyb206IG5vZGUuZnJvbSwgb3B0aW9uczogYXRSdWxlcywgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbiAgICBpZiAoIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhYm92ZSA9IG5vZGUucmVzb2x2ZShwb3MpLCBiZWZvcmUgPSBhYm92ZS5jaGlsZEJlZm9yZShwb3MpO1xuICAgIGlmIChiZWZvcmUgJiYgYmVmb3JlLm5hbWUgPT0gXCI6XCIgJiYgYWJvdmUubmFtZSA9PSBcIlBzZXVkb0NsYXNzU2VsZWN0b3JcIilcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogcG9zLCBvcHRpb25zOiBwc2V1ZG9DbGFzc2VzLCB2YWxpZEZvcjogaWRlbnRpZmllciB9O1xuICAgIGlmIChiZWZvcmUgJiYgYmVmb3JlLm5hbWUgPT0gXCI6XCIgJiYgYWJvdmUubmFtZSA9PSBcIkRlY2xhcmF0aW9uXCIgfHwgYWJvdmUubmFtZSA9PSBcIkFyZ0xpc3RcIilcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogcG9zLCBvcHRpb25zOiB2YWx1ZXMsIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgaWYgKGFib3ZlLm5hbWUgPT0gXCJCbG9ja1wiIHx8IGFib3ZlLm5hbWUgPT0gXCJTdHlsZXNcIilcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogcG9zLCBvcHRpb25zOiBwcm9wZXJ0aWVzKCksIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG5DU1MgcHJvcGVydHksIHZhcmlhYmxlLCBhbmQgdmFsdWUga2V5d29yZCBjb21wbGV0aW9uIHNvdXJjZS5cbiovXG5jb25zdCBjc3NDb21wbGV0aW9uU291cmNlID0gLypAX19QVVJFX18qL2RlZmluZUNTU0NvbXBsZXRpb25Tb3VyY2UobiA9PiBuLm5hbWUgPT0gXCJWYXJpYWJsZU5hbWVcIik7XG5cbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIENTU1xucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL2NzcyksIGV4dGVuZGVkIHdpdGhcbmhpZ2hsaWdodGluZyBhbmQgaW5kZW50YXRpb24gaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgY3NzTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9mb2xkTm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBcIkJsb2NrIEtleWZyYW1lTGlzdFwiOiBmb2xkSW5zaWRlXG4gICAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgfSksXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICAgIGNvbW1lbnRUb2tlbnM6IHsgYmxvY2s6IHsgb3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wiIH0gfSxcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqXFx9JC8sXG4gICAgICAgIHdvcmRDaGFyczogXCItXCJcbiAgICB9XG59KTtcbi8qKlxuTGFuZ3VhZ2Ugc3VwcG9ydCBmb3IgQ1NTLlxuKi9cbmZ1bmN0aW9uIGNzcygpIHtcbiAgICByZXR1cm4gbmV3IExhbmd1YWdlU3VwcG9ydChjc3NMYW5ndWFnZSwgY3NzTGFuZ3VhZ2UuZGF0YS5vZih7IGF1dG9jb21wbGV0ZTogY3NzQ29tcGxldGlvblNvdXJjZSB9KSk7XG59XG5cbmV4cG9ydCB7IGNzcywgY3NzQ29tcGxldGlvblNvdXJjZSwgY3NzTGFuZ3VhZ2UsIGRlZmluZUNTU0NvbXBsZXRpb25Tb3VyY2UgfTtcbiJdLCJuYW1lcyI6WyJwYXJzZXIiLCJzeW50YXhUcmVlIiwiTFJMYW5ndWFnZSIsImluZGVudE5vZGVQcm9wIiwiY29udGludWVkSW5kZW50IiwiZm9sZE5vZGVQcm9wIiwiZm9sZEluc2lkZSIsIkxhbmd1YWdlU3VwcG9ydCIsIk5vZGVXZWFrTWFwIiwiSXRlck1vZGUiLCJfcHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJkb2N1bWVudCIsImJvZHkiLCJzdHlsZSIsIm5hbWVzIiwic2VlbiIsIlNldCIsInByb3AiLCJ0ZXN0IiwicmVwbGFjZSIsImNoIiwidG9Mb3dlckNhc2UiLCJoYXMiLCJwdXNoIiwiYWRkIiwic29ydCIsIm1hcCIsIm5hbWUiLCJ0eXBlIiwibGFiZWwiLCJhcHBseSIsInBzZXVkb0NsYXNzZXMiLCJ2YWx1ZXMiLCJjb25jYXQiLCJ0YWdzIiwiYXRSdWxlcyIsImlkZW50aWZpZXIiLCJ2YXJpYWJsZSIsImlzVmFyQXJnIiwibm9kZSIsImRvYyIsIl9hIiwiaXNFcnJvciIsInBhcmVudCIsImNhbGxlZSIsImZpcnN0Q2hpbGQiLCJzbGljZVN0cmluZyIsImZyb20iLCJ0byIsIlZhcmlhYmxlc0J5Tm9kZSIsImRlY2xTZWxlY3RvciIsImFzdFRvcCIsImN1ciIsImlzVG9wIiwidmFyaWFibGVOYW1lcyIsImlzVmFyaWFibGUiLCJrbm93biIsImdldCIsInJlc3VsdCIsImN1cnNvciIsIkluY2x1ZGVBbm9ueW1vdXMiLCJvcHRpb24iLCJuZXh0U2libGluZyIsInNldCIsIml0ZXJhdGUiLCJtYXRjaENvbnRleHQiLCJkZWZpbmVDU1NDb21wbGV0aW9uU291cmNlIiwiY29udGV4dCIsInN0YXRlIiwicG9zIiwicmVzb2x2ZUlubmVyIiwiaXNEYXNoIiwicmVzb2x2ZSIsIm9wdGlvbnMiLCJ2YWxpZEZvciIsImV4cGxpY2l0IiwiYWJvdmUiLCJiZWZvcmUiLCJjaGlsZEJlZm9yZSIsImNzc0NvbXBsZXRpb25Tb3VyY2UiLCJuIiwiY3NzTGFuZ3VhZ2UiLCJkZWZpbmUiLCJjb25maWd1cmUiLCJwcm9wcyIsIkRlY2xhcmF0aW9uIiwibGFuZ3VhZ2VEYXRhIiwiY29tbWVudFRva2VucyIsImJsb2NrIiwib3BlbiIsImNsb3NlIiwiaW5kZW50T25JbnB1dCIsIndvcmRDaGFycyIsImNzcyIsImRhdGEiLCJvZiIsImF1dG9jb21wbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lang-css/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lang-html/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@codemirror/lang-html/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoCloseTags: () => (/* binding */ autoCloseTags),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   htmlCompletionSource: () => (/* binding */ htmlCompletionSource),\n/* harmony export */   htmlCompletionSourceWith: () => (/* binding */ htmlCompletionSourceWith),\n/* harmony export */   htmlLanguage: () => (/* binding */ htmlLanguage)\n/* harmony export */ });\n/* harmony import */ var _lezer_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/html */ \"(ssr)/./node_modules/@lezer/html/dist/index.js\");\n/* harmony import */ var _codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/lang-css */ \"(ssr)/./node_modules/@codemirror/lang-css/dist/index.js\");\n/* harmony import */ var _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/lang-javascript */ \"(ssr)/./node_modules/@codemirror/lang-javascript/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n\n\n\nconst Targets = [\n    \"_blank\",\n    \"_self\",\n    \"_top\",\n    \"_parent\"\n];\nconst Charsets = [\n    \"ascii\",\n    \"utf-8\",\n    \"utf-16\",\n    \"latin1\",\n    \"latin1\"\n];\nconst Methods = [\n    \"get\",\n    \"post\",\n    \"put\",\n    \"delete\"\n];\nconst Encs = [\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n];\nconst Bool = [\n    \"true\",\n    \"false\"\n];\nconst S = {}; // Empty tag spec\nconst Tags = {\n    a: {\n        attrs: {\n            href: null,\n            ping: null,\n            type: null,\n            media: null,\n            target: Targets,\n            hreflang: null\n        }\n    },\n    abbr: S,\n    address: S,\n    area: {\n        attrs: {\n            alt: null,\n            coords: null,\n            href: null,\n            target: null,\n            ping: null,\n            media: null,\n            hreflang: null,\n            type: null,\n            shape: [\n                \"default\",\n                \"rect\",\n                \"circle\",\n                \"poly\"\n            ]\n        }\n    },\n    article: S,\n    aside: S,\n    audio: {\n        attrs: {\n            src: null,\n            mediagroup: null,\n            crossorigin: [\n                \"anonymous\",\n                \"use-credentials\"\n            ],\n            preload: [\n                \"none\",\n                \"metadata\",\n                \"auto\"\n            ],\n            autoplay: [\n                \"autoplay\"\n            ],\n            loop: [\n                \"loop\"\n            ],\n            controls: [\n                \"controls\"\n            ]\n        }\n    },\n    b: S,\n    base: {\n        attrs: {\n            href: null,\n            target: Targets\n        }\n    },\n    bdi: S,\n    bdo: S,\n    blockquote: {\n        attrs: {\n            cite: null\n        }\n    },\n    body: S,\n    br: S,\n    button: {\n        attrs: {\n            form: null,\n            formaction: null,\n            name: null,\n            value: null,\n            autofocus: [\n                \"autofocus\"\n            ],\n            disabled: [\n                \"autofocus\"\n            ],\n            formenctype: Encs,\n            formmethod: Methods,\n            formnovalidate: [\n                \"novalidate\"\n            ],\n            formtarget: Targets,\n            type: [\n                \"submit\",\n                \"reset\",\n                \"button\"\n            ]\n        }\n    },\n    canvas: {\n        attrs: {\n            width: null,\n            height: null\n        }\n    },\n    caption: S,\n    center: S,\n    cite: S,\n    code: S,\n    col: {\n        attrs: {\n            span: null\n        }\n    },\n    colgroup: {\n        attrs: {\n            span: null\n        }\n    },\n    command: {\n        attrs: {\n            type: [\n                \"command\",\n                \"checkbox\",\n                \"radio\"\n            ],\n            label: null,\n            icon: null,\n            radiogroup: null,\n            command: null,\n            title: null,\n            disabled: [\n                \"disabled\"\n            ],\n            checked: [\n                \"checked\"\n            ]\n        }\n    },\n    data: {\n        attrs: {\n            value: null\n        }\n    },\n    datagrid: {\n        attrs: {\n            disabled: [\n                \"disabled\"\n            ],\n            multiple: [\n                \"multiple\"\n            ]\n        }\n    },\n    datalist: {\n        attrs: {\n            data: null\n        }\n    },\n    dd: S,\n    del: {\n        attrs: {\n            cite: null,\n            datetime: null\n        }\n    },\n    details: {\n        attrs: {\n            open: [\n                \"open\"\n            ]\n        }\n    },\n    dfn: S,\n    div: S,\n    dl: S,\n    dt: S,\n    em: S,\n    embed: {\n        attrs: {\n            src: null,\n            type: null,\n            width: null,\n            height: null\n        }\n    },\n    eventsource: {\n        attrs: {\n            src: null\n        }\n    },\n    fieldset: {\n        attrs: {\n            disabled: [\n                \"disabled\"\n            ],\n            form: null,\n            name: null\n        }\n    },\n    figcaption: S,\n    figure: S,\n    footer: S,\n    form: {\n        attrs: {\n            action: null,\n            name: null,\n            \"accept-charset\": Charsets,\n            autocomplete: [\n                \"on\",\n                \"off\"\n            ],\n            enctype: Encs,\n            method: Methods,\n            novalidate: [\n                \"novalidate\"\n            ],\n            target: Targets\n        }\n    },\n    h1: S,\n    h2: S,\n    h3: S,\n    h4: S,\n    h5: S,\n    h6: S,\n    head: {\n        children: [\n            \"title\",\n            \"base\",\n            \"link\",\n            \"style\",\n            \"meta\",\n            \"script\",\n            \"noscript\",\n            \"command\"\n        ]\n    },\n    header: S,\n    hgroup: S,\n    hr: S,\n    html: {\n        attrs: {\n            manifest: null\n        }\n    },\n    i: S,\n    iframe: {\n        attrs: {\n            src: null,\n            srcdoc: null,\n            name: null,\n            width: null,\n            height: null,\n            sandbox: [\n                \"allow-top-navigation\",\n                \"allow-same-origin\",\n                \"allow-forms\",\n                \"allow-scripts\"\n            ],\n            seamless: [\n                \"seamless\"\n            ]\n        }\n    },\n    img: {\n        attrs: {\n            alt: null,\n            src: null,\n            ismap: null,\n            usemap: null,\n            width: null,\n            height: null,\n            crossorigin: [\n                \"anonymous\",\n                \"use-credentials\"\n            ]\n        }\n    },\n    input: {\n        attrs: {\n            alt: null,\n            dirname: null,\n            form: null,\n            formaction: null,\n            height: null,\n            list: null,\n            max: null,\n            maxlength: null,\n            min: null,\n            name: null,\n            pattern: null,\n            placeholder: null,\n            size: null,\n            src: null,\n            step: null,\n            value: null,\n            width: null,\n            accept: [\n                \"audio/*\",\n                \"video/*\",\n                \"image/*\"\n            ],\n            autocomplete: [\n                \"on\",\n                \"off\"\n            ],\n            autofocus: [\n                \"autofocus\"\n            ],\n            checked: [\n                \"checked\"\n            ],\n            disabled: [\n                \"disabled\"\n            ],\n            formenctype: Encs,\n            formmethod: Methods,\n            formnovalidate: [\n                \"novalidate\"\n            ],\n            formtarget: Targets,\n            multiple: [\n                \"multiple\"\n            ],\n            readonly: [\n                \"readonly\"\n            ],\n            required: [\n                \"required\"\n            ],\n            type: [\n                \"hidden\",\n                \"text\",\n                \"search\",\n                \"tel\",\n                \"url\",\n                \"email\",\n                \"password\",\n                \"datetime\",\n                \"date\",\n                \"month\",\n                \"week\",\n                \"time\",\n                \"datetime-local\",\n                \"number\",\n                \"range\",\n                \"color\",\n                \"checkbox\",\n                \"radio\",\n                \"file\",\n                \"submit\",\n                \"image\",\n                \"reset\",\n                \"button\"\n            ]\n        }\n    },\n    ins: {\n        attrs: {\n            cite: null,\n            datetime: null\n        }\n    },\n    kbd: S,\n    keygen: {\n        attrs: {\n            challenge: null,\n            form: null,\n            name: null,\n            autofocus: [\n                \"autofocus\"\n            ],\n            disabled: [\n                \"disabled\"\n            ],\n            keytype: [\n                \"RSA\"\n            ]\n        }\n    },\n    label: {\n        attrs: {\n            for: null,\n            form: null\n        }\n    },\n    legend: S,\n    li: {\n        attrs: {\n            value: null\n        }\n    },\n    link: {\n        attrs: {\n            href: null,\n            type: null,\n            hreflang: null,\n            media: null,\n            sizes: [\n                \"all\",\n                \"16x16\",\n                \"16x16 32x32\",\n                \"16x16 32x32 64x64\"\n            ]\n        }\n    },\n    map: {\n        attrs: {\n            name: null\n        }\n    },\n    mark: S,\n    menu: {\n        attrs: {\n            label: null,\n            type: [\n                \"list\",\n                \"context\",\n                \"toolbar\"\n            ]\n        }\n    },\n    meta: {\n        attrs: {\n            content: null,\n            charset: Charsets,\n            name: [\n                \"viewport\",\n                \"application-name\",\n                \"author\",\n                \"description\",\n                \"generator\",\n                \"keywords\"\n            ],\n            \"http-equiv\": [\n                \"content-language\",\n                \"content-type\",\n                \"default-style\",\n                \"refresh\"\n            ]\n        }\n    },\n    meter: {\n        attrs: {\n            value: null,\n            min: null,\n            low: null,\n            high: null,\n            max: null,\n            optimum: null\n        }\n    },\n    nav: S,\n    noscript: S,\n    object: {\n        attrs: {\n            data: null,\n            type: null,\n            name: null,\n            usemap: null,\n            form: null,\n            width: null,\n            height: null,\n            typemustmatch: [\n                \"typemustmatch\"\n            ]\n        }\n    },\n    ol: {\n        attrs: {\n            reversed: [\n                \"reversed\"\n            ],\n            start: null,\n            type: [\n                \"1\",\n                \"a\",\n                \"A\",\n                \"i\",\n                \"I\"\n            ]\n        },\n        children: [\n            \"li\",\n            \"script\",\n            \"template\",\n            \"ul\",\n            \"ol\"\n        ]\n    },\n    optgroup: {\n        attrs: {\n            disabled: [\n                \"disabled\"\n            ],\n            label: null\n        }\n    },\n    option: {\n        attrs: {\n            disabled: [\n                \"disabled\"\n            ],\n            label: null,\n            selected: [\n                \"selected\"\n            ],\n            value: null\n        }\n    },\n    output: {\n        attrs: {\n            for: null,\n            form: null,\n            name: null\n        }\n    },\n    p: S,\n    param: {\n        attrs: {\n            name: null,\n            value: null\n        }\n    },\n    pre: S,\n    progress: {\n        attrs: {\n            value: null,\n            max: null\n        }\n    },\n    q: {\n        attrs: {\n            cite: null\n        }\n    },\n    rp: S,\n    rt: S,\n    ruby: S,\n    samp: S,\n    script: {\n        attrs: {\n            type: [\n                \"text/javascript\"\n            ],\n            src: null,\n            async: [\n                \"async\"\n            ],\n            defer: [\n                \"defer\"\n            ],\n            charset: Charsets\n        }\n    },\n    section: S,\n    select: {\n        attrs: {\n            form: null,\n            name: null,\n            size: null,\n            autofocus: [\n                \"autofocus\"\n            ],\n            disabled: [\n                \"disabled\"\n            ],\n            multiple: [\n                \"multiple\"\n            ]\n        }\n    },\n    slot: {\n        attrs: {\n            name: null\n        }\n    },\n    small: S,\n    source: {\n        attrs: {\n            src: null,\n            type: null,\n            media: null\n        }\n    },\n    span: S,\n    strong: S,\n    style: {\n        attrs: {\n            type: [\n                \"text/css\"\n            ],\n            media: null,\n            scoped: null\n        }\n    },\n    sub: S,\n    summary: S,\n    sup: S,\n    table: S,\n    tbody: S,\n    td: {\n        attrs: {\n            colspan: null,\n            rowspan: null,\n            headers: null\n        }\n    },\n    template: S,\n    textarea: {\n        attrs: {\n            dirname: null,\n            form: null,\n            maxlength: null,\n            name: null,\n            placeholder: null,\n            rows: null,\n            cols: null,\n            autofocus: [\n                \"autofocus\"\n            ],\n            disabled: [\n                \"disabled\"\n            ],\n            readonly: [\n                \"readonly\"\n            ],\n            required: [\n                \"required\"\n            ],\n            wrap: [\n                \"soft\",\n                \"hard\"\n            ]\n        }\n    },\n    tfoot: S,\n    th: {\n        attrs: {\n            colspan: null,\n            rowspan: null,\n            headers: null,\n            scope: [\n                \"row\",\n                \"col\",\n                \"rowgroup\",\n                \"colgroup\"\n            ]\n        }\n    },\n    thead: S,\n    time: {\n        attrs: {\n            datetime: null\n        }\n    },\n    title: S,\n    tr: S,\n    track: {\n        attrs: {\n            src: null,\n            label: null,\n            default: null,\n            kind: [\n                \"subtitles\",\n                \"captions\",\n                \"descriptions\",\n                \"chapters\",\n                \"metadata\"\n            ],\n            srclang: null\n        }\n    },\n    ul: {\n        children: [\n            \"li\",\n            \"script\",\n            \"template\",\n            \"ul\",\n            \"ol\"\n        ]\n    },\n    var: S,\n    video: {\n        attrs: {\n            src: null,\n            poster: null,\n            width: null,\n            height: null,\n            crossorigin: [\n                \"anonymous\",\n                \"use-credentials\"\n            ],\n            preload: [\n                \"auto\",\n                \"metadata\",\n                \"none\"\n            ],\n            autoplay: [\n                \"autoplay\"\n            ],\n            mediagroup: [\n                \"movie\"\n            ],\n            muted: [\n                \"muted\"\n            ],\n            controls: [\n                \"controls\"\n            ]\n        }\n    },\n    wbr: S\n};\nconst GlobalAttrs = {\n    accesskey: null,\n    class: null,\n    contenteditable: Bool,\n    contextmenu: null,\n    dir: [\n        \"ltr\",\n        \"rtl\",\n        \"auto\"\n    ],\n    draggable: [\n        \"true\",\n        \"false\",\n        \"auto\"\n    ],\n    dropzone: [\n        \"copy\",\n        \"move\",\n        \"link\",\n        \"string:\",\n        \"file:\"\n    ],\n    hidden: [\n        \"hidden\"\n    ],\n    id: null,\n    inert: [\n        \"inert\"\n    ],\n    itemid: null,\n    itemprop: null,\n    itemref: null,\n    itemscope: [\n        \"itemscope\"\n    ],\n    itemtype: null,\n    lang: [\n        \"ar\",\n        \"bn\",\n        \"de\",\n        \"en-GB\",\n        \"en-US\",\n        \"es\",\n        \"fr\",\n        \"hi\",\n        \"id\",\n        \"ja\",\n        \"pa\",\n        \"pt\",\n        \"ru\",\n        \"tr\",\n        \"zh\"\n    ],\n    spellcheck: Bool,\n    autocorrect: Bool,\n    autocapitalize: Bool,\n    style: null,\n    tabindex: null,\n    title: null,\n    translate: [\n        \"yes\",\n        \"no\"\n    ],\n    rel: [\n        \"stylesheet\",\n        \"alternate\",\n        \"author\",\n        \"bookmark\",\n        \"help\",\n        \"license\",\n        \"next\",\n        \"nofollow\",\n        \"noreferrer\",\n        \"prefetch\",\n        \"prev\",\n        \"search\",\n        \"tag\"\n    ],\n    role: /*@__PURE__*/ \"alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer\".split(\" \"),\n    \"aria-activedescendant\": null,\n    \"aria-atomic\": Bool,\n    \"aria-autocomplete\": [\n        \"inline\",\n        \"list\",\n        \"both\",\n        \"none\"\n    ],\n    \"aria-busy\": Bool,\n    \"aria-checked\": [\n        \"true\",\n        \"false\",\n        \"mixed\",\n        \"undefined\"\n    ],\n    \"aria-controls\": null,\n    \"aria-describedby\": null,\n    \"aria-disabled\": Bool,\n    \"aria-dropeffect\": null,\n    \"aria-expanded\": [\n        \"true\",\n        \"false\",\n        \"undefined\"\n    ],\n    \"aria-flowto\": null,\n    \"aria-grabbed\": [\n        \"true\",\n        \"false\",\n        \"undefined\"\n    ],\n    \"aria-haspopup\": Bool,\n    \"aria-hidden\": Bool,\n    \"aria-invalid\": [\n        \"true\",\n        \"false\",\n        \"grammar\",\n        \"spelling\"\n    ],\n    \"aria-label\": null,\n    \"aria-labelledby\": null,\n    \"aria-level\": null,\n    \"aria-live\": [\n        \"off\",\n        \"polite\",\n        \"assertive\"\n    ],\n    \"aria-multiline\": Bool,\n    \"aria-multiselectable\": Bool,\n    \"aria-owns\": null,\n    \"aria-posinset\": null,\n    \"aria-pressed\": [\n        \"true\",\n        \"false\",\n        \"mixed\",\n        \"undefined\"\n    ],\n    \"aria-readonly\": Bool,\n    \"aria-relevant\": null,\n    \"aria-required\": Bool,\n    \"aria-selected\": [\n        \"true\",\n        \"false\",\n        \"undefined\"\n    ],\n    \"aria-setsize\": null,\n    \"aria-sort\": [\n        \"ascending\",\n        \"descending\",\n        \"none\",\n        \"other\"\n    ],\n    \"aria-valuemax\": null,\n    \"aria-valuemin\": null,\n    \"aria-valuenow\": null,\n    \"aria-valuetext\": null\n};\nconst eventAttributes = /*@__PURE__*/ (\"beforeunload copy cut dragstart dragover dragleave dragenter dragend \" + \"drag paste focus blur change click load mousedown mouseenter mouseleave \" + \"mouseup keydown keyup resize scroll unload\").split(\" \").map((n)=>\"on\" + n);\nfor (let a of eventAttributes)GlobalAttrs[a] = null;\nclass Schema {\n    constructor(extraTags, extraAttrs){\n        this.tags = {\n            ...Tags,\n            ...extraTags\n        };\n        this.globalAttrs = {\n            ...GlobalAttrs,\n            ...extraAttrs\n        };\n        this.allTags = Object.keys(this.tags);\n        this.globalAttrNames = Object.keys(this.globalAttrs);\n    }\n}\nSchema.default = /*@__PURE__*/ new Schema;\nfunction elementName(doc, tree, max = doc.length) {\n    if (!tree) return \"\";\n    let tag = tree.firstChild;\n    let name = tag && tag.getChild(\"TagName\");\n    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : \"\";\n}\nfunction findParentElement(tree, skip = false) {\n    for(; tree; tree = tree.parent)if (tree.name == \"Element\") {\n        if (skip) skip = false;\n        else return tree;\n    }\n    return null;\n}\nfunction allowedChildren(doc, tree, schema) {\n    let parentInfo = schema.tags[elementName(doc, findParentElement(tree))];\n    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;\n}\nfunction openTags(doc, tree) {\n    let open = [];\n    for(let parent = findParentElement(tree); parent && !parent.type.isTop; parent = findParentElement(parent.parent)){\n        let tagName = elementName(doc, parent);\n        if (tagName && parent.lastChild.name == \"CloseTag\") break;\n        if (tagName && open.indexOf(tagName) < 0 && (tree.name == \"EndTag\" || tree.from >= parent.firstChild.to)) open.push(tagName);\n    }\n    return open;\n}\nconst identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction completeTag(state, schema, tree, from, to) {\n    let end = /\\s*>/.test(state.sliceDoc(to, to + 5)) ? \"\" : \">\";\n    let parent = findParentElement(tree, tree.name == \"StartTag\" || tree.name == \"TagName\");\n    return {\n        from,\n        to,\n        options: allowedChildren(state.doc, parent, schema).map((tagName)=>({\n                label: tagName,\n                type: \"type\"\n            })).concat(openTags(state.doc, tree).map((tag, i)=>({\n                label: \"/\" + tag,\n                apply: \"/\" + tag + end,\n                type: \"type\",\n                boost: 99 - i\n            }))),\n        validFor: /^\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nfunction completeCloseTag(state, tree, from, to) {\n    let end = /\\s*>/.test(state.sliceDoc(to, to + 5)) ? \"\" : \">\";\n    return {\n        from,\n        to,\n        options: openTags(state.doc, tree).map((tag, i)=>({\n                label: tag,\n                apply: tag + end,\n                type: \"type\",\n                boost: 99 - i\n            })),\n        validFor: identifier\n    };\n}\nfunction completeStartTag(state, schema, tree, pos) {\n    let options = [], level = 0;\n    for (let tagName of allowedChildren(state.doc, tree, schema))options.push({\n        label: \"<\" + tagName,\n        type: \"type\"\n    });\n    for (let open of openTags(state.doc, tree))options.push({\n        label: \"</\" + open + \">\",\n        type: \"type\",\n        boost: 99 - level++\n    });\n    return {\n        from: pos,\n        to: pos,\n        options,\n        validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nfunction completeAttrName(state, schema, tree, from, to) {\n    let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;\n    let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];\n    let names = info && info.globalAttrs === false ? localAttrs : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;\n    return {\n        from,\n        to,\n        options: names.map((attrName)=>({\n                label: attrName,\n                type: \"property\"\n            })),\n        validFor: identifier\n    };\n}\nfunction completeAttrValue(state, schema, tree, from, to) {\n    var _a;\n    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild(\"AttributeName\");\n    let options = [], token = undefined;\n    if (nameNode) {\n        let attrName = state.sliceDoc(nameNode.from, nameNode.to);\n        let attrs = schema.globalAttrs[attrName];\n        if (!attrs) {\n            let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;\n            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];\n        }\n        if (attrs) {\n            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '\"', quoteEnd = '\"';\n            if (/^['\"]/.test(base)) {\n                token = base[0] == '\"' ? /^[^\"]*$/ : /^[^']*$/;\n                quoteStart = \"\";\n                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? \"\" : base[0];\n                base = base.slice(1);\n                from++;\n            } else {\n                token = /^[^\\s<>='\"]*$/;\n            }\n            for (let value of attrs)options.push({\n                label: value,\n                apply: quoteStart + value + quoteEnd,\n                type: \"constant\"\n            });\n        }\n    }\n    return {\n        from,\n        to,\n        options,\n        validFor: token\n    };\n}\nfunction htmlCompletionFor(schema, context) {\n    let { state, pos } = context, tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.syntaxTree)(state).resolveInner(pos, -1), around = tree.resolve(pos);\n    for(let scan = pos, before; around == tree && (before = tree.childBefore(scan));){\n        let last = before.lastChild;\n        if (!last || !last.type.isError || last.from < last.to) break;\n        around = tree = before;\n        scan = last.from;\n    }\n    if (tree.name == \"TagName\") {\n        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos) : completeTag(state, schema, tree, tree.from, pos);\n    } else if (tree.name == \"StartTag\" || tree.name == \"IncompleteTag\") {\n        return completeTag(state, schema, tree, pos, pos);\n    } else if (tree.name == \"StartCloseTag\" || tree.name == \"IncompleteCloseTag\") {\n        return completeCloseTag(state, tree, pos, pos);\n    } else if (tree.name == \"OpenTag\" || tree.name == \"SelfClosingTag\" || tree.name == \"AttributeName\") {\n        return completeAttrName(state, schema, tree, tree.name == \"AttributeName\" ? tree.from : pos, pos);\n    } else if (tree.name == \"Is\" || tree.name == \"AttributeValue\" || tree.name == \"UnquotedAttributeValue\") {\n        return completeAttrValue(state, schema, tree, tree.name == \"Is\" ? pos : tree.from, pos);\n    } else if (context.explicit && (around.name == \"Element\" || around.name == \"Text\" || around.name == \"Document\")) {\n        return completeStartTag(state, schema, tree, pos);\n    } else {\n        return null;\n    }\n}\n/**\nHTML tag completion. Opens and closes tags and attributes in a\ncontext-aware way.\n*/ function htmlCompletionSource(context) {\n    return htmlCompletionFor(Schema.default, context);\n}\n/**\nCreate a completion source for HTML extended with additional tags\nor attributes.\n*/ function htmlCompletionSourceWith(config) {\n    let { extraTags, extraGlobalAttributes: extraAttrs } = config;\n    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;\n    return (context)=>htmlCompletionFor(schema, context);\n}\nconst jsonParser = /*@__PURE__*/ _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascriptLanguage.parser.configure({\n    top: \"SingleExpression\"\n});\nconst defaultNesting = [\n    {\n        tag: \"script\",\n        attrs: (attrs)=>attrs.type == \"text/typescript\" || attrs.lang == \"ts\",\n        parser: _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.typescriptLanguage.parser\n    },\n    {\n        tag: \"script\",\n        attrs: (attrs)=>attrs.type == \"text/babel\" || attrs.type == \"text/jsx\",\n        parser: _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.jsxLanguage.parser\n    },\n    {\n        tag: \"script\",\n        attrs: (attrs)=>attrs.type == \"text/typescript-jsx\",\n        parser: _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.tsxLanguage.parser\n    },\n    {\n        tag: \"script\",\n        attrs (attrs) {\n            return /^(importmap|speculationrules|application\\/(.+\\+)?json)$/i.test(attrs.type);\n        },\n        parser: jsonParser\n    },\n    {\n        tag: \"script\",\n        attrs (attrs) {\n            return !attrs.type || /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);\n        },\n        parser: _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascriptLanguage.parser\n    },\n    {\n        tag: \"style\",\n        attrs (attrs) {\n            return (!attrs.lang || attrs.lang == \"css\") && (!attrs.type || /^(text\\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));\n        },\n        parser: _codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__.cssLanguage.parser\n    }\n];\nconst defaultAttrs = /*@__PURE__*/ [\n    {\n        name: \"style\",\n        parser: /*@__PURE__*/ _codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__.cssLanguage.parser.configure({\n            top: \"Styles\"\n        })\n    }\n].concat(/*@__PURE__*/ eventAttributes.map((name)=>({\n        name,\n        parser: _codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascriptLanguage.parser\n    })));\nconst htmlPlain = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LRLanguage.define({\n    name: \"html\",\n    parser: /*@__PURE__*/ _lezer_html__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.indentNodeProp.add({\n                Element (context) {\n                    let after = /^(\\s*)(<\\/)?/.exec(context.textAfter);\n                    if (context.node.to <= context.pos + after[0].length) return context.continue();\n                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);\n                },\n                \"OpenTag CloseTag SelfClosingTag\" (context) {\n                    return context.column(context.node.from) + context.unit;\n                },\n                Document (context) {\n                    if (context.pos + /\\s*/.exec(context.textAfter)[0].length < context.node.to) return context.continue();\n                    let endElt = null, close;\n                    for(let cur = context.node;;){\n                        let last = cur.lastChild;\n                        if (!last || last.name != \"Element\" || last.to != cur.to) break;\n                        endElt = cur = last;\n                    }\n                    if (endElt && !((close = endElt.lastChild) && (close.name == \"CloseTag\" || close.name == \"SelfClosingTag\"))) return context.lineIndent(endElt.from) + context.unit;\n                    return null;\n                }\n            }),\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.foldNodeProp.add({\n                Element (node) {\n                    let first = node.firstChild, last = node.lastChild;\n                    if (!first || first.name != \"OpenTag\") return null;\n                    return {\n                        from: first.to,\n                        to: last.name == \"CloseTag\" ? last.from : node.to\n                    };\n                }\n            }),\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.bracketMatchingHandle.add({\n                \"OpenTag CloseTag\": (node)=>node.getChild(\"TagName\")\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: {\n            block: {\n                open: \"<!--\",\n                close: \"-->\"\n            }\n        },\n        indentOnInput: /^\\s*<\\/\\w+\\W$/,\n        wordChars: \"-_\"\n    }\n});\n/**\nA language provider based on the [Lezer HTML\nparser](https://github.com/lezer-parser/html), extended with the\nJavaScript and CSS parsers to parse the content of `<script>` and\n`<style>` tags.\n*/ const htmlLanguage = /*@__PURE__*/ htmlPlain.configure({\n    wrap: /*@__PURE__*/ (0,_lezer_html__WEBPACK_IMPORTED_MODULE_0__.configureNesting)(defaultNesting, defaultAttrs)\n});\n/**\nLanguage support for HTML, including\n[`htmlCompletion`](https://codemirror.net/6/docs/ref/#lang-html.htmlCompletion) and JavaScript and\nCSS support extensions.\n*/ function html(config = {}) {\n    let dialect = \"\", wrap;\n    if (config.matchClosingTags === false) dialect = \"noMatch\";\n    if (config.selfClosingTags === true) dialect = (dialect ? dialect + \" \" : \"\") + \"selfClosing\";\n    if (config.nestedLanguages && config.nestedLanguages.length || config.nestedAttributes && config.nestedAttributes.length) wrap = (0,_lezer_html__WEBPACK_IMPORTED_MODULE_0__.configureNesting)((config.nestedLanguages || []).concat(defaultNesting), (config.nestedAttributes || []).concat(defaultAttrs));\n    let lang = wrap ? htmlPlain.configure({\n        wrap,\n        dialect\n    }) : dialect ? htmlLanguage.configure({\n        dialect\n    }) : htmlLanguage;\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LanguageSupport(lang, [\n        htmlLanguage.data.of({\n            autocomplete: htmlCompletionSourceWith(config)\n        }),\n        config.autoCloseTags !== false ? autoCloseTags : [],\n        (0,_codemirror_lang_javascript__WEBPACK_IMPORTED_MODULE_2__.javascript)().support,\n        (0,_codemirror_lang_css__WEBPACK_IMPORTED_MODULE_3__.css)().support\n    ]);\n}\nconst selfClosers = /*@__PURE__*/ new Set(/*@__PURE__*/ \"area base br col command embed frame hr img input keygen link meta param source track wbr menuitem\".split(\" \"));\n/**\nExtension that will automatically insert close tags when a `>` or\n`/` is typed.\n*/ const autoCloseTags = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.inputHandler.of((view, from, to, text, insertTransaction)=>{\n    if (view.composing || view.state.readOnly || from != to || text != \">\" && text != \"/\" || !htmlLanguage.isActiveAt(view.state, from, -1)) return false;\n    let base = insertTransaction(), { state } = base;\n    let closeTags = state.changeByRange((range)=>{\n        var _a, _b, _c;\n        let didType = state.doc.sliceString(range.from - 1, range.to) == text;\n        let { head } = range, after = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.syntaxTree)(state).resolveInner(head, -1), name;\n        if (didType && text == \">\" && after.name == \"EndTag\") {\n            let tag = after.parent;\n            if (((_b = (_a = tag.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != \"CloseTag\" && (name = elementName(state.doc, tag.parent, head)) && !selfClosers.has(name)) {\n                let to = head + (state.doc.sliceString(head, head + 1) === \">\" ? 1 : 0);\n                let insert = `</${name}>`;\n                return {\n                    range,\n                    changes: {\n                        from: head,\n                        to,\n                        insert\n                    }\n                };\n            }\n        } else if (didType && text == \"/\" && after.name == \"IncompleteCloseTag\") {\n            let tag = after.parent;\n            if (after.from == head - 2 && ((_c = tag.lastChild) === null || _c === void 0 ? void 0 : _c.name) != \"CloseTag\" && (name = elementName(state.doc, tag, head)) && !selfClosers.has(name)) {\n                let to = head + (state.doc.sliceString(head, head + 1) === \">\" ? 1 : 0);\n                let insert = `${name}>`;\n                return {\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + insert.length, -1),\n                    changes: {\n                        from: head,\n                        to,\n                        insert\n                    }\n                };\n            }\n        }\n        return {\n            range\n        };\n    });\n    if (closeTags.changes.empty) return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, {\n            userEvent: \"input.complete\",\n            scrollIntoView: true\n        })\n    ]);\n    return true;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1odG1sL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDQztBQUNtRTtBQUM3RTtBQUNNO0FBQ2dGO0FBRXBJLE1BQU1pQixVQUFVO0lBQUM7SUFBVTtJQUFTO0lBQVE7Q0FBVTtBQUN0RCxNQUFNQyxXQUFXO0lBQUM7SUFBUztJQUFTO0lBQVU7SUFBVTtDQUFTO0FBQ2pFLE1BQU1DLFVBQVU7SUFBQztJQUFPO0lBQVE7SUFBTztDQUFTO0FBQ2hELE1BQU1DLE9BQU87SUFBQztJQUFxQztJQUF1QjtDQUFhO0FBQ3ZGLE1BQU1DLE9BQU87SUFBQztJQUFRO0NBQVE7QUFDOUIsTUFBTUMsSUFBSSxDQUFDLEdBQUcsaUJBQWlCO0FBQy9CLE1BQU1DLE9BQU87SUFDVEMsR0FBRztRQUNDQyxPQUFPO1lBQ0hDLE1BQU07WUFBTUMsTUFBTTtZQUFNQyxNQUFNO1lBQzlCQyxPQUFPO1lBQ1BDLFFBQVFiO1lBQ1JjLFVBQVU7UUFDZDtJQUNKO0lBQ0FDLE1BQU1WO0lBQ05XLFNBQVNYO0lBQ1RZLE1BQU07UUFDRlQsT0FBTztZQUNIVSxLQUFLO1lBQU1DLFFBQVE7WUFBTVYsTUFBTTtZQUFNSSxRQUFRO1lBQU1ILE1BQU07WUFDekRFLE9BQU87WUFBTUUsVUFBVTtZQUFNSCxNQUFNO1lBQ25DUyxPQUFPO2dCQUFDO2dCQUFXO2dCQUFRO2dCQUFVO2FBQU87UUFDaEQ7SUFDSjtJQUNBQyxTQUFTaEI7SUFDVGlCLE9BQU9qQjtJQUNQa0IsT0FBTztRQUNIZixPQUFPO1lBQ0hnQixLQUFLO1lBQU1DLFlBQVk7WUFDdkJDLGFBQWE7Z0JBQUM7Z0JBQWE7YUFBa0I7WUFDN0NDLFNBQVM7Z0JBQUM7Z0JBQVE7Z0JBQVk7YUFBTztZQUNyQ0MsVUFBVTtnQkFBQzthQUFXO1lBQ3RCQyxNQUFNO2dCQUFDO2FBQU87WUFDZEMsVUFBVTtnQkFBQzthQUFXO1FBQzFCO0lBQ0o7SUFD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SUYsVUFBVVEsT0FBTyxDQUFDRSxLQUFLLEVBQ3ZCLE9BQU87SUFDWGhCLEtBQUtpQixRQUFRLENBQUM7UUFDVi9VO1FBQ0EyTyxNQUFNcUcsTUFBTSxDQUFDWixXQUFXO1lBQ3BCYSxXQUFXO1lBQ1hDLGdCQUFnQjtRQUNwQjtLQUNIO0lBQ0QsT0FBTztBQUNYO0FBRTZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm5jb2RlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmctaHRtbC9kaXN0L2luZGV4LmpzP2M2MGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VyLCBjb25maWd1cmVOZXN0aW5nIH0gZnJvbSAnQGxlemVyL2h0bWwnO1xuaW1wb3J0IHsgY3NzTGFuZ3VhZ2UsIGNzcyB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmctY3NzJztcbmltcG9ydCB7IGphdmFzY3JpcHRMYW5ndWFnZSwgdHlwZXNjcmlwdExhbmd1YWdlLCBqc3hMYW5ndWFnZSwgdHN4TGFuZ3VhZ2UsIGphdmFzY3JpcHQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGZvbGROb2RlUHJvcCwgYnJhY2tldE1hdGNoaW5nSGFuZGxlLCBMYW5ndWFnZVN1cHBvcnQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5cbmNvbnN0IFRhcmdldHMgPSBbXCJfYmxhbmtcIiwgXCJfc2VsZlwiLCBcIl90b3BcIiwgXCJfcGFyZW50XCJdO1xuY29uc3QgQ2hhcnNldHMgPSBbXCJhc2NpaVwiLCBcInV0Zi04XCIsIFwidXRmLTE2XCIsIFwibGF0aW4xXCIsIFwibGF0aW4xXCJdO1xuY29uc3QgTWV0aG9kcyA9IFtcImdldFwiLCBcInBvc3RcIiwgXCJwdXRcIiwgXCJkZWxldGVcIl07XG5jb25zdCBFbmNzID0gW1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBcInRleHQvcGxhaW5cIl07XG5jb25zdCBCb29sID0gW1widHJ1ZVwiLCBcImZhbHNlXCJdO1xuY29uc3QgUyA9IHt9OyAvLyBFbXB0eSB0YWcgc3BlY1xuY29uc3QgVGFncyA9IHtcbiAgICBhOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBocmVmOiBudWxsLCBwaW5nOiBudWxsLCB0eXBlOiBudWxsLFxuICAgICAgICAgICAgbWVkaWE6IG51bGwsXG4gICAgICAgICAgICB0YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICBocmVmbGFuZzogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBhYmJyOiBTLFxuICAgIGFkZHJlc3M6IFMsXG4gICAgYXJlYToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgYWx0OiBudWxsLCBjb29yZHM6IG51bGwsIGhyZWY6IG51bGwsIHRhcmdldDogbnVsbCwgcGluZzogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLCBocmVmbGFuZzogbnVsbCwgdHlwZTogbnVsbCxcbiAgICAgICAgICAgIHNoYXBlOiBbXCJkZWZhdWx0XCIsIFwicmVjdFwiLCBcImNpcmNsZVwiLCBcInBvbHlcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYXJ0aWNsZTogUyxcbiAgICBhc2lkZTogUyxcbiAgICBhdWRpbzoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiBudWxsLCBtZWRpYWdyb3VwOiBudWxsLFxuICAgICAgICAgICAgY3Jvc3NvcmlnaW46IFtcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiXSxcbiAgICAgICAgICAgIHByZWxvYWQ6IFtcIm5vbmVcIiwgXCJtZXRhZGF0YVwiLCBcImF1dG9cIl0sXG4gICAgICAgICAgICBhdXRvcGxheTogW1wiYXV0b3BsYXlcIl0sXG4gICAgICAgICAgICBsb29wOiBbXCJsb29wXCJdLFxuICAgICAgICAgICAgY29udHJvbHM6IFtcImNvbnRyb2xzXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGI6IFMsXG4gICAgYmFzZTogeyBhdHRyczogeyBocmVmOiBudWxsLCB0YXJnZXQ6IFRhcmdldHMgfSB9LFxuICAgIGJkaTogUyxcbiAgICBiZG86IFMsXG4gICAgYmxvY2txdW90ZTogeyBhdHRyczogeyBjaXRlOiBudWxsIH0gfSxcbiAgICBib2R5OiBTLFxuICAgIGJyOiBTLFxuICAgIGJ1dHRvbjoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZm9ybTogbnVsbCwgZm9ybWFjdGlvbjogbnVsbCwgbmFtZTogbnVsbCwgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBmb3JtZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIGZvcm1tZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBmb3Jtbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgICAgICAgIGZvcm10YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICB0eXBlOiBbXCJzdWJtaXRcIiwgXCJyZXNldFwiLCBcImJ1dHRvblwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW52YXM6IHsgYXR0cnM6IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gICAgY2FwdGlvbjogUyxcbiAgICBjZW50ZXI6IFMsXG4gICAgY2l0ZTogUyxcbiAgICBjb2RlOiBTLFxuICAgIGNvbDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgICBjb2xncm91cDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgICBjb21tYW5kOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJjb21tYW5kXCIsIFwiY2hlY2tib3hcIiwgXCJyYWRpb1wiXSxcbiAgICAgICAgICAgIGxhYmVsOiBudWxsLCBpY29uOiBudWxsLCByYWRpb2dyb3VwOiBudWxsLCBjb21tYW5kOiBudWxsLCB0aXRsZTogbnVsbCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IFtcImNoZWNrZWRcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogeyBhdHRyczogeyB2YWx1ZTogbnVsbCB9IH0sXG4gICAgZGF0YWdyaWQ6IHsgYXR0cnM6IHsgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLCBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl0gfSB9LFxuICAgIGRhdGFsaXN0OiB7IGF0dHJzOiB7IGRhdGE6IG51bGwgfSB9LFxuICAgIGRkOiBTLFxuICAgIGRlbDogeyBhdHRyczogeyBjaXRlOiBudWxsLCBkYXRldGltZTogbnVsbCB9IH0sXG4gICAgZGV0YWlsczogeyBhdHRyczogeyBvcGVuOiBbXCJvcGVuXCJdIH0gfSxcbiAgICBkZm46IFMsXG4gICAgZGl2OiBTLFxuICAgIGRsOiBTLFxuICAgIGR0OiBTLFxuICAgIGVtOiBTLFxuICAgIGVtYmVkOiB7IGF0dHJzOiB7IHNyYzogbnVsbCwgdHlwZTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gICAgZXZlbnRzb3VyY2U6IHsgYXR0cnM6IHsgc3JjOiBudWxsIH0gfSxcbiAgICBmaWVsZHNldDogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGZvcm06IG51bGwsIG5hbWU6IG51bGwgfSB9LFxuICAgIGZpZ2NhcHRpb246IFMsXG4gICAgZmlndXJlOiBTLFxuICAgIGZvb3RlcjogUyxcbiAgICBmb3JtOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhY3Rpb246IG51bGwsIG5hbWU6IG51bGwsXG4gICAgICAgICAgICBcImFjY2VwdC1jaGFyc2V0XCI6IENoYXJzZXRzLFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBbXCJvblwiLCBcIm9mZlwiXSxcbiAgICAgICAgICAgIGVuY3R5cGU6IEVuY3MsXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBub3ZhbGlkYXRlOiBbXCJub3ZhbGlkYXRlXCJdLFxuICAgICAgICAgICAgdGFyZ2V0OiBUYXJnZXRzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGgxOiBTLCBoMjogUywgaDM6IFMsIGg0OiBTLCBoNTogUywgaDY6IFMsXG4gICAgaGVhZDoge1xuICAgICAgICBjaGlsZHJlbjogW1widGl0bGVcIiwgXCJiYXNlXCIsIFwibGlua1wiLCBcInN0eWxlXCIsIFwibWV0YVwiLCBcInNjcmlwdFwiLCBcIm5vc2NyaXB0XCIsIFwiY29tbWFuZFwiXVxuICAgIH0sXG4gICAgaGVhZGVyOiBTLFxuICAgIGhncm91cDogUyxcbiAgICBocjogUyxcbiAgICBodG1sOiB7XG4gICAgICAgIGF0dHJzOiB7IG1hbmlmZXN0OiBudWxsIH1cbiAgICB9LFxuICAgIGk6IFMsXG4gICAgaWZyYW1lOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIHNyY2RvYzogbnVsbCwgbmFtZTogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNhbmRib3g6IFtcImFsbG93LXRvcC1uYXZpZ2F0aW9uXCIsIFwiYWxsb3ctc2FtZS1vcmlnaW5cIiwgXCJhbGxvdy1mb3Jtc1wiLCBcImFsbG93LXNjcmlwdHNcIl0sXG4gICAgICAgICAgICBzZWFtbGVzczogW1wic2VhbWxlc3NcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW1nOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBhbHQ6IG51bGwsIHNyYzogbnVsbCwgaXNtYXA6IG51bGwsIHVzZW1hcDogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5wdXQ6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGFsdDogbnVsbCwgZGlybmFtZTogbnVsbCwgZm9ybTogbnVsbCwgZm9ybWFjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIGhlaWdodDogbnVsbCwgbGlzdDogbnVsbCwgbWF4OiBudWxsLCBtYXhsZW5ndGg6IG51bGwsIG1pbjogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IG51bGwsIHBhdHRlcm46IG51bGwsIHBsYWNlaG9sZGVyOiBudWxsLCBzaXplOiBudWxsLCBzcmM6IG51bGwsXG4gICAgICAgICAgICBzdGVwOiBudWxsLCB2YWx1ZTogbnVsbCwgd2lkdGg6IG51bGwsXG4gICAgICAgICAgICBhY2NlcHQ6IFtcImF1ZGlvLypcIiwgXCJ2aWRlby8qXCIsIFwiaW1hZ2UvKlwiXSxcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogW1wib25cIiwgXCJvZmZcIl0sXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGNoZWNrZWQ6IFtcImNoZWNrZWRcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBmb3JtZW5jdHlwZTogRW5jcyxcbiAgICAgICAgICAgIGZvcm1tZXRob2Q6IE1ldGhvZHMsXG4gICAgICAgICAgICBmb3Jtbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgICAgICAgIGZvcm10YXJnZXQ6IFRhcmdldHMsXG4gICAgICAgICAgICBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl0sXG4gICAgICAgICAgICByZWFkb25seTogW1wicmVhZG9ubHlcIl0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wicmVxdWlyZWRcIl0sXG4gICAgICAgICAgICB0eXBlOiBbXCJoaWRkZW5cIiwgXCJ0ZXh0XCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcImRhdGV0aW1lXCIsIFwiZGF0ZVwiLCBcIm1vbnRoXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwibnVtYmVyXCIsIFwicmFuZ2VcIiwgXCJjb2xvclwiLCBcImNoZWNrYm94XCIsIFwicmFkaW9cIixcbiAgICAgICAgICAgICAgICBcImZpbGVcIiwgXCJzdWJtaXRcIiwgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGluczogeyBhdHRyczogeyBjaXRlOiBudWxsLCBkYXRldGltZTogbnVsbCB9IH0sXG4gICAga2JkOiBTLFxuICAgIGtleWdlbjoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgY2hhbGxlbmdlOiBudWxsLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICAgICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICAgICAgICBrZXl0eXBlOiBbXCJSU0FcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGFiZWw6IHsgYXR0cnM6IHsgZm9yOiBudWxsLCBmb3JtOiBudWxsIH0gfSxcbiAgICBsZWdlbmQ6IFMsXG4gICAgbGk6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwgfSB9LFxuICAgIGxpbms6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGhyZWY6IG51bGwsIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBocmVmbGFuZzogbnVsbCxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgc2l6ZXM6IFtcImFsbFwiLCBcIjE2eDE2XCIsIFwiMTZ4MTYgMzJ4MzJcIiwgXCIxNngxNiAzMngzMiA2NHg2NFwiXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXA6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gICAgbWFyazogUyxcbiAgICBtZW51OiB7IGF0dHJzOiB7IGxhYmVsOiBudWxsLCB0eXBlOiBbXCJsaXN0XCIsIFwiY29udGV4dFwiLCBcInRvb2xiYXJcIl0gfSB9LFxuICAgIG1ldGE6IHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgICAgICAgICBjaGFyc2V0OiBDaGFyc2V0cyxcbiAgICAgICAgICAgIG5hbWU6IFtcInZpZXdwb3J0XCIsIFwiYXBwbGljYXRpb24tbmFtZVwiLCBcImF1dGhvclwiLCBcImRlc2NyaXB0aW9uXCIsIFwiZ2VuZXJhdG9yXCIsIFwia2V5d29yZHNcIl0sXG4gICAgICAgICAgICBcImh0dHAtZXF1aXZcIjogW1wiY29udGVudC1sYW5ndWFnZVwiLCBcImNvbnRlbnQtdHlwZVwiLCBcImRlZmF1bHQtc3R5bGVcIiwgXCJyZWZyZXNoXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGVyOiB7IGF0dHJzOiB7IHZhbHVlOiBudWxsLCBtaW46IG51bGwsIGxvdzogbnVsbCwgaGlnaDogbnVsbCwgbWF4OiBudWxsLCBvcHRpbXVtOiBudWxsIH0gfSxcbiAgICBuYXY6IFMsXG4gICAgbm9zY3JpcHQ6IFMsXG4gICAgb2JqZWN0OiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLCB0eXBlOiBudWxsLCBuYW1lOiBudWxsLCB1c2VtYXA6IG51bGwsIGZvcm06IG51bGwsIHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlbXVzdG1hdGNoOiBbXCJ0eXBlbXVzdG1hdGNoXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9sOiB7IGF0dHJzOiB7IHJldmVyc2VkOiBbXCJyZXZlcnNlZFwiXSwgc3RhcnQ6IG51bGwsIHR5cGU6IFtcIjFcIiwgXCJhXCIsIFwiQVwiLCBcImlcIiwgXCJJXCJdIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbXCJsaVwiLCBcInNjcmlwdFwiLCBcInRlbXBsYXRlXCIsIFwidWxcIiwgXCJvbFwiXSB9LFxuICAgIG9wdGdyb3VwOiB7IGF0dHJzOiB7IGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSwgbGFiZWw6IG51bGwgfSB9LFxuICAgIG9wdGlvbjogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGxhYmVsOiBudWxsLCBzZWxlY3RlZDogW1wic2VsZWN0ZWRcIl0sIHZhbHVlOiBudWxsIH0gfSxcbiAgICBvdXRwdXQ6IHsgYXR0cnM6IHsgZm9yOiBudWxsLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsIH0gfSxcbiAgICBwOiBTLFxuICAgIHBhcmFtOiB7IGF0dHJzOiB7IG5hbWU6IG51bGwsIHZhbHVlOiBudWxsIH0gfSxcbiAgICBwcmU6IFMsXG4gICAgcHJvZ3Jlc3M6IHsgYXR0cnM6IHsgdmFsdWU6IG51bGwsIG1heDogbnVsbCB9IH0sXG4gICAgcTogeyBhdHRyczogeyBjaXRlOiBudWxsIH0gfSxcbiAgICBycDogUyxcbiAgICBydDogUyxcbiAgICBydWJ5OiBTLFxuICAgIHNhbXA6IFMsXG4gICAgc2NyaXB0OiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJ0ZXh0L2phdmFzY3JpcHRcIl0sXG4gICAgICAgICAgICBzcmM6IG51bGwsXG4gICAgICAgICAgICBhc3luYzogW1wiYXN5bmNcIl0sXG4gICAgICAgICAgICBkZWZlcjogW1wiZGVmZXJcIl0sXG4gICAgICAgICAgICBjaGFyc2V0OiBDaGFyc2V0c1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZWN0aW9uOiBTLFxuICAgIHNlbGVjdDoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZm9ybTogbnVsbCwgbmFtZTogbnVsbCwgc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGF1dG9mb2N1czogW1wiYXV0b2ZvY3VzXCJdLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLFxuICAgICAgICAgICAgbXVsdGlwbGU6IFtcIm11bHRpcGxlXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNsb3Q6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gICAgc21hbGw6IFMsXG4gICAgc291cmNlOiB7IGF0dHJzOiB7IHNyYzogbnVsbCwgdHlwZTogbnVsbCwgbWVkaWE6IG51bGwgfSB9LFxuICAgIHNwYW46IFMsXG4gICAgc3Ryb25nOiBTLFxuICAgIHN0eWxlOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICB0eXBlOiBbXCJ0ZXh0L2Nzc1wiXSxcbiAgICAgICAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgICAgICAgc2NvcGVkOiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN1YjogUyxcbiAgICBzdW1tYXJ5OiBTLFxuICAgIHN1cDogUyxcbiAgICB0YWJsZTogUyxcbiAgICB0Ym9keTogUyxcbiAgICB0ZDogeyBhdHRyczogeyBjb2xzcGFuOiBudWxsLCByb3dzcGFuOiBudWxsLCBoZWFkZXJzOiBudWxsIH0gfSxcbiAgICB0ZW1wbGF0ZTogUyxcbiAgICB0ZXh0YXJlYToge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgZGlybmFtZTogbnVsbCwgZm9ybTogbnVsbCwgbWF4bGVuZ3RoOiBudWxsLCBuYW1lOiBudWxsLCBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgICAgIHJvd3M6IG51bGwsIGNvbHM6IG51bGwsXG4gICAgICAgICAgICBhdXRvZm9jdXM6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgICAgICAgIHJlYWRvbmx5OiBbXCJyZWFkb25seVwiXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJyZXF1aXJlZFwiXSxcbiAgICAgICAgICAgIHdyYXA6IFtcInNvZnRcIiwgXCJoYXJkXCJdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRmb290OiBTLFxuICAgIHRoOiB7IGF0dHJzOiB7IGNvbHNwYW46IG51bGwsIHJvd3NwYW46IG51bGwsIGhlYWRlcnM6IG51bGwsIHNjb3BlOiBbXCJyb3dcIiwgXCJjb2xcIiwgXCJyb3dncm91cFwiLCBcImNvbGdyb3VwXCJdIH0gfSxcbiAgICB0aGVhZDogUyxcbiAgICB0aW1lOiB7IGF0dHJzOiB7IGRhdGV0aW1lOiBudWxsIH0gfSxcbiAgICB0aXRsZTogUyxcbiAgICB0cjogUyxcbiAgICB0cmFjazoge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgc3JjOiBudWxsLCBsYWJlbDogbnVsbCwgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIGtpbmQ6IFtcInN1YnRpdGxlc1wiLCBcImNhcHRpb25zXCIsIFwiZGVzY3JpcHRpb25zXCIsIFwiY2hhcHRlcnNcIiwgXCJtZXRhZGF0YVwiXSxcbiAgICAgICAgICAgIHNyY2xhbmc6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdWw6IHsgY2hpbGRyZW46IFtcImxpXCIsIFwic2NyaXB0XCIsIFwidGVtcGxhdGVcIiwgXCJ1bFwiLCBcIm9sXCJdIH0sXG4gICAgdmFyOiBTLFxuICAgIHZpZGVvOiB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBzcmM6IG51bGwsIHBvc3RlcjogbnVsbCwgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl0sXG4gICAgICAgICAgICBwcmVsb2FkOiBbXCJhdXRvXCIsIFwibWV0YWRhdGFcIiwgXCJub25lXCJdLFxuICAgICAgICAgICAgYXV0b3BsYXk6IFtcImF1dG9wbGF5XCJdLFxuICAgICAgICAgICAgbWVkaWFncm91cDogW1wibW92aWVcIl0sXG4gICAgICAgICAgICBtdXRlZDogW1wibXV0ZWRcIl0sXG4gICAgICAgICAgICBjb250cm9sczogW1wiY29udHJvbHNcIl1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2JyOiBTXG59O1xuY29uc3QgR2xvYmFsQXR0cnMgPSB7XG4gICAgYWNjZXNza2V5OiBudWxsLFxuICAgIGNsYXNzOiBudWxsLFxuICAgIGNvbnRlbnRlZGl0YWJsZTogQm9vbCxcbiAgICBjb250ZXh0bWVudTogbnVsbCxcbiAgICBkaXI6IFtcImx0clwiLCBcInJ0bFwiLCBcImF1dG9cIl0sXG4gICAgZHJhZ2dhYmxlOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJhdXRvXCJdLFxuICAgIGRyb3B6b25lOiBbXCJjb3B5XCIsIFwibW92ZVwiLCBcImxpbmtcIiwgXCJzdHJpbmc6XCIsIFwiZmlsZTpcIl0sXG4gICAgaGlkZGVuOiBbXCJoaWRkZW5cIl0sXG4gICAgaWQ6IG51bGwsXG4gICAgaW5lcnQ6IFtcImluZXJ0XCJdLFxuICAgIGl0ZW1pZDogbnVsbCxcbiAgICBpdGVtcHJvcDogbnVsbCxcbiAgICBpdGVtcmVmOiBudWxsLFxuICAgIGl0ZW1zY29wZTogW1wiaXRlbXNjb3BlXCJdLFxuICAgIGl0ZW10eXBlOiBudWxsLFxuICAgIGxhbmc6IFtcImFyXCIsIFwiYm5cIiwgXCJkZVwiLCBcImVuLUdCXCIsIFwiZW4tVVNcIiwgXCJlc1wiLCBcImZyXCIsIFwiaGlcIiwgXCJpZFwiLCBcImphXCIsIFwicGFcIiwgXCJwdFwiLCBcInJ1XCIsIFwidHJcIiwgXCJ6aFwiXSxcbiAgICBzcGVsbGNoZWNrOiBCb29sLFxuICAgIGF1dG9jb3JyZWN0OiBCb29sLFxuICAgIGF1dG9jYXBpdGFsaXplOiBCb29sLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHRhYmluZGV4OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHRyYW5zbGF0ZTogW1wieWVzXCIsIFwibm9cIl0sXG4gICAgcmVsOiBbXCJzdHlsZXNoZWV0XCIsIFwiYWx0ZXJuYXRlXCIsIFwiYXV0aG9yXCIsIFwiYm9va21hcmtcIiwgXCJoZWxwXCIsIFwibGljZW5zZVwiLCBcIm5leHRcIiwgXCJub2ZvbGxvd1wiLCBcIm5vcmVmZXJyZXJcIiwgXCJwcmVmZXRjaFwiLCBcInByZXZcIiwgXCJzZWFyY2hcIiwgXCJ0YWdcIl0sXG4gICAgcm9sZTogLypAX19QVVJFX18qL1wiYWxlcnQgYXBwbGljYXRpb24gYXJ0aWNsZSBiYW5uZXIgYnV0dG9uIGNlbGwgY2hlY2tib3ggY29tcGxlbWVudGFyeSBjb250ZW50aW5mbyBkaWFsb2cgZG9jdW1lbnQgZmVlZCBmaWd1cmUgZm9ybSBncmlkIGdyaWRjZWxsIGhlYWRpbmcgaW1nIGxpc3QgbGlzdGJveCBsaXN0aXRlbSBtYWluIG5hdmlnYXRpb24gcmVnaW9uIHJvdyByb3dncm91cCBzZWFyY2ggc3dpdGNoIHRhYiB0YWJsZSB0YWJwYW5lbCB0ZXh0Ym94IHRpbWVyXCIuc3BsaXQoXCIgXCIpLFxuICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IG51bGwsXG4gICAgXCJhcmlhLWF0b21pY1wiOiBCb29sLFxuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogW1wiaW5saW5lXCIsIFwibGlzdFwiLCBcImJvdGhcIiwgXCJub25lXCJdLFxuICAgIFwiYXJpYS1idXN5XCI6IEJvb2wsXG4gICAgXCJhcmlhLWNoZWNrZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibWl4ZWRcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6IG51bGwsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IG51bGwsXG4gICAgXCJhcmlhLWRpc2FibGVkXCI6IEJvb2wsXG4gICAgXCJhcmlhLWRyb3BlZmZlY3RcIjogbnVsbCxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwidW5kZWZpbmVkXCJdLFxuICAgIFwiYXJpYS1mbG93dG9cIjogbnVsbCxcbiAgICBcImFyaWEtZ3JhYmJlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLWhhc3BvcHVwXCI6IEJvb2wsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBCb29sLFxuICAgIFwiYXJpYS1pbnZhbGlkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcImdyYW1tYXJcIiwgXCJzcGVsbGluZ1wiXSxcbiAgICBcImFyaWEtbGFiZWxcIjogbnVsbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBudWxsLFxuICAgIFwiYXJpYS1sZXZlbFwiOiBudWxsLFxuICAgIFwiYXJpYS1saXZlXCI6IFtcIm9mZlwiLCBcInBvbGl0ZVwiLCBcImFzc2VydGl2ZVwiXSxcbiAgICBcImFyaWEtbXVsdGlsaW5lXCI6IEJvb2wsXG4gICAgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiBCb29sLFxuICAgIFwiYXJpYS1vd25zXCI6IG51bGwsXG4gICAgXCJhcmlhLXBvc2luc2V0XCI6IG51bGwsXG4gICAgXCJhcmlhLXByZXNzZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibWl4ZWRcIiwgXCJ1bmRlZmluZWRcIl0sXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6IEJvb2wsXG4gICAgXCJhcmlhLXJlbGV2YW50XCI6IG51bGwsXG4gICAgXCJhcmlhLXJlcXVpcmVkXCI6IEJvb2wsXG4gICAgXCJhcmlhLXNlbGVjdGVkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcInVuZGVmaW5lZFwiXSxcbiAgICBcImFyaWEtc2V0c2l6ZVwiOiBudWxsLFxuICAgIFwiYXJpYS1zb3J0XCI6IFtcImFzY2VuZGluZ1wiLCBcImRlc2NlbmRpbmdcIiwgXCJub25lXCIsIFwib3RoZXJcIl0sXG4gICAgXCJhcmlhLXZhbHVlbWF4XCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVlbWluXCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVlbm93XCI6IG51bGwsXG4gICAgXCJhcmlhLXZhbHVldGV4dFwiOiBudWxsXG59O1xuY29uc3QgZXZlbnRBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qLyhcImJlZm9yZXVubG9hZCBjb3B5IGN1dCBkcmFnc3RhcnQgZHJhZ292ZXIgZHJhZ2xlYXZlIGRyYWdlbnRlciBkcmFnZW5kIFwiICtcbiAgICBcImRyYWcgcGFzdGUgZm9jdXMgYmx1ciBjaGFuZ2UgY2xpY2sgbG9hZCBtb3VzZWRvd24gbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcbiAgICBcIm1vdXNldXAga2V5ZG93biBrZXl1cCByZXNpemUgc2Nyb2xsIHVubG9hZFwiKS5zcGxpdChcIiBcIikubWFwKG4gPT4gXCJvblwiICsgbik7XG5mb3IgKGxldCBhIG9mIGV2ZW50QXR0cmlidXRlcylcbiAgICBHbG9iYWxBdHRyc1thXSA9IG51bGw7XG5jbGFzcyBTY2hlbWEge1xuICAgIGNvbnN0cnVjdG9yKGV4dHJhVGFncywgZXh0cmFBdHRycykge1xuICAgICAgICB0aGlzLnRhZ3MgPSB7IC4uLlRhZ3MsIC4uLmV4dHJhVGFncyB9O1xuICAgICAgICB0aGlzLmdsb2JhbEF0dHJzID0geyAuLi5HbG9iYWxBdHRycywgLi4uZXh0cmFBdHRycyB9O1xuICAgICAgICB0aGlzLmFsbFRhZ3MgPSBPYmplY3Qua2V5cyh0aGlzLnRhZ3MpO1xuICAgICAgICB0aGlzLmdsb2JhbEF0dHJOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuZ2xvYmFsQXR0cnMpO1xuICAgIH1cbn1cblNjaGVtYS5kZWZhdWx0ID0gLypAX19QVVJFX18qL25ldyBTY2hlbWE7XG5mdW5jdGlvbiBlbGVtZW50TmFtZShkb2MsIHRyZWUsIG1heCA9IGRvYy5sZW5ndGgpIHtcbiAgICBpZiAoIXRyZWUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIGxldCB0YWcgPSB0cmVlLmZpcnN0Q2hpbGQ7XG4gICAgbGV0IG5hbWUgPSB0YWcgJiYgdGFnLmdldENoaWxkKFwiVGFnTmFtZVwiKTtcbiAgICByZXR1cm4gbmFtZSA/IGRvYy5zbGljZVN0cmluZyhuYW1lLmZyb20sIE1hdGgubWluKG5hbWUudG8sIG1heCkpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGZpbmRQYXJlbnRFbGVtZW50KHRyZWUsIHNraXAgPSBmYWxzZSkge1xuICAgIGZvciAoOyB0cmVlOyB0cmVlID0gdHJlZS5wYXJlbnQpXG4gICAgICAgIGlmICh0cmVlLm5hbWUgPT0gXCJFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIGlmIChza2lwKVxuICAgICAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYWxsb3dlZENoaWxkcmVuKGRvYywgdHJlZSwgc2NoZW1hKSB7XG4gICAgbGV0IHBhcmVudEluZm8gPSBzY2hlbWEudGFnc1tlbGVtZW50TmFtZShkb2MsIGZpbmRQYXJlbnRFbGVtZW50KHRyZWUpKV07XG4gICAgcmV0dXJuIChwYXJlbnRJbmZvID09PSBudWxsIHx8IHBhcmVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEluZm8uY2hpbGRyZW4pIHx8IHNjaGVtYS5hbGxUYWdzO1xufVxuZnVuY3Rpb24gb3BlblRhZ3MoZG9jLCB0cmVlKSB7XG4gICAgbGV0IG9wZW4gPSBbXTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlKTsgcGFyZW50ICYmICFwYXJlbnQudHlwZS5pc1RvcDsgcGFyZW50ID0gZmluZFBhcmVudEVsZW1lbnQocGFyZW50LnBhcmVudCkpIHtcbiAgICAgICAgbGV0IHRhZ05hbWUgPSBlbGVtZW50TmFtZShkb2MsIHBhcmVudCk7XG4gICAgICAgIGlmICh0YWdOYW1lICYmIHBhcmVudC5sYXN0Q2hpbGQubmFtZSA9PSBcIkNsb3NlVGFnXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHRhZ05hbWUgJiYgb3Blbi5pbmRleE9mKHRhZ05hbWUpIDwgMCAmJiAodHJlZS5uYW1lID09IFwiRW5kVGFnXCIgfHwgdHJlZS5mcm9tID49IHBhcmVudC5maXJzdENoaWxkLnRvKSlcbiAgICAgICAgICAgIG9wZW4ucHVzaCh0YWdOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wZW47XG59XG5jb25zdCBpZGVudGlmaWVyID0gL15bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC87XG5mdW5jdGlvbiBjb21wbGV0ZVRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCBmcm9tLCB0bykge1xuICAgIGxldCBlbmQgPSAvXFxzKj4vLnRlc3Qoc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgNSkpID8gXCJcIiA6IFwiPlwiO1xuICAgIGxldCBwYXJlbnQgPSBmaW5kUGFyZW50RWxlbWVudCh0cmVlLCB0cmVlLm5hbWUgPT0gXCJTdGFydFRhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIlRhZ05hbWVcIik7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sXG4gICAgICAgIG9wdGlvbnM6IGFsbG93ZWRDaGlsZHJlbihzdGF0ZS5kb2MsIHBhcmVudCwgc2NoZW1hKS5tYXAodGFnTmFtZSA9PiAoeyBsYWJlbDogdGFnTmFtZSwgdHlwZTogXCJ0eXBlXCIgfSkpLmNvbmNhdChvcGVuVGFncyhzdGF0ZS5kb2MsIHRyZWUpLm1hcCgodGFnLCBpKSA9PiAoeyBsYWJlbDogXCIvXCIgKyB0YWcsIGFwcGx5OiBcIi9cIiArIHRhZyArIGVuZCxcbiAgICAgICAgICAgIHR5cGU6IFwidHlwZVwiLCBib29zdDogOTkgLSBpIH0pKSksXG4gICAgICAgIHZhbGlkRm9yOiAvXlxcLz9bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC8gfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlQ2xvc2VUYWcoc3RhdGUsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgbGV0IGVuZCA9IC9cXHMqPi8udGVzdChzdGF0ZS5zbGljZURvYyh0bywgdG8gKyA1KSkgPyBcIlwiIDogXCI+XCI7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sXG4gICAgICAgIG9wdGlvbnM6IG9wZW5UYWdzKHN0YXRlLmRvYywgdHJlZSkubWFwKCh0YWcsIGkpID0+ICh7IGxhYmVsOiB0YWcsIGFwcGx5OiB0YWcgKyBlbmQsIHR5cGU6IFwidHlwZVwiLCBib29zdDogOTkgLSBpIH0pKSxcbiAgICAgICAgdmFsaWRGb3I6IGlkZW50aWZpZXIgfTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlU3RhcnRUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgcG9zKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgbGV2ZWwgPSAwO1xuICAgIGZvciAobGV0IHRhZ05hbWUgb2YgYWxsb3dlZENoaWxkcmVuKHN0YXRlLmRvYywgdHJlZSwgc2NoZW1hKSlcbiAgICAgICAgb3B0aW9ucy5wdXNoKHsgbGFiZWw6IFwiPFwiICsgdGFnTmFtZSwgdHlwZTogXCJ0eXBlXCIgfSk7XG4gICAgZm9yIChsZXQgb3BlbiBvZiBvcGVuVGFncyhzdGF0ZS5kb2MsIHRyZWUpKVxuICAgICAgICBvcHRpb25zLnB1c2goeyBsYWJlbDogXCI8L1wiICsgb3BlbiArIFwiPlwiLCB0eXBlOiBcInR5cGVcIiwgYm9vc3Q6IDk5IC0gbGV2ZWwrKyB9KTtcbiAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MsIG9wdGlvbnMsIHZhbGlkRm9yOiAvXjxcXC8/WzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvIH07XG59XG5mdW5jdGlvbiBjb21wbGV0ZUF0dHJOYW1lKHN0YXRlLCBzY2hlbWEsIHRyZWUsIGZyb20sIHRvKSB7XG4gICAgbGV0IGVsdCA9IGZpbmRQYXJlbnRFbGVtZW50KHRyZWUpLCBpbmZvID0gZWx0ID8gc2NoZW1hLnRhZ3NbZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBlbHQpXSA6IG51bGw7XG4gICAgbGV0IGxvY2FsQXR0cnMgPSBpbmZvICYmIGluZm8uYXR0cnMgPyBPYmplY3Qua2V5cyhpbmZvLmF0dHJzKSA6IFtdO1xuICAgIGxldCBuYW1lcyA9IGluZm8gJiYgaW5mby5nbG9iYWxBdHRycyA9PT0gZmFsc2UgPyBsb2NhbEF0dHJzXG4gICAgICAgIDogbG9jYWxBdHRycy5sZW5ndGggPyBsb2NhbEF0dHJzLmNvbmNhdChzY2hlbWEuZ2xvYmFsQXR0ck5hbWVzKSA6IHNjaGVtYS5nbG9iYWxBdHRyTmFtZXM7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sXG4gICAgICAgIG9wdGlvbnM6IG5hbWVzLm1hcChhdHRyTmFtZSA9PiAoeyBsYWJlbDogYXR0ck5hbWUsIHR5cGU6IFwicHJvcGVydHlcIiB9KSksXG4gICAgICAgIHZhbGlkRm9yOiBpZGVudGlmaWVyIH07XG59XG5mdW5jdGlvbiBjb21wbGV0ZUF0dHJWYWx1ZShzdGF0ZSwgc2NoZW1hLCB0cmVlLCBmcm9tLCB0bykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbmFtZU5vZGUgPSAoX2EgPSB0cmVlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENoaWxkKFwiQXR0cmlidXRlTmFtZVwiKTtcbiAgICBsZXQgb3B0aW9ucyA9IFtdLCB0b2tlbiA9IHVuZGVmaW5lZDtcbiAgICBpZiAobmFtZU5vZGUpIHtcbiAgICAgICAgbGV0IGF0dHJOYW1lID0gc3RhdGUuc2xpY2VEb2MobmFtZU5vZGUuZnJvbSwgbmFtZU5vZGUudG8pO1xuICAgICAgICBsZXQgYXR0cnMgPSBzY2hlbWEuZ2xvYmFsQXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICBpZiAoIWF0dHJzKSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gZmluZFBhcmVudEVsZW1lbnQodHJlZSksIGluZm8gPSBlbHQgPyBzY2hlbWEudGFnc1tlbGVtZW50TmFtZShzdGF0ZS5kb2MsIGVsdCldIDogbnVsbDtcbiAgICAgICAgICAgIGF0dHJzID0gKGluZm8gPT09IG51bGwgfHwgaW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mby5hdHRycykgJiYgaW5mby5hdHRyc1thdHRyTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKS50b0xvd2VyQ2FzZSgpLCBxdW90ZVN0YXJ0ID0gJ1wiJywgcXVvdGVFbmQgPSAnXCInO1xuICAgICAgICAgICAgaWYgKC9eWydcIl0vLnRlc3QoYmFzZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGJhc2VbMF0gPT0gJ1wiJyA/IC9eW15cIl0qJC8gOiAvXlteJ10qJC87XG4gICAgICAgICAgICAgICAgcXVvdGVTdGFydCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgcXVvdGVFbmQgPSBzdGF0ZS5zbGljZURvYyh0bywgdG8gKyAxKSA9PSBiYXNlWzBdID8gXCJcIiA6IGJhc2VbMF07XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2Uuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgZnJvbSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSAvXlteXFxzPD49J1wiXSokLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGF0dHJzKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7IGxhYmVsOiB2YWx1ZSwgYXBwbHk6IHF1b3RlU3RhcnQgKyB2YWx1ZSArIHF1b3RlRW5kLCB0eXBlOiBcImNvbnN0YW50XCIgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZnJvbSwgdG8sIG9wdGlvbnMsIHZhbGlkRm9yOiB0b2tlbiB9O1xufVxuZnVuY3Rpb24gaHRtbENvbXBsZXRpb25Gb3Ioc2NoZW1hLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgc3RhdGUsIHBvcyB9ID0gY29udGV4dCwgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MsIC0xKSwgYXJvdW5kID0gdHJlZS5yZXNvbHZlKHBvcyk7XG4gICAgZm9yIChsZXQgc2NhbiA9IHBvcywgYmVmb3JlOyBhcm91bmQgPT0gdHJlZSAmJiAoYmVmb3JlID0gdHJlZS5jaGlsZEJlZm9yZShzY2FuKSk7KSB7XG4gICAgICAgIGxldCBsYXN0ID0gYmVmb3JlLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICFsYXN0LnR5cGUuaXNFcnJvciB8fCBsYXN0LmZyb20gPCBsYXN0LnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGFyb3VuZCA9IHRyZWUgPSBiZWZvcmU7XG4gICAgICAgIHNjYW4gPSBsYXN0LmZyb207XG4gICAgfVxuICAgIGlmICh0cmVlLm5hbWUgPT0gXCJUYWdOYW1lXCIpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUucGFyZW50ICYmIC9DbG9zZVRhZyQvLnRlc3QodHJlZS5wYXJlbnQubmFtZSkgPyBjb21wbGV0ZUNsb3NlVGFnKHN0YXRlLCB0cmVlLCB0cmVlLmZyb20sIHBvcylcbiAgICAgICAgICAgIDogY29tcGxldGVUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgdHJlZS5mcm9tLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmVlLm5hbWUgPT0gXCJTdGFydFRhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIkluY29tcGxldGVUYWdcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVUYWcoc3RhdGUsIHNjaGVtYSwgdHJlZSwgcG9zLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmVlLm5hbWUgPT0gXCJTdGFydENsb3NlVGFnXCIgfHwgdHJlZS5uYW1lID09IFwiSW5jb21wbGV0ZUNsb3NlVGFnXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlQ2xvc2VUYWcoc3RhdGUsIHRyZWUsIHBvcywgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJlZS5uYW1lID09IFwiT3BlblRhZ1wiIHx8IHRyZWUubmFtZSA9PSBcIlNlbGZDbG9zaW5nVGFnXCIgfHwgdHJlZS5uYW1lID09IFwiQXR0cmlidXRlTmFtZVwiKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZUF0dHJOYW1lKHN0YXRlLCBzY2hlbWEsIHRyZWUsIHRyZWUubmFtZSA9PSBcIkF0dHJpYnV0ZU5hbWVcIiA/IHRyZWUuZnJvbSA6IHBvcywgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJlZS5uYW1lID09IFwiSXNcIiB8fCB0cmVlLm5hbWUgPT0gXCJBdHRyaWJ1dGVWYWx1ZVwiIHx8IHRyZWUubmFtZSA9PSBcIlVucXVvdGVkQXR0cmlidXRlVmFsdWVcIikge1xuICAgICAgICByZXR1cm4gY29tcGxldGVBdHRyVmFsdWUoc3RhdGUsIHNjaGVtYSwgdHJlZSwgdHJlZS5uYW1lID09IFwiSXNcIiA/IHBvcyA6IHRyZWUuZnJvbSwgcG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dC5leHBsaWNpdCAmJiAoYXJvdW5kLm5hbWUgPT0gXCJFbGVtZW50XCIgfHwgYXJvdW5kLm5hbWUgPT0gXCJUZXh0XCIgfHwgYXJvdW5kLm5hbWUgPT0gXCJEb2N1bWVudFwiKSkge1xuICAgICAgICByZXR1cm4gY29tcGxldGVTdGFydFRhZyhzdGF0ZSwgc2NoZW1hLCB0cmVlLCBwb3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG5IVE1MIHRhZyBjb21wbGV0aW9uLiBPcGVucyBhbmQgY2xvc2VzIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgaW4gYVxuY29udGV4dC1hd2FyZSB3YXkuXG4qL1xuZnVuY3Rpb24gaHRtbENvbXBsZXRpb25Tb3VyY2UoY29udGV4dCkge1xuICAgIHJldHVybiBodG1sQ29tcGxldGlvbkZvcihTY2hlbWEuZGVmYXVsdCwgY29udGV4dCk7XG59XG4vKipcbkNyZWF0ZSBhIGNvbXBsZXRpb24gc291cmNlIGZvciBIVE1MIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbCB0YWdzXG5vciBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIGh0bWxDb21wbGV0aW9uU291cmNlV2l0aChjb25maWcpIHtcbiAgICBsZXQgeyBleHRyYVRhZ3MsIGV4dHJhR2xvYmFsQXR0cmlidXRlczogZXh0cmFBdHRycyB9ID0gY29uZmlnO1xuICAgIGxldCBzY2hlbWEgPSBleHRyYUF0dHJzIHx8IGV4dHJhVGFncyA/IG5ldyBTY2hlbWEoZXh0cmFUYWdzLCBleHRyYUF0dHJzKSA6IFNjaGVtYS5kZWZhdWx0O1xuICAgIHJldHVybiAoY29udGV4dCkgPT4gaHRtbENvbXBsZXRpb25Gb3Ioc2NoZW1hLCBjb250ZXh0KTtcbn1cblxuY29uc3QganNvblBhcnNlciA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UucGFyc2VyLmNvbmZpZ3VyZSh7IHRvcDogXCJTaW5nbGVFeHByZXNzaW9uXCIgfSk7XG5jb25zdCBkZWZhdWx0TmVzdGluZyA9IFtcbiAgICB7IHRhZzogXCJzY3JpcHRcIixcbiAgICAgICAgYXR0cnM6IGF0dHJzID0+IGF0dHJzLnR5cGUgPT0gXCJ0ZXh0L3R5cGVzY3JpcHRcIiB8fCBhdHRycy5sYW5nID09IFwidHNcIixcbiAgICAgICAgcGFyc2VyOiB0eXBlc2NyaXB0TGFuZ3VhZ2UucGFyc2VyIH0sXG4gICAgeyB0YWc6IFwic2NyaXB0XCIsXG4gICAgICAgIGF0dHJzOiBhdHRycyA9PiBhdHRycy50eXBlID09IFwidGV4dC9iYWJlbFwiIHx8IGF0dHJzLnR5cGUgPT0gXCJ0ZXh0L2pzeFwiLFxuICAgICAgICBwYXJzZXI6IGpzeExhbmd1YWdlLnBhcnNlciB9LFxuICAgIHsgdGFnOiBcInNjcmlwdFwiLFxuICAgICAgICBhdHRyczogYXR0cnMgPT4gYXR0cnMudHlwZSA9PSBcInRleHQvdHlwZXNjcmlwdC1qc3hcIixcbiAgICAgICAgcGFyc2VyOiB0c3hMYW5ndWFnZS5wYXJzZXIgfSxcbiAgICB7IHRhZzogXCJzY3JpcHRcIixcbiAgICAgICAgYXR0cnMoYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiAvXihpbXBvcnRtYXB8c3BlY3VsYXRpb25ydWxlc3xhcHBsaWNhdGlvblxcLyguK1xcKyk/anNvbikkL2kudGVzdChhdHRycy50eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VyOiBqc29uUGFyc2VyIH0sXG4gICAgeyB0YWc6IFwic2NyaXB0XCIsXG4gICAgICAgIGF0dHJzKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gIWF0dHJzLnR5cGUgfHwgL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcLyg/OngtKT8oPzpqYXZhfGVjbWEpc2NyaXB0JHxebW9kdWxlJHxeJC9pLnRlc3QoYXR0cnMudHlwZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlcjogamF2YXNjcmlwdExhbmd1YWdlLnBhcnNlciB9LFxuICAgIHsgdGFnOiBcInN0eWxlXCIsXG4gICAgICAgIGF0dHJzKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFhdHRycy5sYW5nIHx8IGF0dHJzLmxhbmcgPT0gXCJjc3NcIikgJiYgKCFhdHRycy50eXBlIHx8IC9eKHRleHRcXC8pPyh4LSk/KHN0eWxlc2hlZXR8Y3NzKSQvaS50ZXN0KGF0dHJzLnR5cGUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VyOiBjc3NMYW5ndWFnZS5wYXJzZXIgfVxuXTtcbmNvbnN0IGRlZmF1bHRBdHRycyA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBuYW1lOiBcInN0eWxlXCIsXG4gICAgICAgIHBhcnNlcjogLypAX19QVVJFX18qL2Nzc0xhbmd1YWdlLnBhcnNlci5jb25maWd1cmUoeyB0b3A6IFwiU3R5bGVzXCIgfSkgfVxuXS5jb25jYXQoLypAX19QVVJFX18qL2V2ZW50QXR0cmlidXRlcy5tYXAobmFtZSA9PiAoeyBuYW1lLCBwYXJzZXI6IGphdmFzY3JpcHRMYW5ndWFnZS5wYXJzZXIgfSkpKTtcbmNvbnN0IGh0bWxQbGFpbiA9IC8qQF9fUFVSRV9fKi9MUkxhbmd1YWdlLmRlZmluZSh7XG4gICAgbmFtZTogXCJodG1sXCIsXG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBFbGVtZW50KGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gL14oXFxzKikoPFxcLyk/Ly5leGVjKGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQubm9kZS50byA8PSBjb250ZXh0LnBvcyArIGFmdGVyWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5ub2RlLmZyb20pICsgKGFmdGVyWzJdID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIk9wZW5UYWcgQ2xvc2VUYWcgU2VsZkNsb3NpbmdUYWdcIihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbHVtbihjb250ZXh0Lm5vZGUuZnJvbSkgKyBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBEb2N1bWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnBvcyArIC9cXHMqLy5leGVjKGNvbnRleHQudGV4dEFmdGVyKVswXS5sZW5ndGggPCBjb250ZXh0Lm5vZGUudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kRWx0ID0gbnVsbCwgY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IGNvbnRleHQubm9kZTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC5uYW1lICE9IFwiRWxlbWVudFwiIHx8IGxhc3QudG8gIT0gY3VyLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRWx0ID0gY3VyID0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kRWx0ICYmICEoKGNsb3NlID0gZW5kRWx0Lmxhc3RDaGlsZCkgJiYgKGNsb3NlLm5hbWUgPT0gXCJDbG9zZVRhZ1wiIHx8IGNsb3NlLm5hbWUgPT0gXCJTZWxmQ2xvc2luZ1RhZ1wiKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGVuZEVsdC5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgRWxlbWVudChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgbGFzdCA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0IHx8IGZpcnN0Lm5hbWUgIT0gXCJPcGVuVGFnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0Lm5hbWUgPT0gXCJDbG9zZVRhZ1wiID8gbGFzdC5mcm9tIDogbm9kZS50byB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLypAX19QVVJFX18qL2JyYWNrZXRNYXRjaGluZ0hhbmRsZS5hZGQoe1xuICAgICAgICAgICAgICAgIFwiT3BlblRhZyBDbG9zZVRhZ1wiOiBub2RlID0+IG5vZGUuZ2V0Q2hpbGQoXCJUYWdOYW1lXCIpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgfSksXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICAgIGNvbW1lbnRUb2tlbnM6IHsgYmxvY2s6IHsgb3BlbjogXCI8IS0tXCIsIGNsb3NlOiBcIi0tPlwiIH0gfSxcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqPFxcL1xcdytcXFckLyxcbiAgICAgICAgd29yZENoYXJzOiBcIi1fXCJcbiAgICB9XG59KTtcbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIEhUTUxcbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci9odG1sKSwgZXh0ZW5kZWQgd2l0aCB0aGVcbkphdmFTY3JpcHQgYW5kIENTUyBwYXJzZXJzIHRvIHBhcnNlIHRoZSBjb250ZW50IG9mIGA8c2NyaXB0PmAgYW5kXG5gPHN0eWxlPmAgdGFncy5cbiovXG5jb25zdCBodG1sTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovaHRtbFBsYWluLmNvbmZpZ3VyZSh7XG4gICAgd3JhcDogLypAX19QVVJFX18qL2NvbmZpZ3VyZU5lc3RpbmcoZGVmYXVsdE5lc3RpbmcsIGRlZmF1bHRBdHRycylcbn0pO1xuLyoqXG5MYW5ndWFnZSBzdXBwb3J0IGZvciBIVE1MLCBpbmNsdWRpbmdcbltgaHRtbENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctaHRtbC5odG1sQ29tcGxldGlvbikgYW5kIEphdmFTY3JpcHQgYW5kXG5DU1Mgc3VwcG9ydCBleHRlbnNpb25zLlxuKi9cbmZ1bmN0aW9uIGh0bWwoY29uZmlnID0ge30pIHtcbiAgICBsZXQgZGlhbGVjdCA9IFwiXCIsIHdyYXA7XG4gICAgaWYgKGNvbmZpZy5tYXRjaENsb3NpbmdUYWdzID09PSBmYWxzZSlcbiAgICAgICAgZGlhbGVjdCA9IFwibm9NYXRjaFwiO1xuICAgIGlmIChjb25maWcuc2VsZkNsb3NpbmdUYWdzID09PSB0cnVlKVxuICAgICAgICBkaWFsZWN0ID0gKGRpYWxlY3QgPyBkaWFsZWN0ICsgXCIgXCIgOiBcIlwiKSArIFwic2VsZkNsb3NpbmdcIjtcbiAgICBpZiAoY29uZmlnLm5lc3RlZExhbmd1YWdlcyAmJiBjb25maWcubmVzdGVkTGFuZ3VhZ2VzLmxlbmd0aCB8fFxuICAgICAgICBjb25maWcubmVzdGVkQXR0cmlidXRlcyAmJiBjb25maWcubmVzdGVkQXR0cmlidXRlcy5sZW5ndGgpXG4gICAgICAgIHdyYXAgPSBjb25maWd1cmVOZXN0aW5nKChjb25maWcubmVzdGVkTGFuZ3VhZ2VzIHx8IFtdKS5jb25jYXQoZGVmYXVsdE5lc3RpbmcpLCAoY29uZmlnLm5lc3RlZEF0dHJpYnV0ZXMgfHwgW10pLmNvbmNhdChkZWZhdWx0QXR0cnMpKTtcbiAgICBsZXQgbGFuZyA9IHdyYXAgPyBodG1sUGxhaW4uY29uZmlndXJlKHsgd3JhcCwgZGlhbGVjdCB9KSA6IGRpYWxlY3QgPyBodG1sTGFuZ3VhZ2UuY29uZmlndXJlKHsgZGlhbGVjdCB9KSA6IGh0bWxMYW5ndWFnZTtcbiAgICByZXR1cm4gbmV3IExhbmd1YWdlU3VwcG9ydChsYW5nLCBbXG4gICAgICAgIGh0bWxMYW5ndWFnZS5kYXRhLm9mKHsgYXV0b2NvbXBsZXRlOiBodG1sQ29tcGxldGlvblNvdXJjZVdpdGgoY29uZmlnKSB9KSxcbiAgICAgICAgY29uZmlnLmF1dG9DbG9zZVRhZ3MgIT09IGZhbHNlID8gYXV0b0Nsb3NlVGFncyA6IFtdLFxuICAgICAgICBqYXZhc2NyaXB0KCkuc3VwcG9ydCxcbiAgICAgICAgY3NzKCkuc3VwcG9ydFxuICAgIF0pO1xufVxuY29uc3Qgc2VsZkNsb3NlcnMgPSAvKkBfX1BVUkVfXyovbmV3IFNldCgvKkBfX1BVUkVfXyovXCJhcmVhIGJhc2UgYnIgY29sIGNvbW1hbmQgZW1iZWQgZnJhbWUgaHIgaW1nIGlucHV0IGtleWdlbiBsaW5rIG1ldGEgcGFyYW0gc291cmNlIHRyYWNrIHdiciBtZW51aXRlbVwiLnNwbGl0KFwiIFwiKSk7XG4vKipcbkV4dGVuc2lvbiB0aGF0IHdpbGwgYXV0b21hdGljYWxseSBpbnNlcnQgY2xvc2UgdGFncyB3aGVuIGEgYD5gIG9yXG5gL2AgaXMgdHlwZWQuXG4qL1xuY29uc3QgYXV0b0Nsb3NlVGFncyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQsIGluc2VydFRyYW5zYWN0aW9uKSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkgfHwgZnJvbSAhPSB0byB8fCAodGV4dCAhPSBcIj5cIiAmJiB0ZXh0ICE9IFwiL1wiKSB8fFxuICAgICAgICAhaHRtbExhbmd1YWdlLmlzQWN0aXZlQXQodmlldy5zdGF0ZSwgZnJvbSwgLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGJhc2UgPSBpbnNlcnRUcmFuc2FjdGlvbigpLCB7IHN0YXRlIH0gPSBiYXNlO1xuICAgIGxldCBjbG9zZVRhZ3MgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBkaWRUeXBlID0gc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHJhbmdlLmZyb20gLSAxLCByYW5nZS50bykgPT0gdGV4dDtcbiAgICAgICAgbGV0IHsgaGVhZCB9ID0gcmFuZ2UsIGFmdGVyID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGhlYWQsIC0xKSwgbmFtZTtcbiAgICAgICAgaWYgKGRpZFR5cGUgJiYgdGV4dCA9PSBcIj5cIiAmJiBhZnRlci5uYW1lID09IFwiRW5kVGFnXCIpIHtcbiAgICAgICAgICAgIGxldCB0YWcgPSBhZnRlci5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRhZy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgdGFnLnBhcmVudCwgaGVhZCkpICYmXG4gICAgICAgICAgICAgICAgIXNlbGZDbG9zZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCB0byA9IGhlYWQgKyAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQsIGhlYWQgKyAxKSA9PT0gXCI+XCIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc2VydCA9IGA8LyR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCB0bywgaW5zZXJ0IH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWRUeXBlICYmIHRleHQgPT0gXCIvXCIgJiYgYWZ0ZXIubmFtZSA9PSBcIkluY29tcGxldGVDbG9zZVRhZ1wiKSB7XG4gICAgICAgICAgICBsZXQgdGFnID0gYWZ0ZXIucGFyZW50O1xuICAgICAgICAgICAgaWYgKGFmdGVyLmZyb20gPT0gaGVhZCAtIDIgJiYgKChfYyA9IHRhZy5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgdGFnLCBoZWFkKSkgJiYgIXNlbGZDbG9zZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCB0byA9IGhlYWQgKyAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQsIGhlYWQgKyAxKSA9PT0gXCI+XCIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc2VydCA9IGAke25hbWV9PmA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoaGVhZCArIGluc2VydC5sZW5ndGgsIC0xKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBoZWFkLCB0bywgaW5zZXJ0IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKGNsb3NlVGFncy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChbXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHN0YXRlLnVwZGF0ZShjbG9zZVRhZ3MsIHtcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSlcbiAgICBdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG5leHBvcnQgeyBhdXRvQ2xvc2VUYWdzLCBodG1sLCBodG1sQ29tcGxldGlvblNvdXJjZSwgaHRtbENvbXBsZXRpb25Tb3VyY2VXaXRoLCBodG1sTGFuZ3VhZ2UgfTtcbiJdLCJuYW1lcyI6WyJwYXJzZXIiLCJjb25maWd1cmVOZXN0aW5nIiwiY3NzTGFuZ3VhZ2UiLCJjc3MiLCJqYXZhc2NyaXB0TGFuZ3VhZ2UiLCJ0eXBlc2NyaXB0TGFuZ3VhZ2UiLCJqc3hMYW5ndWFnZSIsInRzeExhbmd1YWdlIiwiamF2YXNjcmlwdCIsIkVkaXRvclZpZXciLCJFZGl0b3JTZWxlY3Rpb24iLCJzeW50YXhUcmVlIiwiTFJMYW5ndWFnZSIsImluZGVudE5vZGVQcm9wIiwiZm9sZE5vZGVQcm9wIiwiYnJhY2tldE1hdGNoaW5nSGFuZGxlIiwiTGFuZ3VhZ2VTdXBwb3J0IiwiVGFyZ2V0cyIsIkNoYXJzZXRzIiwiTWV0aG9kcyIsIkVuY3MiLCJCb29sIiwiUyIsIlRhZ3MiLCJhIiwiYXR0cnMiLCJocmVmIiwicGluZyIsInR5cGUiLCJtZWRpYSIsInRhcmdldCIsImhyZWZsYW5nIiwiYWJiciIsImFkZHJlc3MiLCJhcmVhIiwiYWx0IiwiY29vcmRzIiwic2hhcGUiLCJhcnRpY2xlIiwiYXNpZGUiLCJhdWRpbyIsInNyYyIsIm1lZGlhZ3JvdXAiLCJjcm9zc29yaWdpbiIsInByZWxvYWQiLCJhdXRvcGxheSIsImxvb3AiLCJjb250cm9scyIsImIiLCJiYXNlIiwiYmRpIiwiYmRvIiwiYmxvY2txdW90ZSIsImNpdGUiLCJib2R5IiwiYnIiLCJidXR0b24iLCJmb3JtIiwiZm9ybWFjdGlvbiIsIm5hbWUiLCJ2YWx1ZSIsImF1dG9mb2N1cyIsImRpc2FibGVkIiwiZm9ybWVuY3R5cGUiLCJmb3JtbWV0aG9kIiwiZm9ybW5vdmFsaWRhdGUiLCJmb3JtdGFyZ2V0IiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJjYXB0aW9uIiwiY2VudGVyIiwiY29kZSIsImNvbCIsInNwYW4iLCJjb2xncm91cCIsImNvbW1hbmQiLCJsYWJlbCIsImljb24iLCJyYWRpb2dyb3VwIiwidGl0bGUiLCJjaGVja2VkIiwiZGF0YSIsImRhdGFncmlkIiwibXVsdGlwbGUiLCJkYXRhbGlzdCIsImRkIiwiZGVsIiwiZGF0ZXRpbWUiLCJkZXRhaWxzIiwib3BlbiIsImRmbiIsImRpdiIsImRsIiwiZHQiLCJlbSIsImVtYmVkIiwiZXZlbnRzb3VyY2UiLCJmaWVsZHNldCIsImZpZ2NhcHRpb24iLCJmaWd1cmUiLCJmb290ZXIiLCJhY3Rpb24iLCJhdXRvY29tcGxldGUiLCJlbmN0eXBlIiwibWV0aG9kIiwibm92YWxpZGF0ZSIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWQiLCJjaGlsZHJlbiIsImhlYWRlciIsImhncm91cCIsImhyIiwiaHRtbCIsIm1hbmlmZXN0IiwiaSIsImlmcmFtZSIsInNyY2RvYyIsInNhbmRib3giLCJzZWFtbGVzcyIsImltZyIsImlzbWFwIiwidXNlbWFwIiwiaW5wdXQiLCJkaXJuYW1lIiwibGlzdCIsIm1heCIsIm1heGxlbmd0aCIsIm1pbiIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInNpemUiLCJzdGVwIiwiYWNjZXB0IiwicmVhZG9ubHkiLCJyZXF1aXJlZCIsImlucyIsImtiZCIsImtleWdlbiIsImNoYWxsZW5nZSIsImtleXR5cGUiLCJmb3IiLCJsZWdlbmQiLCJsaSIsImxpbmsiLCJzaXplcyIsIm1hcCIsIm1hcmsiLCJtZW51IiwibWV0YSIsImNvbnRlbnQiLCJjaGFyc2V0IiwibWV0ZXIiLCJsb3ciLCJoaWdoIiwib3B0aW11bSIsIm5hdiIsIm5vc2NyaXB0Iiwib2JqZWN0IiwidHlwZW11c3RtYXRjaCIsIm9sIiwicmV2ZXJzZWQiLCJzdGFydCIsIm9wdGdyb3VwIiwib3B0aW9uIiwic2VsZWN0ZWQiLCJvdXRwdXQiLCJwIiwicGFyYW0iLCJwcmUiLCJwcm9ncmVzcyIsInEiLCJycCIsInJ0IiwicnVieSIsInNhbXAiLCJzY3JpcHQiLCJhc3luYyIsImRlZmVyIiwic2VjdGlvbiIsInNlbGVjdCIsInNsb3QiLCJzbWFsbCIsInNvdXJjZSIsInN0cm9uZyIsInN0eWxlIiwic2NvcGVkIiwic3ViIiwic3VtbWFyeSIsInN1cCIsInRhYmxlIiwidGJvZHkiLCJ0ZCIsImNvbHNwYW4iLCJyb3dzcGFuIiwiaGVhZGVycyIsInRlbXBsYXRlIiwidGV4dGFyZWEiLCJyb3dzIiwiY29scyIsIndyYXAiLCJ0Zm9vdCIsInRoIiwic2NvcGUiLCJ0aGVhZCIsInRpbWUiLCJ0ciIsInRyYWNrIiwiZGVmYXVsdCIsImtpbmQiLCJzcmNsYW5nIiwidWwiLCJ2YXIiLCJ2aWRlbyIsInBvc3RlciIsIm11dGVkIiwid2JyIiwiR2xvYmFsQXR0cnMiLCJhY2Nlc3NrZXkiLCJjbGFzcyIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiZGlyIiwiZHJhZ2dhYmxlIiwiZHJvcHpvbmUiLCJoaWRkZW4iLCJpZCIsImluZXJ0IiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJsYW5nIiwic3BlbGxjaGVjayIsImF1dG9jb3JyZWN0IiwiYXV0b2NhcGl0YWxpemUiLCJ0YWJpbmRleCIsInRyYW5zbGF0ZSIsInJlbCIsInJvbGUiLCJzcGxpdCIsImV2ZW50QXR0cmlidXRlcyIsIm4iLCJTY2hlbWEiLCJjb25zdHJ1Y3RvciIsImV4dHJhVGFncyIsImV4dHJhQXR0cnMiLCJ0YWdzIiwiZ2xvYmFsQXR0cnMiLCJhbGxUYWdzIiwiT2JqZWN0Iiwia2V5cyIsImdsb2JhbEF0dHJOYW1lcyIsImVsZW1lbnROYW1lIiwiZG9jIiwidHJlZSIsImxlbmd0aCIsInRhZyIsImZpcnN0Q2hpbGQiLCJnZXRDaGlsZCIsInNsaWNlU3RyaW5nIiwiZnJvbSIsIk1hdGgiLCJ0byIsImZpbmRQYXJlbnRFbGVtZW50Iiwic2tpcCIsInBhcmVudCIsImFsbG93ZWRDaGlsZHJlbiIsInNjaGVtYSIsInBhcmVudEluZm8iLCJvcGVuVGFncyIsImlzVG9wIiwidGFnTmFtZSIsImxhc3RDaGlsZCIsImluZGV4T2YiLCJwdXNoIiwiaWRlbnRpZmllciIsImNvbXBsZXRlVGFnIiwic3RhdGUiLCJlbmQiLCJ0ZXN0Iiwic2xpY2VEb2MiLCJvcHRpb25zIiwiY29uY2F0IiwiYXBwbHkiLCJib29zdCIsInZhbGlkRm9yIiwiY29tcGxldGVDbG9zZVRhZyIsImNvbXBsZXRlU3RhcnRUYWciLCJwb3MiLCJsZXZlbCIsImNvbXBsZXRlQXR0ck5hbWUiLCJlbHQiLCJpbmZvIiwibG9jYWxBdHRycyIsIm5hbWVzIiwiYXR0ck5hbWUiLCJjb21wbGV0ZUF0dHJWYWx1ZSIsIl9hIiwibmFtZU5vZGUiLCJ0b2tlbiIsInVuZGVmaW5lZCIsInRvTG93ZXJDYXNlIiwicXVvdGVTdGFydCIsInF1b3RlRW5kIiwic2xpY2UiLCJodG1sQ29tcGxldGlvbkZvciIsImNvbnRleHQiLCJyZXNvbHZlSW5uZXIiLCJhcm91bmQiLCJyZXNvbHZlIiwic2NhbiIsImJlZm9yZSIsImNoaWxkQmVmb3JlIiwibGFzdCIsImlzRXJyb3IiLCJleHBsaWNpdCIsImh0bWxDb21wbGV0aW9uU291cmNlIiwiaHRtbENvbXBsZXRpb25Tb3VyY2VXaXRoIiwiY29uZmlnIiwiZXh0cmFHbG9iYWxBdHRyaWJ1dGVzIiwianNvblBhcnNlciIsImNvbmZpZ3VyZSIsInRvcCIsImRlZmF1bHROZXN0aW5nIiwiZGVmYXVsdEF0dHJzIiwiaHRtbFBsYWluIiwiZGVmaW5lIiwicHJvcHMiLCJhZGQiLCJFbGVtZW50IiwiYWZ0ZXIiLCJleGVjIiwidGV4dEFmdGVyIiwibm9kZSIsImNvbnRpbnVlIiwibGluZUluZGVudCIsInVuaXQiLCJjb2x1bW4iLCJEb2N1bWVudCIsImVuZEVsdCIsImNsb3NlIiwiY3VyIiwiZmlyc3QiLCJsYW5ndWFnZURhdGEiLCJjb21tZW50VG9rZW5zIiwiYmxvY2siLCJpbmRlbnRPbklucHV0Iiwid29yZENoYXJzIiwiaHRtbExhbmd1YWdlIiwiZGlhbGVjdCIsIm1hdGNoQ2xvc2luZ1RhZ3MiLCJzZWxmQ2xvc2luZ1RhZ3MiLCJuZXN0ZWRMYW5ndWFnZXMiLCJuZXN0ZWRBdHRyaWJ1dGVzIiwib2YiLCJhdXRvQ2xvc2VUYWdzIiwic3VwcG9ydCIsInNlbGZDbG9zZXJzIiwiU2V0IiwiaW5wdXRIYW5kbGVyIiwidmlldyIsInRleHQiLCJpbnNlcnRUcmFuc2FjdGlvbiIsImNvbXBvc2luZyIsInJlYWRPbmx5IiwiaXNBY3RpdmVBdCIsImNsb3NlVGFncyIsImNoYW5nZUJ5UmFuZ2UiLCJyYW5nZSIsIl9iIiwiX2MiLCJkaWRUeXBlIiwiaGFzIiwiaW5zZXJ0IiwiY2hhbmdlcyIsImN1cnNvciIsImVtcHR5IiwiZGlzcGF0Y2giLCJ1cGRhdGUiLCJ1c2VyRXZlbnQiLCJzY3JvbGxJbnRvVmlldyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lang-html/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lang-javascript/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codemirror/lang-javascript/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoCloseTags: () => (/* binding */ autoCloseTags),\n/* harmony export */   completionPath: () => (/* binding */ completionPath),\n/* harmony export */   esLint: () => (/* binding */ esLint),\n/* harmony export */   javascript: () => (/* binding */ javascript),\n/* harmony export */   javascriptLanguage: () => (/* binding */ javascriptLanguage),\n/* harmony export */   jsxLanguage: () => (/* binding */ jsxLanguage),\n/* harmony export */   localCompletionSource: () => (/* binding */ localCompletionSource),\n/* harmony export */   scopeCompletionSource: () => (/* binding */ scopeCompletionSource),\n/* harmony export */   snippets: () => (/* binding */ snippets),\n/* harmony export */   tsxLanguage: () => (/* binding */ tsxLanguage),\n/* harmony export */   typescriptLanguage: () => (/* binding */ typescriptLanguage),\n/* harmony export */   typescriptSnippets: () => (/* binding */ typescriptSnippets)\n/* harmony export */ });\n/* harmony import */ var _lezer_javascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/javascript */ \"(ssr)/./node_modules/@lezer/javascript/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/ const snippets = [\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"function ${name}(${params}) {\\n\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${name} of ${collection}) {\\n\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"do {\\n\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"while (${}) {\\n\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"try {\\n\t${}\\n} catch (${error}) {\\n\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\t${}\\n} else {\\n\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"class ${name} {\\n\tconstructor(${params}) {\\n\t\t${}\\n\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)('import {${names}} from \"${module}\"\\n${}', {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)('import ${name} from \"${module}\"\\n${}', {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/ const typescriptSnippets = /*@__PURE__*/ snippets.concat([\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"interface ${name} {\\n\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"enum ${name} {\\n\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\nconst cache = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/ new Set([\n    \"Script\",\n    \"Block\",\n    \"FunctionExpression\",\n    \"FunctionDeclaration\",\n    \"ArrowFunction\",\n    \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def)=>{\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id) def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\n    \"FunctionDeclaration\"\n];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/ defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/ defID(\"class\"),\n    ClassExpression: ()=>true,\n    EnumDeclaration: /*@__PURE__*/ defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/ defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/ defID(\"namespace\"),\n    VariableDefinition (node, def) {\n        if (!node.matchContext(functionContext)) def(node, \"variable\");\n    },\n    TypeDefinition (node, def) {\n        def(node, \"type\");\n    },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached) return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({\n            label: name,\n            type\n        });\n    }\n    node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous).iterate((node)=>{\n        if (top) {\n            top = false;\n        } else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name)) return false;\n        } else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\",\n    \"String\",\n    \"RegExp\",\n    \"LineComment\",\n    \"BlockComment\",\n    \"VariableDefinition\",\n    \"TypeDefinition\",\n    \"Label\",\n    \"PropertyDefinition\",\n    \"PropertyName\",\n    \"PrivatePropertyDefinition\",\n    \"PrivatePropertyName\",\n    \"JSXText\",\n    \"JSXAttributeValue\",\n    \"JSXOpenTag\",\n    \"JSXCloseTag\",\n    \"JSXSelfClosingTag\",\n    \".\",\n    \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/ function localCompletionSource(context) {\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1) return null;\n    let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit) return null;\n    let options = [];\n    for(let pos = inner; pos; pos = pos.parent){\n        if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for(;;){\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return {\n                path: path.reverse(),\n                name\n            };\n        } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = prop = obj.lastChild) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        } else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/ function completionPath(context) {\n    let read = (node)=>context.state.doc.sliceString(node.from, node.to);\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    } else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    } else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    } else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return {\n            path: [],\n            name: read(inner)\n        };\n    } else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    } else {\n        return context.explicit ? {\n            path: [],\n            name: \"\"\n        } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for(let depth = 0;; depth++){\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)){\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name)) continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            } catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? /^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\" : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next) return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/ function scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context)=>{\n        let path = completionPath(context);\n        if (!path) return null;\n        let target = scope;\n        for (let step of path.path){\n            target = target[step];\n            if (!target) return null;\n        }\n        let options = cache.get(target);\n        if (!options) cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/ const javascriptLanguage = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/ _lezer_javascript__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentNodeProp.add({\n                IfStatement: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^\\s*({|else\\b)/\n                }),\n                TryStatement: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^\\s*({|catch\\b|finally\\b)/\n                }),\n                LabeledStatement: _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.flatIndent,\n                SwitchBody: (context)=>{\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.delimitedIndent)({\n                    closing: \"}\"\n                }),\n                ArrowFunction: (cx)=>cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": ()=>null,\n                \"Statement Property\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^\\s*{/\n                }),\n                JSXElement (context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape (context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\" (context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldInside,\n                BlockComment (tree) {\n                    return {\n                        from: tree.from + 2,\n                        to: tree.to - 2\n                    };\n                }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\n                \"(\",\n                \"[\",\n                \"{\",\n                \"'\",\n                '\"',\n                \"`\"\n            ]\n        },\n        commentTokens: {\n            line: \"//\",\n            block: {\n                open: \"/*\",\n                close: \"*/\"\n            }\n        },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: (node)=>/^JSX/.test(node.name),\n    facet: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defineLanguageFacet)({\n        commentTokens: {\n            block: {\n                open: \"{/*\",\n                close: \"*/}\"\n            }\n        }\n    })\n};\n/**\nA language provider for TypeScript.\n*/ const typescriptLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"ts\"\n}, \"typescript\");\n/**\nLanguage provider for JSX.\n*/ const jsxLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [\n        /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add((n)=>n.isTop ? [\n                jsxSublanguage\n            ] : undefined)\n    ]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/ const tsxLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [\n        /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add((n)=>n.isTop ? [\n                jsxSublanguage\n            ] : undefined)\n    ]\n}, \"typescript\");\nlet kwCompletion = (name)=>({\n        label: name,\n        type: \"keyword\"\n    });\nconst keywords = /*@__PURE__*/ \"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/ keywords.concat(/*@__PURE__*/ [\n    \"declare\",\n    \"implements\",\n    \"private\",\n    \"protected\",\n    \"public\"\n].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/ function javascript(config = {}) {\n    let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.ifNotIn)(dontComplete, (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.completeFromList)(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : []\n    ]);\n}\nfunction findOpenTag(node) {\n    for(;;){\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\") return node;\n        if (node.name == \"JSXEscape\" || !node.parent) return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for(let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling){\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" || ch.name == \"JSXMemberExpression\") return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/ const autoCloseTags = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.inputHandler.of((view, from, to, text, defaultInsert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != \">\" && text != \"/\" || !javascriptLanguage.isActiveAt(view.state, from, -1)) return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange((range)=>{\n        var _a;\n        let { head } = range, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\") around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return {\n                range,\n                changes: {\n                    from: head,\n                    insert: `</>`\n                }\n            };\n        } else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 && ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return {\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + insert.length, -1),\n                    changes: {\n                        from: head,\n                        insert\n                    }\n                };\n            }\n        } else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && openTag.name == \"JSXOpenTag\" && !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) && (name = elementName(state.doc, openTag, head))) return {\n                range,\n                changes: {\n                    from: head,\n                    insert: `</${name}>`\n                }\n            };\n        }\n        return {\n            range\n        };\n    });\n    if (closeTags.changes.empty) return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, {\n            userEvent: \"input.complete\",\n            scrollIntoView: true\n        })\n    ]);\n    return true;\n});\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/ function esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: {\n                ecmaVersion: 2019,\n                sourceType: \"module\"\n            },\n            env: {\n                browser: true,\n                node: true,\n                es6: true,\n                es2015: true,\n                es2017: true,\n                es2020: true\n            },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name)=>{\n            var _a;\n            if ((_a = desc.meta.docs) === null || _a === void 0 ? void 0 : _a.recommended) config.rules[name] = 2;\n        });\n    }\n    return (view)=>{\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)){\n            let fromLine = state.doc.lineAt(from), offset = {\n                line: fromLine.number - 1,\n                col: from - fromLine.from,\n                pos: from\n            };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\"\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [\n            {\n                name: \"fix\",\n                apply (view, start) {\n                    view.dispatch({\n                        changes: {\n                            from: start + from,\n                            to: start + to,\n                            insert: text\n                        },\n                        scrollIntoView: true\n                    });\n                }\n            }\n        ];\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1qYXZhc2NyaXB0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ2tLO0FBQ3pKO0FBQ047QUFDMEM7QUFDbEM7QUFFdEQ7OztBQUdBLEdBQ0EsTUFBTW1CLFdBQVc7SUFDYixXQUFXLEdBQUVMLDJFQUFpQkEsQ0FBQywwQ0FBMkM7UUFDdEVNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyxzRUFBdUU7UUFDbEdNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyxpREFBa0Q7UUFDN0VNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw2QkFBOEI7UUFDekRNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQywwQkFBMkI7UUFDdERNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw4Q0FBZ0Q7UUFDM0VNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyx1QkFBd0I7UUFDbkRNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyx1Q0FBeUM7UUFDcEVNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw0REFBZ0U7UUFDM0ZNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQywyQ0FBNkM7UUFDeEVN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QU1JLFNBQVMsSUFBSSxJQUFJTCxPQUFPQyxNQUFNRyxPQUFPLEVBQUVILE1BQU1JLFNBQVMsRUFBRXpMLEtBQUs4SyxVQUFVUTtRQUMxR0ksU0FBU0wsTUFBTUssT0FBTztRQUN0QkMsUUFBUU4sTUFBTU8sTUFBTSxHQUFHLFlBQVlQLE1BQU1PLE1BQU0sR0FBRztRQUNsREMsVUFBVVIsTUFBTVEsUUFBUSxJQUFJLElBQUksWUFBWTtJQUNoRDtJQUNBLElBQUlSLE1BQU1TLEdBQUcsRUFBRTtRQUNYLElBQUksRUFBRWpELEtBQUssRUFBRVQsSUFBSSxFQUFFLEdBQUdpRCxNQUFNUyxHQUFHLEVBQUV2TCxPQUFPc0ksS0FBSyxDQUFDLEVBQUUsR0FBR2lDLE9BQU90SixHQUFHLEdBQUc4SixPQUFPOUssS0FBS3FJLEtBQUssQ0FBQyxFQUFFLEdBQUdpQyxPQUFPdEosR0FBRyxHQUFHOEo7UUFDcEdDLE9BQU9RLE9BQU8sR0FBRztZQUFDO2dCQUNWMUwsTUFBTTtnQkFDTjJMLE9BQU03RCxJQUFJLEVBQUVtRCxLQUFLO29CQUNibkQsS0FBS2lCLFFBQVEsQ0FBQzt3QkFBRUosU0FBUzs0QkFBRXpJLE1BQU0rSyxRQUFRL0s7NEJBQU1DLElBQUk4SyxRQUFROUs7NEJBQUl5SSxRQUFRYjt3QkFBSzt3QkFBR21CLGdCQUFnQjtvQkFBSztnQkFDeEc7WUFDSjtTQUFFO0lBQ1Y7SUFDQSxPQUFPZ0M7QUFDWDtBQUUyTSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYXJuY29kZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLWphdmFzY3JpcHQvZGlzdC9pbmRleC5qcz9mOThkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ0BsZXplci9qYXZhc2NyaXB0JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIExSTGFuZ3VhZ2UsIGluZGVudE5vZGVQcm9wLCBjb250aW51ZWRJbmRlbnQsIGZsYXRJbmRlbnQsIGRlbGltaXRlZEluZGVudCwgZm9sZE5vZGVQcm9wLCBmb2xkSW5zaWRlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBzdWJsYW5ndWFnZVByb3AsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHNuaXBwZXRDb21wbGV0aW9uLCBpZk5vdEluLCBjb21wbGV0ZUZyb21MaXN0IH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcbmltcG9ydCB7IE5vZGVXZWFrTWFwLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkEgY29sbGVjdGlvbiBvZiBKYXZhU2NyaXB0LXJlbGF0ZWRcbltzbmlwcGV0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc25pcHBldCkuXG4qL1xuY29uc3Qgc25pcHBldHMgPSBbXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZnVuY3Rpb24gJHtuYW1lfSgke3BhcmFtc30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtib3VuZH07ICR7aW5kZXh9KyspIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZm9yXCIsXG4gICAgICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZm9yIChsZXQgJHtuYW1lfSBvZiAke2NvbGxlY3Rpb259KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImZvclwiLFxuICAgICAgICBkZXRhaWw6IFwib2YgbG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImRvIHtcXG5cXHQke31cXG59IHdoaWxlICgke30pXCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZG9cIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ3aGlsZSAoJHt9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcIndoaWxlXCIsXG4gICAgICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwidHJ5IHtcXG5cXHQke31cXG59IGNhdGNoICgke2Vycm9yfSkge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJ0cnlcIixcbiAgICAgICAgZGV0YWlsOiBcIi8gY2F0Y2ggYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpZiAoJHt9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImlmXCIsXG4gICAgICAgIGRldGFpbDogXCJibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImlmICgke30pIHtcXG5cXHQke31cXG59IGVsc2Uge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJpZlwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBlbHNlIGJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiY2xhc3MgJHtuYW1lfSB7XFxuXFx0Y29uc3RydWN0b3IoJHtwYXJhbXN9KSB7XFxuXFx0XFx0JHt9XFxuXFx0fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJjbGFzc1wiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImltcG9ydCB7JHtuYW1lc319IGZyb20gXFxcIiR7bW9kdWxlfVxcXCJcXG4ke31cIiwge1xuICAgICAgICBsYWJlbDogXCJpbXBvcnRcIixcbiAgICAgICAgZGV0YWlsOiBcIm5hbWVkXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaW1wb3J0ICR7bmFtZX0gZnJvbSBcXFwiJHttb2R1bGV9XFxcIlxcbiR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImltcG9ydFwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmYXVsdFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pXG5dO1xuLyoqXG5BIGNvbGxlY3Rpb24gb2Ygc25pcHBldCBjb21wbGV0aW9ucyBmb3IgVHlwZVNjcmlwdC4gSW5jbHVkZXMgdGhlXG5KYXZhU2NyaXB0IFtzbmlwcGV0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLWphdmFzY3JpcHQuc25pcHBldHMpLlxuKi9cbmNvbnN0IHR5cGVzY3JpcHRTbmlwcGV0cyA9IC8qQF9fUFVSRV9fKi9zbmlwcGV0cy5jb25jYXQoW1xuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImludGVyZmFjZSAke25hbWV9IHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW50ZXJmYWNlXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwidHlwZSAke25hbWV9ID0gJHt0eXBlfVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInR5cGVcIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJlbnVtICR7bmFtZX0ge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJlbnVtXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSlcbl0pO1xuXG5jb25zdCBjYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVdlYWtNYXAoKTtcbmNvbnN0IFNjb3BlTm9kZXMgPSAvKkBfX1BVUkVfXyovbmV3IFNldChbXG4gICAgXCJTY3JpcHRcIiwgXCJCbG9ja1wiLFxuICAgIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIkFycm93RnVuY3Rpb25cIiwgXCJNZXRob2REZWNsYXJhdGlvblwiLFxuICAgIFwiRm9yU3RhdGVtZW50XCJcbl0pO1xuZnVuY3Rpb24gZGVmSUQodHlwZSkge1xuICAgIHJldHVybiAobm9kZSwgZGVmKSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG5vZGUubm9kZS5nZXRDaGlsZChcIlZhcmlhYmxlRGVmaW5pdGlvblwiKTtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgZGVmKGlkLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IFtcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIl07XG5jb25zdCBnYXRoZXJDb21wbGV0aW9ucyA9IHtcbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJmdW5jdGlvblwiKSxcbiAgICBDbGFzc0RlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJjbGFzc1wiKSxcbiAgICBDbGFzc0V4cHJlc3Npb246ICgpID0+IHRydWUsXG4gICAgRW51bURlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJjb25zdGFudFwiKSxcbiAgICBUeXBlQWxpYXNEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwidHlwZVwiKSxcbiAgICBOYW1lc3BhY2VEZWNsYXJhdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwibmFtZXNwYWNlXCIpLFxuICAgIFZhcmlhYmxlRGVmaW5pdGlvbihub2RlLCBkZWYpIHsgaWYgKCFub2RlLm1hdGNoQ29udGV4dChmdW5jdGlvbkNvbnRleHQpKVxuICAgICAgICBkZWYobm9kZSwgXCJ2YXJpYWJsZVwiKTsgfSxcbiAgICBUeXBlRGVmaW5pdGlvbihub2RlLCBkZWYpIHsgZGVmKG5vZGUsIFwidHlwZVwiKTsgfSxcbiAgICBfX3Byb3RvX186IG51bGxcbn07XG5mdW5jdGlvbiBnZXRTY29wZShkb2MsIG5vZGUpIHtcbiAgICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IGNvbXBsZXRpb25zID0gW10sIHRvcCA9IHRydWU7XG4gICAgZnVuY3Rpb24gZGVmKG5vZGUsIHR5cGUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb2Muc2xpY2VTdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKTtcbiAgICAgICAgY29tcGxldGlvbnMucHVzaCh7IGxhYmVsOiBuYW1lLCB0eXBlIH0pO1xuICAgIH1cbiAgICBub2RlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKS5pdGVyYXRlKG5vZGUgPT4ge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICB0b3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgIGxldCBnYXRoZXIgPSBnYXRoZXJDb21wbGV0aW9uc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgaWYgKGdhdGhlciAmJiBnYXRoZXIobm9kZSwgZGVmKSB8fCBTY29wZU5vZGVzLmhhcyhub2RlLm5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnRvIC0gbm9kZS5mcm9tID4gODE5Mikge1xuICAgICAgICAgICAgLy8gQWxsb3cgY2FjaGluZyBmb3IgYmlnZ2VyIGludGVybmFsIG5vZGVzXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGdldFNjb3BlKGRvYywgbm9kZS5ub2RlKSlcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2FjaGUuc2V0KG5vZGUsIGNvbXBsZXRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG5jb25zdCBJZGVudGlmaWVyID0gL15bXFx3JFxceGExLVxcdWZmZmZdW1xcdyRcXGRcXHhhMS1cXHVmZmZmXSokLztcbmNvbnN0IGRvbnRDb21wbGV0ZSA9IFtcbiAgICBcIlRlbXBsYXRlU3RyaW5nXCIsIFwiU3RyaW5nXCIsIFwiUmVnRXhwXCIsXG4gICAgXCJMaW5lQ29tbWVudFwiLCBcIkJsb2NrQ29tbWVudFwiLFxuICAgIFwiVmFyaWFibGVEZWZpbml0aW9uXCIsIFwiVHlwZURlZmluaXRpb25cIiwgXCJMYWJlbFwiLFxuICAgIFwiUHJvcGVydHlEZWZpbml0aW9uXCIsIFwiUHJvcGVydHlOYW1lXCIsXG4gICAgXCJQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uXCIsIFwiUHJpdmF0ZVByb3BlcnR5TmFtZVwiLFxuICAgIFwiSlNYVGV4dFwiLCBcIkpTWEF0dHJpYnV0ZVZhbHVlXCIsIFwiSlNYT3BlblRhZ1wiLCBcIkpTWENsb3NlVGFnXCIsIFwiSlNYU2VsZkNsb3NpbmdUYWdcIixcbiAgICBcIi5cIiwgXCI/LlwiXG5dO1xuLyoqXG5Db21wbGV0aW9uIHNvdXJjZSB0aGF0IGxvb2tzIHVwIGxvY2FsbHkgZGVmaW5lZCBuYW1lcyBpblxuSmF2YVNjcmlwdCBjb2RlLlxuKi9cbmZ1bmN0aW9uIGxvY2FsQ29tcGxldGlvblNvdXJjZShjb250ZXh0KSB7XG4gICAgbGV0IGlubmVyID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTtcbiAgICBpZiAoZG9udENvbXBsZXRlLmluZGV4T2YoaW5uZXIubmFtZSkgPiAtMSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGlzV29yZCA9IGlubmVyLm5hbWUgPT0gXCJWYXJpYWJsZU5hbWVcIiB8fFxuICAgICAgICBpbm5lci50byAtIGlubmVyLmZyb20gPCAyMCAmJiBJZGVudGlmaWVyLnRlc3QoY29udGV4dC5zdGF0ZS5zbGljZURvYyhpbm5lci5mcm9tLCBpbm5lci50bykpO1xuICAgIGlmICghaXNXb3JkICYmICFjb250ZXh0LmV4cGxpY2l0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb3B0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGlubmVyOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgaWYgKFNjb3BlTm9kZXMuaGFzKHBvcy5uYW1lKSlcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNvbmNhdChnZXRTY29wZShjb250ZXh0LnN0YXRlLmRvYywgcG9zKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGZyb206IGlzV29yZCA/IGlubmVyLmZyb20gOiBjb250ZXh0LnBvcyxcbiAgICAgICAgdmFsaWRGb3I6IElkZW50aWZpZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gcGF0aEZvcihyZWFkLCBtZW1iZXIsIG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhdGggPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBvYmogPSBtZW1iZXIuZmlyc3RDaGlsZCwgcHJvcDtcbiAgICAgICAgaWYgKChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoubmFtZSkgPT0gXCJWYXJpYWJsZU5hbWVcIikge1xuICAgICAgICAgICAgcGF0aC5wdXNoKHJlYWQob2JqKSk7XG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLnJldmVyc2UoKSwgbmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoubmFtZSkgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgKChfYSA9IChwcm9wID0gb2JqLmxhc3RDaGlsZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PSBcIlByb3BlcnR5TmFtZVwiKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gocmVhZChwcm9wKSk7XG4gICAgICAgICAgICBtZW1iZXIgPSBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuSGVscGVyIGZ1bmN0aW9uIGZvciBkZWZpbmluZyBKYXZhU2NyaXB0IGNvbXBsZXRpb24gc291cmNlcy4gSXRcbnJldHVybnMgdGhlIGNvbXBsZXRhYmxlIG5hbWUgYW5kIG9iamVjdCBwYXRoIGZvciBhIGNvbXBsZXRpb25cbmNvbnRleHQsIG9yIG51bGwgaWYgbm8gbmFtZS9wcm9wZXJ0eSBjb21wbGV0aW9uIHNob3VsZCBoYXBwZW4gYXRcbnRoYXQgcG9zaXRpb24uIEZvciBleGFtcGxlLCB3aGVuIGNvbXBsZXRpbmcgYWZ0ZXIgYGEuYi5jYCBpdCB3aWxsXG5yZXR1cm4gYHtwYXRoOiBbXCJhXCIsIFwiYlwiXSwgbmFtZTogXCJjXCJ9YC4gV2hlbiBjb21wbGV0aW5nIGFmdGVyIGB4YFxuaXQgd2lsbCByZXR1cm4gYHtwYXRoOiBbXSwgbmFtZTogXCJ4XCJ9YC4gV2hlbiBub3QgaW4gYSBwcm9wZXJ0eSBvclxubmFtZSwgaXQgd2lsbCByZXR1cm4gbnVsbCBpZiBgY29udGV4dC5leHBsaWNpdGAgaXMgZmFsc2UsIGFuZFxuYHtwYXRoOiBbXSwgbmFtZTogXCJcIn1gIG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBjb21wbGV0aW9uUGF0aChjb250ZXh0KSB7XG4gICAgbGV0IHJlYWQgPSAobm9kZSkgPT4gY29udGV4dC5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcobm9kZS5mcm9tLCBub2RlLnRvKTtcbiAgICBsZXQgaW5uZXIgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpO1xuICAgIGlmIChpbm5lci5uYW1lID09IFwiUHJvcGVydHlOYW1lXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhGb3IocmVhZCwgaW5uZXIucGFyZW50LCByZWFkKGlubmVyKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChpbm5lci5uYW1lID09IFwiLlwiIHx8IGlubmVyLm5hbWUgPT0gXCI/LlwiKSAmJiBpbm5lci5wYXJlbnQubmFtZSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gcGF0aEZvcihyZWFkLCBpbm5lci5wYXJlbnQsIFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb250Q29tcGxldGUuaW5kZXhPZihpbm5lci5uYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbm5lci5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIgfHwgaW5uZXIudG8gLSBpbm5lci5mcm9tIDwgMjAgJiYgSWRlbnRpZmllci50ZXN0KHJlYWQoaW5uZXIpKSkge1xuICAgICAgICByZXR1cm4geyBwYXRoOiBbXSwgbmFtZTogcmVhZChpbm5lcikgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5uZXIubmFtZSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gcGF0aEZvcihyZWFkLCBpbm5lciwgXCJcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGV4dC5leHBsaWNpdCA/IHsgcGF0aDogW10sIG5hbWU6IFwiXCIgfSA6IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZW51bWVyYXRlUHJvcGVydHlDb21wbGV0aW9ucyhvYmosIHRvcCkge1xuICAgIGxldCBvcHRpb25zID0gW10sIHNlZW4gPSBuZXcgU2V0O1xuICAgIGZvciAobGV0IGRlcHRoID0gMDs7IGRlcHRoKyspIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBvZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgT2JqZWN0LmtleXMpKG9iaikpIHtcbiAgICAgICAgICAgIGlmICghL15bYS16QS1aXyRcXHhhYS1cXHVmZmRjXVtcXHckXFx4YWEtXFx1ZmZkY10qJC8udGVzdChuYW1lKSB8fCBzZWVuLmhhcyhuYW1lKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHNlZW4uYWRkKG5hbWUpO1xuICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9ialtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIgPyAoL15bQS1aXS8udGVzdChuYW1lKSA/IFwiY2xhc3NcIiA6IHRvcCA/IFwiZnVuY3Rpb25cIiA6IFwibWV0aG9kXCIpXG4gICAgICAgICAgICAgICAgICAgIDogdG9wID8gXCJ2YXJpYWJsZVwiIDogXCJwcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICAgIGJvb3N0OiAtZGVwdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICBvYmogPSBuZXh0O1xuICAgIH1cbn1cbi8qKlxuRGVmaW5lcyBhIFtjb21wbGV0aW9uIHNvdXJjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvblNvdXJjZSkgdGhhdFxuY29tcGxldGVzIGZyb20gdGhlIGdpdmVuIHNjb3BlIG9iamVjdCAoZm9yIGV4YW1wbGUgYGdsb2JhbFRoaXNgKS5cbldpbGwgZW50ZXIgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IHdoZW4gY29tcGxldGluZyBwcm9wZXJ0aWVzIG9uXG5hIGRpcmVjdGx5LW5hbWVkIHBhdGguXG4qL1xuZnVuY3Rpb24gc2NvcGVDb21wbGV0aW9uU291cmNlKHNjb3BlKSB7XG4gICAgbGV0IGNhY2hlID0gbmV3IE1hcDtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHBhdGggPSBjb21wbGV0aW9uUGF0aChjb250ZXh0KTtcbiAgICAgICAgaWYgKCFwYXRoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0YXJnZXQgPSBzY29wZTtcbiAgICAgICAgZm9yIChsZXQgc3RlcCBvZiBwYXRoLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtzdGVwXTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcHRpb25zID0gY2FjaGUuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIGNhY2hlLnNldCh0YXJnZXQsIG9wdGlvbnMgPSBlbnVtZXJhdGVQcm9wZXJ0eUNvbXBsZXRpb25zKHRhcmdldCwgIXBhdGgucGF0aC5sZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGNvbnRleHQucG9zIC0gcGF0aC5uYW1lLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgICAgICB9O1xuICAgIH07XG59XG5cbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIEphdmFTY3JpcHRcbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci9qYXZhc2NyaXB0KSwgZXh0ZW5kZWQgd2l0aFxuaGlnaGxpZ2h0aW5nIGFuZCBpbmRlbnRhdGlvbiBpbmZvcm1hdGlvbi5cbiovXG5jb25zdCBqYXZhc2NyaXB0TGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIG5hbWU6IFwiamF2YXNjcmlwdFwiLFxuICAgIHBhcnNlcjogLypAX19QVVJFX18qL3BhcnNlci5jb25maWd1cmUoe1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgLypAX19QVVJFX18qL2luZGVudE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgSWZTdGF0ZW1lbnQ6IC8qQF9fUFVSRV9fKi9jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eXFxzKih7fGVsc2VcXGIpLyB9KSxcbiAgICAgICAgICAgICAgICBUcnlTdGF0ZW1lbnQ6IC8qQF9fUFVSRV9fKi9jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eXFxzKih7fGNhdGNoXFxifGZpbmFsbHlcXGIpLyB9KSxcbiAgICAgICAgICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBmbGF0SW5kZW50LFxuICAgICAgICAgICAgICAgIFN3aXRjaEJvZHk6IGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBjb250ZXh0LnRleHRBZnRlciwgY2xvc2VkID0gL15cXHMqXFx9Ly50ZXN0KGFmdGVyKSwgaXNDYXNlID0gL15cXHMqKGNhc2V8ZGVmYXVsdClcXGIvLnRlc3QoYWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBpc0Nhc2UgPyAxIDogMikgKiBjb250ZXh0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBCbG9jazogLypAX19QVVJFX18qL2RlbGltaXRlZEluZGVudCh7IGNsb3Npbmc6IFwifVwiIH0pLFxuICAgICAgICAgICAgICAgIEFycm93RnVuY3Rpb246IGN4ID0+IGN4LmJhc2VJbmRlbnQgKyBjeC51bml0LFxuICAgICAgICAgICAgICAgIFwiVGVtcGxhdGVTdHJpbmcgQmxvY2tDb21tZW50XCI6ICgpID0+IG51bGwsXG4gICAgICAgICAgICAgICAgXCJTdGF0ZW1lbnQgUHJvcGVydHlcIjogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqey8gfSksXG4gICAgICAgICAgICAgICAgSlNYRWxlbWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9zZWQgPSAvXlxccyo8XFwvLy50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChjb250ZXh0Lm5vZGUuZnJvbSkgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBKU1hFc2NhcGUoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2xvc2VkID0gL1xccypcXH0vLnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGNvbnRleHQubm9kZS5mcm9tKSArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiSlNYT3BlblRhZyBKU1hTZWxmQ2xvc2luZ1RhZ1wiKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29sdW1uKGNvbnRleHQubm9kZS5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9mb2xkTm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBcIkJsb2NrIENsYXNzQm9keSBTd2l0Y2hCb2R5IEVudW1Cb2R5IE9iamVjdEV4cHJlc3Npb24gQXJyYXlFeHByZXNzaW9uIE9iamVjdFR5cGVcIjogZm9sZEluc2lkZSxcbiAgICAgICAgICAgICAgICBCbG9ja0NvbW1lbnQodHJlZSkgeyByZXR1cm4geyBmcm9tOiB0cmVlLmZyb20gKyAyLCB0bzogdHJlZS50byAtIDIgfTsgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIGxhbmd1YWdlRGF0YToge1xuICAgICAgICBjbG9zZUJyYWNrZXRzOiB7IGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIicsIFwiYFwiXSB9LFxuICAgICAgICBjb21tZW50VG9rZW5zOiB7IGxpbmU6IFwiLy9cIiwgYmxvY2s6IHsgb3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wiIH0gfSxcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqKD86Y2FzZSB8ZGVmYXVsdDp8XFx7fFxcfXw8XFwvKSQvLFxuICAgICAgICB3b3JkQ2hhcnM6IFwiJFwiXG4gICAgfVxufSk7XG5jb25zdCBqc3hTdWJsYW5ndWFnZSA9IHtcbiAgICB0ZXN0OiBub2RlID0+IC9eSlNYLy50ZXN0KG5vZGUubmFtZSksXG4gICAgZmFjZXQ6IC8qQF9fUFVSRV9fKi9kZWZpbmVMYW5ndWFnZUZhY2V0KHsgY29tbWVudFRva2VuczogeyBibG9jazogeyBvcGVuOiBcInsvKlwiLCBjbG9zZTogXCIqL31cIiB9IH0gfSlcbn07XG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgZm9yIFR5cGVTY3JpcHQuXG4qL1xuY29uc3QgdHlwZXNjcmlwdExhbmd1YWdlID0gLypAX19QVVJFX18qL2phdmFzY3JpcHRMYW5ndWFnZS5jb25maWd1cmUoeyBkaWFsZWN0OiBcInRzXCIgfSwgXCJ0eXBlc2NyaXB0XCIpO1xuLyoqXG5MYW5ndWFnZSBwcm92aWRlciBmb3IgSlNYLlxuKi9cbmNvbnN0IGpzeExhbmd1YWdlID0gLypAX19QVVJFX18qL2phdmFzY3JpcHRMYW5ndWFnZS5jb25maWd1cmUoe1xuICAgIGRpYWxlY3Q6IFwianN4XCIsXG4gICAgcHJvcHM6IFsvKkBfX1BVUkVfXyovc3VibGFuZ3VhZ2VQcm9wLmFkZChuID0+IG4uaXNUb3AgPyBbanN4U3VibGFuZ3VhZ2VdIDogdW5kZWZpbmVkKV1cbn0pO1xuLyoqXG5MYW5ndWFnZSBwcm92aWRlciBmb3IgSlNYICsgVHlwZVNjcmlwdC5cbiovXG5jb25zdCB0c3hMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UuY29uZmlndXJlKHtcbiAgICBkaWFsZWN0OiBcImpzeCB0c1wiLFxuICAgIHByb3BzOiBbLypAX19QVVJFX18qL3N1Ymxhbmd1YWdlUHJvcC5hZGQobiA9PiBuLmlzVG9wID8gW2pzeFN1Ymxhbmd1YWdlXSA6IHVuZGVmaW5lZCldXG59LCBcInR5cGVzY3JpcHRcIik7XG5sZXQga3dDb21wbGV0aW9uID0gKG5hbWUpID0+ICh7IGxhYmVsOiBuYW1lLCB0eXBlOiBcImtleXdvcmRcIiB9KTtcbmNvbnN0IGtleXdvcmRzID0gLypAX19QVVJFX18qL1wiYnJlYWsgY2FzZSBjb25zdCBjb250aW51ZSBkZWZhdWx0IGRlbGV0ZSBleHBvcnQgZXh0ZW5kcyBmYWxzZSBmaW5hbGx5IGluIGluc3RhbmNlb2YgbGV0IG5ldyByZXR1cm4gc3RhdGljIHN1cGVyIHN3aXRjaCB0aGlzIHRocm93IHRydWUgdHlwZW9mIHZhciB5aWVsZFwiLnNwbGl0KFwiIFwiKS5tYXAoa3dDb21wbGV0aW9uKTtcbmNvbnN0IHR5cGVzY3JpcHRLZXl3b3JkcyA9IC8qQF9fUFVSRV9fKi9rZXl3b3Jkcy5jb25jYXQoLypAX19QVVJFX18qL1tcImRlY2xhcmVcIiwgXCJpbXBsZW1lbnRzXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiXS5tYXAoa3dDb21wbGV0aW9uKSk7XG4vKipcbkphdmFTY3JpcHQgc3VwcG9ydC4gSW5jbHVkZXMgW3NuaXBwZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZy1qYXZhc2NyaXB0LnNuaXBwZXRzKVxuYW5kIGxvY2FsIHZhcmlhYmxlIGNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gamF2YXNjcmlwdChjb25maWcgPSB7fSkge1xuICAgIGxldCBsYW5nID0gY29uZmlnLmpzeCA/IChjb25maWcudHlwZXNjcmlwdCA/IHRzeExhbmd1YWdlIDoganN4TGFuZ3VhZ2UpXG4gICAgICAgIDogY29uZmlnLnR5cGVzY3JpcHQgPyB0eXBlc2NyaXB0TGFuZ3VhZ2UgOiBqYXZhc2NyaXB0TGFuZ3VhZ2U7XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29uZmlnLnR5cGVzY3JpcHQgPyB0eXBlc2NyaXB0U25pcHBldHMuY29uY2F0KHR5cGVzY3JpcHRLZXl3b3JkcykgOiBzbmlwcGV0cy5jb25jYXQoa2V5d29yZHMpO1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KGxhbmcsIFtcbiAgICAgICAgamF2YXNjcmlwdExhbmd1YWdlLmRhdGEub2Yoe1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBpZk5vdEluKGRvbnRDb21wbGV0ZSwgY29tcGxldGVGcm9tTGlzdChjb21wbGV0aW9ucykpXG4gICAgICAgIH0pLFxuICAgICAgICBqYXZhc2NyaXB0TGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IGxvY2FsQ29tcGxldGlvblNvdXJjZVxuICAgICAgICB9KSxcbiAgICAgICAgY29uZmlnLmpzeCA/IGF1dG9DbG9zZVRhZ3MgOiBbXSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGZpbmRPcGVuVGFnKG5vZGUpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJKU1hPcGVuVGFnXCIgfHwgbm9kZS5uYW1lID09IFwiSlNYU2VsZkNsb3NpbmdUYWdcIiB8fCBub2RlLm5hbWUgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJKU1hFc2NhcGVcIiB8fCAhbm9kZS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnROYW1lKGRvYywgdHJlZSwgbWF4ID0gZG9jLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGNoID0gdHJlZSA9PT0gbnVsbCB8fCB0cmVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmVlLmZpcnN0Q2hpbGQ7IGNoOyBjaCA9IGNoLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChjaC5uYW1lID09IFwiSlNYSWRlbnRpZmllclwiIHx8IGNoLm5hbWUgPT0gXCJKU1hCdWlsdGluXCIgfHwgY2gubmFtZSA9PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIgfHxcbiAgICAgICAgICAgIGNoLm5hbWUgPT0gXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgICAgICAgICByZXR1cm4gZG9jLnNsaWNlU3RyaW5nKGNoLmZyb20sIE1hdGgubWluKGNoLnRvLCBtYXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8qKlxuRXh0ZW5zaW9uIHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IGluc2VydCBKU1ggY2xvc2UgdGFncyB3aGVuIGEgYD5gIG9yXG5gL2AgaXMgdHlwZWQuXG4qL1xuY29uc3QgYXV0b0Nsb3NlVGFncyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIHRleHQsIGRlZmF1bHRJbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5IHx8XG4gICAgICAgIGZyb20gIT0gdG8gfHwgKHRleHQgIT0gXCI+XCIgJiYgdGV4dCAhPSBcIi9cIikgfHxcbiAgICAgICAgIWphdmFzY3JpcHRMYW5ndWFnZS5pc0FjdGl2ZUF0KHZpZXcuc3RhdGUsIGZyb20sIC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBiYXNlID0gZGVmYXVsdEluc2VydCgpLCB7IHN0YXRlIH0gPSBiYXNlO1xuICAgIGxldCBjbG9zZVRhZ3MgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgeyBoZWFkIH0gPSByYW5nZSwgYXJvdW5kID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGhlYWQgLSAxLCAtMSksIG5hbWU7XG4gICAgICAgIGlmIChhcm91bmQubmFtZSA9PSBcIkpTWFN0YXJ0VGFnXCIpXG4gICAgICAgICAgICBhcm91bmQgPSBhcm91bmQucGFyZW50O1xuICAgICAgICBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQgLSAxLCBoZWFkKSAhPSB0ZXh0IHx8IGFyb3VuZC5uYW1lID09IFwiSlNYQXR0cmlidXRlVmFsdWVcIiAmJiBhcm91bmQudG8gPiBoZWFkKSA7XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gXCI+XCIgJiYgYXJvdW5kLm5hbWUgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCBpbnNlcnQ6IGA8Lz5gIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09IFwiL1wiICYmIGFyb3VuZC5uYW1lID09IFwiSlNYU3RhcnRDbG9zZVRhZ1wiKSB7XG4gICAgICAgICAgICBsZXQgZW1wdHkgPSBhcm91bmQucGFyZW50LCBiYXNlID0gZW1wdHkucGFyZW50O1xuICAgICAgICAgICAgaWYgKGJhc2UgJiYgZW1wdHkuZnJvbSA9PSBoZWFkIC0gMiAmJlxuICAgICAgICAgICAgICAgICgobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgYmFzZS5maXJzdENoaWxkLCBoZWFkKSkgfHwgKChfYSA9IGJhc2UuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiSlNYRnJhZ21lbnRUYWdcIikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ID0gYCR7bmFtZX0+YDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkICsgaW5zZXJ0Lmxlbmd0aCwgLTEpLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydCB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIj5cIikge1xuICAgICAgICAgICAgbGV0IG9wZW5UYWcgPSBmaW5kT3BlblRhZyhhcm91bmQpO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWcgJiYgb3BlblRhZy5uYW1lID09IFwiSlNYT3BlblRhZ1wiICYmXG4gICAgICAgICAgICAgICAgIS9eXFwvPz58XjxcXC8vLnRlc3Qoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQsIGhlYWQgKyAyKSkgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgb3BlblRhZywgaGVhZCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydDogYDwvJHtuYW1lfT5gIH0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgIH0pO1xuICAgIGlmIChjbG9zZVRhZ3MuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goW1xuICAgICAgICBiYXNlLFxuICAgICAgICBzdGF0ZS51cGRhdGUoY2xvc2VUYWdzLCB7IHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KVxuICAgIF0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5cbi8qKlxuQ29ubmVjdHMgYW4gW0VTTGludF0oaHR0cHM6Ly9lc2xpbnQub3JnLykgbGludGVyIHRvIENvZGVNaXJyb3Inc1xuW2xpbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludCkgaW50ZWdyYXRpb24uIGBlc2xpbnRgIHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiB0aGVcbltgTGludGVyYF0oaHR0cHM6Ly9lc2xpbnQub3JnL2RvY3MvZGV2ZWxvcGVyLWd1aWRlL25vZGVqcy1hcGkjbGludGVyKVxuY2xhc3MsIGFuZCBgY29uZmlnYCBhbiBvcHRpb25hbCBFU0xpbnQgY29uZmlndXJhdGlvbi4gVGhlIHJldHVyblxudmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIHRvIFtgbGludGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50LmxpbnRlcilcbnRvIGNyZWF0ZSBhIEphdmFTY3JpcHQgbGludGluZyBleHRlbnNpb24uXG5cbk5vdGUgdGhhdCBFU0xpbnQgdGFyZ2V0cyBub2RlLCBhbmQgaXMgdHJpY2t5IHRvIHJ1biBpbiB0aGVcbmJyb3dzZXIuIFRoZVxuW2VzbGludC1saW50ZXItYnJvd3NlcmlmeV0oaHR0cHM6Ly9naXRodWIuY29tL1V6aVRlY2gvZXNsaW50LWxpbnRlci1icm93c2VyaWZ5KVxucGFja2FnZSBtYXkgaGVscCB3aXRoIHRoYXQgKHNlZVxuW2V4YW1wbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9VemlUZWNoL2VzbGludC1saW50ZXItYnJvd3NlcmlmeS9ibG9iL21hc3Rlci9leGFtcGxlL3NjcmlwdC5qcykpLlxuKi9cbmZ1bmN0aW9uIGVzTGludChlc2xpbnQsIGNvbmZpZykge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHBhcnNlck9wdGlvbnM6IHsgZWNtYVZlcnNpb246IDIwMTksIHNvdXJjZVR5cGU6IFwibW9kdWxlXCIgfSxcbiAgICAgICAgICAgIGVudjogeyBicm93c2VyOiB0cnVlLCBub2RlOiB0cnVlLCBlczY6IHRydWUsIGVzMjAxNTogdHJ1ZSwgZXMyMDE3OiB0cnVlLCBlczIwMjA6IHRydWUgfSxcbiAgICAgICAgICAgIHJ1bGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBlc2xpbnQuZ2V0UnVsZXMoKS5mb3JFYWNoKChkZXNjLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoKF9hID0gZGVzYy5tZXRhLmRvY3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWNvbW1lbmRlZClcbiAgICAgICAgICAgICAgICBjb25maWcucnVsZXNbbmFtZV0gPSAyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgamF2YXNjcmlwdExhbmd1YWdlLmZpbmRSZWdpb25zKHN0YXRlKSkge1xuICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKSwgb2Zmc2V0ID0geyBsaW5lOiBmcm9tTGluZS5udW1iZXIgLSAxLCBjb2w6IGZyb20gLSBmcm9tTGluZS5mcm9tLCBwb3M6IGZyb20gfTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZXNsaW50LnZlcmlmeShzdGF0ZS5zbGljZURvYyhmcm9tLCB0byksIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaCh0cmFuc2xhdGVEaWFnbm9zdGljKGQsIHN0YXRlLmRvYywgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXBQb3MobGluZSwgY29sLCBkb2MsIG9mZnNldCkge1xuICAgIHJldHVybiBkb2MubGluZShsaW5lICsgb2Zmc2V0LmxpbmUpLmZyb20gKyBjb2wgKyAobGluZSA9PSAxID8gb2Zmc2V0LmNvbCAtIDEgOiAtMSk7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVEaWFnbm9zdGljKGlucHV0LCBkb2MsIG9mZnNldCkge1xuICAgIGxldCBzdGFydCA9IG1hcFBvcyhpbnB1dC5saW5lLCBpbnB1dC5jb2x1bW4sIGRvYywgb2Zmc2V0KTtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBmcm9tOiBzdGFydCxcbiAgICAgICAgdG86IGlucHV0LmVuZExpbmUgIT0gbnVsbCAmJiBpbnB1dC5lbmRDb2x1bW4gIT0gMSA/IG1hcFBvcyhpbnB1dC5lbmRMaW5lLCBpbnB1dC5lbmRDb2x1bW4sIGRvYywgb2Zmc2V0KSA6IHN0YXJ0LFxuICAgICAgICBtZXNzYWdlOiBpbnB1dC5tZXNzYWdlLFxuICAgICAgICBzb3VyY2U6IGlucHV0LnJ1bGVJZCA/IFwiZXNsaW50OlwiICsgaW5wdXQucnVsZUlkIDogXCJlc2xpbnRcIixcbiAgICAgICAgc2V2ZXJpdHk6IGlucHV0LnNldmVyaXR5ID09IDEgPyBcIndhcm5pbmdcIiA6IFwiZXJyb3JcIixcbiAgICB9O1xuICAgIGlmIChpbnB1dC5maXgpIHtcbiAgICAgICAgbGV0IHsgcmFuZ2UsIHRleHQgfSA9IGlucHV0LmZpeCwgZnJvbSA9IHJhbmdlWzBdICsgb2Zmc2V0LnBvcyAtIHN0YXJ0LCB0byA9IHJhbmdlWzFdICsgb2Zmc2V0LnBvcyAtIHN0YXJ0O1xuICAgICAgICByZXN1bHQuYWN0aW9ucyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJmaXhcIixcbiAgICAgICAgICAgICAgICBhcHBseSh2aWV3LCBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlczogeyBmcm9tOiBzdGFydCArIGZyb20sIHRvOiBzdGFydCArIHRvLCBpbnNlcnQ6IHRleHQgfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGF1dG9DbG9zZVRhZ3MsIGNvbXBsZXRpb25QYXRoLCBlc0xpbnQsIGphdmFzY3JpcHQsIGphdmFzY3JpcHRMYW5ndWFnZSwganN4TGFuZ3VhZ2UsIGxvY2FsQ29tcGxldGlvblNvdXJjZSwgc2NvcGVDb21wbGV0aW9uU291cmNlLCBzbmlwcGV0cywgdHN4TGFuZ3VhZ2UsIHR5cGVzY3JpcHRMYW5ndWFnZSwgdHlwZXNjcmlwdFNuaXBwZXRzIH07XG4iXSwibmFtZXMiOlsicGFyc2VyIiwic3ludGF4VHJlZSIsIkxSTGFuZ3VhZ2UiLCJpbmRlbnROb2RlUHJvcCIsImNvbnRpbnVlZEluZGVudCIsImZsYXRJbmRlbnQiLCJkZWxpbWl0ZWRJbmRlbnQiLCJmb2xkTm9kZVByb3AiLCJmb2xkSW5zaWRlIiwiZGVmaW5lTGFuZ3VhZ2VGYWNldCIsInN1Ymxhbmd1YWdlUHJvcCIsIkxhbmd1YWdlU3VwcG9ydCIsIkVkaXRvclNlbGVjdGlvbiIsIkVkaXRvclZpZXciLCJzbmlwcGV0Q29tcGxldGlvbiIsImlmTm90SW4iLCJjb21wbGV0ZUZyb21MaXN0IiwiTm9kZVdlYWtNYXAiLCJJdGVyTW9kZSIsInNuaXBwZXRzIiwibGFiZWwiLCJkZXRhaWwiLCJ0eXBlIiwidHlwZXNjcmlwdFNuaXBwZXRzIiwiY29uY2F0IiwiY2FjaGUiLCJTY29wZU5vZGVzIiwiU2V0IiwiZGVmSUQiLCJub2RlIiwiZGVmIiwiaWQiLCJnZXRDaGlsZCIsImZ1bmN0aW9uQ29udGV4dCIsImdhdGhlckNvbXBsZXRpb25zIiwiRnVuY3Rpb25EZWNsYXJhdGlvbiIsIkNsYXNzRGVjbGFyYXRpb24iLCJDbGFzc0V4cHJlc3Npb24iLCJFbnVtRGVjbGFyYXRpb24iLCJUeXBlQWxpYXNEZWNsYXJhdGlvbiIsIk5hbWVzcGFjZURlY2xhcmF0aW9uIiwiVmFyaWFibGVEZWZpbml0aW9uIiwibWF0Y2hDb250ZXh0IiwiVHlwZURlZmluaXRpb24iLCJfX3Byb3RvX18iLCJnZXRTY29wZSIsImRvYyIsImNhY2hlZCIsImdldCIsImNvbXBsZXRpb25zIiwidG9wIiwibmFtZSIsInNsaWNlU3RyaW5nIiwiZnJvbSIsInRvIiwicHVzaCIsImN1cnNvciIsIkluY2x1ZGVBbm9ueW1vdXMiLCJpdGVyYXRlIiwiZ2F0aGVyIiwiaGFzIiwiYyIsInNldCIsIklkZW50aWZpZXIiLCJkb250Q29tcGxldGUiLCJsb2NhbENvbXBsZXRpb25Tb3VyY2UiLCJjb250ZXh0IiwiaW5uZXIiLCJzdGF0ZSIsInJlc29sdmVJbm5lciIsInBvcyIsImluZGV4T2YiLCJpc1dvcmQiLCJ0ZXN0Iiwic2xpY2VEb2MiLCJleHBsaWNpdCIsIm9wdGlvbnMiLCJwYXJlbnQiLCJ2YWxpZEZvciIsInBhdGhGb3IiLCJyZWFkIiwibWVtYmVyIiwiX2EiLCJwYXRoIiwib2JqIiwiZmlyc3RDaGlsZCIsInByb3AiLCJyZXZlcnNlIiwibGFzdENoaWxkIiwiY29tcGxldGlvblBhdGgiLCJlbnVtZXJhdGVQcm9wZXJ0eUNvbXBsZXRpb25zIiwic2VlbiIsImRlcHRoIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleXMiLCJhZGQiLCJ2YWx1ZSIsIl8iLCJib29zdCIsIm5leHQiLCJnZXRQcm90b3R5cGVPZiIsInNjb3BlQ29tcGxldGlvblNvdXJjZSIsInNjb3BlIiwiTWFwIiwidGFyZ2V0Iiwic3RlcCIsImxlbmd0aCIsImphdmFzY3JpcHRMYW5ndWFnZSIsImRlZmluZSIsImNvbmZpZ3VyZSIsInByb3BzIiwiSWZTdGF0ZW1lbnQiLCJleGNlcHQiLCJUcnlTdGF0ZW1lbnQiLCJMYWJlbGVkU3RhdGVtZW50IiwiU3dpdGNoQm9keSIsImFmdGVyIiwidGV4dEFmdGVyIiwiY2xvc2VkIiwiaXNDYXNlIiwiYmFzZUluZGVudCIsInVuaXQiLCJCbG9jayIsImNsb3NpbmciLCJBcnJvd0Z1bmN0aW9uIiwiY3giLCJKU1hFbGVtZW50IiwibGluZUluZGVudCIsIkpTWEVzY2FwZSIsImNvbHVtbiIsIkJsb2NrQ29tbWVudCIsInRyZWUiLCJsYW5ndWFnZURhdGEiLCJjbG9zZUJyYWNrZXRzIiwiYnJhY2tldHMiLCJjb21tZW50VG9rZW5zIiwibGluZSIsImJsb2NrIiwib3BlbiIsImNsb3NlIiwiaW5kZW50T25JbnB1dCIsIndvcmRDaGFycyIsImpzeFN1Ymxhbmd1YWdlIiwiZmFjZXQiLCJ0eXBlc2NyaXB0TGFuZ3VhZ2UiLCJkaWFsZWN0IiwianN4TGFuZ3VhZ2UiLCJuIiwiaXNUb3AiLCJ1bmRlZmluZWQiLCJ0c3hMYW5ndWFnZSIsImt3Q29tcGxldGlvbiIsImtleXdvcmRzIiwic3BsaXQiLCJtYXAiLCJ0eXBlc2NyaXB0S2V5d29yZHMiLCJqYXZhc2NyaXB0IiwiY29uZmlnIiwibGFuZyIsImpzeCIsInR5cGVzY3JpcHQiLCJkYXRhIiwib2YiLCJhdXRvY29tcGxldGUiLCJhdXRvQ2xvc2VUYWdzIiwiZmluZE9wZW5UYWciLCJlbGVtZW50TmFtZSIsIm1heCIsImNoIiwibmV4dFNpYmxpbmciLCJNYXRoIiwibWluIiwiYW5kcm9pZCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlucHV0SGFuZGxlciIsInZpZXciLCJ0ZXh0IiwiZGVmYXVsdEluc2VydCIsImNvbXBvc2luZyIsImNvbXBvc2l0aW9uU3RhcnRlZCIsInJlYWRPbmx5IiwiaXNBY3RpdmVBdCIsImJhc2UiLCJjbG9zZVRhZ3MiLCJjaGFuZ2VCeVJhbmdlIiwicmFuZ2UiLCJoZWFkIiwiYXJvdW5kIiwiY2hhbmdlcyIsImluc2VydCIsImVtcHR5Iiwib3BlblRhZyIsImRpc3BhdGNoIiwidXBkYXRlIiwidXNlckV2ZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJlc0xpbnQiLCJlc2xpbnQiLCJwYXJzZXJPcHRpb25zIiwiZWNtYVZlcnNpb24iLCJzb3VyY2VUeXBlIiwiZW52IiwiYnJvd3NlciIsImVzNiIsImVzMjAxNSIsImVzMjAxNyIsImVzMjAyMCIsInJ1bGVzIiwiZ2V0UnVsZXMiLCJmb3JFYWNoIiwiZGVzYyIsIm1ldGEiLCJkb2NzIiwicmVjb21tZW5kZWQiLCJmb3VuZCIsImZpbmRSZWdpb25zIiwiZnJvbUxpbmUiLCJsaW5lQXQiLCJvZmZzZXQiLCJudW1iZXIiLCJjb2wiLCJkIiwidmVyaWZ5IiwidHJhbnNsYXRlRGlhZ25vc3RpYyIsIm1hcFBvcyIsImlucHV0Iiwic3RhcnQiLCJyZXN1bHQiLCJlbmRMaW5lIiwiZW5kQ29sdW1uIiwibWVzc2FnZSIsInNvdXJjZSIsInJ1bGVJZCIsInNldmVyaXR5IiwiZml4IiwiYWN0aW9ucyIsImFwcGx5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lang-javascript/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: () => (/* binding */ DocInput),\n/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),\n/* harmony export */   IndentContext: () => (/* binding */ IndentContext),\n/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),\n/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),\n/* harmony export */   ParseContext: () => (/* binding */ ParseContext),\n/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),\n/* harmony export */   StringStream: () => (/* binding */ StringStream),\n/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),\n/* harmony export */   bidiIsolates: () => (/* binding */ bidiIsolates),\n/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),\n/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   codeFolding: () => (/* binding */ codeFolding),\n/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),\n/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),\n/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),\n/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   flatIndent: () => (/* binding */ flatIndent),\n/* harmony export */   foldAll: () => (/* binding */ foldAll),\n/* harmony export */   foldCode: () => (/* binding */ foldCode),\n/* harmony export */   foldEffect: () => (/* binding */ foldEffect),\n/* harmony export */   foldGutter: () => (/* binding */ foldGutter),\n/* harmony export */   foldInside: () => (/* binding */ foldInside),\n/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),\n/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),\n/* harmony export */   foldService: () => (/* binding */ foldService),\n/* harmony export */   foldState: () => (/* binding */ foldState),\n/* harmony export */   foldable: () => (/* binding */ foldable),\n/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),\n/* harmony export */   forceParsing: () => (/* binding */ forceParsing),\n/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),\n/* harmony export */   getIndentation: () => (/* binding */ getIndentation),\n/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),\n/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),\n/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),\n/* harmony export */   indentRange: () => (/* binding */ indentRange),\n/* harmony export */   indentService: () => (/* binding */ indentService),\n/* harmony export */   indentString: () => (/* binding */ indentString),\n/* harmony export */   indentUnit: () => (/* binding */ indentUnit),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),\n/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),\n/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),\n/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),\n/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),\n/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),\n/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   toggleFold: () => (/* binding */ toggleFold),\n/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),\n/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),\n/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/ const languageDataProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/ function defineLanguageFacet(baseData) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n        combine: baseData ? (values)=>values.concat(baseData) : undefined\n    });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/ const sublanguageProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/ class Language {\n    /**\n    Construct a language object. If you need to invoke this\n    directly, first define a data facet with\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n    to the language's outer syntax node.\n    */ constructor(/**\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n    used for this language.\n    */ data, parser, extraExtensions = [], /**\n    A language name.\n    */ name = \"\"){\n        this.data = data;\n        this.name = name;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n            get () {\n                return syntaxTree(this);\n            }\n        });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side)=>{\n                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);\n                if (!data) return [];\n                let base = state.facet(data), sub = top.type.prop(sublanguageProp);\n                if (sub) {\n                    let innerNode = top.resolve(pos - top.from, side);\n                    for (let sublang of sub)if (sublang.test(innerNode, state)) {\n                        let data = state.facet(sublang.facet);\n                        return sublang.type == \"replace\" ? data : data.concat(base);\n                    }\n                }\n                return base;\n            })\n        ].concat(extraExtensions);\n    }\n    /**\n    Query whether this language is active at the given position.\n    */ isActiveAt(state, pos, side = -1) {\n        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */ findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [\n            {\n                from: 0,\n                to: state.doc.length\n            }\n        ];\n        if (!lang || !lang.allowsNesting) return [];\n        let result = [];\n        let explore = (tree, from)=>{\n            if (tree.prop(languageDataProp) == this.data) {\n                result.push({\n                    from,\n                    to: from + tree.length\n                });\n                return;\n            }\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n            if (mount) {\n                if (mount.tree.prop(languageDataProp) == this.data) {\n                    if (mount.overlay) for (let r of mount.overlay)result.push({\n                        from: r.from + from,\n                        to: r.to + from\n                    });\n                    else result.push({\n                        from: from,\n                        to: from + tree.length\n                    });\n                    return;\n                } else if (mount.overlay) {\n                    let size = result.length;\n                    explore(mount.tree, mount.overlay[0].from + from);\n                    if (result.length > size) return;\n                }\n            }\n            for(let i = 0; i < tree.children.length; i++){\n                let ch = tree.children[i];\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n            }\n        };\n        explore(syntaxTree(state), 0);\n        return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */ get allowsNesting() {\n        return true;\n    }\n}\n/**\n@internal\n*/ Language.setState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n    let topLang = state.facet(language), tree = syntaxTree(state).topNode;\n    if (!topLang || topLang.allowsNesting) {\n        for(let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers))if (node.type.isTop) tree = node;\n    }\n    return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/ class LRLanguage extends Language {\n    constructor(data, parser, name){\n        super(data, parser, [], name);\n        this.parser = parser;\n    }\n    /**\n    Define a language from a parser.\n    */ static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LRLanguage(data, spec.parser.configure({\n            props: [\n                languageDataProp.add((type)=>type.isTop ? data : undefined)\n            ]\n        }), spec.name);\n    }\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser and optionally a new name.\n    */ configure(options, name) {\n        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n    }\n    get allowsNesting() {\n        return this.parser.hasWrappers();\n    }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/ function syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/ function ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    if (!parse) return null;\n    let oldVieport = parse.viewport;\n    parse.updateViewport({\n        from: 0,\n        to: upto\n    });\n    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n    parse.updateViewport(oldVieport);\n    return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of thatâ€”the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/ function syntaxTreeAvailable(state, upto = state.doc.length) {\n    var _a;\n    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/ function forceParsing(view, upto = view.viewport.to, timeout = 100) {\n    let success = ensureSyntaxTree(view.state, upto, timeout);\n    if (success != syntaxTree(view.state)) view.dispatch({});\n    return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/ function syntaxParserRunning(view) {\n    var _a;\n    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/ class DocInput {\n    /**\n    Create an input object for the given document.\n    */ constructor(doc){\n        this.doc = doc;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get length() {\n        return this.doc.length;\n    }\n    syncTo(pos) {\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    chunk(pos) {\n        this.syncTo(pos);\n        return this.string;\n    }\n    get lineChunks() {\n        return true;\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);\n        else return this.string.slice(from - stringStart, to - stringStart);\n    }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/ class ParseContext {\n    constructor(parser, /**\n    The current editor state.\n    */ state, /**\n    Tree fragments that can be reused by incremental re-parses.\n    */ fragments = [], /**\n    @internal\n    */ tree, /**\n    @internal\n    */ treeLen, /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */ viewport, /**\n    @internal\n    */ skipped, /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */ scheduleOn){\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.treeLen = treeLen;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.scheduleOn = scheduleOn;\n        this.parse = null;\n        /**\n        @internal\n        */ this.tempSkipped = [];\n    }\n    /**\n    @internal\n    */ static create(parser, state, viewport) {\n        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n    }\n    startParse() {\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */ work(until, upto) {\n        if (upto != null && upto >= this.state.doc.length) upto = undefined;\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n            this.takeTree();\n            return true;\n        }\n        return this.withContext(()=>{\n            var _a;\n            if (typeof until == \"number\") {\n                let endTime = Date.now() + until;\n                until = ()=>Date.now() > endTime;\n            }\n            if (!this.parse) this.parse = this.startParse();\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n            for(;;){\n                let done = this.parse.advance();\n                if (done) {\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n                    this.tree = done;\n                    this.parse = null;\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();\n                    else return true;\n                }\n                if (until()) return false;\n            }\n        });\n    }\n    /**\n    @internal\n    */ takeTree() {\n        let pos, tree;\n        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n            this.withContext(()=>{\n                while(!(tree = this.parse.advance())){}\n            });\n            this.treeLen = pos;\n            this.tree = tree;\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n            this.parse = null;\n        }\n    }\n    withContext(f) {\n        let prev = currentContext;\n        currentContext = this;\n        try {\n            return f();\n        } finally{\n            currentContext = prev;\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for(let r; r = this.tempSkipped.pop();)fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /**\n    @internal\n    */ changes(changes, newState) {\n        let { fragments, tree, treeLen, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB)=>ranges.push({\n                    fromA,\n                    toA,\n                    fromB,\n                    toB\n                }));\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n            treeLen = 0;\n            viewport = {\n                from: changes.mapPos(viewport.from, -1),\n                to: changes.mapPos(viewport.to, 1)\n            };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped){\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to) skipped.push({\n                        from,\n                        to\n                    });\n                }\n            }\n        }\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */ updateViewport(viewport) {\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for(let i = 0; i < this.skipped.length; i++){\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        if (this.skipped.length >= startLen) return false;\n        this.reset();\n        return true;\n    }\n    /**\n    @internal\n    */ reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */ skipUntilInView(from, to) {\n        this.skipped.push({\n            from,\n            to\n        });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */ static getSkippingParser(until) {\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\n                let parser = {\n                    parsedPos: from,\n                    advance () {\n                        let cx = currentContext;\n                        if (cx) {\n                            for (let r of ranges)cx.tempSkipped.push(r);\n                            if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([\n                                cx.scheduleOn,\n                                until\n                            ]) : until;\n                        }\n                        this.parsedPos = to;\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n                    },\n                    stoppedAt: null,\n                    stopAt () {}\n                };\n                return parser;\n            }\n        };\n    }\n    /**\n    @internal\n    */ isDone(upto) {\n        upto = Math.min(upto, this.state.doc.length);\n        let frags = this.fragments;\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */ static get() {\n        return currentContext;\n    }\n}\nfunction cutFragments(fragments, from, to) {\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [\n        {\n            fromA: from,\n            toA: to,\n            fromB: from,\n            toB: to\n        }\n    ]);\n}\nclass LanguageState {\n    constructor(// A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context){\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged && this.tree == this.context.tree) return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n        if (!newCx.work(20 /* Work.Apply */ , upto)) newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let vpTo = Math.min(3000 /* Work.InitViewport */ , state.doc.length);\n        let parseState = ParseContext.create(state.facet(language).parser, state, {\n            from: 0,\n            to: vpTo\n        });\n        if (!parseState.work(20 /* Work.Apply */ , vpTo)) parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create: LanguageState.init,\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(Language.setState)) return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = (callback)=>{\n    let timeout = setTimeout(()=>callback(), 500 /* Work.MaxPause */ );\n    return ()=>clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = (callback)=>{\n    let idle = -1, timeout = setTimeout(()=>{\n        idle = requestIdleCallback(callback, {\n            timeout: 500 /* Work.MaxPause */  - 100 /* Work.MinPause */ \n        });\n    }, 100 /* Work.MinPause */ );\n    return ()=>idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? ()=>navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n    constructor(view){\n        this.view = view;\n        this.working = null;\n        this.workScheduled = 0;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        let cx = this.view.state.field(Language.state).context;\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n        if (update.docChanged || update.selectionSet) {\n            if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */ ;\n            this.scheduleWork();\n        }\n        this.checkAsyncSchedule(cx);\n    }\n    scheduleWork() {\n        if (this.working) return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n    }\n    work(deadline) {\n        this.working = null;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n            this.chunkEnd = now + 30000 /* Work.ChunkTime */ ;\n            this.chunkBudget = 3000 /* Work.ChunkBudget */ ;\n        }\n        if (this.chunkBudget <= 0) return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */ )) return;\n        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */ , deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */ , deadline.timeRemaining() - 5) : 1e9);\n        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n        let done = field.context.work(()=>{\n            return isInputPending && isInputPending() || Date.now() > endTime;\n        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */ ));\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0) {\n            field.context.takeTree();\n            this.view.dispatch({\n                effects: Language.setState.of(new LanguageState(field.context))\n            });\n        }\n        if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n        this.checkAsyncSchedule(field.context);\n    }\n    checkAsyncSchedule(cx) {\n        if (cx.scheduleOn) {\n            this.workScheduled++;\n            cx.scheduleOn.then(()=>this.scheduleWork()).catch((err)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(()=>this.workScheduled--);\n            cx.scheduleOn = null;\n        }\n    }\n    destroy() {\n        if (this.working) this.working();\n    }\n    isWorking() {\n        return !!(this.working || this.workScheduled > 0);\n    }\n}, {\n    eventHandlers: {\n        focus () {\n            this.scheduleWork();\n        }\n    }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/ const language = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (languages) {\n        return languages.length ? languages[0] : null;\n    },\n    enables: (language)=>[\n            Language.state,\n            parseWorker,\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([\n                language\n            ], (state)=>{\n                let lang = state.facet(language);\n                return lang && lang.name ? {\n                    \"data-language\": lang.name\n                } : {};\n            })\n        ]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/ class LanguageSupport {\n    /**\n    Create a language support object.\n    */ constructor(/**\n    The language object.\n    */ language, /**\n    An optional set of supporting extensions. When nesting a\n    language in another language, the outer language is encouraged\n    to include the supporting extensions for its inner languages\n    in its own set of support extensions.\n    */ support = []){\n        this.language = language;\n        this.support = support;\n        this.extension = [\n            language,\n            support\n        ];\n    }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/ class LanguageDescription {\n    constructor(/**\n    The name of this language.\n    */ name, /**\n    Alternative names for the mode (lowercased, includes `this.name`).\n    */ alias, /**\n    File extensions associated with this language.\n    */ extensions, /**\n    Optional filename pattern that should be associated with this\n    language.\n    */ filename, loadFunc, /**\n    If the language has been loaded, this will hold its value.\n    */ support = undefined){\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        this.support = support;\n        this.loading = null;\n    }\n    /**\n    Start loading the the language. Will return a promise that\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n    object when the language successfully loads.\n    */ load() {\n        return this.loading || (this.loading = this.loadFunc().then((support)=>this.support = support, (err)=>{\n            this.loading = null;\n            throw err;\n        }));\n    }\n    /**\n    Create a language description.\n    */ static of(spec) {\n        let { load, support } = spec;\n        if (!load) {\n            if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n            load = ()=>Promise.resolve(support);\n        }\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s)=>s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */ static matchFilename(descs, filename) {\n        for (let d of descs)if (d.filename && d.filename.test(filename)) return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext) {\n            for (let d of descs)if (d.extensions.indexOf(ext[1]) > -1) return d;\n        }\n        return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */ static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)if (d.alias.some((a)=>a == name)) return d;\n        if (fuzzy) for (let d of descs)for (let a of d.alias){\n            let found = name.indexOf(a);\n            if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n        }\n        return null;\n    }\n}\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/ const indentService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting entirely of the same whitespace character.\nWhen not set, this defaults to 2 spaces.\n*/ const indentUnit = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>{\n        if (!values.length) return \"  \";\n        let unit = values[0];\n        if (!unit || /\\S/.test(unit) || Array.from(unit).some((e)=>e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return unit;\n    }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/ function getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/ function indentString(state, cols) {\n    let result = \"\", ts = state.tabSize, ch = state.facet(indentUnit)[0];\n    if (ch == \"\t\") {\n        while(cols >= ts){\n            result += \"\t\";\n            cols -= ts;\n        }\n        ch = \" \";\n    }\n    for(let i = 0; i < cols; i++)result += ch;\n    return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/ function getIndentation(context, pos) {\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)){\n        let result = service(context, pos);\n        if (result !== undefined) return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/ function indentRange(state, from, to) {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, {\n        overrideIndentation: (start)=>{\n            var _a;\n            return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n        }\n    });\n    let changes = [];\n    for(let pos = from; pos <= to;){\n        let line = state.doc.lineAt(pos);\n        pos = line.to + 1;\n        let indent = getIndentation(context, line.from);\n        if (indent == null) continue;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    }\n    return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/ class IndentContext {\n    /**\n    Create an indent context.\n    */ constructor(/**\n    The editor state.\n    */ state, /**\n    @internal\n    */ options = {}){\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /**\n    Get a description of the line at the given position, taking\n    [simulated line\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    into account. If there is such a break at `pos`, the `bias`\n    argument determines whether the part of the line line before or\n    after the break is used.\n    */ lineAt(pos, bias = 1) {\n        let line = this.state.doc.lineAt(pos);\n        let { simulateBreak, simulateDoubleBreak } = this.options;\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n            if (simulateDoubleBreak && simulateBreak == pos) return {\n                text: \"\",\n                from: pos\n            };\n            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n                text: line.text.slice(simulateBreak - line.from),\n                from: simulateBreak\n            };\n            else return {\n                text: line.text.slice(0, simulateBreak - line.from),\n                from: line.from\n            };\n        }\n        return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ textAfterPos(pos, bias = 1) {\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n        let { text, from } = this.lineAt(pos, bias);\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */ column(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let result = this.countColumn(text, pos - from);\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n        if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n        return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */ countColumn(line, pos = line.length) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */ lineIndent(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let override = this.options.overrideIndentation;\n        if (override) {\n            let overriden = override(from);\n            if (overriden > -1) return overriden;\n        }\n        return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */ get simulatedBreak() {\n        return this.options.simulateBreak || null;\n    }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/ const indentNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let stack = ast.resolveStack(pos);\n    let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);\n    if (inner != stack.node) {\n        let add = [];\n        for(let cur = inner; cur && !(cur.from < stack.node.from || cur.to > stack.node.to || cur.from == stack.node.from && cur.type == stack.node.type); cur = cur.parent)add.push(cur);\n        for(let i = add.length - 1; i >= 0; i--)stack = {\n            node: add[i],\n            next: stack\n        };\n    }\n    return indentFor(stack, cx, pos);\n}\nfunction indentFor(stack, cx, pos) {\n    for(let cur = stack; cur; cur = cur.next){\n        let strategy = indentStrategy(cur.node);\n        if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));\n    }\n    return 0;\n}\nfunction ignoreClosed(cx) {\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy) return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return (cx)=>delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() {\n    return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/ class TreeIndentContext extends IndentContext {\n    constructor(base, /**\n    The position at which indentation is being computed.\n    */ pos, /**\n    @internal\n    */ context){\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.context = context;\n    }\n    /**\n    The syntax tree node to which the indentation strategy\n    applies.\n    */ get node() {\n        return this.context.node;\n    }\n    /**\n    @internal\n    */ static create(base, pos, context) {\n        return new TreeIndentContext(base, pos, context);\n    }\n    /**\n    Get the text directly after `this.pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */ get baseIndent() {\n        return this.baseIndentFor(this.node);\n    }\n    /**\n    Get the indentation for the reference line of the given node\n    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n    */ baseIndentFor(node) {\n        let line = this.state.doc.lineAt(node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for(;;){\n            let atBreak = node.resolve(line.from);\n            while(atBreak.parent && atBreak.parent.from == atBreak.from)atBreak = atBreak.parent;\n            if (isParent(atBreak, node)) break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */ continue() {\n        return indentFor(this.context.next, this.base, this.pos);\n    }\n}\nfunction isParent(parent, of) {\n    for(let cur = of; cur; cur = cur.parent)if (parent == cur) return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken) return null;\n    let sim = context.options.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for(let pos = openToken.to;;){\n        let next = tree.childAfter(pos);\n        if (!next || next == last) return null;\n        if (!next.type.isSkipped) {\n            if (next.from >= lineEnd) return null;\n            let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;\n            return {\n                from: openToken.from,\n                to: openToken.to + space\n            };\n        }\n        pos = next.to;\n    }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/ function delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context)=>delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/ const flatIndent = (context)=>context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/ function continuedIndent({ except, units = 1 } = {}) {\n    return (context)=>{\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/ function indentOnInput() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of((tr)=>{\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length) return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond) return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some((r)=>r.test(lineStart))) return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges){\n            let line = state.doc.lineAt(head);\n            if (line.from == last) continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null) continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm) changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n        return changes.length ? [\n            tr,\n            {\n                changes,\n                sequential: true\n            }\n        ] : tr;\n    });\n}\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/ const foldService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/ const foldNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/ function foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? {\n        from: first.to,\n        to: last.type.isError ? node.to : last.from\n    } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length < end) return null;\n    let stack = tree.resolveStack(end, 1);\n    let found = null;\n    for(let iter = stack; iter; iter = iter.next){\n        let cur = iter.node;\n        if (cur.to <= end || cur.from > end) continue;\n        if (found && cur.from < start) break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n        }\n    }\n    return found;\n}\nfunction isUnfinished(node) {\n    let ch = node.lastChild;\n    return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/ function foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)){\n        let result = service(state, lineStart, lineEnd);\n        if (result) return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : {\n        from,\n        to\n    };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstancesâ€”usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/ const foldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/ const unfoldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges){\n        if (lines.some((l)=>l.from <= head && l.to >= head)) continue;\n        lines.push(view.lineBlockAt(head));\n    }\n    return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/ const foldState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (folded, tr) {\n        if (tr.isUserEvent(\"delete\")) tr.changes.iterChangedRanges((fromA, toA)=>folded = clearTouchedFolds(folded, fromA, toA));\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects){\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n                let { preparePlaceholder } = tr.state.facet(foldConfig);\n                let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n                    widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))\n                });\n                folded = folded.update({\n                    add: [\n                        widget.range(e.value.from, e.value.to)\n                    ]\n                });\n            } else if (e.is(unfoldEffect)) {\n                folded = folded.update({\n                    filter: (from, to)=>e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from,\n                    filterTo: e.value.to\n                });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) folded = clearTouchedFolds(folded, tr.selection.main.head);\n        return folded;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n    toJSON (folded, state) {\n        let ranges = [];\n        folded.between(0, state.doc.length, (from, to)=>{\n            ranges.push(from, to);\n        });\n        return ranges;\n    },\n    fromJSON (value) {\n        if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n        let ranges = [];\n        for(let i = 0; i < value.length;){\n            let from = value[i++], to = value[i++];\n            if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n            ranges.push(foldWidget.range(from, to));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n    }\n});\nfunction clearTouchedFolds(folded, from, to = from) {\n    let touched = false;\n    folded.between(from, to, (a, b)=>{\n        if (a < to && b > from) touched = true;\n    });\n    return !touched ? folded : folded.update({\n        filterFrom: from,\n        filterTo: to,\n        filter: (a, b)=>a >= to || b <= from\n    });\n}\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/ function foldedRanges(state) {\n    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to)=>{\n        if (!found || found.from > from) found = {\n            from,\n            to\n        };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b)=>{\n        if (a == from && b == to) found = true;\n    });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/ const foldCode = (view)=>{\n    for (let line of selectedLines(view)){\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({\n                effects: maybeEnable(view.state, [\n                    foldEffect.of(range),\n                    announceFold(view, range)\n                ])\n            });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/ const unfoldCode = (view)=>{\n    if (!view.state.field(foldState, false)) return false;\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length) view.dispatch({\n        effects\n    });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/ const foldAll = (view)=>{\n    let { state } = view, effects = [];\n    for(let pos = 0; pos < state.doc.length;){\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\n        if (range) effects.push(foldEffect.of(range));\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n    }\n    if (effects.length) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/ const unfoldAll = (view)=>{\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size) return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to)=>{\n        effects.push(unfoldEffect.of({\n            from,\n            to\n        }));\n    });\n    view.dispatch({\n        effects\n    });\n    return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n    // Look backwards through line blocks until we find a foldable region that\n    // intersects with the line\n    for(let line = lineBlock;;){\n        let foldableRegion = foldable(view.state, line.from, line.to);\n        if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n        if (!line.from) return null;\n        line = view.lineBlockAt(line.from - 1);\n    }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/ const toggleFold = (view)=>{\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n        } else {\n            let foldRange = foldableContainer(view, line);\n            if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n        }\n    }\n    if (effects.length > 0) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/ const foldKeymap = [\n    {\n        key: \"Ctrl-Shift-[\",\n        mac: \"Cmd-Alt-[\",\n        run: foldCode\n    },\n    {\n        key: \"Ctrl-Shift-]\",\n        mac: \"Cmd-Alt-]\",\n        run: unfoldCode\n    },\n    {\n        key: \"Ctrl-Alt-[\",\n        run: foldAll\n    },\n    {\n        key: \"Ctrl-Alt-]\",\n        run: unfoldAll\n    }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    preparePlaceholder: null,\n    placeholderText: \"â€¦\"\n};\nconst foldConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n    }\n});\n/**\nCreate an extension that configures code folding.\n*/ function codeFolding(config) {\n    let result = [\n        foldState,\n        baseTheme$1\n    ];\n    if (config) result.push(foldConfig.of(config));\n    return result;\n}\nfunction widgetToDOM(view, prepared) {\n    let { state } = view, conf = state.facet(foldConfig);\n    let onclick = (event)=>{\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n            effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n    };\n    if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);\n    let element = document.createElement(\"span\");\n    element.textContent = conf.placeholderText;\n    element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n    element.title = state.phrase(\"unfold\");\n    element.className = \"cm-foldPlaceholder\";\n    element.onclick = onclick;\n    return element;\n}\nconst foldWidget = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n        toDOM(view) {\n            return widgetToDOM(view, null);\n        }\n    }\n});\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    eq(other) {\n        return this.value == other.value;\n    }\n    toDOM(view) {\n        return widgetToDOM(view, this.value);\n    }\n}\nconst foldGutterDefaults = {\n    openText: \"âŒ„\",\n    closedText: \"â€º\",\n    markerDOM: null,\n    domEventHandlers: {},\n    foldingChanged: ()=>false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n    constructor(config, open){\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) {\n        return this.config == other.config && this.open == other.open;\n    }\n    toDOM(view) {\n        if (this.config.markerDOM) return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/ function foldGutter(config = {}) {\n    let fullConfig = {\n        ...foldGutterDefaults,\n        ...config\n    };\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n        constructor(view){\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n            for (let line of view.viewportLineBlocks){\n                let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n                if (mark) builder.add(line.from, line.from, mark);\n            }\n            return builder.finish();\n        }\n    });\n    let { domEventHandlers } = fullConfig;\n    return [\n        markers,\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n            class: \"cm-foldGutter\",\n            markers (view) {\n                var _a;\n                return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n            },\n            initialSpacer () {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: {\n                ...domEventHandlers,\n                click: (view, line, event)=>{\n                    if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n                    let folded = findFold(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({\n                            effects: unfoldEffect.of(folded)\n                        });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({\n                            effects: foldEffect.of(range)\n                        });\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter span\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/ class HighlightStyle {\n    constructor(/**\n    The tag styles used to create this highlight style.\n    */ specs, options){\n        this.specs = specs;\n        let modSpec;\n        function def(spec) {\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n        const scopeOpt = options.scope;\n        this.scope = scopeOpt instanceof Language ? (type)=>type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type)=>type == scopeOpt : undefined;\n        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map((style)=>({\n                tag: style.tag,\n                class: style.class || def(Object.assign({}, style, {\n                    tag: null\n                }))\n            })), {\n            all\n        }).style;\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n        this.themeType = options.themeType;\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The specs must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighter\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */ static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n}\nconst highlighterFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return values.length ? [\n            values[0]\n        ] : null;\n    }\n});\nfunction getHighlighters(state) {\n    let main = state.facet(highlighterFacet);\n    return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/ function syntaxHighlighting(highlighter, options) {\n    let ext = [\n        treeHighlighter\n    ], themeType;\n    if (highlighter instanceof HighlightStyle) {\n        if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n        themeType = highlighter.themeType;\n    }\n    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));\n    else if (themeType) ext.push(highlighterFacet.computeN([\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme\n    ], (state)=>{\n        return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [\n            highlighter\n        ] : [];\n    }));\n    else ext.push(highlighterFacet.of(highlighter));\n    return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/ function highlightingFor(state, tags, scope) {\n    let highlighters = getHighlighters(state);\n    let result = null;\n    if (highlighters) for (let highlighter of highlighters){\n        if (!highlighter.scope || scope && highlighter.scope(scope)) {\n            let cls = highlighter.style(tags);\n            if (cls) result = result ? result + \" \" + cls : cls;\n        }\n    }\n    return result;\n}\nclass TreeHighlighter {\n    constructor(view){\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view, getHighlighters(view.state));\n        this.decoratedTo = view.viewport.to;\n    }\n    update(update) {\n        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);\n        let styleChange = highlighters != getHighlighters(update.startState);\n        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);\n        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n            this.decoratedTo = decoratedToMapped;\n        } else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, highlighters);\n            this.decoratedTo = viewport.to;\n        }\n    }\n    buildDeco(view, highlighters) {\n        if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges){\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style)=>{\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n                    class: style\n                })));\n            }, from, to);\n        }\n        return builder.finish();\n    }\n}\nconst treeHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: (v)=>v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/ const defaultHighlightStyle = /*@__PURE__*/ HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n        color: \"#404740\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n        color: \"#708\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName\n        ],\n        color: \"#219\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted\n        ],\n        color: \"#164\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted\n        ],\n        color: \"#a11\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)\n        ],\n        color: \"#e40\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#00f\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#30a\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace\n        ],\n        color: \"#085\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n        color: \"#167\"\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName\n        ],\n        color: \"#256\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n        color: \"#00c\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n        color: \"#940\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n        color: \"#f00\"\n    }\n]);\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \"&.cm-focused .cm-matchingBracket\": {\n        backgroundColor: \"#328c8252\"\n    },\n    \"&.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bb555544\"\n    }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist,\n            renderMatch: defaultRenderMatch\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n}), nonmatchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n});\nfunction defaultRenderMatch(match) {\n    let decorations = [];\n    let mark = match.matched ? matchingMark : nonmatchingMark;\n    decorations.push(mark.range(match.start.from, match.start.to));\n    if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (deco, tr) {\n        if (!tr.docChanged && !tr.selection) return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges){\n            if (!range.empty) continue;\n            let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n            if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/ function bracketMatching(config = {}) {\n    return [\n        bracketMatchingConfig.of(config),\n        bracketMatchingUnique\n    ];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a â€˜handleâ€™â€”the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/ const bracketMatchingHandle = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n    if (byProp) return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [\n            brackets[index + dir]\n        ];\n    }\n    return null;\n}\nfunction findHandle(node) {\n    let hasHandle = node.type.prop(bracketMatchingHandle);\n    return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/ function matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for(let cur = node; cur; cur = cur.parent){\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to) {\n            let handle = findHandle(cur);\n            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n        }\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n    let parent = token.parent, firstToken = {\n        from: handle.from,\n        to: handle.to\n    };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n            if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                let endHandle = findHandle(cursor);\n                return {\n                    start: firstToken,\n                    end: endHandle ? {\n                        from: endHandle.from,\n                        to: endHandle.to\n                    } : undefined,\n                    matched: true\n                };\n            } else if (matchingNodes(cursor.type, dir, brackets)) {\n                depth++;\n            } else if (matchingNodes(cursor.type, -dir, brackets)) {\n                if (depth == 0) {\n                    let endHandle = findHandle(cursor);\n                    return {\n                        start: firstToken,\n                        end: endHandle && endHandle.from < endHandle.to ? {\n                            from: endHandle.from,\n                            to: endHandle.to\n                        } : undefined,\n                        matched: false\n                    };\n                }\n                depth--;\n            }\n        }\n    }while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return {\n        start: firstToken,\n        matched: false\n    };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n    let startToken = {\n        from: dir < 0 ? pos - 1 : pos,\n        to: dir > 0 ? pos + 1 : pos\n    };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for(let distance = 0; !iter.next().done && distance <= maxScanDistance;){\n        let text = iter.value;\n        if (dir < 0) distance += text.length;\n        let basePos = pos + distance * dir;\n        for(let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir){\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n            if (found % 2 == 0 == dir > 0) {\n                depth++;\n            } else if (depth == 1) {\n                return {\n                    start: startToken,\n                    end: {\n                        from: basePos + pos,\n                        to: basePos + pos + 1\n                    },\n                    matched: found >> 1 == bracket >> 1\n                };\n            } else {\n                depth--;\n            }\n        }\n        if (dir > 0) distance += text.length;\n    }\n    return iter.done ? {\n        start: startToken,\n        matched: false\n    } : null;\n}\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1) end = string.length;\n    }\n    let n = startValue;\n    for(let i = startIndex; i < end; i++){\n        if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;\n        else n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/ class StringStream {\n    /**\n    Create a stream.\n    */ constructor(/**\n    The line.\n    */ string, tabSize, /**\n    The current indent unit size.\n    */ indentUnit, overrideIndent){\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        this.overrideIndent = overrideIndent;\n        /**\n        The current position on the line.\n        */ this.pos = 0;\n        /**\n        The start position of the current token.\n        */ this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */ eol() {\n        return this.pos >= this.string.length;\n    }\n    /**\n    True if we are at the start of the line.\n    */ sol() {\n        return this.pos == 0;\n    }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */ peek() {\n        return this.string.charAt(this.pos) || undefined;\n    }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */ next() {\n        if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */ eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\") ok = ch == match;\n        else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */ eatWhile(match) {\n        let start = this.pos;\n        while(this.eat(match)){}\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */ eatSpace() {\n        let start = this.pos;\n        while(/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */ skipToEnd() {\n        this.pos = this.string.length;\n    }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */ skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */ backUp(n) {\n        this.pos -= n;\n    }\n    /**\n    Get the column position at `this.pos`.\n    */ column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */ indentation() {\n        var _a;\n        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */ match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str)=>caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false) this.pos += pattern.length;\n                return true;\n            } else return null;\n        } else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0) return null;\n            if (match && consume !== false) this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */ current() {\n        return this.string.slice(this.start, this.pos);\n    }\n}\nfunction fullParser(spec) {\n    return {\n        name: spec.name || \"\",\n        token: spec.token,\n        blankLine: spec.blankLine || (()=>{}),\n        startState: spec.startState || (()=>true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (()=>null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens,\n        mergeTokens: spec.mergeTokens !== false\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\") return state;\n    let newState = {};\n    for(let prop in state){\n        let val = state[prop];\n        newState[prop] = val instanceof Array ? val.slice() : val;\n    }\n    return newState;\n}\nconst IndentedFrom = /*@__PURE__*/ new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/ class StreamLanguage extends Language {\n    constructor(parser){\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, [], parser.name);\n        this.topNode = docID(data, this);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n            perNode: true\n        });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    /**\n    Define a stream language.\n    */ static define(spec) {\n        return new StreamLanguage(spec);\n    }\n    /**\n    @internal\n    */ getIndent(cx) {\n        let from = undefined;\n        let { overrideIndentation } = cx.options;\n        if (overrideIndentation) {\n            from = IndentedFrom.get(cx.state);\n            if (from != null && from < cx.pos - 1e4) from = undefined;\n        }\n        let start = findState(this, cx.node.tree, cx.node.from, cx.node.from, from !== null && from !== void 0 ? from : cx.pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        } else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = cx.node.from;\n        }\n        if (cx.pos - statePos > 10000 /* C.MaxIndentScanDist */ ) return null;\n        while(statePos < cx.pos){\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(cx.pos, line.to);\n            if (line.length) {\n                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n                while(stream.pos < end - line.from)readToken(this.streamParser.token, stream, state);\n            } else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == cx.pos) break;\n            statePos = line.to + 1;\n        }\n        let line = cx.lineAt(cx.pos);\n        if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n    }\n    get allowsNesting() {\n        return false;\n    }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state) return {\n        state: lang.streamParser.copyState(state),\n        pos: off + tree.length\n    };\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found) return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length) return tree;\n    if (!inside && from == 0 && tree.type == lang.topNode) inside = true;\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n            return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, endPos, editorState) {\n    for (let f of fragments){\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && found.pos <= endPos && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n            state: found.state,\n            tree\n        };\n    }\n    return {\n        state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n        tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n    };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges){\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, this.to, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for(let i = 0; i < tree.children.length; i++){\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */  && ranges.some((r)=>r.from <= context.viewport.from && r.to >= context.viewport.from)) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 512 /* C.ChunkSize */ );\n        if (context) end = Math.min(end, context.viewport.to);\n        while(this.parsedPos < end)this.parseLine(context);\n        if (this.chunkStart < this.parsedPos) this.finishChunk();\n        if (this.parsedPos >= parseEnd) return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1) chunk = chunk.slice(0, eol);\n        } else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for(let index = this.rangeIndex;;){\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end) break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length) break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return {\n            line,\n            end\n        };\n    }\n    skipGapsTo(pos, offset, side) {\n        for(;;){\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos) break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while(this.ranges[this.rangeIndex].to < this.parsedPos)this.rangeIndex++;\n    }\n    emitToken(id, from, to, offset) {\n        let size = 4;\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        let last = this.chunk.length - 4;\n        if (this.lang.streamParser.mergeTokens && size == 4 && last >= 0 && this.chunk[last] == id && this.chunk[last + 2] == from) this.chunk[last + 2] = to;\n        else this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        } else {\n            while(!stream.eol()){\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, offset);\n                if (stream.start > 10000 /* C.MaxLineLength */ ) break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to) this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 512 /* C.ChunkSize */ ,\n            reused: this.chunkReused\n        });\n        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [\n            [\n                this.lang.stateAfter,\n                this.lang.streamParser.copyState(this.state)\n            ]\n        ]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for(let i = 0; i < 10; i++){\n        let result = token(stream, state);\n        if (stream.pos > stream.start) return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/ Object.create(null);\nconst typeArray = [\n    _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none\n];\nconst nodeSet = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\n// Cache of node types by name and tags\nconst byTag = /*@__PURE__*/ Object.create(null);\nconst defaultTable = /*@__PURE__*/ Object.create(null);\nfor (let [legacyName, name] of [\n    [\n        \"variable\",\n        \"variableName\"\n    ],\n    [\n        \"variable-2\",\n        \"variableName.special\"\n    ],\n    [\n        \"string-2\",\n        \"string.special\"\n    ],\n    [\n        \"def\",\n        \"variableName.definition\"\n    ],\n    [\n        \"tag\",\n        \"tagName\"\n    ],\n    [\n        \"attribute\",\n        \"attributeName\"\n    ],\n    [\n        \"type\",\n        \"typeName\"\n    ],\n    [\n        \"builtin\",\n        \"variableName.standard\"\n    ],\n    [\n        \"qualifier\",\n        \"modifier\"\n    ],\n    [\n        \"error\",\n        \"invalid\"\n    ],\n    [\n        \"header\",\n        \"heading\"\n    ],\n    [\n        \"property\",\n        \"propertyName\"\n    ]\n])defaultTable[legacyName] = /*@__PURE__*/ createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra){\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/ new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1) return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tags$1 = [];\n    for (let name of tagStr.split(\" \")){\n        let found = [];\n        for (let part of name.split(\".\")){\n            let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n            if (!value) {\n                warnForPart(part, `Unknown highlighting tag ${part}`);\n            } else if (typeof value == \"function\") {\n                if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);\n                else found = found.map(value);\n            } else {\n                if (found.length) warnForPart(part, `Tag ${part} used as modifier`);\n                else found = Array.isArray(value) ? value : [\n                    value\n                ];\n            }\n        }\n        for (let tag of found)tags$1.push(tag);\n    }\n    if (!tags$1.length) return 0;\n    let name = tagStr.replace(/ /g, \"_\"), key = name + \" \" + tags$1.map((t)=>t.id);\n    let known = byTag[key];\n    if (known) return known.id;\n    let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n                [name]: tags$1\n            })\n        ]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data, lang) {\n    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name: \"Document\",\n        props: [\n            languageDataProp.add(()=>data),\n            indentNodeProp.add(()=>(cx)=>lang.getIndent(cx))\n        ],\n        top: true\n    });\n    typeArray.push(type);\n    return type;\n}\nfunction buildForLine(line) {\n    return line.length <= 4096 && /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/.test(line);\n}\nfunction textHasRTL(text) {\n    for(let i = text.iter(); !i.next().done;)if (buildForLine(i.value)) return true;\n    return false;\n}\nfunction changeAddsRTL(change) {\n    let added = false;\n    change.iterChanges((fA, tA, fB, tB, ins)=>{\n        if (!added && textHasRTL(ins)) added = true;\n    });\n    return added;\n}\nconst alwaysIsolate = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nMake sure nodes\n[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)\nas isolating for bidirectional text are rendered in a way that\nisolates them from the surrounding text.\n*/ function bidiIsolates(options = {}) {\n    let extensions = [\n        isolateMarks\n    ];\n    if (options.alwaysIsolate) extensions.push(alwaysIsolate.of(true));\n    return extensions;\n}\nconst isolateMarks = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.always = view.state.facet(alwaysIsolate) || view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        this.hasRTL = !this.always && textHasRTL(view.state.doc);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    }\n    update(update) {\n        let always = update.state.facet(alwaysIsolate) || update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        if (!always && !this.hasRTL && changeAddsRTL(update.changes)) this.hasRTL = true;\n        if (!always && !this.hasRTL) return;\n        let tree = syntaxTree(update.state);\n        if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {\n            this.tree = tree;\n            this.always = always;\n            this.decorations = buildDeco(update.view, tree, always);\n        }\n    }\n}, {\n    provide: (plugin)=>{\n        function access(view) {\n            var _a, _b;\n            return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        }\n        return [\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.outerDecorations.of(access),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.bidiIsolatedRanges.of(access))\n        ];\n    }\n});\nfunction buildDeco(view, tree, always) {\n    let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n    let ranges = view.visibleRanges;\n    if (!always) ranges = clipRTLLines(ranges, view.state.doc);\n    for (let { from, to } of ranges){\n        tree.iterate({\n            enter: (node)=>{\n                let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.isolate);\n                if (iso) deco.add(node.from, node.to, marks[iso]);\n            },\n            from,\n            to\n        });\n    }\n    return deco.finish();\n}\nfunction clipRTLLines(ranges, doc) {\n    let cur = doc.iter(), pos = 0, result = [], last = null;\n    for (let { from, to } of ranges){\n        if (last && last.to > from) {\n            from = last.to;\n            if (from >= to) continue;\n        }\n        if (pos + cur.value.length < from) {\n            cur.next(from - (pos + cur.value.length));\n            pos = from;\n        }\n        for(;;){\n            let start = pos, end = pos + cur.value.length;\n            if (!cur.lineBreak && buildForLine(cur.value)) {\n                if (last && last.to > start - 10) last.to = Math.min(to, end);\n                else result.push(last = {\n                    from: start,\n                    to: Math.min(to, end)\n                });\n            }\n            if (end >= to) break;\n            pos = end;\n            cur.next();\n        }\n    }\n    return result;\n}\nconst marks = {\n    rtl: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"rtl\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.RTL\n    }),\n    ltr: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"ltr\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR\n    }),\n    auto: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"auto\"\n        },\n        bidiIsolate: null\n    })\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRztBQUMyQztBQUNaO0FBQy9DO0FBQzFDO0FBRXhDLElBQUk2QjtBQUNKOzs7QUFHQSxHQUNBLE1BQU1DLG1CQUFtQixXQUFXLEdBQUUsSUFBSTlCLG1EQUFRQTtBQUNsRDs7Ozs7OztBQU9BLEdBQ0EsU0FBUytCLG9CQUFvQkMsUUFBUTtJQUNqQyxPQUFPdkIsb0RBQUtBLENBQUN3QixNQUFNLENBQUM7UUFDaEJDLFNBQVNGLFdBQVdHLENBQUFBLFNBQVVBLE9BQU9DLE1BQU0sQ0FBQ0osWUFBWUs7SUFDNUQ7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLE1BQU1DLGtCQUFrQixXQUFXLEdBQUUsSUFBSXRDLG1EQUFRQTtBQUNqRDs7Ozs7Ozs7QUFRQSxHQUNBLE1BQU11QztJQUNGOzs7Ozs7SUFNQSxHQUNBQyxZQUNBOzs7SUFHQSxHQUNBQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUUsRUFDbEM7O0lBRUEsR0FDQUMsT0FBTyxFQUFFLENBQUU7UUFDUCxJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNHLElBQUksR0FBR0E7UUFDWiwyREFBMkQ7UUFDM0QseURBQXlEO1FBQ3pELDZCQUE2QjtRQUM3QixJQUFJLENBQUNsQywwREFBV0EsQ0FBQ21DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDLFNBQ3RDQyxPQUFPQyxjQUFjLENBQUN0QywwREFBV0EsQ0FBQ21DLFNBQVMsRUFBRSxRQUFRO1lBQUVJO2dCQUFRLE9BQU9DLFdBQVcsSUFBSTtZQUFHO1FBQUU7UUFDOUYsSUFBSSxDQUFDUixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUyxTQUFTLEdBQUc7WUFDYkMsU0FBU0MsRUFBRSxDQUFDLElBQUk7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SCxJQUFJb1M7cUJBRXZCaFMsT0FBT0csSUFBSSxDQUFDNE8sT0FBTztvQkFBRXpQLE1BQU1zTjtvQkFBT2hOLElBQUlpSCxLQUFLQyxHQUFHLENBQUNsSCxJQUFJb1M7Z0JBQUs7WUFDaEU7WUFDQSxJQUFJQSxPQUFPcFMsSUFDUDtZQUNKakIsTUFBTXFUO1lBQ04vRSxJQUFJM0osSUFBSTtRQUNaO0lBQ0o7SUFDQSxPQUFPdEQ7QUFDWDtBQUNBLE1BQU0wb0IsUUFBUTtJQUNWRSxLQUFLLFdBQVcsR0FBRXRzQix3REFBVUEsQ0FBQzhiLElBQUksQ0FBQztRQUFFRSxPQUFPO1FBQVV1USxXQUFXO1FBQU1DLFlBQVk7WUFBRTFLLEtBQUs7UUFBTTtRQUFHMkssYUFBYXJzQix1REFBU0EsQ0FBQ3NzQixHQUFHO0lBQUM7SUFDN0hDLEtBQUssV0FBVyxHQUFFM3NCLHdEQUFVQSxDQUFDOGIsSUFBSSxDQUFDO1FBQUVFLE9BQU87UUFBVXVRLFdBQVc7UUFBTUMsWUFBWTtZQUFFMUssS0FBSztRQUFNO1FBQUcySyxhQUFhcnNCLHVEQUFTQSxDQUFDb3JCLEdBQUc7SUFBQztJQUM3SG9CLE1BQU0sV0FBVyxHQUFFNXNCLHdEQUFVQSxDQUFDOGIsSUFBSSxDQUFDO1FBQUVFLE9BQU87UUFBVXVRLFdBQVc7UUFBTUMsWUFBWTtZQUFFMUssS0FBSztRQUFPO1FBQUcySyxhQUFhO0lBQUs7QUFDMUg7QUFFd3lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm5jb2RlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmd1YWdlL2Rpc3QvaW5kZXguanM/ZDczZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCwgSXRlck1vZGUsIFRyZWUsIFRyZWVGcmFnbWVudCwgUGFyc2VyLCBOb2RlVHlwZSwgTm9kZVNldCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBFZGl0b3JTdGF0ZSwgY291bnRDb2x1bW4sIGNvbWJpbmVDb25maWcsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFByZWMgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBWaWV3UGx1Z2luLCBsb2dFeGNlcHRpb24sIEVkaXRvclZpZXcsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGd1dHRlciwgR3V0dGVyTWFya2VyLCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcbmltcG9ydCB7IFN0eWxlTW9kdWxlIH0gZnJvbSAnc3R5bGUtbW9kJztcblxudmFyIF9hO1xuLyoqXG5Ob2RlIHByb3Agc3RvcmVkIGluIGEgcGFyc2VyJ3MgdG9wIHN5bnRheCBub2RlIHRvIHByb3ZpZGUgdGhlXG5mYWNldCB0aGF0IHN0b3JlcyBsYW5ndWFnZS1zcGVjaWZpYyBkYXRhIGZvciB0aGF0IGxhbmd1YWdlLlxuKi9cbmNvbnN0IGxhbmd1YWdlRGF0YVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbkhlbHBlciBmdW5jdGlvbiB0byBkZWZpbmUgYSBmYWNldCAodG8gYmUgYWRkZWQgdG8gdGhlIHRvcCBzeW50YXhcbm5vZGUocykgZm9yIGEgbGFuZ3VhZ2UgdmlhXG5bYGxhbmd1YWdlRGF0YVByb3BgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApKSwgdGhhdCB3aWxsIGJlXG51c2VkIHRvIGFzc29jaWF0ZSBsYW5ndWFnZSBkYXRhIHdpdGggdGhlIGxhbmd1YWdlLiBZb3VcbnByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIHdoZW4gc3ViY2xhc3NpbmdcbltgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKS5cbiovXG5mdW5jdGlvbiBkZWZpbmVMYW5ndWFnZUZhY2V0KGJhc2VEYXRhKSB7XG4gICAgcmV0dXJuIEZhY2V0LmRlZmluZSh7XG4gICAgICAgIGNvbWJpbmU6IGJhc2VEYXRhID8gdmFsdWVzID0+IHZhbHVlcy5jb25jYXQoYmFzZURhdGEpIDogdW5kZWZpbmVkXG4gICAgfSk7XG59XG4vKipcblN5bnRheCBub2RlIHByb3AgdXNlZCB0byByZWdpc3RlciBzdWJsYW5ndWFnZXMuIFNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHRvcCBsZXZlbCBub2RlIHR5cGUgZm9yIHRoZSBsYW5ndWFnZS5cbiovXG5jb25zdCBzdWJsYW5ndWFnZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbkEgbGFuZ3VhZ2Ugb2JqZWN0IG1hbmFnZXMgcGFyc2luZyBhbmQgcGVyLWxhbmd1YWdlXG5bbWV0YWRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLiBQYXJzZSBkYXRhIGlzXG5tYW5hZ2VkIGFzIGEgW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0KSB0cmVlLiBUaGUgY2xhc3NcbmNhbiBiZSB1c2VkIGRpcmVjdGx5LCB2aWEgdGhlIFtgTFJMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTFJMYW5ndWFnZSlcbnN1YmNsYXNzIGZvciBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvKSBMUiBwYXJzZXJzLCBvclxudmlhIHRoZSBbYFN0cmVhbUxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1MYW5ndWFnZSkgc3ViY2xhc3NcbmZvciBzdHJlYW0gcGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbGFuZ3VhZ2Ugb2JqZWN0LiBJZiB5b3UgbmVlZCB0byBpbnZva2UgdGhpc1xuICAgIGRpcmVjdGx5LCBmaXJzdCBkZWZpbmUgYSBkYXRhIGZhY2V0IHdpdGhcbiAgICBbYGRlZmluZUxhbmd1YWdlRmFjZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmluZUxhbmd1YWdlRmFjZXQpLCBhbmQgdGhlblxuICAgIGNvbmZpZ3VyZSB5b3VyIHBhcnNlciB0byBbYXR0YWNoXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApIGl0XG4gICAgdG8gdGhlIGxhbmd1YWdlJ3Mgb3V0ZXIgc3ludGF4IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgW2xhbmd1YWdlIGRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIGZhY2V0XG4gICAgdXNlZCBmb3IgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGRhdGEsIHBhcnNlciwgZXh0cmFFeHRlbnNpb25zID0gW10sIFxuICAgIC8qKlxuICAgIEEgbGFuZ3VhZ2UgbmFtZS5cbiAgICAqL1xuICAgIG5hbWUgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIC8vIEtsdWRnZSB0byBkZWZpbmUgRWRpdG9yU3RhdGUudHJlZSBhcyBhIGRlYnVnZ2luZyBoZWxwZXIsXG4gICAgICAgIC8vIHdpdGhvdXQgdGhlIEVkaXRvclN0YXRlIHBhY2thZ2UgYWN0dWFsbHkga25vd2luZyBhYm91dFxuICAgICAgICAvLyBsYW5ndWFnZXMgYW5kIGxlemVyIHRyZWVzLlxuICAgICAgICBpZiAoIUVkaXRvclN0YXRlLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInRyZWVcIikpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWRpdG9yU3RhdGUucHJvdG90eXBlLCBcInRyZWVcIiwgeyBnZXQoKSB7IHJldHVybiBzeW50YXhUcmVlKHRoaXMpOyB9IH0pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbXG4gICAgICAgICAgICBsYW5ndWFnZS5vZih0aGlzKSxcbiAgICAgICAgICAgIEVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YS5vZigoc3RhdGUsIHBvcywgc2lkZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSksIGRhdGEgPSB0b3AudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gc3RhdGUuZmFjZXQoZGF0YSksIHN1YiA9IHRvcC50eXBlLnByb3Aoc3VibGFuZ3VhZ2VQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lck5vZGUgPSB0b3AucmVzb2x2ZShwb3MgLSB0b3AuZnJvbSwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN1Ymxhbmcgb2Ygc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmxhbmcudGVzdChpbm5lck5vZGUsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gc3RhdGUuZmFjZXQoc3VibGFuZy5mYWNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmxhbmcudHlwZSA9PSBcInJlcGxhY2VcIiA/IGRhdGEgOiBkYXRhLmNvbmNhdChiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICBdLmNvbmNhdChleHRyYUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgaXMgYWN0aXZlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGlzQWN0aXZlQXQoc3RhdGUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSkudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcmVnaW9ucyB0aGF0IHdlcmUgcGFyc2VkIHVzaW5nIHRoaXMgbGFuZ3VhZ2UuXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gICAgaW4gdGhpcyBsYW5ndWFnZSwgd2hlbiB0aG9zZSBleGlzdC5cbiAgICAqL1xuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XG4gICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoKGxhbmcgPT09IG51bGwgfHwgbGFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZy5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XG4gICAgICAgIGlmICghbGFuZyB8fCAhbGFuZy5hbGxvd3NOZXN0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHRyZWUsIGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3VudCA9IHRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgIGlmIChtb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VudC50cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogci5mcm9tICsgZnJvbSwgdG86IHIudG8gKyBmcm9tIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUobW91bnQudHJlZSwgbW91bnQub3ZlcmxheVswXS5mcm9tICsgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUoY2gsIHRyZWUucG9zaXRpb25zW2ldICsgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV4cGxvcmUoc3ludGF4VHJlZShzdGF0ZSksIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGxhbmd1YWdlIGFsbG93cyBuZXN0ZWQgbGFuZ3VhZ2VzLiBUaGVcbiAgICBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICAqL1xuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5MYW5ndWFnZS5zZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmZ1bmN0aW9uIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHRvcExhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSksIHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS50b3BOb2RlO1xuICAgIGlmICghdG9wTGFuZyB8fCB0b3BMYW5nLmFsbG93c05lc3RpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRyZWU7IG5vZGU7IG5vZGUgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICB0cmVlID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWU7XG59XG4vKipcbkEgc3ViY2xhc3Mgb2YgW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGZvciB1c2Ugd2l0aCBMZXplclxuW0xSIHBhcnNlcnNdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjbHIuTFJQYXJzZXIpXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExSTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKGRhdGEsIHBhcnNlciwgW10sIG5hbWUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbGFuZ3VhZ2UgZnJvbSBhIHBhcnNlci5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQoc3BlYy5sYW5ndWFnZURhdGEpO1xuICAgICAgICByZXR1cm4gbmV3IExSTGFuZ3VhZ2UoZGF0YSwgc3BlYy5wYXJzZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQodHlwZSA9PiB0eXBlLmlzVG9wID8gZGF0YSA6IHVuZGVmaW5lZCldXG4gICAgICAgIH0pLCBzcGVjLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBsYW5ndWFnZSB3aXRoIGEgcmVjb25maWd1cmVkXG4gICAgdmVyc2lvbiBvZiBpdHMgcGFyc2VyIGFuZCBvcHRpb25hbGx5IGEgbmV3IG5hbWUuXG4gICAgKi9cbiAgICBjb25maWd1cmUob3B0aW9ucywgbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IExSTGFuZ3VhZ2UodGhpcy5kYXRhLCB0aGlzLnBhcnNlci5jb25maWd1cmUob3B0aW9ucyksIG5hbWUgfHwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0aGlzLnBhcnNlci5oYXNXcmFwcGVycygpOyB9XG59XG4vKipcbkdldCB0aGUgc3ludGF4IHRyZWUgZm9yIGEgc3RhdGUsIHdoaWNoIGlzIHRoZSBjdXJyZW50IChwb3NzaWJseVxuaW5jb21wbGV0ZSkgcGFyc2UgdHJlZSBvZiB0aGUgYWN0aXZlXG5bbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLCBvciB0aGUgZW1wdHkgdHJlZSBpZiB0aGVyZSBpcyBub1xubGFuZ3VhZ2UgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWUoc3RhdGUpIHtcbiAgICBsZXQgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBmaWVsZCA/IGZpZWxkLnRyZWUgOiBUcmVlLmVtcHR5O1xufVxuLyoqXG5UcnkgdG8gZ2V0IGEgcGFyc2UgdHJlZSB0aGF0IHNwYW5zIGF0IGxlYXN0IHVwIHRvIGB1cHRvYC4gVGhlXG5tZXRob2Qgd2lsbCBkbyBhdCBtb3N0IGB0aW1lb3V0YCBtaWxsaXNlY29uZHMgb2Ygd29yayB0byBwYXJzZVxudXAgdG8gdGhhdCBwb2ludCBpZiB0aGUgdHJlZSBpc24ndCBhbHJlYWR5IGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBlbnN1cmVTeW50YXhUcmVlKHN0YXRlLCB1cHRvLCB0aW1lb3V0ID0gNTApIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnNlID0gKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQ7XG4gICAgaWYgKCFwYXJzZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG9sZFZpZXBvcnQgPSBwYXJzZS52aWV3cG9ydDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydCh7IGZyb206IDAsIHRvOiB1cHRvIH0pO1xuICAgIGxldCByZXN1bHQgPSBwYXJzZS5pc0RvbmUodXB0bykgfHwgcGFyc2Uud29yayh0aW1lb3V0LCB1cHRvKSA/IHBhcnNlLnRyZWUgOiBudWxsO1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KG9sZFZpZXBvcnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcblF1ZXJpZXMgd2hldGhlciB0aGVyZSBpcyBhIGZ1bGwgc3ludGF4IHRyZWUgYXZhaWxhYmxlIHVwIHRvIHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIElmIHRoZXJlIGlzbid0LCB0aGUgYmFja2dyb3VuZCBwYXJzZVxucHJvY2VzcyBfbWlnaHRfIHN0aWxsIGJlIHdvcmtpbmcgYW5kIHVwZGF0ZSB0aGUgdHJlZSBmdXJ0aGVyLCBidXRcbnRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB0aGF04oCUdGhlIHBhcnNlciB3aWxsIFtzdG9wXG53b3JraW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFBhcnNlclJ1bm5pbmcpIHdoZW4gaXQgaGFzIHNwZW50IGFcbmNlcnRhaW4gYW1vdW50IG9mIHRpbWUgb3IgaGFzIG1vdmVkIGJleW9uZCB0aGUgdmlzaWJsZSB2aWV3cG9ydC5cbkFsd2F5cyByZXR1cm5zIGZhbHNlIGlmIG5vIGxhbmd1YWdlIGhhcyBiZWVuIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZUF2YWlsYWJsZShzdGF0ZSwgdXB0byA9IHN0YXRlLmRvYy5sZW5ndGgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dC5pc0RvbmUodXB0bykpIHx8IGZhbHNlO1xufVxuLyoqXG5Nb3ZlIHBhcnNpbmcgZm9yd2FyZCwgYW5kIHVwZGF0ZSB0aGUgZWRpdG9yIHN0YXRlIGFmdGVyd2FyZHMgdG9cbnJlZmxlY3QgdGhlIG5ldyB0cmVlLiBXaWxsIHdvcmsgZm9yIGF0IG1vc3QgYHRpbWVvdXRgXG5taWxsaXNlY29uZHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyc2VyIG1hbmFnZWQgZ2V0IHRvIHRoZSBnaXZlblxucG9zaXRpb24gaW4gdGhhdCB0aW1lLlxuKi9cbmZ1bmN0aW9uIGZvcmNlUGFyc2luZyh2aWV3LCB1cHRvID0gdmlldy52aWV3cG9ydC50bywgdGltZW91dCA9IDEwMCkge1xuICAgIGxldCBzdWNjZXNzID0gZW5zdXJlU3ludGF4VHJlZSh2aWV3LnN0YXRlLCB1cHRvLCB0aW1lb3V0KTtcbiAgICBpZiAoc3VjY2VzcyAhPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHt9KTtcbiAgICByZXR1cm4gISFzdWNjZXNzO1xufVxuLyoqXG5UZWxscyB5b3Ugd2hldGhlciB0aGUgbGFuZ3VhZ2UgcGFyc2VyIGlzIHBsYW5uaW5nIHRvIGRvIG1vcmVcbnBhcnNpbmcgd29yayAoaW4gYSBgcmVxdWVzdElkbGVDYWxsYmFja2AgcHNldWRvLXRocmVhZCkgb3IgaGFzXG5zdG9wcGVkIHJ1bm5pbmcsIGVpdGhlciBiZWNhdXNlIGl0IHBhcnNlZCB0aGUgZW50aXJlIGRvY3VtZW50LFxuYmVjYXVzZSBpdCBzcGVudCB0b28gbXVjaCB0aW1lIGFuZCB3YXMgY3V0IG9mZiwgb3IgYmVjYXVzZSB0aGVyZVxuaXMgbm8gbGFuZ3VhZ2UgcGFyc2VyIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4UGFyc2VyUnVubmluZyh2aWV3KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGFyc2VXb3JrZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNXb3JraW5nKCkpIHx8IGZhbHNlO1xufVxuLyoqXG5MZXplci1zdHlsZVxuW2BJbnB1dGBdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjY29tbW9uLklucHV0KVxub2JqZWN0IGZvciBhIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgb2JqZWN0LlxuKi9cbmNsYXNzIERvY0lucHV0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5wdXQgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmRvYy5sZW5ndGg7IH1cbiAgICBzeW5jVG8ocG9zKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gdGhpcy5jdXJzb3IubmV4dChwb3MgLSB0aGlzLmN1cnNvclBvcykudmFsdWU7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zICsgdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGNodW5rKHBvcykge1xuICAgICAgICB0aGlzLnN5bmNUbyhwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0ID0gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChmcm9tIDwgc3RyaW5nU3RhcnQgfHwgdG8gPj0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSAtIHN0cmluZ1N0YXJ0LCB0byAtIHN0cmluZ1N0YXJ0KTtcbiAgICB9XG59XG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xuLyoqXG5BIHBhcnNlIGNvbnRleHQgcHJvdmlkZWQgdG8gcGFyc2VycyB3b3JraW5nIG9uIHRoZSBlZGl0b3IgY29udGVudC5cbiovXG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRyZWUgZnJhZ21lbnRzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBpbmNyZW1lbnRhbCByZS1wYXJzZXMuXG4gICAgKi9cbiAgICBmcmFnbWVudHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWVMZW4sIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciB2aWV3cG9ydCAob3Igc29tZSBvdmVyYXBwcm94aW1hdGlvblxuICAgIHRoZXJlb2YpLiBJbnRlbmRlZCB0byBiZSB1c2VkIGZvciBvcHBvcnR1bmlzdGljYWxseSBhdm9pZGluZ1xuICAgIHdvcmsgKGluIHdoaWNoIGNhc2VcbiAgICBbYHNraXBVbnRpbEluVmlld2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuUGFyc2VDb250ZXh0LnNraXBVbnRpbEluVmlldylcbiAgICBzaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgcGFyc2VyIGlzIHJlc3RhcnRlZCB3aGVuIHRoZVxuICAgIHNraXBwZWQgcmVnaW9uIGJlY29tZXMgdmlzaWJsZSkuXG4gICAgKi9cbiAgICB2aWV3cG9ydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBza2lwcGVkLCBcbiAgICAvKipcbiAgICBUaGlzIGlzIHdoZXJlIHNraXBwaW5nIHBhcnNlcnMgY2FuIHJlZ2lzdGVyIGEgcHJvbWlzZSB0aGF0LFxuICAgIHdoZW4gcmVzb2x2ZWQsIHdpbGwgc2NoZWR1bGUgYSBuZXcgcGFyc2UuIEl0IGlzIGNsZWFyZWQgd2hlblxuICAgIHRoZSBwYXJzZSB3b3JrZXIgcGlja3MgdXAgdGhlIHByb21pc2UuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NoZWR1bGVPbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy50cmVlTGVuID0gdHJlZUxlbjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnNraXBwZWQgPSBza2lwcGVkO1xuICAgICAgICB0aGlzLnNjaGVkdWxlT24gPSBzY2hlZHVsZU9uO1xuICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRlbXBTa2lwcGVkID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJzZXIsIHN0YXRlLCB2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dChwYXJzZXIsIHN0YXRlLCBbXSwgVHJlZS5lbXB0eSwgMCwgdmlld3BvcnQsIFtdLCBudWxsKTtcbiAgICB9XG4gICAgc3RhcnRQYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnN0YXJ0UGFyc2UobmV3IERvY0lucHV0KHRoaXMuc3RhdGUuZG9jKSwgdGhpcy5mcmFnbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdvcmsodW50aWwsIHVwdG8pIHtcbiAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiB1cHRvID49IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHVwdG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnRyZWUgIT0gVHJlZS5lbXB0eSAmJiB0aGlzLmlzRG9uZSh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVudGlsID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyB1bnRpbDtcbiAgICAgICAgICAgICAgICB1bnRpbCA9ICgpID0+IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiB1cHRvKSAmJlxuICAgICAgICAgICAgICAgIHVwdG8gPCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQodXB0byk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKGRvbmUsIHRoaXMuZnJhZ21lbnRzLCB0aGlzLnBhcnNlLnN0b3BwZWRBdCAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IChfYSA9IHRoaXMucGFyc2Uuc3RvcHBlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlTGVuIDwgKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW50aWwoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0YWtlVHJlZSgpIHtcbiAgICAgICAgbGV0IHBvcywgdHJlZTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UgJiYgKHBvcyA9IHRoaXMucGFyc2UucGFyc2VkUG9zKSA+PSB0aGlzLnRyZWVMZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgICAgICB0aGlzLndpdGhDb250ZXh0KCgpID0+IHsgd2hpbGUgKCEodHJlZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpKSkgeyB9IH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gcG9zO1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUodGhpcy50cmVlLCB0aGlzLmZyYWdtZW50cywgdHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aENvbnRleHQoZikge1xuICAgICAgICBsZXQgcHJldiA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhvdXRUZW1wU2tpcHBlZChmcmFnbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcjsgciA9IHRoaXMudGVtcFNraXBwZWQucG9wKCk7KVxuICAgICAgICAgICAgZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgci5mcm9tLCByLnRvKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGFuZ2VzKGNoYW5nZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGxldCB7IGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiByYW5nZXMucHVzaCh7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSkpO1xuICAgICAgICAgICAgZnJhZ21lbnRzID0gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB0cmVlID0gVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHRyZWVMZW4gPSAwO1xuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyhyLmZyb20sIDEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHIudG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dCh0aGlzLnBhcnNlciwgbmV3U3RhdGUsIGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQsIHRoaXMuc2NoZWR1bGVPbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQuZnJvbSA9PSB2aWV3cG9ydC5mcm9tICYmIHRoaXMudmlld3BvcnQudG8gPT0gdmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IHN0YXJ0TGVuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHZpZXdwb3J0LnRvICYmIHRvID4gdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKHRoaXMuZnJhZ21lbnRzLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoID49IHN0YXJ0TGVuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXG4gICAgYmVjYXVzZSBpdCB3YXNuJ3QgaW4gdmlldywgYW5kIHRoZSBwYXJzZSBzaG91bGQgYmUgcmVzdGFydGVkXG4gICAgd2hlbiBpdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBza2lwVW50aWxJblZpZXcoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5za2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHBhcnNlciBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIHBsYWNlaG9sZGVyIHdoZW5cbiAgICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXG4gICAgbWFyayBpdCBhcyBub3QtcmVhbGx5LXBhcnNlZCwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCBwYXJzZVxuICAgIGl0IGFnYWluLlxuICAgIFxuICAgIFdoZW4gYHVudGlsYCBpcyBnaXZlbiwgYSByZXBhcnNlIHdpbGwgYmUgc2NoZWR1bGVkIHdoZW4gdGhhdFxuICAgIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0U2tpcHBpbmdQYXJzZXIodW50aWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1swXS5mcm9tLCB0byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUG9zOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gudGVtcFNraXBwZWQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW50aWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBjeC5zY2hlZHVsZU9uID8gUHJvbWlzZS5hbGwoW2N4LnNjaGVkdWxlT24sIHVudGlsXSkgOiB1bnRpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0byAtIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkQXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCgpIHsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpc0RvbmUodXB0bykge1xuICAgICAgICB1cHRvID0gTWF0aC5taW4odXB0bywgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IGZyYWdzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVMZW4gPj0gdXB0byAmJiBmcmFncy5sZW5ndGggJiYgZnJhZ3NbMF0uZnJvbSA9PSAwICYmIGZyYWdzWzBdLnRvID49IHVwdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgcGFyc2UsIG9yIGBudWxsYCBpZiBubyBlZGl0b3JcbiAgICBwYXJzZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQoKSB7IHJldHVybiBjdXJyZW50Q29udGV4dDsgfVxufVxuZnVuY3Rpb24gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIFt7IGZyb21BOiBmcm9tLCB0b0E6IHRvLCBmcm9tQjogZnJvbSwgdG9COiB0byB9XSk7XG59XG5jbGFzcyBMYW5ndWFnZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBBIG11dGFibGUgcGFyc2Ugc3RhdGUgdGhhdCBpcyB1c2VkIHRvIHByZXNlcnZlIHdvcmsgZG9uZSBkdXJpbmdcbiAgICAvLyB0aGUgbGlmZXRpbWUgb2YgYSBzdGF0ZSB3aGVuIG1vdmluZyB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHJlZSA9IGNvbnRleHQudHJlZTtcbiAgICB9XG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmIHRoaXMudHJlZSA9PSB0aGlzLmNvbnRleHQudHJlZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgbmV3Q3ggPSB0aGlzLmNvbnRleHQuY2hhbmdlcyh0ci5jaGFuZ2VzLCB0ci5zdGF0ZSk7XG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwYXJzZSB3YXNuJ3QgZG9uZSwgZ28gZm9yd2FyZCBvbmx5IHVwIHRvIGl0c1xuICAgICAgICAvLyBlbmQgcG9zaXRpb24gb3IgdGhlIGVuZCBvZiB0aGUgdmlld3BvcnQsIHRvIGF2b2lkIHNsb3dpbmcgZG93blxuICAgICAgICAvLyBzdGF0ZSB1cGRhdGVzIHdpdGggcGFyc2Ugd29yayBiZXlvbmQgdGhlIHZpZXdwb3J0LlxuICAgICAgICBsZXQgdXB0byA9IHRoaXMuY29udGV4dC50cmVlTGVuID09IHRyLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBNYXRoLm1heCh0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbnRleHQudHJlZUxlbiksIG5ld0N4LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKCFuZXdDeC53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHVwdG8pKVxuICAgICAgICAgICAgbmV3Q3gudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKG5ld0N4KTtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZwVG8gPSBNYXRoLm1pbigzMDAwIC8qIFdvcmsuSW5pdFZpZXdwb3J0ICovLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IHBhcnNlU3RhdGUgPSBQYXJzZUNvbnRleHQuY3JlYXRlKHN0YXRlLmZhY2V0KGxhbmd1YWdlKS5wYXJzZXIsIHN0YXRlLCB7IGZyb206IDAsIHRvOiB2cFRvIH0pO1xuICAgICAgICBpZiAoIXBhcnNlU3RhdGUud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB2cFRvKSlcbiAgICAgICAgICAgIHBhcnNlU3RhdGUudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKHBhcnNlU3RhdGUpO1xuICAgIH1cbn1cbkxhbmd1YWdlLnN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGU6IExhbmd1YWdlU3RhdGUuaW5pdCxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKExhbmd1YWdlLnNldFN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHRyLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSlcbiAgICAgICAgICAgIHJldHVybiBMYW5ndWFnZVN0YXRlLmluaXQodHIuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodHIpO1xuICAgIH1cbn0pO1xubGV0IHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCksIDUwMCAvKiBXb3JrLk1heFBhdXNlICovKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcbmlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPSBcInVuZGVmaW5lZFwiKVxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCBpZGxlID0gLTEsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlkbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCB7IHRpbWVvdXQ6IDUwMCAvKiBXb3JrLk1heFBhdXNlICovIC0gMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8gfSk7XG4gICAgICAgIH0sIDEwMCAvKiBXb3JrLk1pblBhdXNlICovKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGlkbGUgPCAwID8gY2xlYXJUaW1lb3V0KHRpbWVvdXQpIDogY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGUpO1xuICAgIH07XG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcbiAgICA/ICgpID0+IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKCkgOiBudWxsO1xuY29uc3QgcGFyc2VXb3JrZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3MgUGFyc2VXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkID0gMDtcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBjdXJyZW50IHRpbWUgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0VuZCA9IC0xO1xuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IC0xO1xuICAgICAgICB0aGlzLndvcmsgPSB0aGlzLndvcmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XG4gICAgICAgIGlmIChjeC51cGRhdGVWaWV3cG9ydCh1cGRhdGUudmlldy52aWV3cG9ydCkgfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvID4gY3gudHJlZUxlbilcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3Lmhhc0ZvY3VzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgKz0gNTAgLyogV29yay5DaGFuZ2VCb251cyAqLztcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoY3gpO1xuICAgIH1cbiAgICBzY2hlZHVsZVdvcmsoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSAhPSBmaWVsZC5jb250ZXh0LnRyZWUgfHwgIWZpZWxkLmNvbnRleHQuaXNEb25lKHN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nID0gcmVxdWVzdElkbGUodGhpcy53b3JrKTtcbiAgICB9XG4gICAgd29yayhkZWFkbGluZSkge1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBudWxsO1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtFbmQgPCBub3cgJiYgKHRoaXMuY2h1bmtFbmQgPCAwIHx8IHRoaXMudmlldy5oYXNGb2N1cykpIHsgLy8gU3RhcnQgYSBuZXcgY2h1bmtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtFbmQgPSBub3cgKyAzMDAwMCAvKiBXb3JrLkNodW5rVGltZSAqLztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAzMDAwIC8qIFdvcmsuQ2h1bmtCdWRnZXQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPD0gMClcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gbW9yZSBidWRnZXRcbiAgICAgICAgbGV0IHsgc3RhdGUsIHZpZXdwb3J0OiB7IHRvOiB2cFRvIH0gfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlID09IGZpZWxkLmNvbnRleHQudHJlZSAmJiBmaWVsZC5jb250ZXh0LmlzRG9uZSh2cFRvICsgMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIE1hdGgubWluKHRoaXMuY2h1bmtCdWRnZXQsIDEwMCAvKiBXb3JrLlNsaWNlICovLCBkZWFkbGluZSAmJiAhaXNJbnB1dFBlbmRpbmcgPyBNYXRoLm1heCgyNSAvKiBXb3JrLk1pblNsaWNlICovLCBkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgLSA1KSA6IDFlOSk7XG4gICAgICAgIGxldCB2aWV3cG9ydEZpcnN0ID0gZmllbGQuY29udGV4dC50cmVlTGVuIDwgdnBUbyAmJiBzdGF0ZS5kb2MubGVuZ3RoID4gdnBUbyArIDEwMDA7XG4gICAgICAgIGxldCBkb25lID0gZmllbGQuY29udGV4dC53b3JrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc0lucHV0UGVuZGluZyAmJiBpc0lucHV0UGVuZGluZygpIHx8IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICB9LCB2cFRvICsgKHZpZXdwb3J0Rmlyc3QgPyAwIDogMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpO1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0IC09IERhdGUubm93KCkgLSBub3c7XG4gICAgICAgIGlmIChkb25lIHx8IHRoaXMuY2h1bmtCdWRnZXQgPD0gMCkge1xuICAgICAgICAgICAgZmllbGQuY29udGV4dC50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogTGFuZ3VhZ2Uuc2V0U3RhdGUub2YobmV3IExhbmd1YWdlU3RhdGUoZmllbGQuY29udGV4dCkpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0ID4gMCAmJiAhKGRvbmUgJiYgIXZpZXdwb3J0Rmlyc3QpKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoZmllbGQuY29udGV4dCk7XG4gICAgfVxuICAgIGNoZWNrQXN5bmNTY2hlZHVsZShjeCkge1xuICAgICAgICBpZiAoY3guc2NoZWR1bGVPbikge1xuICAgICAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkKys7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zY2hlZHVsZVdvcmsoKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycikpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy53b3JrU2NoZWR1bGVkLS0pO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHRoaXMud29ya2luZygpO1xuICAgIH1cbiAgICBpc1dvcmtpbmcoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLndvcmtpbmcgfHwgdGhpcy53b3JrU2NoZWR1bGVkID4gMCk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHsgZm9jdXMoKSB7IHRoaXMuc2NoZWR1bGVXb3JrKCk7IH0gfVxufSk7XG4vKipcblRoZSBmYWNldCB1c2VkIHRvIGFzc29jaWF0ZSBhIGxhbmd1YWdlIHdpdGggYW4gZWRpdG9yIHN0YXRlLiBVc2VkXG5ieSBgTGFuZ3VhZ2VgIG9iamVjdCdzIGBleHRlbnNpb25gIHByb3BlcnR5IChzbyB5b3UgZG9uJ3QgbmVlZCB0b1xubWFudWFsbHkgd3JhcCB5b3VyIGxhbmd1YWdlcyBpbiB0aGlzKS4gQ2FuIGJlIHVzZWQgdG8gYWNjZXNzIHRoZVxuY3VycmVudCBsYW5ndWFnZSBvbiBhIHN0YXRlLlxuKi9cbmNvbnN0IGxhbmd1YWdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShsYW5ndWFnZXMpIHsgcmV0dXJuIGxhbmd1YWdlcy5sZW5ndGggPyBsYW5ndWFnZXNbMF0gOiBudWxsOyB9LFxuICAgIGVuYWJsZXM6IGxhbmd1YWdlID0+IFtcbiAgICAgICAgTGFuZ3VhZ2Uuc3RhdGUsXG4gICAgICAgIHBhcnNlV29ya2VyLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmNvbXB1dGUoW2xhbmd1YWdlXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgICAgICByZXR1cm4gbGFuZyAmJiBsYW5nLm5hbWUgPyB7IFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLm5hbWUgfSA6IHt9O1xuICAgICAgICB9KVxuICAgIF1cbn0pO1xuLyoqXG5UaGlzIGNsYXNzIGJ1bmRsZXMgYSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIHdpdGggYW5cbm9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIExhbmd1YWdlIHBhY2thZ2VzIGFyZVxuZW5jb3VyYWdlZCB0byBleHBvcnQgYSBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgdGFrZXMgYVxuY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIHJldHVybnMgYSBgTGFuZ3VhZ2VTdXBwb3J0YCBpbnN0YW5jZSwgYXNcbnRoZSBtYWluIHdheSBmb3IgY2xpZW50IGNvZGUgdG8gdXNlIHRoZSBwYWNrYWdlLlxuKi9cbmNsYXNzIExhbmd1YWdlU3VwcG9ydCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2Ugc3VwcG9ydCBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgICovXG4gICAgbGFuZ3VhZ2UsIFxuICAgIC8qKlxuICAgIEFuIG9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIFdoZW4gbmVzdGluZyBhXG4gICAgbGFuZ3VhZ2UgaW4gYW5vdGhlciBsYW5ndWFnZSwgdGhlIG91dGVyIGxhbmd1YWdlIGlzIGVuY291cmFnZWRcbiAgICB0byBpbmNsdWRlIHRoZSBzdXBwb3J0aW5nIGV4dGVuc2lvbnMgZm9yIGl0cyBpbm5lciBsYW5ndWFnZXNcbiAgICBpbiBpdHMgb3duIHNldCBvZiBzdXBwb3J0IGV4dGVuc2lvbnMuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gW10pIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtsYW5ndWFnZSwgc3VwcG9ydF07XG4gICAgfVxufVxuLyoqXG5MYW5ndWFnZSBkZXNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXQgbGFuZ3VhZ2VzXG5hbmQgdG8gZHluYW1pY2FsbHkgbG9hZCB0aGVtLiBUaGVpciBtYWluIHJvbGUgaXMgZmluZGluZyB0aGVcbmFwcHJvcHJpYXRlIGxhbmd1YWdlIGZvciBhIGZpbGVuYW1lIG9yIGR5bmFtaWNhbGx5IGxvYWRpbmcgbmVzdGVkXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBbHRlcm5hdGl2ZSBuYW1lcyBmb3IgdGhlIG1vZGUgKGxvd2VyY2FzZWQsIGluY2x1ZGVzIGB0aGlzLm5hbWVgKS5cbiAgICAqL1xuICAgIGFsaWFzLCBcbiAgICAvKipcbiAgICBGaWxlIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBleHRlbnNpb25zLCBcbiAgICAvKipcbiAgICBPcHRpb25hbCBmaWxlbmFtZSBwYXR0ZXJuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBmaWxlbmFtZSwgbG9hZEZ1bmMsIFxuICAgIC8qKlxuICAgIElmIHRoZSBsYW5ndWFnZSBoYXMgYmVlbiBsb2FkZWQsIHRoaXMgd2lsbCBob2xkIGl0cyB2YWx1ZS5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubG9hZEZ1bmMgPSBsb2FkRnVuYztcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgbG9hZGluZyB0aGUgdGhlIGxhbmd1YWdlLiBXaWxsIHJldHVybiBhIHByb21pc2UgdGhhdFxuICAgIHJlc29sdmVzIHRvIGEgW2BMYW5ndWFnZVN1cHBvcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlU3VwcG9ydClcbiAgICBvYmplY3Qgd2hlbiB0aGUgbGFuZ3VhZ2Ugc3VjY2Vzc2Z1bGx5IGxvYWRzLlxuICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyB8fCAodGhpcy5sb2FkaW5nID0gdGhpcy5sb2FkRnVuYygpLnRoZW4oc3VwcG9ydCA9PiB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0LCBlcnIgPT4geyB0aGlzLmxvYWRpbmcgPSBudWxsOyB0aHJvdyBlcnI7IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2UgZGVzY3JpcHRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgb2Yoc3BlYykge1xuICAgICAgICBsZXQgeyBsb2FkLCBzdXBwb3J0IH0gPSBzcGVjO1xuICAgICAgICBpZiAoIWxvYWQpIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11c3QgcGFzcyBlaXRoZXIgJ2xvYWQnIG9yICdzdXBwb3J0JyB0byBMYW5ndWFnZURlc2NyaXB0aW9uLm9mXCIpO1xuICAgICAgICAgICAgbG9hZCA9ICgpID0+IFByb21pc2UucmVzb2x2ZShzdXBwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlRGVzY3JpcHRpb24oc3BlYy5uYW1lLCAoc3BlYy5hbGlhcyB8fCBbXSkuY29uY2F0KHNwZWMubmFtZSkubWFwKHMgPT4gcy50b0xvd2VyQ2FzZSgpKSwgc3BlYy5leHRlbnNpb25zIHx8IFtdLCBzcGVjLmZpbGVuYW1lLCBsb2FkLCBzdXBwb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVzY3JpcHRpb25zIHRoYXRcbiAgICBtYXRjaGVzIHRoZSBmaWxlbmFtZS4gV2lsbCBmaXJzdCBtYXRjaFxuICAgIFtgZmlsZW5hbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZmlsZW5hbWUpIHBhdHRlcm5zLFxuICAgIGFuZCB0aGVuIFtleHRlbnNpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZXh0ZW5zaW9ucyksXG4gICAgYW5kIHJldHVybiB0aGUgZmlyc3QgbGFuZ3VhZ2UgdGhhdCBtYXRjaGVzLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoRmlsZW5hbWUoZGVzY3MsIGZpbGVuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5maWxlbmFtZSAmJiBkLmZpbGVuYW1lLnRlc3QoZmlsZW5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBsZXQgZXh0ID0gL1xcLihbXi5dKykkLy5leGVjKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgaWYgKGQuZXh0ZW5zaW9ucy5pbmRleE9mKGV4dFsxXSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWUgb3IgYWxpYXMgbWF0Y2hlcyB0aGUgdGhlIGdpdmVuXG4gICAgbmFtZSAoY2FzZS1pbnNlbnNpdGl2ZWx5KS4gSWYgYGZ1enp5YCBpcyB0cnVlLCBhbmQgbm8gZGlyZWN0XG4gICAgbWF0Y2hzIGlzIGZvdW5kLCB0aGlzJ2xsIGFsc28gc2VhcmNoIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWVcbiAgICBvciBhbGlhcyBvY2N1cnMgaW4gdGhlIHN0cmluZyAoZm9yIG5hbWVzIHNob3J0ZXIgdGhhbiB0aHJlZVxuICAgIGNoYXJhY3RlcnMsIG9ubHkgd2hlbiBzdXJyb3VuZGVkIGJ5IG5vbi13b3JkIGNoYXJhY3RlcnMpLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoTGFuZ3VhZ2VOYW1lKGRlc2NzLCBuYW1lLCBmdXp6eSA9IHRydWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmFsaWFzLnNvbWUoYSA9PiBhID09IG5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBpZiAoZnV6enkpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgb2YgZC5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBuYW1lLmluZGV4T2YoYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xICYmIChhLmxlbmd0aCA+IDIgfHwgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCAtIDFdKSAmJiAhL1xcdy8udGVzdChuYW1lW2ZvdW5kICsgYS5sZW5ndGhdKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG5GYWNldCB0aGF0IGRlZmluZXMgYSB3YXkgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlXG5hcHByb3ByaWF0ZSBpbmRlbnRhdGlvbiBkZXB0aCwgYXMgYSBjb2x1bW4gbnVtYmVyIChzZWVcbltgaW5kZW50U3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTdHJpbmcpKSwgYXQgdGhlIHN0YXJ0IG9mIGEgZ2l2ZW5cbmxpbmUuIEEgcmV0dXJuIHZhbHVlIG9mIGBudWxsYCBpbmRpY2F0ZXMgbm8gaW5kZW50YXRpb24gY2FuIGJlXG5kZXRlcm1pbmVkLCBhbmQgdGhlIGxpbmUgc2hvdWxkIGluaGVyaXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBvbmVcbmFib3ZlIGl0LiBBIHJldHVybiB2YWx1ZSBvZiBgdW5kZWZpbmVkYCBkZWZlcnMgdG8gdGhlIG5leHQgaW5kZW50XG5zZXJ2aWNlLlxuKi9cbmNvbnN0IGluZGVudFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IGZvciBvdmVycmlkaW5nIHRoZSB1bml0IGJ5IHdoaWNoIGluZGVudGF0aW9uIGhhcHBlbnMuIFNob3VsZFxuYmUgYSBzdHJpbmcgY29uc2lzdGluZyBlbnRpcmVseSBvZiB0aGUgc2FtZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbldoZW4gbm90IHNldCwgdGhpcyBkZWZhdWx0cyB0byAyIHNwYWNlcy5cbiovXG5jb25zdCBpbmRlbnRVbml0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFwiICBcIjtcbiAgICAgICAgbGV0IHVuaXQgPSB2YWx1ZXNbMF07XG4gICAgICAgIGlmICghdW5pdCB8fCAvXFxTLy50ZXN0KHVuaXQpIHx8IEFycmF5LmZyb20odW5pdCkuc29tZShlID0+IGUgIT0gdW5pdFswXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGVudCB1bml0OiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlc1swXSkpO1xuICAgICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJuIHRoZSBfY29sdW1uIHdpZHRoXyBvZiBhbiBpbmRlbnQgdW5pdCBpbiB0aGUgc3RhdGUuXG5EZXRlcm1pbmVkIGJ5IHRoZSBbYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpXG5mYWNldCwgYW5kIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgd2hlbiB0aGF0XG5jb250YWlucyB0YWJzLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudFVuaXQoc3RhdGUpIHtcbiAgICBsZXQgdW5pdCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgIHJldHVybiB1bml0LmNoYXJDb2RlQXQoMCkgPT0gOSA/IHN0YXRlLnRhYlNpemUgKiB1bml0Lmxlbmd0aCA6IHVuaXQubGVuZ3RoO1xufVxuLyoqXG5DcmVhdGUgYW4gaW5kZW50YXRpb24gc3RyaW5nIHRoYXQgY292ZXJzIGNvbHVtbnMgMCB0byBgY29sc2AuXG5XaWxsIHVzZSB0YWJzIGZvciBhcyBtdWNoIG9mIHRoZSBjb2x1bW5zIGFzIHBvc3NpYmxlIHdoZW4gdGhlXG5bYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIGZhY2V0IGNvbnRhaW5zXG50YWJzLlxuKi9cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdGF0ZSwgY29scykge1xuICAgIGxldCByZXN1bHQgPSBcIlwiLCB0cyA9IHN0YXRlLnRhYlNpemUsIGNoID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdClbMF07XG4gICAgaWYgKGNoID09IFwiXFx0XCIpIHtcbiAgICAgICAgd2hpbGUgKGNvbHMgPj0gdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgY29scyAtPSB0cztcbiAgICAgICAgfVxuICAgICAgICBjaCA9IFwiIFwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHM7IGkrKylcbiAgICAgICAgcmVzdWx0ICs9IGNoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkdldCB0aGUgaW5kZW50YXRpb24sIGFzIGEgY29sdW1uIG51bWJlciwgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuV2lsbCBmaXJzdCBjb25zdWx0IGFueSBbaW5kZW50IHNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpXG50aGF0IGFyZSByZWdpc3RlcmVkLCBhbmQgaWYgbm9uZSBvZiB0aG9zZSByZXR1cm4gYW4gaW5kZW50YXRpb24sXG50aGlzIHdpbGwgY2hlY2sgdGhlIHN5bnRheCB0cmVlIGZvciB0aGUgW2luZGVudCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE5vZGVQcm9wKSBhbmQgdXNlIHRoYXQgaWYgZm91bmQuIFJldHVybnMgYVxubnVtYmVyIHdoZW4gYW4gaW5kZW50YXRpb24gY291bGQgYmUgZGV0ZXJtaW5lZCwgYW5kIG51bGxcbm90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBwb3MpIHtcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIEVkaXRvclN0YXRlKVxuICAgICAgICBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoY29udGV4dCk7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBjb250ZXh0LnN0YXRlLmZhY2V0KGluZGVudFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKGNvbnRleHQsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKTtcbiAgICByZXR1cm4gdHJlZS5sZW5ndGggPj0gcG9zID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhIGNoYW5nZSBzZXQgdGhhdCBhdXRvLWluZGVudHMgYWxsIGxpbmVzIHRvdWNoZWQgYnkgdGhlXG5naXZlbiBkb2N1bWVudCByYW5nZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRSYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHVwZGF0ZWRbc3RhcnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTsgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG59XG4vKipcbkluZGVudGF0aW9uIGNvbnRleHRzIGFyZSB1c2VkIHdoZW4gY2FsbGluZyBbaW5kZW50YXRpb25cbnNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpLiBUaGV5IHByb3ZpZGUgaGVscGVyIHV0aWxpdGllc1xudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxuaW5kZW50YXRpb24gcmVwb3J0ZWQgZm9yIHNvbWUgbGluZXMuXG4qL1xuY2xhc3MgSW5kZW50Q29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluZGVudCBjb250ZXh0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xuICAgIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxuICAgIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciB0aGUgcGFydCBvZiB0aGUgbGluZSBsaW5lIGJlZm9yZSBvclxuICAgIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAgICovXG4gICAgbGluZUF0KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhaywgc2ltdWxhdGVEb3VibGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc2ltdWxhdGVCcmVhayAhPSBudWxsICYmIHNpbXVsYXRlQnJlYWsgPj0gbGluZS5mcm9tICYmIHNpbXVsYXRlQnJlYWsgPD0gbGluZS50bykge1xuICAgICAgICAgICAgaWYgKHNpbXVsYXRlRG91YmxlQnJlYWsgJiYgc2ltdWxhdGVCcmVhayA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogXCJcIiwgZnJvbTogcG9zIH07XG4gICAgICAgICAgICBlbHNlIGlmIChiaWFzIDwgMCA/IHNpbXVsYXRlQnJlYWsgPCBwb3MgOiBzaW11bGF0ZUJyZWFrIDw9IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2Uoc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IHNpbXVsYXRlQnJlYWsgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2UoMCwgc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IGxpbmUuZnJvbSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICB0ZXh0QWZ0ZXJQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWsgJiYgcG9zID09IHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvcyAtIGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyAxMDAgLSBmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgY29sdW1uKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY291bnRDb2x1bW4odGV4dCwgcG9zIC0gZnJvbSk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oZnJvbSkgOiAtMTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID4gLTEpXG4gICAgICAgICAgICByZXN1bHQgKz0gb3ZlcnJpZGUgLSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MgPSBsaW5lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY291bnRDb2x1bW4obGluZSwgdGhpcy5zdGF0ZS50YWJTaXplLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICovXG4gICAgbGluZUluZGVudChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZW4gPSBvdmVycmlkZShmcm9tKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZW4gPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgZm9yIHRoaXMgY29udGV4dCwgaWYgYW55LlxuICAgICovXG4gICAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWsgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkEgc3ludGF4IHRyZWUgbm9kZSBwcm9wIHVzZWQgdG8gYXNzb2NpYXRlIGluZGVudGF0aW9uIHN0cmF0ZWdpZXNcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxuY29udGV4dCB0byBhIGNvbHVtbiBudW1iZXIgKHNlZSBhbHNvXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSkgb3IgbnVsbCwgd2hlcmUgbnVsbFxuaW5kaWNhdGVzIHRoYXQgbm8gZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cbiovXG5jb25zdCBpbmRlbnROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxuZnVuY3Rpb24gc3ludGF4SW5kZW50YXRpb24oY3gsIGFzdCwgcG9zKSB7XG4gICAgbGV0IHN0YWNrID0gYXN0LnJlc29sdmVTdGFjayhwb3MpO1xuICAgIGxldCBpbm5lciA9IGFzdC5yZXNvbHZlSW5uZXIocG9zLCAtMSkucmVzb2x2ZShwb3MsIDApLmVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcyk7XG4gICAgaWYgKGlubmVyICE9IHN0YWNrLm5vZGUpIHtcbiAgICAgICAgbGV0IGFkZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBpbm5lcjsgY3VyICYmICEoY3VyLmZyb20gPCBzdGFjay5ub2RlLmZyb20gfHwgY3VyLnRvID4gc3RhY2subm9kZS50byB8fFxuICAgICAgICAgICAgY3VyLmZyb20gPT0gc3RhY2subm9kZS5mcm9tICYmIGN1ci50eXBlID09IHN0YWNrLm5vZGUudHlwZSk7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBhZGQucHVzaChjdXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gYWRkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgc3RhY2sgPSB7IG5vZGU6IGFkZFtpXSwgbmV4dDogc3RhY2sgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudEZvcihzdGFjaywgY3gsIHBvcyk7XG59XG5mdW5jdGlvbiBpbmRlbnRGb3Ioc3RhY2ssIGN4LCBwb3MpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICBsZXQgc3RyYXRlZ3kgPSBpbmRlbnRTdHJhdGVneShjdXIubm9kZSk7XG4gICAgICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShUcmVlSW5kZW50Q29udGV4dC5jcmVhdGUoY3gsIHBvcywgY3VyKSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgcmV0dXJuIGN4LnBvcyA9PSBjeC5vcHRpb25zLnNpbXVsYXRlQnJlYWsgJiYgY3gub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gaW5kZW50U3RyYXRlZ3kodHJlZSkge1xuICAgIGxldCBzdHJhdGVneSA9IHRyZWUudHlwZS5wcm9wKGluZGVudE5vZGVQcm9wKTtcbiAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICBsZXQgZmlyc3QgPSB0cmVlLmZpcnN0Q2hpbGQsIGNsb3NlO1xuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMgcmVnaXN0ZXJlZCBvbiBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGV4dCkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN5bnRheCB0cmVlIG5vZGUgdG8gd2hpY2ggdGhlIGluZGVudGF0aW9uIHN0cmF0ZWd5XG4gICAgYXBwbGllcy5cbiAgICAqL1xuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0Lm5vZGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYmFzZSwgcG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VJbmRlbnRGb3IodGhpcy5ub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBmb3IgdGhlIHJlZmVyZW5jZSBsaW5lIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgKHNlZSBbYGJhc2VJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlRyZWVJbmRlbnRDb250ZXh0LmJhc2VJbmRlbnQpKS5cbiAgICAqL1xuICAgIGJhc2VJbmRlbnRGb3Iobm9kZSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChub2RlLmZyb20pO1xuICAgICAgICAvLyBTa2lwIGxpbmUgc3RhcnRzIHRoYXQgYXJlIGNvdmVyZWQgYnkgYSBzaWJsaW5nIChvciBjb3VzaW4sIGV0YylcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGF0QnJlYWsgPSBub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgbm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXG4gICAgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQuXG4gICAgKi9cbiAgICBjb250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIGluZGVudEZvcih0aGlzLmNvbnRleHQubmV4dCwgdGhpcy5iYXNlLCB0aGlzLnBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZCkge1xuICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA+PSBsaW5lRW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHNwYWNlID0gL14gKi8uZXhlYyhvcGVuTGluZS50ZXh0LnNsaWNlKG9wZW5Ub2tlbi50byAtIG9wZW5MaW5lLmZyb20pKVswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBvcGVuVG9rZW4uZnJvbSwgdG86IG9wZW5Ub2tlbi50byArIHNwYWNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA8IGVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHN0YWNrID0gdHJlZS5yZXNvbHZlU3RhY2soZW5kLCAxKTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGl0ZXIgPSBzdGFjazsgaXRlcjsgaXRlciA9IGl0ZXIubmV4dCkge1xuICAgICAgICBsZXQgY3VyID0gaXRlci5ub2RlO1xuICAgICAgICBpZiAoY3VyLnRvIDw9IGVuZCB8fCBjdXIuZnJvbSA+IGVuZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgY3VyLmZyb20gPCBzdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgcHJvcCA9IGN1ci50eXBlLnByb3AoZm9sZE5vZGVQcm9wKTtcbiAgICAgICAgaWYgKHByb3AgJiYgKGN1ci50byA8IHRyZWUubGVuZ3RoIC0gNTAgfHwgdHJlZS5sZW5ndGggPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCAhaXNVbmZpbmlzaGVkKGN1cikpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wKGN1ciwgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmZyb20gPD0gZW5kICYmIHZhbHVlLmZyb20gPj0gc3RhcnQgJiYgdmFsdWUudG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc1VuZmluaXNoZWQobm9kZSkge1xuICAgIGxldCBjaCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBjaCAmJiBjaC50byA9PSBub2RlLnRvICYmIGNoLnR5cGUuaXNFcnJvcjtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbGluZSBpcyBmb2xkYWJsZS4gRmlyc3QgYXNrcyBhbnkgZm9sZFxuc2VydmljZXMgcmVnaXN0ZXJlZCB0aHJvdWdoXG5bYGZvbGRTZXJ2aWNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkU2VydmljZSksIGFuZCBpZiBub25lIG9mIHRoZW0gcmV0dXJuXG5hIHJlc3VsdCwgdHJpZXMgdG8gcXVlcnkgdGhlIFtmb2xkIG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBvZiBzeW50YXggbm9kZXMgdGhhdCBjb3ZlciB0aGUgZW5kXG5vZiB0aGUgbGluZS5cbiovXG5mdW5jdGlvbiBmb2xkYWJsZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKSB7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBzdGF0ZS5mYWNldChmb2xkU2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2Uoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3ludGF4Rm9sZGluZyhzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlKHJhbmdlLCBtYXBwaW5nKSB7XG4gICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS50bywgLTEpO1xuICAgIHJldHVybiBmcm9tID49IHRvID8gdW5kZWZpbmVkIDogeyBmcm9tLCB0byB9O1xufVxuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBmb2xkIHRoZVxuZ2l2ZW4gcmFuZ2UuIChZb3UgcHJvYmFibHkgb25seSBuZWVkIHRoaXMgaW4gZXhjZXB0aW9uYWxcbmNpcmN1bXN0YW5jZXPigJR1c3VhbGx5IHlvdSdsbCBqdXN0IHdhbnQgdG8gbGV0XG5bYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkgYW5kIHRoZSBbZm9sZFxuZ3V0dGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRHdXR0ZXIpIGNyZWF0ZSB0aGUgdHJhbnNhY3Rpb25zLilcbiovXG5jb25zdCBmb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IHVuZm9sZHMgdGhlIGdpdmVuIHJhbmdlIChpZiBpdCB3YXMgZm9sZGVkKS5cbiovXG5jb25zdCB1bmZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZXModmlldykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBpZiAobGluZXMuc29tZShsID0+IGwuZnJvbSA8PSBoZWFkICYmIGwudG8gPj0gaGVhZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGluZXMucHVzaCh2aWV3LmxpbmVCbG9ja0F0KGhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdGhhdCBzdG9yZXMgdGhlIGZvbGRlZCByYW5nZXMgKGFzIGEgW2RlY29yYXRpb25cbnNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpKS4gQ2FuIGJlIHBhc3NlZCB0b1xuW2BFZGl0b3JTdGF0ZS50b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgYW5kXG5bYGZyb21KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgdG8gc2VyaWFsaXplIHRoZSBmb2xkXG5zdGF0ZS5cbiovXG5jb25zdCBmb2xkU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9LFxuICAgIHVwZGF0ZShmb2xkZWQsIHRyKSB7XG4gICAgICAgIGlmICh0ci5pc1VzZXJFdmVudChcImRlbGV0ZVwiKSlcbiAgICAgICAgICAgIHRyLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EpID0+IGZvbGRlZCA9IGNsZWFyVG91Y2hlZEZvbGRzKGZvbGRlZCwgZnJvbUEsIHRvQSkpO1xuICAgICAgICBmb2xkZWQgPSBmb2xkZWQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlLmlzKGZvbGRFZmZlY3QpICYmICFmb2xkRXhpc3RzKGZvbGRlZCwgZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKSkge1xuICAgICAgICAgICAgICAgIGxldCB7IHByZXBhcmVQbGFjZWhvbGRlciB9ID0gdHIuc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgbGV0IHdpZGdldCA9ICFwcmVwYXJlUGxhY2Vob2xkZXIgPyBmb2xkV2lkZ2V0IDpcbiAgICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgUHJlcGFyZWRGb2xkV2lkZ2V0KHByZXBhcmVQbGFjZWhvbGRlcih0ci5zdGF0ZSwgZS52YWx1ZSkpIH0pO1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBhZGQ6IFt3aWRnZXQucmFuZ2UoZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmlzKHVuZm9sZEVmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgZmlsdGVyOiAoZnJvbSwgdG8pID0+IGUudmFsdWUuZnJvbSAhPSBmcm9tIHx8IGUudmFsdWUudG8gIT0gdG8sXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGUudmFsdWUuZnJvbSwgZmlsdGVyVG86IGUudmFsdWUudG8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgZm9sZGVkIHJhbmdlcyB0aGF0IGNvdmVyIHRoZSBzZWxlY3Rpb24gaGVhZFxuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgZm9sZGVkID0gY2xlYXJUb3VjaGVkRm9sZHMoZm9sZGVkLCB0ci5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgcmV0dXJuIGZvbGRlZDtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpLFxuICAgIHRvSlNPTihmb2xkZWQsIHN0YXRlKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9sZGVkLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IHJhbmdlcy5wdXNoKGZyb20sIHRvKTsgfSk7XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfSxcbiAgICBmcm9tSlNPTih2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAlIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmFsdWVbaSsrXSwgdG8gPSB2YWx1ZVtpKytdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgICAgICByYW5nZXMucHVzaChmb2xkV2lkZ2V0LnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KHJhbmdlcywgdHJ1ZSk7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBjbGVhclRvdWNoZWRGb2xkcyhmb2xkZWQsIGZyb20sIHRvID0gZnJvbSkge1xuICAgIGxldCB0b3VjaGVkID0gZmFsc2U7XG4gICAgZm9sZGVkLmJldHdlZW4oZnJvbSwgdG8sIChhLCBiKSA9PiB7IGlmIChhIDwgdG8gJiYgYiA+IGZyb20pXG4gICAgICAgIHRvdWNoZWQgPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gIXRvdWNoZWQgPyBmb2xkZWQgOiBmb2xkZWQudXBkYXRlKHtcbiAgICAgICAgZmlsdGVyRnJvbTogZnJvbSxcbiAgICAgICAgZmlsdGVyVG86IHRvLFxuICAgICAgICBmaWx0ZXI6IChhLCBiKSA9PiBhID49IHRvIHx8IGIgPD0gZnJvbVxuICAgIH0pO1xufVxuLyoqXG5HZXQgYSBbcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBjb250YWluaW5nIHRoZSBmb2xkZWQgcmFuZ2VzXG5pbiB0aGUgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gZm9sZGVkUmFuZ2VzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpIHx8IFJhbmdlU2V0LmVtcHR5O1xufVxuZnVuY3Rpb24gZmluZEZvbGQoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgKF9hID0gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iZXR3ZWVuKGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKCFmb3VuZCB8fCBmb3VuZC5mcm9tID4gZnJvbSlcbiAgICAgICAgICAgIGZvdW5kID0geyBmcm9tLCB0byB9O1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGZvbGRFeGlzdHMoZm9sZGVkLCBmcm9tLCB0bykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGZvbGRlZC5iZXR3ZWVuKGZyb20sIGZyb20sIChhLCBiKSA9PiB7IGlmIChhID09IGZyb20gJiYgYiA9PSB0bylcbiAgICAgICAgZm91bmQgPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZShzdGF0ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgPyBvdGhlciA6IG90aGVyLmNvbmNhdChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoY29kZUZvbGRpbmcoKSkpO1xufVxuLyoqXG5Gb2xkIHRoZSBsaW5lcyB0aGF0IGFyZSBzZWxlY3RlZCwgaWYgcG9zc2libGUuXG4qL1xuY29uc3QgZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgW2ZvbGRFZmZlY3Qub2YocmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgcmFuZ2UpXSkgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5VbmZvbGQgZm9sZGVkIHJhbmdlcyBvbiBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCB1bmZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkZWQsIGZhbHNlKSk7XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIGVmZmVjdHMubGVuZ3RoID4gMDtcbn07XG5mdW5jdGlvbiBhbm5vdW5jZUZvbGQodmlldywgcmFuZ2UsIGZvbGQgPSB0cnVlKSB7XG4gICAgbGV0IGxpbmVGcm9tID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLm51bWJlciwgbGluZVRvID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKS5udW1iZXI7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYCR7dmlldy5zdGF0ZS5waHJhc2UoZm9sZCA/IFwiRm9sZGVkIGxpbmVzXCIgOiBcIlVuZm9sZGVkIGxpbmVzXCIpfSAke2xpbmVGcm9tfSAke3ZpZXcuc3RhdGUucGhyYXNlKFwidG9cIil9ICR7bGluZVRvfS5gKTtcbn1cbi8qKlxuRm9sZCBhbGwgdG9wLWxldmVsIGZvbGRhYmxlIHJhbmdlcy4gTm90ZSB0aGF0LCBpbiBtb3N0IGNhc2VzLFxuZm9sZGluZyBpbmZvcm1hdGlvbiB3aWxsIGRlcGVuZCBvbiB0aGUgW3N5bnRheFxudHJlZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKSwgYW5kIGZvbGRpbmcgZXZlcnl0aGluZyBtYXkgbm90IHdvcmtcbnJlbGlhYmx5IHdoZW4gdGhlIGRvY3VtZW50IGhhc24ndCBiZWVuIGZ1bGx5IHBhcnNlZCAoZWl0aGVyXG5iZWNhdXNlIHRoZSBlZGl0b3Igc3RhdGUgd2FzIG9ubHkganVzdCBpbml0aWFsaXplZCwgb3IgYmVjYXVzZSB0aGVcbmRvY3VtZW50IGlzIHNvIGJpZyB0aGF0IHRoZSBwYXJzZXIgZGVjaWRlZCBub3QgdG8gcGFyc2UgaXRcbmVudGlyZWx5KS5cbiovXG5jb25zdCBmb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBzdGF0ZS5kb2MubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKSwgcmFuZ2UgPSBmb2xkYWJsZShzdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGZvbGRFZmZlY3Qub2YocmFuZ2UpKTtcbiAgICAgICAgcG9zID0gKHJhbmdlID8gdmlldy5saW5lQmxvY2tBdChyYW5nZS50bykgOiBsaW5lKS50byArIDE7XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuVW5mb2xkIGFsbCBmb2xkZWQgY29kZS5cbiovXG5jb25zdCB1bmZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZpZWxkLmJldHdlZW4oMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZih7IGZyb20sIHRvIH0pKTsgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCB0aGUgZm9sZGFibGUgcmVnaW9uIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGxpbmUsIGlmIG9uZSBleGlzdHNcbmZ1bmN0aW9uIGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmVCbG9jaykge1xuICAgIC8vIExvb2sgYmFja3dhcmRzIHRocm91Z2ggbGluZSBibG9ja3MgdW50aWwgd2UgZmluZCBhIGZvbGRhYmxlIHJlZ2lvbiB0aGF0XG4gICAgLy8gaW50ZXJzZWN0cyB3aXRoIHRoZSBsaW5lXG4gICAgZm9yIChsZXQgbGluZSA9IGxpbmVCbG9jazs7KSB7XG4gICAgICAgIGxldCBmb2xkYWJsZVJlZ2lvbiA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkYWJsZVJlZ2lvbiAmJiBmb2xkYWJsZVJlZ2lvbi50byA+IGxpbmVCbG9jay5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIGZvbGRhYmxlUmVnaW9uO1xuICAgICAgICBpZiAoIWxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsaW5lID0gdmlldy5saW5lQmxvY2tBdChsaW5lLmZyb20gLSAxKTtcbiAgICB9XG59XG4vKipcblRvZ2dsZSBmb2xkaW5nIGF0IGN1cnNvcnMuIFVuZm9sZHMgaWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgZm9sZFxuc3RhcnRpbmcgaW4gdGhhdCBsaW5lLCB0cmllcyB0byBmaW5kIGEgZm9sZGFibGUgcmFuZ2UgYXJvdW5kIGl0XG5vdGhlcndpc2UuXG4qL1xuY29uc3QgdG9nZ2xlRm9sZCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb2xkUmFuZ2UgPSBmb2xkYWJsZUNvbnRhaW5lcih2aWV3LCBsaW5lKTtcbiAgICAgICAgICAgIGlmIChmb2xkUmFuZ2UpXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGZvbGRFZmZlY3Qub2YoZm9sZFJhbmdlKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRSYW5nZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBlZmZlY3RzKSB9KTtcbiAgICByZXR1cm4gISFlZmZlY3RzLmxlbmd0aDtcbn07XG4vKipcbkRlZmF1bHQgZm9sZC1yZWxhdGVkIGtleSBiaW5kaW5ncy5cblxuIC0gQ3RybC1TaGlmdC1bIChDbWQtQWx0LVsgb24gbWFjT1MpOiBbYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkuXG4gLSBDdHJsLVNoaWZ0LV0gKENtZC1BbHQtXSBvbiBtYWNPUyk6IFtgdW5mb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQ29kZSkuXG4gLSBDdHJsLUFsdC1bOiBbYGZvbGRBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRBbGwpLlxuIC0gQ3RybC1BbHQtXTogW2B1bmZvbGRBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnVuZm9sZEFsbCkuXG4qL1xuY29uc3QgZm9sZEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LVtcIiwgbWFjOiBcIkNtZC1BbHQtW1wiLCBydW46IGZvbGRDb2RlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1dXCIsIG1hYzogXCJDbWQtQWx0LV1cIiwgcnVuOiB1bmZvbGRDb2RlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtW1wiLCBydW46IGZvbGRBbGwgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1dXCIsIHJ1bjogdW5mb2xkQWxsIH1cbl07XG5jb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgIHBsYWNlaG9sZGVyRE9NOiBudWxsLFxuICAgIHByZXBhcmVQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwbGFjZWhvbGRlclRleHQ6IFwi4oCmXCJcbn07XG5jb25zdCBmb2xkQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCBkZWZhdWx0Q29uZmlnKTsgfVxufSk7XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIGNvZGUgZm9sZGluZy5cbiovXG5mdW5jdGlvbiBjb2RlRm9sZGluZyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW2ZvbGRTdGF0ZSwgYmFzZVRoZW1lJDFdO1xuICAgIGlmIChjb25maWcpXG4gICAgICAgIHJlc3VsdC5wdXNoKGZvbGRDb25maWcub2YoY29uZmlnKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdpZGdldFRvRE9NKHZpZXcsIHByZXBhcmVkKSB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChmb2xkQ29uZmlnKTtcbiAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQodmlldy5wb3NBdERPTShldmVudC50YXJnZXQpKTtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCkgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBpZiAoY29uZi5wbGFjZWhvbGRlckRPTSlcbiAgICAgICAgcmV0dXJuIGNvbmYucGxhY2Vob2xkZXJET00odmlldywgb25jbGljaywgcHJlcGFyZWQpO1xuICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbmYucGxhY2Vob2xkZXJUZXh0O1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzdGF0ZS5waHJhc2UoXCJmb2xkZWQgY29kZVwiKSk7XG4gICAgZWxlbWVudC50aXRsZSA9IHN0YXRlLnBocmFzZShcInVuZm9sZFwiKTtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiY20tZm9sZFBsYWNlaG9sZGVyXCI7XG4gICAgZWxlbWVudC5vbmNsaWNrID0gb25jbGljaztcbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmNvbnN0IGZvbGRXaWRnZXQgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIG51bGwpOyB9XG4gICAgfSB9KTtcbmNsYXNzIFByZXBhcmVkRm9sZFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMudmFsdWUgPT0gb3RoZXIudmFsdWU7IH1cbiAgICB0b0RPTSh2aWV3KSB7IHJldHVybiB3aWRnZXRUb0RPTSh2aWV3LCB0aGlzLnZhbHVlKTsgfVxufVxuY29uc3QgZm9sZEd1dHRlckRlZmF1bHRzID0ge1xuICAgIG9wZW5UZXh0OiBcIuKMhFwiLFxuICAgIGNsb3NlZFRleHQ6IFwi4oC6XCIsXG4gICAgbWFya2VyRE9NOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9LFxuICAgIGZvbGRpbmdDaGFuZ2VkOiAoKSA9PiBmYWxzZVxufTtcbmNsYXNzIEZvbGRNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgb3Blbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY29uZmlnID09IG90aGVyLmNvbmZpZyAmJiB0aGlzLm9wZW4gPT0gb3RoZXIub3BlbjsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcmtlckRPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXJrZXJET00odGhpcy5vcGVuKTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHRoaXMub3BlbiA/IHRoaXMuY29uZmlnLm9wZW5UZXh0IDogdGhpcy5jb25maWcuY2xvc2VkVGV4dDtcbiAgICAgICAgc3Bhbi50aXRsZSA9IHZpZXcuc3RhdGUucGhyYXNlKHRoaXMub3BlbiA/IFwiRm9sZCBsaW5lXCIgOiBcIlVuZm9sZCBsaW5lXCIpO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCByZWdpc3RlcnMgYSBmb2xkIGd1dHRlciwgd2hpY2ggc2hvd3MgYVxuZm9sZCBzdGF0dXMgaW5kaWNhdG9yIGJlZm9yZSBmb2xkYWJsZSBsaW5lcyAod2hpY2ggY2FuIGJlIGNsaWNrZWRcbnRvIGZvbGQgb3IgdW5mb2xkIHRoZSBsaW5lKS5cbiovXG5mdW5jdGlvbiBmb2xkR3V0dGVyKGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGZ1bGxDb25maWcgPSB7IC4uLmZvbGRHdXR0ZXJEZWZhdWx0cywgLi4uY29uZmlnIH07XG4gICAgbGV0IGNhbkZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCB0cnVlKSwgY2FuVW5mb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgIGxldCBtYXJrZXJzID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB2aWV3LnZpZXdwb3J0LmZyb207XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGFuZ3VhZ2UpIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgIT0gdXBkYXRlLnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgc3ludGF4VHJlZSh1cGRhdGUuc3RhcnRTdGF0ZSkgIT0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgZnVsbENvbmZpZy5mb2xkaW5nQ2hhbmdlZCh1cGRhdGUpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZE1hcmtlcnModmlldykge1xuICAgICAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuVW5mb2xkXG4gICAgICAgICAgICAgICAgICAgIDogZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhbkZvbGQgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrKVxuICAgICAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChsaW5lLmZyb20sIGxpbmUuZnJvbSwgbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB7IGRvbUV2ZW50SGFuZGxlcnMgfSA9IGZ1bGxDb25maWc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFya2VycyxcbiAgICAgICAgZ3V0dGVyKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWZvbGRHdXR0ZXJcIixcbiAgICAgICAgICAgIG1hcmtlcnModmlldykgeyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4obWFya2VycykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrZXJzKSB8fCBSYW5nZVNldC5lbXB0eTsgfSxcbiAgICAgICAgICAgIGluaXRpYWxTcGFjZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4uZG9tRXZlbnRIYW5kbGVycyxcbiAgICAgICAgICAgICAgICBjbGljazogKHZpZXcsIGxpbmUsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21FdmVudEhhbmRsZXJzLmNsaWNrICYmIGRvbUV2ZW50SGFuZGxlcnMuY2xpY2sodmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBmb2xkRWZmZWN0Lm9mKHJhbmdlKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBjb2RlRm9sZGluZygpXG4gICAgXTtcbn1cbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2VlZVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNkZGRcIixcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiLjJlbVwiLFxuICAgICAgICBtYXJnaW46IFwiMCAxcHhcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkR3V0dGVyIHNwYW5cIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgMXB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9XG59KTtcblxuLyoqXG5BIGhpZ2hsaWdodCBzdHlsZSBhc3NvY2lhdGVzIENTUyBzdHlsZXMgd2l0aCBoaWdsaWdodGluZ1xuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykuXG4qL1xuY2xhc3MgSGlnaGxpZ2h0U3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0YWcgc3R5bGVzIHVzZWQgdG8gY3JlYXRlIHRoaXMgaGlnaGxpZ2h0IHN0eWxlLlxuICAgICovXG4gICAgc3BlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHNwZWNzO1xuICAgICAgICBsZXQgbW9kU3BlYztcbiAgICAgICAgZnVuY3Rpb24gZGVmKHNwZWMpIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgICAgICAobW9kU3BlYyB8fCAobW9kU3BlYyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtcIi5cIiArIGNsc10gPSBzcGVjO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGwgPSB0eXBlb2Ygb3B0aW9ucy5hbGwgPT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuYWxsIDogb3B0aW9ucy5hbGwgPyBkZWYob3B0aW9ucy5hbGwpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzY29wZU9wdCA9IG9wdGlvbnMuc2NvcGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZU9wdCBpbnN0YW5jZW9mIExhbmd1YWdlID8gKHR5cGUpID0+IHR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSBzY29wZU9wdC5kYXRhXG4gICAgICAgICAgICA6IHNjb3BlT3B0ID8gKHR5cGUpID0+IHR5cGUgPT0gc2NvcGVPcHQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB0YWdIaWdobGlnaHRlcihzcGVjcy5tYXAoc3R5bGUgPT4gKHtcbiAgICAgICAgICAgIHRhZzogc3R5bGUudGFnLFxuICAgICAgICAgICAgY2xhc3M6IHN0eWxlLmNsYXNzIHx8IGRlZihPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgeyB0YWc6IG51bGwgfSkpXG4gICAgICAgIH0pKSwge1xuICAgICAgICAgICAgYWxsLFxuICAgICAgICB9KS5zdHlsZTtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2RTcGVjID8gbmV3IFN0eWxlTW9kdWxlKG1vZFNwZWMpIDogbnVsbDtcbiAgICAgICAgdGhpcy50aGVtZVR5cGUgPSBvcHRpb25zLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgaGlnaGxpZ2h0ZXIgc3R5bGUgdGhhdCBhc3NvY2lhdGVzIHRoZSBnaXZlbiBzdHlsZXMgdG9cbiAgICB0aGUgZ2l2ZW4gdGFncy4gVGhlIHNwZWNzIG11c3QgYmUgb2JqZWN0cyB0aGF0IGhvbGQgYSBzdHlsZSB0YWdcbiAgICBvciBhcnJheSBvZiB0YWdzIGluIHRoZWlyIGB0YWdgIHByb3BlcnR5LCBhbmQgZWl0aGVyIGEgc2luZ2xlXG4gICAgYGNsYXNzYCBwcm9wZXJ0eSBwcm92aWRpbmcgYSBzdGF0aWMgQ1NTIGNsYXNzIChmb3IgaGlnaGxpZ2h0ZXJcbiAgICB0aGF0IHJlbHkgb24gZXh0ZXJuYWwgc3R5bGluZyksIG9yIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKS1zdHlsZVxuICAgIHNldCBvZiBDU1MgcHJvcGVydGllcyAod2hpY2ggZGVmaW5lIHRoZSBzdHlsaW5nIGZvciB0aG9zZSB0YWdzKS5cbiAgICBcbiAgICBUaGUgQ1NTIHJ1bGVzIGNyZWF0ZWQgZm9yIGEgaGlnaGxpZ2h0ZXIgd2lsbCBiZSBlbWl0dGVkIGluIHRoZVxuICAgIG9yZGVyIG9mIHRoZSBzcGVjJ3MgcHJvcGVydGllcy4gVGhhdCBtZWFucyB0aGF0IGZvciBlbGVtZW50cyB0aGF0XG4gICAgaGF2ZSBtdWx0aXBsZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLCBzdHlsZXMgZGVmaW5lZCBmdXJ0aGVyXG4gICAgZG93biBpbiB0aGUgbGlzdCB3aWxsIGhhdmUgYSBoaWdoZXIgQ1NTIHByZWNlZGVuY2UgdGhhbiBzdHlsZXNcbiAgICBkZWZpbmVkIGVhcmxpZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0U3R5bGUoc3BlY3MsIG9wdGlvbnMgfHwge30pO1xuICAgIH1cbn1cbmNvbnN0IGhpZ2hsaWdodGVyRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBmYWxsYmFja0hpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlcy5sZW5ndGggPyBbdmFsdWVzWzBdXSA6IG51bGw7IH1cbn0pO1xuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZXJzKHN0YXRlKSB7XG4gICAgbGV0IG1haW4gPSBzdGF0ZS5mYWNldChoaWdobGlnaHRlckZhY2V0KTtcbiAgICByZXR1cm4gbWFpbi5sZW5ndGggPyBtYWluIDogc3RhdGUuZmFjZXQoZmFsbGJhY2tIaWdobGlnaHRlcik7XG59XG4vKipcbldyYXAgYSBoaWdobGlnaHRlciBpbiBhbiBlZGl0b3IgZXh0ZW5zaW9uIHRoYXQgdXNlcyBpdCB0byBhcHBseVxuc3ludGF4IGhpZ2hsaWdodGluZyB0byB0aGUgZWRpdG9yIGNvbnRlbnQuXG5cbldoZW4gbXVsdGlwbGUgKG5vbi1mYWxsYmFjaykgc3R5bGVzIGFyZSBwcm92aWRlZCwgdGhlIHN0eWxpbmdcbmFwcGxpZWQgaXMgdGhlIHVuaW9uIG9mIHRoZSBjbGFzc2VzIHRoZXkgZW1pdC5cbiovXG5mdW5jdGlvbiBzeW50YXhIaWdobGlnaHRpbmcoaGlnaGxpZ2h0ZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW3RyZWVIaWdobGlnaHRlcl0sIHRoZW1lVHlwZTtcbiAgICBpZiAoaGlnaGxpZ2h0ZXIgaW5zdGFuY2VvZiBIaWdobGlnaHRTdHlsZSkge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0ZXIubW9kdWxlKVxuICAgICAgICAgICAgZXh0LnB1c2goRWRpdG9yVmlldy5zdHlsZU1vZHVsZS5vZihoaWdobGlnaHRlci5tb2R1bGUpKTtcbiAgICAgICAgdGhlbWVUeXBlID0gaGlnaGxpZ2h0ZXIudGhlbWVUeXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrKVxuICAgICAgICBleHQucHVzaChmYWxsYmFja0hpZ2hsaWdodGVyLm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgZWxzZSBpZiAodGhlbWVUeXBlKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0LmNvbXB1dGVOKFtFZGl0b3JWaWV3LmRhcmtUaGVtZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5mYWNldChFZGl0b3JWaWV3LmRhcmtUaGVtZSkgPT0gKHRoZW1lVHlwZSA9PSBcImRhcmtcIikgPyBbaGlnaGxpZ2h0ZXJdIDogW107XG4gICAgICAgIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQub2YoaGlnaGxpZ2h0ZXIpKTtcbiAgICByZXR1cm4gZXh0O1xufVxuLyoqXG5SZXR1cm5zIHRoZSBDU1MgY2xhc3NlcyAoaWYgYW55KSB0aGF0IHRoZSBoaWdobGlnaHRlcnMgYWN0aXZlIGluXG50aGUgc3RhdGUgd291bGQgYXNzaWduIHRvIHRoZSBnaXZlbiBzdHlsZVxuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykgYW5kXG4ob3B0aW9uYWwpIGxhbmd1YWdlXG5bc2NvcGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSGlnaGxpZ2h0U3R5bGVeZGVmaW5lXm9wdGlvbnMuc2NvcGUpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodGluZ0ZvcihzdGF0ZSwgdGFncywgc2NvcGUpIHtcbiAgICBsZXQgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHN0YXRlKTtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoaGlnaGxpZ2h0ZXJzKVxuICAgICAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZXIuc2NvcGUgfHwgc2NvcGUgJiYgaGlnaGxpZ2h0ZXIuc2NvcGUoc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNscyA9IGhpZ2hsaWdodGVyLnN0eWxlKHRhZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgY2xzIDogY2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIFRyZWVIaWdobGlnaHRlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLm1hcmtDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudHJlZSA9IHN5bnRheFRyZWUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh2aWV3LCBnZXRIaWdobGlnaHRlcnModmlldy5zdGF0ZSkpO1xuICAgICAgICB0aGlzLmRlY29yYXRlZFRvID0gdmlldy52aWV3cG9ydC50bztcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSwgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGxldCBzdHlsZUNoYW5nZSA9IGhpZ2hsaWdodGVycyAhPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXJ0U3RhdGUpO1xuICAgICAgICBsZXQgeyB2aWV3cG9ydCB9ID0gdXBkYXRlLnZpZXcsIGRlY29yYXRlZFRvTWFwcGVkID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMuZGVjb3JhdGVkVG8sIDEpO1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPCB2aWV3cG9ydC50byAmJiAhc3R5bGVDaGFuZ2UgJiYgdHJlZS50eXBlID09IHRoaXMudHJlZS50eXBlICYmIGRlY29yYXRlZFRvTWFwcGVkID49IHZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZWRUbyA9IGRlY29yYXRlZFRvTWFwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgc3R5bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odXBkYXRlLnZpZXcsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlZFRvID0gdmlld3BvcnQudG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGREZWNvKHZpZXcsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBpZiAoIWhpZ2hsaWdodGVycyB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRUcmVlKHRoaXMudHJlZSwgaGlnaGxpZ2h0ZXJzLCAoZnJvbSwgdG8sIHN0eWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHRoaXMubWFya0NhY2hlW3N0eWxlXSB8fCAodGhpcy5tYXJrQ2FjaGVbc3R5bGVdID0gRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IHN0eWxlIH0pKSk7XG4gICAgICAgICAgICB9LCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufVxuY29uc3QgdHJlZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ByZWMuaGlnaCgvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoVHJlZUhpZ2hsaWdodGVyLCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSkpO1xuLyoqXG5BIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlICh3b3JrcyB3ZWxsIHdpdGggbGlnaHQgdGhlbWVzKS5cbiovXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5tZXRhLFxuICAgICAgICBjb2xvcjogXCIjNDA0NzQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLFxuICAgICAgICBjb2xvcjogXCIjNzA4XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MuYXRvbSwgdGFncy5ib29sLCB0YWdzLnVybCwgdGFncy5jb250ZW50U2VwYXJhdG9yLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyMTlcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5saXRlcmFsLCB0YWdzLmluc2VydGVkXSxcbiAgICAgICAgY29sb3I6IFwiIzE2NFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnN0cmluZywgdGFncy5kZWxldGVkXSxcbiAgICAgICAgY29sb3I6IFwiI2ExMVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICAgICAgY29sb3I6IFwiI2U0MFwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBmXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMzBhXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MubmFtZXNwYWNlXSxcbiAgICAgICAgY29sb3I6IFwiIzA4NVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICBjb2xvcjogXCIjMTY3XCIgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyNTZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCxcbiAgICAgICAgY29sb3I6IFwiIzk0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IFwiI2YwMFwiIH1cbl0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMyOGM4MjUyXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNiYjU1NTU0NFwiIH1cbn0pO1xuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWZ0ZXJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgICBicmFja2V0czogRGVmYXVsdEJyYWNrZXRzLFxuICAgICAgICAgICAgbWF4U2NhbkRpc3RhbmNlOiBEZWZhdWx0U2NhbkRpc3QsXG4gICAgICAgICAgICByZW5kZXJNYXRjaDogZGVmYXVsdFJlbmRlck1hdGNoXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgbWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW1hdGNoaW5nQnJhY2tldFwiIH0pLCBub25tYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbm9ubWF0Y2hpbmdCcmFja2V0XCIgfSk7XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWF0Y2gobWF0Y2gpIHtcbiAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICBsZXQgbWFyayA9IG1hdGNoLm1hdGNoZWQgPyBtYXRjaGluZ01hcmsgOiBub25tYXRjaGluZ01hcms7XG4gICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLnN0YXJ0LmZyb20sIG1hdGNoLnN0YXJ0LnRvKSk7XG4gICAgaWYgKG1hdGNoLmVuZClcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLmVuZC5mcm9tLCBtYXRjaC5lbmQudG8pKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5jb25zdCBicmFja2V0TWF0Y2hpbmdTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gRGVjb3JhdGlvbi5ub25lOyB9LFxuICAgIHVwZGF0ZShkZWNvLCB0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgIXRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBkZWNvO1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGJyYWNrZXRNYXRjaGluZ0NvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRyLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAtMSwgY29uZmlnKVxuICAgICAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICB8fCAoY29uZmlnLmFmdGVyQ3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAxLCBjb25maWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmFuZ2UuaGVhZCA8IHRyLnN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xLCBjb25maWcpKSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zID0gZGVjb3JhdGlvbnMuY29uY2F0KGNvbmZpZy5yZW5kZXJNYXRjaChtYXRjaCwgdHIuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjb3JhdGlvbnMsIHRydWUpO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xuICAgIGJyYWNrZXRNYXRjaGluZ1N0YXRlLFxuICAgIGJhc2VUaGVtZVxuXTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXG5hcmUgaGlnaGxpZ2h0ZWQuIE9yLCB3aGVuIG5vIG1hdGNoaW5nIGJyYWNrZXQgaXMgZm91bmQsIGFub3RoZXJcbmhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG4qL1xuZnVuY3Rpb24gYnJhY2tldE1hdGNoaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFticmFja2V0TWF0Y2hpbmdDb25maWcub2YoY29uZmlnKSwgYnJhY2tldE1hdGNoaW5nVW5pcXVlXTtcbn1cbi8qKlxuV2hlbiBsYXJnZXIgc3ludGF4IG5vZGVzLCBzdWNoIGFzIEhUTUwgdGFncywgYXJlIG1hcmtlZCBhc1xub3BlbmluZy9jbG9zaW5nLCBpdCBjYW4gYmUgYSBiaXQgbWVzc3kgdG8gdHJlYXQgdGhlIHdob2xlIG5vZGUgYXNcbmEgbWF0Y2hhYmxlIGJyYWNrZXQuIFRoaXMgbm9kZSBwcm9wIGFsbG93cyB5b3UgdG8gZGVmaW5lLCBmb3Igc3VjaFxuYSBub2RlLCBhIOKAmGhhbmRsZeKAmeKAlHRoZSBwYXJ0IG9mIHRoZSBub2RlIHRoYXQgaXMgaGlnaGxpZ2h0ZWQsIGFuZFxudGhhdCB0aGUgY3Vyc29yIG11c3QgYmUgb24gdG8gYWN0aXZhdGUgaGlnaGxpZ2h0aW5nIGluIHRoZSBmaXJzdFxucGxhY2UuXG4qL1xuY29uc3QgYnJhY2tldE1hdGNoaW5nSGFuZGxlID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XG4gICAgbGV0IGJ5UHJvcCA9IG5vZGUucHJvcChkaXIgPCAwID8gTm9kZVByb3Aub3BlbmVkQnkgOiBOb2RlUHJvcC5jbG9zZWRCeSk7XG4gICAgaWYgKGJ5UHJvcClcbiAgICAgICAgcmV0dXJuIGJ5UHJvcDtcbiAgICBpZiAobm9kZS5uYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGJyYWNrZXRzLmluZGV4T2Yobm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgaW5kZXggJSAyID09IChkaXIgPCAwID8gMSA6IDApKVxuICAgICAgICAgICAgcmV0dXJuIFticmFja2V0c1tpbmRleCArIGRpcl1dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRIYW5kbGUobm9kZSkge1xuICAgIGxldCBoYXNIYW5kbGUgPSBub2RlLnR5cGUucHJvcChicmFja2V0TWF0Y2hpbmdIYW5kbGUpO1xuICAgIHJldHVybiBoYXNIYW5kbGUgPyBoYXNIYW5kbGUobm9kZS5ub2RlKSA6IG5vZGU7XG59XG4vKipcbkZpbmQgdGhlIG1hdGNoaW5nIGJyYWNrZXQgZm9yIHRoZSB0b2tlbiBhdCBgcG9zYCwgc2Nhbm5pbmdcbmRpcmVjdGlvbiBgZGlyYC4gT25seSB0aGUgYGJyYWNrZXRzYCBhbmQgYG1heFNjYW5EaXN0YW5jZWBcbnByb3BlcnRpZXMgYXJlIHVzZWQgZnJvbSBgY29uZmlnYCwgaWYgZ2l2ZW4uIFJldHVybnMgbnVsbCBpZiBub1xuYnJhY2tldCB3YXMgZm91bmQgYXQgYHBvc2AsIG9yIGEgbWF0Y2ggcmVzdWx0IG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY29uZmlnID0ge30pIHtcbiAgICBsZXQgbWF4U2NhbkRpc3RhbmNlID0gY29uZmlnLm1heFNjYW5EaXN0YW5jZSB8fCBEZWZhdWx0U2NhbkRpc3QsIGJyYWNrZXRzID0gY29uZmlnLmJyYWNrZXRzIHx8IERlZmF1bHRCcmFja2V0cztcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBub2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBkaXIpO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoaW5nTm9kZXMoY3VyLnR5cGUsIGRpciwgYnJhY2tldHMpO1xuICAgICAgICBpZiAobWF0Y2hlcyAmJiBjdXIuZnJvbSA8IGN1ci50bykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZSA9IGZpbmRIYW5kbGUoY3VyKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgKGRpciA+IDAgPyBwb3MgPj0gaGFuZGxlLmZyb20gJiYgcG9zIDwgaGFuZGxlLnRvIDogcG9zID4gaGFuZGxlLmZyb20gJiYgcG9zIDw9IGhhbmRsZS50bykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTWFya2VkQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjdXIsIGhhbmRsZSwgbWF0Y2hlcywgYnJhY2tldHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCBub2RlLnR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpO1xufVxuZnVuY3Rpb24gbWF0Y2hNYXJrZWRCcmFja2V0cyhfc3RhdGUsIF9wb3MsIGRpciwgdG9rZW4sIGhhbmRsZSwgbWF0Y2hpbmcsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHBhcmVudCA9IHRva2VuLnBhcmVudCwgZmlyc3RUb2tlbiA9IHsgZnJvbTogaGFuZGxlLmZyb20sIHRvOiBoYW5kbGUudG8gfTtcbiAgICBsZXQgZGVwdGggPSAwLCBjdXJzb3IgPSBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuY3Vyc29yKCk7XG4gICAgaWYgKGN1cnNvciAmJiAoZGlyIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZSh0b2tlbi5mcm9tKSA6IGN1cnNvci5jaGlsZEFmdGVyKHRva2VuLnRvKSkpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChkaXIgPCAwID8gY3Vyc29yLnRvIDw9IHRva2VuLmZyb20gOiBjdXJzb3IuZnJvbSA+PSB0b2tlbi50bykge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwICYmIG1hdGNoaW5nLmluZGV4T2YoY3Vyc29yLnR5cGUubmFtZSkgPiAtMSAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgZW5kOiBlbmRIYW5kbGUgPyB7IGZyb206IGVuZEhhbmRsZS5mcm9tLCB0bzogZW5kSGFuZGxlLnRvIH0gOiB1bmRlZmluZWQsIG1hdGNoZWQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgLWRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZEhhbmRsZSAmJiBlbmRIYW5kbGUuZnJvbSA8IGVuZEhhbmRsZS50byA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlyIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgdG9rZW5UeXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHN0YXJ0Q2ggPSBkaXIgPCAwID8gc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSA6IHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSk7XG4gICAgbGV0IGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKHN0YXJ0Q2gpO1xuICAgIGlmIChicmFja2V0IDwgMCB8fCAoYnJhY2tldCAlIDIgPT0gMCkgIT0gKGRpciA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhcnRUb2tlbiA9IHsgZnJvbTogZGlyIDwgMCA/IHBvcyAtIDEgOiBwb3MsIHRvOiBkaXIgPiAwID8gcG9zICsgMSA6IHBvcyB9O1xuICAgIGxldCBpdGVyID0gc3RhdGUuZG9jLml0ZXJSYW5nZShwb3MsIGRpciA+IDAgPyBzdGF0ZS5kb2MubGVuZ3RoIDogMCksIGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBkaXN0YW5jZSA9IDA7ICEoaXRlci5uZXh0KCkpLmRvbmUgJiYgZGlzdGFuY2UgPD0gbWF4U2NhbkRpc3RhbmNlOykge1xuICAgICAgICBsZXQgdGV4dCA9IGl0ZXIudmFsdWU7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBiYXNlUG9zID0gcG9zICsgZGlzdGFuY2UgKiBkaXI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGRpciA+IDAgPyAwIDogdGV4dC5sZW5ndGggLSAxLCBlbmQgPSBkaXIgPiAwID8gdGV4dC5sZW5ndGggOiAtMTsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gYnJhY2tldHMuaW5kZXhPZih0ZXh0W3Bvc10pO1xuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCB8fCB0cmVlLnJlc29sdmVJbm5lcihiYXNlUG9zICsgcG9zLCAxKS50eXBlICE9IHRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoZm91bmQgJSAyID09IDApID09IChkaXIgPiAwKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PSAxKSB7IC8vIENsb3NpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnRUb2tlbiwgZW5kOiB7IGZyb206IGJhc2VQb3MgKyBwb3MsIHRvOiBiYXNlUG9zICsgcG9zICsgMSB9LCBtYXRjaGVkOiAoZm91bmQgPj4gMSkgPT0gKGJyYWNrZXQgPj4gMSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuZG9uZSA/IHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH0gOiBudWxsO1xufVxuXG4vLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbi8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG5mdW5jdGlvbiBjb3VudENvbChzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCA9IDAsIHN0YXJ0VmFsdWUgPSAwKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgICAgaWYgKGVuZCA9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IHN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBuID0gc3RhcnRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KVxuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbisrO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRW5jYXBzdWxhdGVzIGEgc2luZ2xlIGxpbmUgb2YgaW5wdXQuIEdpdmVuIHRvIHN0cmVhbSBzeW50YXggY29kZSxcbndoaWNoIHVzZXMgaXQgdG8gdG9rZW5pemUgdGhlIGNvbnRlbnQuXG4qL1xuY2xhc3MgU3RyaW5nU3RyZWFtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdHJlYW0uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGluZS5cbiAgICAqL1xuICAgIHN0cmluZywgdGFiU2l6ZSwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgaW5kZW50IHVuaXQgc2l6ZS5cbiAgICAqL1xuICAgIGluZGVudFVuaXQsIG92ZXJyaWRlSW5kZW50KSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplO1xuICAgICAgICB0aGlzLmluZGVudFVuaXQgPSBpbmRlbnRVbml0O1xuICAgICAgICB0aGlzLm92ZXJyaWRlSW5kZW50ID0gb3ZlcnJpZGVJbmRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbGluZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHRva2VuLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZW9sKCkgeyByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc29sKCkgeyByZXR1cm4gdGhpcy5wb3MgPT0gMDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbmV4dCBjb2RlIHVuaXQgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIG9yIHVuZGVmaW5lZFxuICAgIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBwZWVrKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWQ7IH1cbiAgICAvKipcbiAgICBSZWFkIHRoZSBuZXh0IGNvZGUgdW5pdCBhbmQgYWR2YW5jZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIG5leHQgY2hhcmFjdGVyIGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZywgcmVndWxhclxuICAgIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZS4gQ29uc3VtZSBhbmQgcmV0dXJuIGl0IGlmIGl0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBlYXQobWF0Y2gpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IG9rO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBvayA9IGNoID09IG1hdGNoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvayA9IGNoICYmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIG1hdGNoaW5nIGNoYXJhY3RlcnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gc3RyaW5nLFxuICAgIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlIGZ1bmN0aW9uLiBSZXR1cm4gdHJ1ZSBpZiBhbnlcbiAgICBjaGFyYWN0ZXJzIHdlcmUgY29uc3VtZWQuXG4gICAgKi9cbiAgICBlYXRXaGlsZShtYXRjaCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdW1lIHdoaXRlc3BhY2UgYWhlYWQgb2YgYHRoaXMucG9zYC4gUmV0dXJuIHRydWUgaWYgYW55IHdhc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgZWF0U3BhY2UoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSlcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG9FbmQoKSB7IHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byBkaXJlY3RseSBiZWZvcmUgdGhlIGdpdmVuIGNoYXJhY3RlciwgaWYgZm91bmQgb24gdGhlXG4gICAgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvKGNoKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZm91bmQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGJhY2sgYG5gIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBiYWNrVXAobikgeyB0aGlzLnBvcyAtPSBuOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIGNvbHVtbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENvbHVtblBvcyA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2wodGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIGluZGVudGF0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm92ZXJyaWRlSW5kZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3VudENvbCh0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIGlucHV0IGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAod2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggYSBgXmApLiBSZXR1cm4gdHJ1ZSBvciB0aGUgcmVnZXhwIG1hdGNoXG4gICAgaWYgaXQgbWF0Y2hlcy5cbiAgICBcbiAgICBVbmxlc3MgYGNvbnN1bWVgIGlzIHNldCB0byBgZmFsc2VgLCB0aGlzIHdpbGwgbW92ZSBgdGhpcy5wb3NgXG4gICAgcGFzdCB0aGUgbWF0Y2hlZCB0ZXh0LlxuICAgIFxuICAgIFdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYGNhc2VJbnNlbnNpdGl2ZWAgY2FuIGJlIHNldCB0byB0cnVlIHRvXG4gICAgbWFrZSB0aGUgbWF0Y2ggY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNhc2VkID0gKHN0cikgPT4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7XG4gICAgICAgICAgICBsZXQgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgKi9cbiAgICBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpOyB9XG59XG5cbmZ1bmN0aW9uIGZ1bGxQYXJzZXIoc3BlYykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHNwZWMubmFtZSB8fCBcIlwiLFxuICAgICAgICB0b2tlbjogc3BlYy50b2tlbixcbiAgICAgICAgYmxhbmtMaW5lOiBzcGVjLmJsYW5rTGluZSB8fCAoKCkgPT4geyB9KSxcbiAgICAgICAgc3RhcnRTdGF0ZTogc3BlYy5zdGFydFN0YXRlIHx8ICgoKSA9PiB0cnVlKSxcbiAgICAgICAgY29weVN0YXRlOiBzcGVjLmNvcHlTdGF0ZSB8fCBkZWZhdWx0Q29weVN0YXRlLFxuICAgICAgICBpbmRlbnQ6IHNwZWMuaW5kZW50IHx8ICgoKSA9PiBudWxsKSxcbiAgICAgICAgbGFuZ3VhZ2VEYXRhOiBzcGVjLmxhbmd1YWdlRGF0YSB8fCB7fSxcbiAgICAgICAgdG9rZW5UYWJsZTogc3BlYy50b2tlblRhYmxlIHx8IG5vVG9rZW5zLFxuICAgICAgICBtZXJnZVRva2Vuczogc3BlYy5tZXJnZVRva2VucyAhPT0gZmFsc2VcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENvcHlTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGxldCBuZXdTdGF0ZSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbCA9IHN0YXRlW3Byb3BdO1xuICAgICAgICBuZXdTdGF0ZVtwcm9wXSA9ICh2YWwgaW5zdGFuY2VvZiBBcnJheSA/IHZhbC5zbGljZSgpIDogdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuY29uc3QgSW5kZW50ZWRGcm9tID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vKipcbkEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBjbGFzcyBiYXNlZCBvbiBhIENvZGVNaXJyb3JcbjUtc3R5bGUgW3N0cmVhbWluZyBwYXJzZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuU3RyZWFtUGFyc2VyKS5cbiovXG5jbGFzcyBTdHJlYW1MYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHBhcnNlci5sYW5ndWFnZURhdGEpO1xuICAgICAgICBsZXQgcCA9IGZ1bGxQYXJzZXIocGFyc2VyKSwgc2VsZjtcbiAgICAgICAgbGV0IGltcGwgPSBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZShzZWxmLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihkYXRhLCBpbXBsLCBbXSwgcGFyc2VyLm5hbWUpO1xuICAgICAgICB0aGlzLnRvcE5vZGUgPSBkb2NJRChkYXRhLCB0aGlzKTtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyID0gcDtcbiAgICAgICAgdGhpcy5zdGF0ZUFmdGVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy50b2tlblRhYmxlID0gcGFyc2VyLnRva2VuVGFibGUgPyBuZXcgVG9rZW5UYWJsZShwLnRva2VuVGFibGUpIDogZGVmYXVsdFRva2VuVGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0cmVhbSBsYW5ndWFnZS5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykgeyByZXR1cm4gbmV3IFN0cmVhbUxhbmd1YWdlKHNwZWMpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXRJbmRlbnQoY3gpIHtcbiAgICAgICAgbGV0IGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB7IG92ZXJyaWRlSW5kZW50YXRpb24gfSA9IGN4Lm9wdGlvbnM7XG4gICAgICAgIGlmIChvdmVycmlkZUluZGVudGF0aW9uKSB7XG4gICAgICAgICAgICBmcm9tID0gSW5kZW50ZWRGcm9tLmdldChjeC5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZnJvbSAhPSBudWxsICYmIGZyb20gPCBjeC5wb3MgLSAxZTQpXG4gICAgICAgICAgICAgICAgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBmaW5kU3RhdGUodGhpcywgY3gubm9kZS50cmVlLCBjeC5ub2RlLmZyb20sIGN4Lm5vZGUuZnJvbSwgZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogY3gucG9zKSwgc3RhdGVQb3MsIHN0YXRlO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IHN0YXJ0LnBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoY3gudW5pdCk7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IGN4Lm5vZGUuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3gucG9zIC0gc3RhdGVQb3MgPiAxMDAwMCAvKiBDLk1heEluZGVudFNjYW5EaXN0ICovKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlIChzdGF0ZVBvcyA8IGN4LnBvcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBjeC5zdGF0ZS5kb2MubGluZUF0KHN0YXRlUG9zKSwgZW5kID0gTWF0aC5taW4oY3gucG9zLCBsaW5lLnRvKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnRhdGlvbiA9IG92ZXJyaWRlSW5kZW50YXRpb24gPyBvdmVycmlkZUluZGVudGF0aW9uKGxpbmUuZnJvbSkgOiAtMTtcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGN4LnN0YXRlLnRhYlNpemUsIGN4LnVuaXQsIGluZGVudGF0aW9uIDwgMCA/IHVuZGVmaW5lZCA6IGluZGVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyLmJsYW5rTGluZShzdGF0ZSwgY3gudW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09IGN4LnBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXRlUG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmUgPSBjeC5saW5lQXQoY3gucG9zKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24gJiYgZnJvbSA9PSBudWxsKVxuICAgICAgICAgICAgSW5kZW50ZWRGcm9tLnNldChjeC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtUGFyc2VyLmluZGVudChzdGF0ZSwgL15cXHMqKC4qKS8uZXhlYyhsaW5lLnRleHQpWzFdLCBjeCk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmZ1bmN0aW9uIGZpbmRTdGF0ZShsYW5nLCB0cmVlLCBvZmYsIHN0YXJ0UG9zLCBiZWZvcmUpIHtcbiAgICBsZXQgc3RhdGUgPSBvZmYgPj0gc3RhcnRQb3MgJiYgb2ZmICsgdHJlZS5sZW5ndGggPD0gYmVmb3JlICYmIHRyZWUucHJvcChsYW5nLnN0YXRlQWZ0ZXIpO1xuICAgIGlmIChzdGF0ZSlcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZShzdGF0ZSksIHBvczogb2ZmICsgdHJlZS5sZW5ndGggfTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBwb3MgPSBvZmYgKyB0cmVlLnBvc2l0aW9uc1tpXTtcbiAgICAgICAgbGV0IGZvdW5kID0gY2hpbGQgaW5zdGFuY2VvZiBUcmVlICYmIHBvcyA8IGJlZm9yZSAmJiBmaW5kU3RhdGUobGFuZywgY2hpbGQsIHBvcywgc3RhcnRQb3MsIGJlZm9yZSk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjdXRUcmVlKGxhbmcsIHRyZWUsIGZyb20sIHRvLCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlICYmIGZyb20gPD0gMCAmJiB0byA+PSB0cmVlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgaWYgKCFpbnNpZGUgJiYgZnJvbSA9PSAwICYmIHRyZWUudHlwZSA9PSBsYW5nLnRvcE5vZGUpXG4gICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHBvcyA9IHRyZWUucG9zaXRpb25zW2ldLCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIGlubmVyO1xuICAgICAgICBpZiAocG9zIDwgdG8gJiYgY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICBpZiAoIShpbm5lciA9IGN1dFRyZWUobGFuZywgY2hpbGQsIGZyb20gLSBwb3MsIHRvIC0gcG9zLCBpbnNpZGUpKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiAhaW5zaWRlID8gaW5uZXJcbiAgICAgICAgICAgICAgICA6IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbi5zbGljZSgwLCBpKS5jb25jYXQoaW5uZXIpLCB0cmVlLnBvc2l0aW9ucy5zbGljZSgwLCBpICsgMSksIHBvcyArIGlubmVyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIHN0YXJ0UG9zLCBlbmRQb3MsIGVkaXRvclN0YXRlKSB7XG4gICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBmLmZyb20gKyAoZi5vcGVuU3RhcnQgPyAyNSA6IDApLCB0byA9IGYudG8gLSAoZi5vcGVuRW5kID8gMjUgOiAwKTtcbiAgICAgICAgbGV0IGZvdW5kID0gZnJvbSA8PSBzdGFydFBvcyAmJiB0byA+IHN0YXJ0UG9zICYmIGZpbmRTdGF0ZShsYW5nLCBmLnRyZWUsIDAgLSBmLm9mZnNldCwgc3RhcnRQb3MsIHRvKSwgdHJlZTtcbiAgICAgICAgaWYgKGZvdW5kICYmIGZvdW5kLnBvcyA8PSBlbmRQb3MgJiYgKHRyZWUgPSBjdXRUcmVlKGxhbmcsIGYudHJlZSwgc3RhcnRQb3MgKyBmLm9mZnNldCwgZm91bmQucG9zICsgZi5vZmZzZXQsIGZhbHNlKSkpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogZm91bmQuc3RhdGUsIHRyZWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZWRpdG9yU3RhdGUgPyBnZXRJbmRlbnRVbml0KGVkaXRvclN0YXRlKSA6IDQpLCB0cmVlOiBUcmVlLmVtcHR5IH07XG59XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IobGFuZywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubGFuZyA9IGxhbmc7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUmV1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCksIGZyb20gPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgbGV0IHsgc3RhdGUsIHRyZWUgfSA9IGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgZnJvbSwgdGhpcy50bywgY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnN0YXRlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRoaXMuY2h1bmtTdGFydCA9IGZyb20gKyB0cmVlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRyZWUucG9zaXRpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA8IGNvbnRleHQudmlld3BvcnQuZnJvbSAtIDEwMDAwMCAvKiBDLk1heERpc3RhbmNlQmVmb3JlVmlld3BvcnQgKi8gJiZcbiAgICAgICAgICAgIHJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDw9IGNvbnRleHQudmlld3BvcnQuZnJvbSAmJiByLnRvID49IGNvbnRleHQudmlld3BvcnQuZnJvbSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSk7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgY29udGV4dC52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gY29udGV4dC52aWV3cG9ydC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCk7XG4gICAgICAgIGxldCBwYXJzZUVuZCA9IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgPyB0aGlzLnRvIDogTWF0aC5taW4odGhpcy50bywgdGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocGFyc2VFbmQsIHRoaXMuY2h1bmtTdGFydCArIDUxMiAvKiBDLkNodW5rU2l6ZSAqLyk7XG4gICAgICAgIGlmIChjb250ZXh0KVxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBjb250ZXh0LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VkUG9zIDwgZW5kKVxuICAgICAgICAgICAgdGhpcy5wYXJzZUxpbmUoY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zID49IHBhcnNlRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zID49IGNvbnRleHQudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBwYXJzZUVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHBvcyk7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dC5saW5lQ2h1bmtzKSB7XG4gICAgICAgICAgICBsZXQgZW9sID0gY2h1bmsuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChlb2wgPiAtMSlcbiAgICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGVvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgY2h1bmsgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3MgKyBjaHVuay5sZW5ndGggPD0gdGhpcy50byA/IGNodW5rIDogY2h1bmsuc2xpY2UoMCwgdGhpcy50byAtIHBvcyk7XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMucGFyc2VkUG9zLCBsaW5lID0gdGhpcy5saW5lQWZ0ZXIoZnJvbSksIGVuZCA9IGZyb20gKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7Oykge1xuICAgICAgICAgICAgbGV0IHJhbmdlRW5kID0gdGhpcy5yYW5nZXNbaW5kZXhdLnRvO1xuICAgICAgICAgICAgaWYgKHJhbmdlRW5kID49IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHJhbmdlRW5kIC0gKGVuZCAtIGxpbmUubGVuZ3RoKSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCByYW5nZVN0YXJ0ID0gdGhpcy5yYW5nZXNbaW5kZXhdLmZyb207XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxpbmVBZnRlcihyYW5nZVN0YXJ0KTtcbiAgICAgICAgICAgIGxpbmUgKz0gYWZ0ZXI7XG4gICAgICAgICAgICBlbmQgPSByYW5nZVN0YXJ0ICsgYWZ0ZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGVuZCB9O1xuICAgIH1cbiAgICBza2lwR2Fwc1RvKHBvcywgb2Zmc2V0LCBzaWRlKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvLCBvZmZQb3MgPSBwb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2lkZSA+IDAgPyBlbmQgPiBvZmZQb3MgOiBlbmQgPj0gb2ZmUG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdLmZyb207XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgbW92ZVJhbmdlSW5kZXgoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvIDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXgrKztcbiAgICB9XG4gICAgZW1pdFRva2VuKGlkLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBzaXplID0gNDtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2tpcEdhcHNUbyhmcm9tLCBvZmZzZXQsIDEpO1xuICAgICAgICAgICAgZnJvbSArPSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgbGVuMCA9IHRoaXMuY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKHRvLCBvZmZzZXQsIC0xKTtcbiAgICAgICAgICAgIHRvICs9IG9mZnNldDtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaHVuay5sZW5ndGggLSBsZW4wO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jaHVuay5sZW5ndGggLSA0O1xuICAgICAgICBpZiAodGhpcy5sYW5nLnN0cmVhbVBhcnNlci5tZXJnZVRva2VucyAmJiBzaXplID09IDQgJiYgbGFzdCA+PSAwICYmXG4gICAgICAgICAgICB0aGlzLmNodW5rW2xhc3RdID09IGlkICYmIHRoaXMuY2h1bmtbbGFzdCArIDJdID09IGZyb20pXG4gICAgICAgICAgICB0aGlzLmNodW5rW2xhc3QgKyAyXSA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNodW5rLnB1c2goaWQsIGZyb20sIHRvLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgcGFyc2VMaW5lKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHsgbGluZSwgZW5kIH0gPSB0aGlzLm5leHRMaW5lKCksIG9mZnNldCA9IDAsIHsgc3RyZWFtUGFyc2VyIH0gPSB0aGlzLmxhbmc7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUsIGNvbnRleHQgPyBjb250ZXh0LnN0YXRlLnRhYlNpemUgOiA0LCBjb250ZXh0ID8gZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSA6IDIpO1xuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICBzdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHRoaXMuc3RhdGUsIHN0cmVhbS5pbmRlbnRVbml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gcmVhZFRva2VuKHN0cmVhbVBhcnNlci50b2tlbiwgc3RyZWFtLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZW1pdFRva2VuKHRoaXMubGFuZy50b2tlblRhYmxlLnJlc29sdmUodG9rZW4pLCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5zdGFydCwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0ucG9zLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uc3RhcnQgPiAxMDAwMCAvKiBDLk1heExpbmVMZW5ndGggKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gZW5kO1xuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA8IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcysrO1xuICAgIH1cbiAgICBmaW5pc2hDaHVuaygpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBUcmVlLmJ1aWxkKHtcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5jaHVuayxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMucGFyc2VkUG9zIC0gdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiAwLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiA1MTIgLyogQy5DaHVua1NpemUgKi8sXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMuY2h1bmtSZXVzZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRyZWUgPSBuZXcgVHJlZSh0cmVlLnR5cGUsIHRyZWUuY2hpbGRyZW4sIHRyZWUucG9zaXRpb25zLCB0cmVlLmxlbmd0aCwgW1t0aGlzLmxhbmcuc3RhdGVBZnRlciwgdGhpcy5sYW5nLnN0cmVhbVBhcnNlci5jb3B5U3RhdGUodGhpcy5zdGF0ZSldXSk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZSk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQgLSB0aGlzLnJhbmdlc1swXS5mcm9tKTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUmV1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSB0aGlzLnBhcnNlZFBvcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy5sYW5nLnRvcE5vZGUsIHRoaXMuY2h1bmtzLCB0aGlzLmNodW5rUG9zLCB0aGlzLnBhcnNlZFBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20pLmJhbGFuY2UoKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFkVG9rZW4odG9rZW4sIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIHBhcnNlciBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO1xufVxuY29uc3Qgbm9Ub2tlbnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IHR5cGVBcnJheSA9IFtOb2RlVHlwZS5ub25lXTtcbmNvbnN0IG5vZGVTZXQgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVTZXQodHlwZUFycmF5KTtcbmNvbnN0IHdhcm5lZCA9IFtdO1xuLy8gQ2FjaGUgb2Ygbm9kZSB0eXBlcyBieSBuYW1lIGFuZCB0YWdzXG5jb25zdCBieVRhZyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgZGVmYXVsdFRhYmxlID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mb3IgKGxldCBbbGVnYWN5TmFtZSwgbmFtZV0gb2YgW1xuICAgIFtcInZhcmlhYmxlXCIsIFwidmFyaWFibGVOYW1lXCJdLFxuICAgIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiXSxcbiAgICBbXCJzdHJpbmctMlwiLCBcInN0cmluZy5zcGVjaWFsXCJdLFxuICAgIFtcImRlZlwiLCBcInZhcmlhYmxlTmFtZS5kZWZpbml0aW9uXCJdLFxuICAgIFtcInRhZ1wiLCBcInRhZ05hbWVcIl0sXG4gICAgW1wiYXR0cmlidXRlXCIsIFwiYXR0cmlidXRlTmFtZVwiXSxcbiAgICBbXCJ0eXBlXCIsIFwidHlwZU5hbWVcIl0sXG4gICAgW1wiYnVpbHRpblwiLCBcInZhcmlhYmxlTmFtZS5zdGFuZGFyZFwiXSxcbiAgICBbXCJxdWFsaWZpZXJcIiwgXCJtb2RpZmllclwiXSxcbiAgICBbXCJlcnJvclwiLCBcImludmFsaWRcIl0sXG4gICAgW1wiaGVhZGVyXCIsIFwiaGVhZGluZ1wiXSxcbiAgICBbXCJwcm9wZXJ0eVwiLCBcInByb3BlcnR5TmFtZVwiXVxuXSlcbiAgICBkZWZhdWx0VGFibGVbbGVnYWN5TmFtZV0gPSAvKkBfX1BVUkVfXyovY3JlYXRlVG9rZW5UeXBlKG5vVG9rZW5zLCBuYW1lKTtcbmNsYXNzIFRva2VuVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGV4dHJhKSB7XG4gICAgICAgIHRoaXMuZXh0cmEgPSBleHRyYTtcbiAgICAgICAgdGhpcy50YWJsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgZGVmYXVsdFRhYmxlKTtcbiAgICB9XG4gICAgcmVzb2x2ZSh0YWcpIHtcbiAgICAgICAgcmV0dXJuICF0YWcgPyAwIDogdGhpcy50YWJsZVt0YWddIHx8ICh0aGlzLnRhYmxlW3RhZ10gPSBjcmVhdGVUb2tlblR5cGUodGhpcy5leHRyYSwgdGFnKSk7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdFRva2VuVGFibGUgPSAvKkBfX1BVUkVfXyovbmV3IFRva2VuVGFibGUobm9Ub2tlbnMpO1xuZnVuY3Rpb24gd2FybkZvclBhcnQocGFydCwgbXNnKSB7XG4gICAgaWYgKHdhcm5lZC5pbmRleE9mKHBhcnQpID4gLTEpXG4gICAgICAgIHJldHVybjtcbiAgICB3YXJuZWQucHVzaChwYXJ0KTtcbiAgICBjb25zb2xlLndhcm4obXNnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuVHlwZShleHRyYSwgdGFnU3RyKSB7XG4gICAgbGV0IHRhZ3MkMSA9IFtdO1xuICAgIGZvciAobGV0IG5hbWUgb2YgdGFnU3RyLnNwbGl0KFwiIFwiKSkge1xuICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBuYW1lLnNwbGl0KFwiLlwiKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gKGV4dHJhW3BhcnRdIHx8IHRhZ3NbcGFydF0pO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBVbmtub3duIGhpZ2hsaWdodGluZyB0YWcgJHtwYXJ0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgTW9kaWZpZXIgJHtwYXJ0fSB1c2VkIGF0IHN0YXJ0IG9mIHRhZ2ApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBmb3VuZC5tYXAodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFRhZyAke3BhcnR9IHVzZWQgYXMgbW9kaWZpZXJgKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdGFnIG9mIGZvdW5kKVxuICAgICAgICAgICAgdGFncyQxLnB1c2godGFnKTtcbiAgICB9XG4gICAgaWYgKCF0YWdzJDEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBsZXQgbmFtZSA9IHRhZ1N0ci5yZXBsYWNlKC8gL2csIFwiX1wiKSwga2V5ID0gbmFtZSArIFwiIFwiICsgdGFncyQxLm1hcCh0ID0+IHQuaWQpO1xuICAgIGxldCBrbm93biA9IGJ5VGFnW2tleV07XG4gICAgaWYgKGtub3duKVxuICAgICAgICByZXR1cm4ga25vd24uaWQ7XG4gICAgbGV0IHR5cGUgPSBieVRhZ1trZXldID0gTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgaWQ6IHR5cGVBcnJheS5sZW5ndGgsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByb3BzOiBbc3R5bGVUYWdzKHsgW25hbWVdOiB0YWdzJDEgfSldXG4gICAgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGUuaWQ7XG59XG5mdW5jdGlvbiBkb2NJRChkYXRhLCBsYW5nKSB7XG4gICAgbGV0IHR5cGUgPSBOb2RlVHlwZS5kZWZpbmUoeyBpZDogdHlwZUFycmF5Lmxlbmd0aCwgbmFtZTogXCJEb2N1bWVudFwiLCBwcm9wczogW1xuICAgICAgICAgICAgbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoKCkgPT4gZGF0YSksXG4gICAgICAgICAgICBpbmRlbnROb2RlUHJvcC5hZGQoKCkgPT4gY3ggPT4gbGFuZy5nZXRJbmRlbnQoY3gpKVxuICAgICAgICBdLCB0b3A6IHRydWUgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRm9yTGluZShsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUubGVuZ3RoIDw9IDQwOTYgJiYgL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLy50ZXN0KGxpbmUpO1xufVxuZnVuY3Rpb24gdGV4dEhhc1JUTCh0ZXh0KSB7XG4gICAgZm9yIChsZXQgaSA9IHRleHQuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspXG4gICAgICAgIGlmIChidWlsZEZvckxpbmUoaS52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGFuZ2VBZGRzUlRMKGNoYW5nZSkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGNoYW5nZS5pdGVyQ2hhbmdlcygoZkEsIHRBLCBmQiwgdEIsIGlucykgPT4ge1xuICAgICAgICBpZiAoIWFkZGVkICYmIHRleHRIYXNSVEwoaW5zKSlcbiAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWRkZWQ7XG59XG5jb25zdCBhbHdheXNJc29sYXRlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpIH0pO1xuLyoqXG5NYWtlIHN1cmUgbm9kZXNcblttYXJrZWRdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1vbi5Ob2RlUHJvcF5pc29sYXRlKVxuYXMgaXNvbGF0aW5nIGZvciBiaWRpcmVjdGlvbmFsIHRleHQgYXJlIHJlbmRlcmVkIGluIGEgd2F5IHRoYXRcbmlzb2xhdGVzIHRoZW0gZnJvbSB0aGUgc3Vycm91bmRpbmcgdGV4dC5cbiovXG5mdW5jdGlvbiBiaWRpSXNvbGF0ZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGV4dGVuc2lvbnMgPSBbaXNvbGF0ZU1hcmtzXTtcbiAgICBpZiAob3B0aW9ucy5hbHdheXNJc29sYXRlKVxuICAgICAgICBleHRlbnNpb25zLnB1c2goYWx3YXlzSXNvbGF0ZS5vZih0cnVlKSk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG59XG5jb25zdCBpc29sYXRlTWFya3MgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5hbHdheXMgPSB2aWV3LnN0YXRlLmZhY2V0KGFsd2F5c0lzb2xhdGUpIHx8XG4gICAgICAgICAgICB2aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiB8fFxuICAgICAgICAgICAgdmlldy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNSVEwgPSAhdGhpcy5hbHdheXMgJiYgdGV4dEhhc1JUTCh2aWV3LnN0YXRlLmRvYyk7XG4gICAgICAgIHRoaXMudHJlZSA9IHN5bnRheFRyZWUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmFsd2F5cyB8fCB0aGlzLmhhc1JUTCA/IGJ1aWxkRGVjbyh2aWV3LCB0aGlzLnRyZWUsIHRoaXMuYWx3YXlzKSA6IERlY29yYXRpb24ubm9uZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgYWx3YXlzID0gdXBkYXRlLnN0YXRlLmZhY2V0KGFsd2F5c0lzb2xhdGUpIHx8XG4gICAgICAgICAgICB1cGRhdGUudmlldy50ZXh0RGlyZWN0aW9uICE9IERpcmVjdGlvbi5MVFIgfHxcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKCFhbHdheXMgJiYgIXRoaXMuaGFzUlRMICYmIGNoYW5nZUFkZHNSVEwodXBkYXRlLmNoYW5nZXMpKVxuICAgICAgICAgICAgdGhpcy5oYXNSVEwgPSB0cnVlO1xuICAgICAgICBpZiAoIWFsd2F5cyAmJiAhdGhpcy5oYXNSVEwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAoYWx3YXlzICE9IHRoaXMuYWx3YXlzIHx8IHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmFsd2F5cyA9IGFsd2F5cztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBidWlsZERlY28odXBkYXRlLnZpZXcsIHRyZWUsIGFsd2F5cyk7XG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IHtcbiAgICAgICAgZnVuY3Rpb24gYWNjZXNzKHZpZXcpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY29yYXRpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtFZGl0b3JWaWV3Lm91dGVyRGVjb3JhdGlvbnMub2YoYWNjZXNzKSxcbiAgICAgICAgICAgIFByZWMubG93ZXN0KEVkaXRvclZpZXcuYmlkaUlzb2xhdGVkUmFuZ2VzLm9mKGFjY2VzcykpXTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGJ1aWxkRGVjbyh2aWV3LCB0cmVlLCBhbHdheXMpIHtcbiAgICBsZXQgZGVjbyA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICBsZXQgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzO1xuICAgIGlmICghYWx3YXlzKVxuICAgICAgICByYW5nZXMgPSBjbGlwUlRMTGluZXMocmFuZ2VzLCB2aWV3LnN0YXRlLmRvYyk7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICB0cmVlLml0ZXJhdGUoe1xuICAgICAgICAgICAgZW50ZXI6IG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpc28gPSBub2RlLnR5cGUucHJvcChOb2RlUHJvcC5pc29sYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNvKVxuICAgICAgICAgICAgICAgICAgICBkZWNvLmFkZChub2RlLmZyb20sIG5vZGUudG8sIG1hcmtzW2lzb10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb20sIHRvXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVjby5maW5pc2goKTtcbn1cbmZ1bmN0aW9uIGNsaXBSVExMaW5lcyhyYW5nZXMsIGRvYykge1xuICAgIGxldCBjdXIgPSBkb2MuaXRlcigpLCBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbGFzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnRvID4gZnJvbSkge1xuICAgICAgICAgICAgZnJvbSA9IGxhc3QudG87XG4gICAgICAgICAgICBpZiAoZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zICsgY3VyLnZhbHVlLmxlbmd0aCA8IGZyb20pIHtcbiAgICAgICAgICAgIGN1ci5uZXh0KGZyb20gLSAocG9zICsgY3VyLnZhbHVlLmxlbmd0aCkpO1xuICAgICAgICAgICAgcG9zID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBwb3MsIGVuZCA9IHBvcyArIGN1ci52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIWN1ci5saW5lQnJlYWsgJiYgYnVpbGRGb3JMaW5lKGN1ci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnRvID4gc3RhcnQgLSAxMClcbiAgICAgICAgICAgICAgICAgICAgbGFzdC50byA9IE1hdGgubWluKHRvLCBlbmQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFzdCA9IHsgZnJvbTogc3RhcnQsIHRvOiBNYXRoLm1pbih0bywgZW5kKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICBjdXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBtYXJrcyA9IHtcbiAgICBydGw6IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1pc29cIiwgaW5jbHVzaXZlOiB0cnVlLCBhdHRyaWJ1dGVzOiB7IGRpcjogXCJydGxcIiB9LCBiaWRpSXNvbGF0ZTogRGlyZWN0aW9uLlJUTCB9KSxcbiAgICBsdHI6IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1pc29cIiwgaW5jbHVzaXZlOiB0cnVlLCBhdHRyaWJ1dGVzOiB7IGRpcjogXCJsdHJcIiB9LCBiaWRpSXNvbGF0ZTogRGlyZWN0aW9uLkxUUiB9KSxcbiAgICBhdXRvOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taXNvXCIsIGluY2x1c2l2ZTogdHJ1ZSwgYXR0cmlidXRlczogeyBkaXI6IFwiYXV0b1wiIH0sIGJpZGlJc29sYXRlOiBudWxsIH0pXG59O1xuXG5leHBvcnQgeyBEb2NJbnB1dCwgSGlnaGxpZ2h0U3R5bGUsIEluZGVudENvbnRleHQsIExSTGFuZ3VhZ2UsIExhbmd1YWdlLCBMYW5ndWFnZURlc2NyaXB0aW9uLCBMYW5ndWFnZVN1cHBvcnQsIFBhcnNlQ29udGV4dCwgU3RyZWFtTGFuZ3VhZ2UsIFN0cmluZ1N0cmVhbSwgVHJlZUluZGVudENvbnRleHQsIGJpZGlJc29sYXRlcywgYnJhY2tldE1hdGNoaW5nLCBicmFja2V0TWF0Y2hpbmdIYW5kbGUsIGNvZGVGb2xkaW5nLCBjb250aW51ZWRJbmRlbnQsIGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgZGVmaW5lTGFuZ3VhZ2VGYWNldCwgZGVsaW1pdGVkSW5kZW50LCBlbnN1cmVTeW50YXhUcmVlLCBmbGF0SW5kZW50LCBmb2xkQWxsLCBmb2xkQ29kZSwgZm9sZEVmZmVjdCwgZm9sZEd1dHRlciwgZm9sZEluc2lkZSwgZm9sZEtleW1hcCwgZm9sZE5vZGVQcm9wLCBmb2xkU2VydmljZSwgZm9sZFN0YXRlLCBmb2xkYWJsZSwgZm9sZGVkUmFuZ2VzLCBmb3JjZVBhcnNpbmcsIGdldEluZGVudFVuaXQsIGdldEluZGVudGF0aW9uLCBoaWdobGlnaHRpbmdGb3IsIGluZGVudE5vZGVQcm9wLCBpbmRlbnRPbklucHV0LCBpbmRlbnRSYW5nZSwgaW5kZW50U2VydmljZSwgaW5kZW50U3RyaW5nLCBpbmRlbnRVbml0LCBsYW5ndWFnZSwgbGFuZ3VhZ2VEYXRhUHJvcCwgbWF0Y2hCcmFja2V0cywgc3VibGFuZ3VhZ2VQcm9wLCBzeW50YXhIaWdobGlnaHRpbmcsIHN5bnRheFBhcnNlclJ1bm5pbmcsIHN5bnRheFRyZWUsIHN5bnRheFRyZWVBdmFpbGFibGUsIHRvZ2dsZUZvbGQsIHVuZm9sZEFsbCwgdW5mb2xkQ29kZSwgdW5mb2xkRWZmZWN0IH07XG4iXSwibmFtZXMiOlsiTm9kZVByb3AiLCJJdGVyTW9kZSIsIlRyZWUiLCJUcmVlRnJhZ21lbnQiLCJQYXJzZXIiLCJOb2RlVHlwZSIsIk5vZGVTZXQiLCJTdGF0ZUVmZmVjdCIsIlN0YXRlRmllbGQiLCJGYWNldCIsIkVkaXRvclN0YXRlIiwiY291bnRDb2x1bW4iLCJjb21iaW5lQ29uZmlnIiwiUmFuZ2VTZXQiLCJSYW5nZVNldEJ1aWxkZXIiLCJQcmVjIiwiVmlld1BsdWdpbiIsImxvZ0V4Y2VwdGlvbiIsIkVkaXRvclZpZXciLCJEZWNvcmF0aW9uIiwiV2lkZ2V0VHlwZSIsImd1dHRlciIsIkd1dHRlck1hcmtlciIsIkRpcmVjdGlvbiIsInRhZ3MiLCJ0YWdIaWdobGlnaHRlciIsImhpZ2hsaWdodFRyZWUiLCJzdHlsZVRhZ3MiLCJTdHlsZU1vZHVsZSIsIl9hIiwibGFuZ3VhZ2VEYXRhUHJvcCIsImRlZmluZUxhbmd1YWdlRmFjZXQiLCJiYXNlRGF0YSIsImRlZmluZSIsImNvbWJpbmUiLCJ2YWx1ZXMiLCJjb25jYXQiLCJ1bmRlZmluZWQiLCJzdWJsYW5ndWFnZVByb3AiLCJMYW5ndWFnZSIsImNvbnN0cnVjdG9yIiwiZGF0YSIsInBhcnNlciIsImV4dHJhRXh0ZW5zaW9ucyIsIm5hbWUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic3ludGF4VHJlZSIsImV4dGVuc2lvbiIsImxhbmd1YWdlIiwib2YiLCJsYW5ndWFnZURhdGEiLCJzdGF0ZSIsInBvcyIsInNpZGUiLCJ0b3AiLCJ0b3BOb2RlQXQiLCJ0eXBlIiwicHJvcCIsImJhc2UiLCJmYWNldCIsInN1YiIsImlubmVyTm9kZSIsInJlc29sdmUiLCJmcm9tIiwic3VibGFuZyIsInRlc3QiLCJpc0FjdGl2ZUF0IiwiZmluZFJlZ2lvbnMiLCJsYW5nIiwidG8iLCJkb2MiLCJsZW5ndGgiLCJhbGxvd3NOZXN0aW5nIiwicmVzdWx0IiwiZXhwbG9yZSIsInRyZWUiLCJwdXNoIiwibW91bnQiLCJtb3VudGVkIiwib3ZlcmxheSIsInIiLCJzaXplIiwiaSIsImNoaWxkcmVuIiwiY2giLCJwb3NpdGlvbnMiLCJzZXRTdGF0ZSIsInRvcExhbmciLCJ0b3BOb2RlIiwibm9kZSIsImVudGVyIiwiRXhjbHVkZUJ1ZmZlcnMiLCJpc1RvcCIsIkxSTGFuZ3VhZ2UiLCJzcGVjIiwiY29uZmlndXJlIiwicHJvcHMiLCJhZGQiLCJvcHRpb25zIiwiaGFzV3JhcHBlcnMiLCJmaWVsZCIsImVtcHR5IiwiZW5zdXJlU3ludGF4VHJlZSIsInVwdG8iLCJ0aW1lb3V0IiwicGFyc2UiLCJjb250ZXh0Iiwib2xkVmllcG9ydCIsInZpZXdwb3J0IiwidXBkYXRlVmlld3BvcnQiLCJpc0RvbmUiLCJ3b3JrIiwic3ludGF4VHJlZUF2YWlsYWJsZSIsImZvcmNlUGFyc2luZyIsInZpZXciLCJzdWNjZXNzIiwiZGlzcGF0Y2giLCJzeW50YXhQYXJzZXJSdW5uaW5nIiwicGx1Z2luIiwicGFyc2VXb3JrZXIiLCJpc1dvcmtpbmciLCJEb2NJbnB1dCIsImN1cnNvclBvcyIsInN0cmluZyIsImN1cnNvciIsIml0ZXIiLCJzeW5jVG8iLCJuZXh0IiwidmFsdWUiLCJjaHVuayIsImxpbmVDaHVua3MiLCJyZWFkIiwic3RyaW5nU3RhcnQiLCJzbGljZVN0cmluZyIsInNsaWNlIiwiY3VycmVudENvbnRleHQiLCJQYXJzZUNvbnRleHQiLCJmcmFnbWVudHMiLCJ0cmVlTGVuIiwic2tpcHBlZCIsInNjaGVkdWxlT24iLCJ0ZW1wU2tpcHBlZCIsImNyZWF0ZSIsInN0YXJ0UGFyc2UiLCJ1bnRpbCIsInRha2VUcmVlIiwid2l0aENvbnRleHQiLCJlbmRUaW1lIiwiRGF0ZSIsIm5vdyIsInN0b3BwZWRBdCIsInN0b3BBdCIsImRvbmUiLCJhZHZhbmNlIiwid2l0aG91dFRlbXBTa2lwcGVkIiwiYWRkVHJlZSIsInBhcnNlZFBvcyIsImYiLCJwcmV2IiwicG9wIiwiY3V0RnJhZ21lbnRzIiwiY2hhbmdlcyIsIm5ld1N0YXRlIiwicmFuZ2VzIiwiaXRlckNoYW5nZWRSYW5nZXMiLCJmcm9tQSIsInRvQSIsImZyb21CIiwidG9CIiwiYXBwbHlDaGFuZ2VzIiwibWFwUG9zIiwic3RhcnRMZW4iLCJzcGxpY2UiLCJyZXNldCIsInNraXBVbnRpbEluVmlldyIsImdldFNraXBwaW5nUGFyc2VyIiwiY3JlYXRlUGFyc2UiLCJpbnB1dCIsImN4IiwiUHJvbWlzZSIsImFsbCIsIm5vbmUiLCJNYXRoIiwibWluIiwiZnJhZ3MiLCJMYW5ndWFnZVN0YXRlIiwiYXBwbHkiLCJ0ciIsImRvY0NoYW5nZWQiLCJuZXdDeCIsInN0YXJ0U3RhdGUiLCJtYXgiLCJpbml0IiwidnBUbyIsInBhcnNlU3RhdGUiLCJ1cGRhdGUiLCJlIiwiZWZmZWN0cyIsImlzIiwicmVxdWVzdElkbGUiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiaWRsZSIsImNhbmNlbElkbGVDYWxsYmFjayIsImlzSW5wdXRQZW5kaW5nIiwibmF2aWdhdG9yIiwic2NoZWR1bGluZyIsImZyb21DbGFzcyIsIlBhcnNlV29ya2VyIiwid29ya2luZyIsIndvcmtTY2hlZHVsZWQiLCJjaHVua0VuZCIsImNodW5rQnVkZ2V0IiwiYmluZCIsInNjaGVkdWxlV29yayIsInNlbGVjdGlvblNldCIsImhhc0ZvY3VzIiwiY2hlY2tBc3luY1NjaGVkdWxlIiwiZGVhZGxpbmUiLCJ0aW1lUmVtYWluaW5nIiwidmlld3BvcnRGaXJzdCIsInRoZW4iLCJjYXRjaCIsImVyciIsImRlc3Ryb3kiLCJldmVudEhhbmRsZXJzIiwiZm9jdXMiLCJsYW5ndWFnZXMiLCJlbmFibGVzIiwiY29udGVudEF0dHJpYnV0ZXMiLCJjb21wdXRlIiwiTGFuZ3VhZ2VTdXBwb3J0Iiwic3VwcG9ydCIsIkxhbmd1YWdlRGVzY3JpcHRpb24iLCJhbGlhcyIsImV4dGVuc2lvbnMiLCJmaWxlbmFtZSIsImxvYWRGdW5jIiwibG9hZGluZyIsImxvYWQiLCJSYW5nZUVycm9yIiwibWFwIiwicyIsInRvTG93ZXJDYXNlIiwibWF0Y2hGaWxlbmFtZSIsImRlc2NzIiwiZCIsImV4dCIsImV4ZWMiLCJpbmRleE9mIiwibWF0Y2hMYW5ndWFnZU5hbWUiLCJmdXp6eSIsInNvbWUiLCJhIiwiZm91bmQiLCJpbmRlbnRTZXJ2aWNlIiwiaW5kZW50VW5pdCIsInVuaXQiLCJBcnJheSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEluZGVudFVuaXQiLCJjaGFyQ29kZUF0IiwidGFiU2l6ZSIsImluZGVudFN0cmluZyIsImNvbHMiLCJ0cyIsImdldEluZGVudGF0aW9uIiwiSW5kZW50Q29udGV4dCIsInNlcnZpY2UiLCJzeW50YXhJbmRlbnRhdGlvbiIsImluZGVudFJhbmdlIiwidXBkYXRlZCIsIm92ZXJyaWRlSW5kZW50YXRpb24iLCJzdGFydCIsImxpbmUiLCJsaW5lQXQiLCJpbmRlbnQiLCJ0ZXh0IiwiY3VyIiwibm9ybSIsImluc2VydCIsImJpYXMiLCJzaW11bGF0ZUJyZWFrIiwic2ltdWxhdGVEb3VibGVCcmVhayIsInRleHRBZnRlclBvcyIsImNvbHVtbiIsIm92ZXJyaWRlIiwic2VhcmNoIiwibGluZUluZGVudCIsIm92ZXJyaWRlbiIsInNpbXVsYXRlZEJyZWFrIiwiaW5kZW50Tm9kZVByb3AiLCJhc3QiLCJzdGFjayIsInJlc29sdmVTdGFjayIsImlubmVyIiwicmVzb2x2ZUlubmVyIiwiZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUiLCJwYXJlbnQiLCJpbmRlbnRGb3IiLCJzdHJhdGVneSIsImluZGVudFN0cmF0ZWd5IiwiVHJlZUluZGVudENvbnRleHQiLCJpZ25vcmVDbG9zZWQiLCJmaXJzdCIsImZpcnN0Q2hpbGQiLCJjbG9zZSIsImNsb3NlZEJ5IiwibGFzdCIsImxhc3RDaGlsZCIsImNsb3NlZCIsImRlbGltaXRlZFN0cmF0ZWd5IiwidG9wSW5kZW50IiwidGV4dEFmdGVyIiwiYmFzZUluZGVudCIsImJhc2VJbmRlbnRGb3IiLCJhdEJyZWFrIiwiaXNQYXJlbnQiLCJjb250aW51ZSIsImJyYWNrZXRlZEFsaWduZWQiLCJvcGVuVG9rZW4iLCJjaGlsZEFmdGVyIiwic2ltIiwib3BlbkxpbmUiLCJsaW5lRW5kIiwiaXNTa2lwcGVkIiwic3BhY2UiLCJkZWxpbWl0ZWRJbmRlbnQiLCJjbG9zaW5nIiwiYWxpZ24iLCJ1bml0cyIsImNsb3NlZEF0IiwiYWZ0ZXIiLCJtYXRjaCIsImFsaWduZWQiLCJmbGF0SW5kZW50IiwiY29udGludWVkSW5kZW50IiwiZXhjZXB0IiwibWF0Y2hFeGNlcHQiLCJEb250SW5kZW50QmV5b25kIiwiaW5kZW50T25JbnB1dCIsInRyYW5zYWN0aW9uRmlsdGVyIiwiaXNVc2VyRXZlbnQiLCJydWxlcyIsImxhbmd1YWdlRGF0YUF0Iiwic2VsZWN0aW9uIiwibWFpbiIsImhlYWQiLCJuZXdEb2MiLCJuZXdTZWxlY3Rpb24iLCJsaW5lU3RhcnQiLCJzZXF1ZW50aWFsIiwiZm9sZFNlcnZpY2UiLCJmb2xkTm9kZVByb3AiLCJmb2xkSW5zaWRlIiwiaXNFcnJvciIsInN5bnRheEZvbGRpbmciLCJlbmQiLCJpc1VuZmluaXNoZWQiLCJmb2xkYWJsZSIsIm1hcFJhbmdlIiwicmFuZ2UiLCJtYXBwaW5nIiwiZm9sZEVmZmVjdCIsInVuZm9sZEVmZmVjdCIsInNlbGVjdGVkTGluZXMiLCJsaW5lcyIsImwiLCJsaW5lQmxvY2tBdCIsImZvbGRTdGF0ZSIsImZvbGRlZCIsImNsZWFyVG91Y2hlZEZvbGRzIiwiZm9sZEV4aXN0cyIsInByZXBhcmVQbGFjZWhvbGRlciIsImZvbGRDb25maWciLCJ3aWRnZXQiLCJmb2xkV2lkZ2V0IiwicmVwbGFjZSIsIlByZXBhcmVkRm9sZFdpZGdldCIsImZpbHRlciIsImZpbHRlckZyb20iLCJmaWx0ZXJUbyIsInByb3ZpZGUiLCJkZWNvcmF0aW9ucyIsInRvSlNPTiIsImJldHdlZW4iLCJmcm9tSlNPTiIsImlzQXJyYXkiLCJzZXQiLCJ0b3VjaGVkIiwiYiIsImZvbGRlZFJhbmdlcyIsImZpbmRGb2xkIiwibWF5YmVFbmFibGUiLCJvdGhlciIsImFwcGVuZENvbmZpZyIsImNvZGVGb2xkaW5nIiwiZm9sZENvZGUiLCJhbm5vdW5jZUZvbGQiLCJ1bmZvbGRDb2RlIiwiZm9sZCIsImxpbmVGcm9tIiwibnVtYmVyIiwibGluZVRvIiwiYW5ub3VuY2UiLCJwaHJhc2UiLCJmb2xkQWxsIiwidW5mb2xkQWxsIiwiZm9sZGFibGVDb250YWluZXIiLCJsaW5lQmxvY2siLCJmb2xkYWJsZVJlZ2lvbiIsInRvZ2dsZUZvbGQiLCJmb2xkUmFuZ2UiLCJmb2xkS2V5bWFwIiwia2V5IiwibWFjIiwicnVuIiwiZGVmYXVsdENvbmZpZyIsInBsYWNlaG9sZGVyRE9NIiwicGxhY2Vob2xkZXJUZXh0IiwiY29uZmlnIiwiYmFzZVRoZW1lJDEiLCJ3aWRnZXRUb0RPTSIsInByZXBhcmVkIiwiY29uZiIsIm9uY2xpY2siLCJldmVudCIsInBvc0F0RE9NIiwidGFyZ2V0IiwicHJldmVudERlZmF1bHQiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJzZXRBdHRyaWJ1dGUiLCJ0aXRsZSIsImNsYXNzTmFtZSIsInRvRE9NIiwiZXEiLCJmb2xkR3V0dGVyRGVmYXVsdHMiLCJvcGVuVGV4dCIsImNsb3NlZFRleHQiLCJtYXJrZXJET00iLCJkb21FdmVudEhhbmRsZXJzIiwiZm9sZGluZ0NoYW5nZWQiLCJGb2xkTWFya2VyIiwib3BlbiIsInNwYW4iLCJmb2xkR3V0dGVyIiwiZnVsbENvbmZpZyIsImNhbkZvbGQiLCJjYW5VbmZvbGQiLCJtYXJrZXJzIiwiYnVpbGRNYXJrZXJzIiwidmlld3BvcnRDaGFuZ2VkIiwiYnVpbGRlciIsInZpZXdwb3J0TGluZUJsb2NrcyIsIm1hcmsiLCJmaW5pc2giLCJjbGFzcyIsImluaXRpYWxTcGFjZXIiLCJjbGljayIsImJhc2VUaGVtZSIsImJhY2tncm91bmRDb2xvciIsImJvcmRlciIsImNvbG9yIiwiYm9yZGVyUmFkaXVzIiwibWFyZ2luIiwicGFkZGluZyIsIkhpZ2hsaWdodFN0eWxlIiwic3BlY3MiLCJtb2RTcGVjIiwiZGVmIiwiY2xzIiwibmV3TmFtZSIsInNjb3BlT3B0Iiwic2NvcGUiLCJzdHlsZSIsInRhZyIsImFzc2lnbiIsIm1vZHVsZSIsInRoZW1lVHlwZSIsImhpZ2hsaWdodGVyRmFjZXQiLCJmYWxsYmFja0hpZ2hsaWdodGVyIiwiZ2V0SGlnaGxpZ2h0ZXJzIiwic3ludGF4SGlnaGxpZ2h0aW5nIiwiaGlnaGxpZ2h0ZXIiLCJ0cmVlSGlnaGxpZ2h0ZXIiLCJzdHlsZU1vZHVsZSIsImZhbGxiYWNrIiwiY29tcHV0ZU4iLCJkYXJrVGhlbWUiLCJoaWdobGlnaHRpbmdGb3IiLCJoaWdobGlnaHRlcnMiLCJUcmVlSGlnaGxpZ2h0ZXIiLCJtYXJrQ2FjaGUiLCJidWlsZERlY28iLCJkZWNvcmF0ZWRUbyIsInN0eWxlQ2hhbmdlIiwiZGVjb3JhdGVkVG9NYXBwZWQiLCJ2aXNpYmxlUmFuZ2VzIiwiaGlnaCIsInYiLCJkZWZhdWx0SGlnaGxpZ2h0U3R5bGUiLCJtZXRhIiwibGluayIsInRleHREZWNvcmF0aW9uIiwiaGVhZGluZyIsImZvbnRXZWlnaHQiLCJlbXBoYXNpcyIsImZvbnRTdHlsZSIsInN0cm9uZyIsInN0cmlrZXRocm91Z2giLCJrZXl3b3JkIiwiYXRvbSIsImJvb2wiLCJ1cmwiLCJjb250ZW50U2VwYXJhdG9yIiwibGFiZWxOYW1lIiwibGl0ZXJhbCIsImluc2VydGVkIiwiZGVsZXRlZCIsInJlZ2V4cCIsImVzY2FwZSIsInNwZWNpYWwiLCJkZWZpbml0aW9uIiwidmFyaWFibGVOYW1lIiwibG9jYWwiLCJ0eXBlTmFtZSIsIm5hbWVzcGFjZSIsIm1hY3JvTmFtZSIsInByb3BlcnR5TmFtZSIsImNvbW1lbnQiLCJpbnZhbGlkIiwiRGVmYXVsdFNjYW5EaXN0IiwiRGVmYXVsdEJyYWNrZXRzIiwiYnJhY2tldE1hdGNoaW5nQ29uZmlnIiwiY29uZmlncyIsImFmdGVyQ3Vyc29yIiwiYnJhY2tldHMiLCJtYXhTY2FuRGlzdGFuY2UiLCJyZW5kZXJNYXRjaCIsImRlZmF1bHRSZW5kZXJNYXRjaCIsIm1hdGNoaW5nTWFyayIsIm5vbm1hdGNoaW5nTWFyayIsIm1hdGNoZWQiLCJicmFja2V0TWF0Y2hpbmdTdGF0ZSIsImRlY28iLCJtYXRjaEJyYWNrZXRzIiwiYnJhY2tldE1hdGNoaW5nVW5pcXVlIiwiYnJhY2tldE1hdGNoaW5nIiwiYnJhY2tldE1hdGNoaW5nSGFuZGxlIiwibWF0Y2hpbmdOb2RlcyIsImRpciIsImJ5UHJvcCIsIm9wZW5lZEJ5IiwiaW5kZXgiLCJmaW5kSGFuZGxlIiwiaGFzSGFuZGxlIiwibWF0Y2hlcyIsImhhbmRsZSIsIm1hdGNoTWFya2VkQnJhY2tldHMiLCJtYXRjaFBsYWluQnJhY2tldHMiLCJfc3RhdGUiLCJfcG9zIiwidG9rZW4iLCJtYXRjaGluZyIsImZpcnN0VG9rZW4iLCJkZXB0aCIsImNoaWxkQmVmb3JlIiwiZW5kSGFuZGxlIiwicHJldlNpYmxpbmciLCJuZXh0U2libGluZyIsInRva2VuVHlwZSIsInN0YXJ0Q2giLCJzbGljZURvYyIsImJyYWNrZXQiLCJzdGFydFRva2VuIiwiaXRlclJhbmdlIiwiZGlzdGFuY2UiLCJiYXNlUG9zIiwiY291bnRDb2wiLCJzdGFydEluZGV4Iiwic3RhcnRWYWx1ZSIsIm4iLCJTdHJpbmdTdHJlYW0iLCJvdmVycmlkZUluZGVudCIsImxhc3RDb2x1bW5Qb3MiLCJsYXN0Q29sdW1uVmFsdWUiLCJlb2wiLCJzb2wiLCJwZWVrIiwiY2hhckF0IiwiZWF0Iiwib2siLCJSZWdFeHAiLCJlYXRXaGlsZSIsImVhdFNwYWNlIiwic2tpcFRvRW5kIiwic2tpcFRvIiwiYmFja1VwIiwiaW5kZW50YXRpb24iLCJwYXR0ZXJuIiwiY29uc3VtZSIsImNhc2VJbnNlbnNpdGl2ZSIsImNhc2VkIiwic3RyIiwic3Vic3RyIiwiY3VycmVudCIsImZ1bGxQYXJzZXIiLCJibGFua0xpbmUiLCJjb3B5U3RhdGUiLCJkZWZhdWx0Q29weVN0YXRlIiwidG9rZW5UYWJsZSIsIm5vVG9rZW5zIiwibWVyZ2VUb2tlbnMiLCJ2YWwiLCJJbmRlbnRlZEZyb20iLCJXZWFrTWFwIiwiU3RyZWFtTGFuZ3VhZ2UiLCJwIiwic2VsZiIsImltcGwiLCJQYXJzZSIsImRvY0lEIiwic3RyZWFtUGFyc2VyIiwic3RhdGVBZnRlciIsInBlck5vZGUiLCJUb2tlblRhYmxlIiwiZGVmYXVsdFRva2VuVGFibGUiLCJnZXRJbmRlbnQiLCJmaW5kU3RhdGUiLCJzdGF0ZVBvcyIsInN0cmVhbSIsInJlYWRUb2tlbiIsIm9mZiIsInN0YXJ0UG9zIiwiYmVmb3JlIiwiY2hpbGQiLCJjdXRUcmVlIiwiaW5zaWRlIiwiZmluZFN0YXJ0SW5GcmFnbWVudHMiLCJlbmRQb3MiLCJlZGl0b3JTdGF0ZSIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJvZmZzZXQiLCJjaHVua3MiLCJjaHVua1BvcyIsImNodW5rUmV1c2VkIiwicmFuZ2VJbmRleCIsImNodW5rU3RhcnQiLCJtb3ZlUmFuZ2VJbmRleCIsInBhcnNlRW5kIiwicGFyc2VMaW5lIiwiZmluaXNoQ2h1bmsiLCJsaW5lQWZ0ZXIiLCJuZXh0TGluZSIsInJhbmdlRW5kIiwicmFuZ2VTdGFydCIsInNraXBHYXBzVG8iLCJvZmZQb3MiLCJlbWl0VG9rZW4iLCJpZCIsImxlbjAiLCJidWlsZCIsImJ1ZmZlciIsIm5vZGVTZXQiLCJ0b3BJRCIsIm1heEJ1ZmZlckxlbmd0aCIsInJldXNlZCIsImJhbGFuY2UiLCJ0eXBlQXJyYXkiLCJ3YXJuZWQiLCJieVRhZyIsImRlZmF1bHRUYWJsZSIsImxlZ2FjeU5hbWUiLCJjcmVhdGVUb2tlblR5cGUiLCJleHRyYSIsInRhYmxlIiwid2FybkZvclBhcnQiLCJwYXJ0IiwibXNnIiwiY29uc29sZSIsIndhcm4iLCJ0YWdTdHIiLCJ0YWdzJDEiLCJzcGxpdCIsInQiLCJrbm93biIsImJ1aWxkRm9yTGluZSIsInRleHRIYXNSVEwiLCJjaGFuZ2VBZGRzUlRMIiwiY2hhbmdlIiwiYWRkZWQiLCJpdGVyQ2hhbmdlcyIsImZBIiwidEEiLCJmQiIsInRCIiwiaW5zIiwiYWx3YXlzSXNvbGF0ZSIsIngiLCJiaWRpSXNvbGF0ZXMiLCJpc29sYXRlTWFya3MiLCJhbHdheXMiLCJ0ZXh0RGlyZWN0aW9uIiwiTFRSIiwicGVyTGluZVRleHREaXJlY3Rpb24iLCJoYXNSVEwiLCJhY2Nlc3MiLCJfYiIsIm91dGVyRGVjb3JhdGlvbnMiLCJsb3dlc3QiLCJiaWRpSXNvbGF0ZWRSYW5nZXMiLCJjbGlwUlRMTGluZXMiLCJpdGVyYXRlIiwiaXNvIiwiaXNvbGF0ZSIsIm1hcmtzIiwibGluZUJyZWFrIiwicnRsIiwiaW5jbHVzaXZlIiwiYXR0cmlidXRlcyIsImJpZGlJc29sYXRlIiwiUlRMIiwibHRyIiwiYXV0byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeLintPanel: () => (/* binding */ closeLintPanel),\n/* harmony export */   diagnosticCount: () => (/* binding */ diagnosticCount),\n/* harmony export */   forEachDiagnostic: () => (/* binding */ forEachDiagnostic),\n/* harmony export */   forceLinting: () => (/* binding */ forceLinting),\n/* harmony export */   lintGutter: () => (/* binding */ lintGutter),\n/* harmony export */   lintKeymap: () => (/* binding */ lintKeymap),\n/* harmony export */   linter: () => (/* binding */ linter),\n/* harmony export */   nextDiagnostic: () => (/* binding */ nextDiagnostic),\n/* harmony export */   openLintPanel: () => (/* binding */ openLintPanel),\n/* harmony export */   previousDiagnostic: () => (/* binding */ previousDiagnostic),\n/* harmony export */   setDiagnostics: () => (/* binding */ setDiagnostics),\n/* harmony export */   setDiagnosticsEffect: () => (/* binding */ setDiagnosticsEffect)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic){\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected){\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        // Filter the list of diagnostics for which to create markers\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\n        if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics, state);\n        let sorted = diagnostics.slice().sort((a, b)=>a.from - b.from || a.to - b.to);\n        let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder(), active = [], pos = 0;\n        let scan = state.doc.iter(), scanPos = 0, docLen = state.doc.length;\n        for(let i = 0;;){\n            let next = i == sorted.length ? null : sorted[i];\n            if (!next && !active.length) break;\n            let from, to;\n            if (active.length) {\n                from = pos;\n                to = active.reduce((p, d)=>Math.min(p, d.to), next && next.from > from ? next.from : 1e8);\n            } else {\n                from = next.from;\n                if (from > docLen) break;\n                to = next.to;\n                active.push(next);\n                i++;\n            }\n            while(i < sorted.length){\n                let next = sorted[i];\n                if (next.from == from && (next.to > next.from || next.to == from)) {\n                    active.push(next);\n                    i++;\n                    to = Math.min(next.to, to);\n                } else {\n                    to = Math.min(next.from, to);\n                    break;\n                }\n            }\n            to = Math.min(to, docLen);\n            let widget = false;\n            if (active.some((d)=>d.from == from && (d.to == to || to == docLen))) {\n                widget = from == to;\n                if (!widget && to - from < 10) {\n                    let behind = from - (scanPos + scan.value.length);\n                    if (behind > 0) {\n                        scan.next(behind);\n                        scanPos = from;\n                    }\n                    for(let check = from;;){\n                        if (check >= to) {\n                            widget = true;\n                            break;\n                        }\n                        if (!scan.lineBreak && scanPos + scan.value.length > check) break;\n                        check = scanPos + scan.value.length;\n                        scanPos += scan.value.length;\n                        scan.next();\n                    }\n                }\n            }\n            let sev = maxSeverity(active);\n            if (widget) {\n                deco.add(from, from, _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n                    widget: new DiagnosticWidget(sev),\n                    diagnostics: active.slice()\n                }));\n            } else {\n                let markClass = active.reduce((c, d)=>d.markClass ? c + \" \" + d.markClass : c, \"\");\n                deco.add(from, to, _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n                    class: \"cm-lintRange cm-lintRange-\" + sev + markClass,\n                    diagnostics: active.slice(),\n                    inclusiveEnd: active.some((a)=>a.to > to)\n                }));\n            }\n            pos = to;\n            if (pos == docLen) break;\n            for(let i = 0; i < active.length; i++)if (active[i].to <= pos) active.splice(i--, 1);\n        }\n        let set = deco.finish();\n        return new LintState(set, panel, findDiagnostic(set));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec })=>{\n        if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0) return;\n        if (!found) found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);\n        else if (spec.diagnostics.indexOf(found.diagnostic) < 0) return false;\n        else found = new SelectedDiagnostic(found.from, to, found.diagnostic);\n    });\n    return found;\n}\nfunction hideTooltip(tr, tooltip) {\n    let from = tooltip.pos, to = tooltip.end || from;\n    let result = tr.state.facet(lintConfig).hideOn(tr, from, to);\n    if (result != null) return result;\n    let line = tr.startState.doc.lineAt(tooltip.pos);\n    return !!(tr.effects.some((e)=>e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));\n}\nfunction maybeEnableLint(state, effects) {\n    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(lintExtensions));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/ function setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [\n            setDiagnosticsEffect.of(diagnostics)\n        ])\n    };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/ const setDiagnosticsEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst lintState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none, null, null);\n    },\n    update (value, tr) {\n        if (tr.docChanged && value.diagnostics.size) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel) panel = null;\n            value = new LintState(mapped, panel, selected);\n        }\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;\n                value = LintState.init(effect.value, panel, tr.state);\n            } else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            } else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val.panel),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, (s)=>s.diagnostics)\n        ]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/ function diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-lintRange cm-lintRange-active\"\n});\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found, start = -1, end = -1;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec })=>{\n        if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {\n            found = spec.diagnostics;\n            start = from;\n            end = to;\n            return false;\n        }\n    });\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n    if (found && diagnosticFilter) found = diagnosticFilter(found, view.state);\n    if (!found) return null;\n    return {\n        pos: start,\n        end: end,\n        above: view.state.doc.lineAt(start).to < end,\n        create () {\n            return {\n                dom: diagnosticsTooltip(view, found)\n            };\n        }\n    };\n}\nfunction diagnosticsTooltip(view, diagnostics) {\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n        class: \"cm-tooltip-lint\"\n    }, diagnostics.map((d)=>renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/ const openLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) view.dispatch({\n        effects: maybeEnableLint(view.state, [\n            togglePanel.of(true)\n        ])\n    });\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, LintPanel.open);\n    if (panel) panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/ const closeLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) return false;\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/ const nextDiagnostic = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field) return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to) return false;\n    }\n    view.dispatch({\n        selection: {\n            anchor: next.from,\n            head: next.to\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nMove the selection to the previous diagnostic.\n*/ const previousDiagnostic = (view)=>{\n    let { state } = view, field = state.field(lintState, false);\n    if (!field) return false;\n    let sel = state.selection.main;\n    let prevFrom, prevTo, lastFrom, lastTo;\n    field.diagnostics.between(0, state.doc.length, (from, to)=>{\n        if (to < sel.to && (prevFrom == null || prevFrom < from)) {\n            prevFrom = from;\n            prevTo = to;\n        }\n        if (lastFrom == null || from > lastFrom) {\n            lastFrom = from;\n            lastTo = to;\n        }\n    });\n    if (lastFrom == null || prevFrom == null && lastFrom == sel.from) return false;\n    view.dispatch({\n        selection: {\n            anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom,\n            head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/ const lintKeymap = [\n    {\n        key: \"Mod-Shift-m\",\n        run: openLintPanel,\n        preventDefault: true\n    },\n    {\n        key: \"F8\",\n        run: nextDiagnostic\n    }\n];\nconst lintPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintConfig);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        clearTimeout(this.timeout);\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            this.timeout = setTimeout(this.run, this.lintTime - now);\n        } else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintConfig);\n            if (sources.length) batchResults(sources.map((s)=>Promise.resolve(s(this.view))), (annotations)=>{\n                if (this.view.state.doc == state.doc) this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a, b)=>a.concat(b))));\n            }, (error)=>{\n                (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, error);\n            });\n        }\n    }\n    update(update) {\n        let config = update.state.facet(lintConfig);\n        if (update.docChanged || config != update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(update)) {\n            this.lintTime = Date.now() + config.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, config.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nfunction batchResults(promises, sink, error) {\n    let collected = [], timeout = -1;\n    for (let p of promises)p.then((value)=>{\n        collected.push(value);\n        clearTimeout(timeout);\n        if (collected.length == promises.length) sink(collected);\n        else timeout = setTimeout(()=>sink(collected), 200);\n    }, error);\n}\nconst lintConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (input) {\n        return {\n            sources: input.map((i)=>i.source).filter((x)=>x != null),\n            ...(0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(input.map((i)=>i.config), {\n                delay: 750,\n                markerFilter: null,\n                tooltipFilter: null,\n                needsRefresh: null,\n                hideOn: ()=>null\n            }, {\n                delay: Math.max,\n                markerFilter: combineFilter,\n                tooltipFilter: combineFilter,\n                needsRefresh: (a, b)=>!a ? b : !b ? a : (u)=>a(u) || b(u),\n                hideOn: (a, b)=>!a ? b : !b ? a : (t, x, y)=>a(t, x, y) || b(t, x, y),\n                autoPanel: (a, b)=>a || b\n            })\n        };\n    }\n});\nfunction combineFilter(a, b) {\n    return !a ? b : !b ? a : (d, s)=>b(a(d, s), s);\n}\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed).\n\nNote that settings given here will apply to all linters active in\nthe editor. If `null` is given as source, this only configures the\nlint extension.\n*/ function linter(source, config = {}) {\n    return [\n        lintConfig.of({\n            source,\n            config\n        }),\n        lintPlugin,\n        lintExtensions\n    ];\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/ function forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin) plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions) actions: for (let { name } of actions){\n        for(let i = 0; i < name.length; i++){\n            let ch = name[i];\n            if (/[a-zA-Z]/.test(ch) && !assigned.some((c)=>c.toLowerCase() == ch.toLowerCase())) {\n                assigned.push(ch);\n                continue actions;\n            }\n        }\n        assigned.push(\"\");\n    }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"li\", {\n        class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n        class: \"cm-diagnosticText\"\n    }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i)=>{\n        let fired = false, click = (e)=>{\n            e.preventDefault();\n            if (fired) return;\n            fired = true;\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found) action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [\n            name.slice(0, keyIndex),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)\n        ];\n        let markClass = action.markClass ? \" \" + action.markClass : \"\";\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\" + markClass,\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n        class: \"cm-diagnosticSource\"\n    }, diagnostic.source));\n}\nclass DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n    constructor(sev){\n        super();\n        this.sev = sev;\n    }\n    eq(other) {\n        return other.sev == this.sev;\n    }\n    toDOM() {\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n            class: \"cm-lintPoint cm-lintPoint-\" + this.sev\n        });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic){\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view){\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event)=>{\n            if (event.keyCode == 27) {\n                closeLintPanel(this.view);\n                this.view.focus();\n            } else if (event.keyCode == 38 || event.keyCode == 33) {\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            } else if (event.keyCode == 40 || event.keyCode == 34) {\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            } else if (event.keyCode == 36) {\n                this.moveSelection(0);\n            } else if (event.keyCode == 35) {\n                this.moveSelection(this.items.length - 1);\n            } else if (event.keyCode == 13) {\n                this.view.focus();\n            } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for(let i = 0; i < keys.length; i++)if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                    let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                    if (found) diagnostic.actions[i].apply(view, found.from, found.to);\n                }\n            } else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event)=>{\n            for(let i = 0; i < this.items.length; i++){\n                if (this.items[i].dom.contains(event.target)) this.moveSelection(i);\n            }\n        };\n        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            class: \"cm-panel-lint\"\n        }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: ()=>closeLintPanel(this.view)\n        }, \"\\xd7\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected) return -1;\n        for(let i = 0; i < this.items.length; i++)if (this.items[i].diagnostic == selected.diagnostic) return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        let seen = new Set();\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec })=>{\n            for (let diagnostic of spec.diagnostics){\n                if (seen.has(diagnostic)) continue;\n                seen.add(diagnostic);\n                let found = -1, item;\n                for(let j = i; j < this.items.length; j++)if (this.items[j].diagnostic == diagnostic) {\n                    found = j;\n                    break;\n                }\n                if (found < 0) {\n                    item = new PanelItem(this.view, diagnostic);\n                    this.items.splice(i, 0, item);\n                    needsSync = true;\n                } else {\n                    item = this.items[found];\n                    if (found > i) {\n                        this.items.splice(i, found - i);\n                        needsSync = true;\n                    }\n                }\n                if (selected && item.diagnostic == selected.diagnostic) {\n                    if (!item.dom.hasAttribute(\"aria-selected\")) {\n                        item.dom.setAttribute(\"aria-selected\", \"true\");\n                        newSelectedItem = item;\n                    }\n                } else if (item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.removeAttribute(\"aria-selected\");\n                }\n                i++;\n            }\n        });\n        while(i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)){\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1,\n                to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: ()=>({\n                        sel: newSelectedItem.dom.getBoundingClientRect(),\n                        panel: this.list.getBoundingClientRect()\n                    }),\n                write: ({ sel, panel })=>{\n                    let scaleY = panel.height / this.list.offsetHeight;\n                    if (sel.top < panel.top) this.list.scrollTop -= (panel.top - sel.top) / scaleY;\n                    else if (sel.bottom > panel.bottom) this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;\n                }\n            });\n        } else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync) this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items){\n            if (item.dom.parentNode == this.list) {\n                while(domPos != item.dom)rm();\n                domPos = item.dom.nextSibling;\n            } else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while(domPos)rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0) return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection) return;\n        this.view.dispatch({\n            selection: {\n                anchor: selection.from,\n                head: selection.to\n            },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) {\n        return new LintPanel(view);\n    }\n}\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\nfunction underline(color) {\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": {\n        borderLeft: \"5px solid #d11\"\n    },\n    \".cm-diagnostic-warning\": {\n        borderLeft: \"5px solid orange\"\n    },\n    \".cm-diagnostic-info\": {\n        borderLeft: \"5px solid #999\"\n    },\n    \".cm-diagnostic-hint\": {\n        borderLeft: \"5px solid #66d\"\n    },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\",\n        cursor: \"pointer\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\",\n        paddingBottom: \"0.7px\"\n    },\n    \".cm-lintRange-error\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#d11\")\n    },\n    \".cm-lintRange-warning\": {\n        backgroundImage: /*@__PURE__*/ underline(\"orange\")\n    },\n    \".cm-lintRange-info\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#999\")\n    },\n    \".cm-lintRange-hint\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#66d\")\n    },\n    \".cm-lintRange-active\": {\n        backgroundColor: \"#ffdd9980\"\n    },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": {\n            borderBottomColor: \"orange\"\n        }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": {\n            borderBottomColor: \"#999\"\n        }\n    },\n    \".cm-lintPoint-hint\": {\n        \"&:after\": {\n            borderBottomColor: \"#66d\"\n        }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": {\n                    textDecoration: \"underline\"\n                }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": {\n                textDecoration: \"none\"\n            },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\nfunction severityWeight(sev) {\n    return sev == \"error\" ? 4 : sev == \"warning\" ? 3 : sev == \"info\" ? 2 : 1;\n}\nfunction maxSeverity(diagnostics) {\n    let sev = \"hint\", weight = 1;\n    for (let d of diagnostics){\n        let w = severityWeight(d.severity);\n        if (w > weight) {\n            weight = w;\n            sev = d.severity;\n        }\n    }\n    return sev;\n}\nclass LintGutterMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.GutterMarker {\n    constructor(diagnostics){\n        super();\n        this.diagnostics = diagnostics;\n        this.severity = maxSeverity(diagnostics);\n    }\n    toDOM(view) {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n        let diagnostics = this.diagnostics;\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n        if (diagnosticsFilter) diagnostics = diagnosticsFilter(diagnostics, view.state);\n        if (diagnostics.length) elt.onmouseover = ()=>gutterMarkerMouseOver(view, elt, diagnostics);\n        return elt;\n    }\n}\nfunction trackHoverOn(view, marker) {\n    let mousemove = (event)=>{\n        let rect = marker.getBoundingClientRect();\n        if (event.clientX > rect.left - 10 /* Hover.Margin */  && event.clientX < rect.right + 10 /* Hover.Margin */  && event.clientY > rect.top - 10 /* Hover.Margin */  && event.clientY < rect.bottom + 10 /* Hover.Margin */ ) return;\n        for(let target = event.target; target; target = target.parentNode){\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\")) return;\n        }\n        window.removeEventListener(\"mousemove\", mousemove);\n        if (view.state.field(lintGutterTooltip)) view.dispatch({\n            effects: setLintGutterTooltip.of(null)\n        });\n    };\n    window.addEventListener(\"mousemove\", mousemove);\n}\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n    function hovered() {\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n        const linePos = view.coordsAtPos(line.from);\n        if (linePos) {\n            view.dispatch({\n                effects: setLintGutterTooltip.of({\n                    pos: line.from,\n                    above: false,\n                    clip: false,\n                    create () {\n                        return {\n                            dom: diagnosticsTooltip(view, diagnostics),\n                            getCoords: ()=>marker.getBoundingClientRect()\n                        };\n                    }\n                })\n            });\n        }\n        marker.onmouseout = marker.onmousemove = null;\n        trackHoverOn(view, marker);\n    }\n    let { hoverTime } = view.state.facet(lintGutterConfig);\n    let hoverTimeout = setTimeout(hovered, hoverTime);\n    marker.onmouseout = ()=>{\n        clearTimeout(hoverTimeout);\n        marker.onmouseout = marker.onmousemove = null;\n    };\n    marker.onmousemove = ()=>{\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(hovered, hoverTime);\n    };\n}\nfunction markersForDiagnostics(doc, diagnostics) {\n    let byLine = Object.create(null);\n    for (let diagnostic of diagnostics){\n        let line = doc.lineAt(diagnostic.from);\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n    }\n    let markers = [];\n    for(let line in byLine){\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.of(markers, true);\n}\nconst lintGutterExtension = /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.gutter)({\n    class: \"cm-gutter-lint\",\n    markers: (view)=>view.state.field(lintGutterMarkers),\n    widgetMarker: (view, widget, block)=>{\n        let diagnostics = [];\n        view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value)=>{\n            if (from > block.from && from < block.to) diagnostics.push(...value.diagnostics);\n        });\n        return diagnostics.length ? new LintGutterMarker(diagnostics) : null;\n    }\n});\nconst lintGutterMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    },\n    update (markers, tr) {\n        markers = markers.map(tr.changes);\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                let diagnostics = effect.value;\n                if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics || [], tr.state);\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n            }\n        }\n        return markers;\n    }\n});\nconst setLintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return null;\n    },\n    update (tooltip, tr) {\n        if (tooltip && tr.docChanged) tooltip = hideTooltip(tr, tooltip) ? null : {\n            ...tooltip,\n            pos: tr.changes.mapPos(tooltip.pos)\n        };\n        return tr.effects.reduce((t, e)=>e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n    },\n    provide: (field)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-gutter-lint\": {\n        width: \"1.4em\",\n        \"& .cm-gutterElement\": {\n            padding: \".2em\"\n        }\n    },\n    \".cm-lint-marker\": {\n        width: \"1em\",\n        height: \"1em\"\n    },\n    \".cm-lint-marker-info\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n    },\n    \".cm-lint-marker-warning\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`)\n    },\n    \".cm-lint-marker-error\": {\n        content: /*@__PURE__*/ svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n    }\n});\nconst lintExtensions = [\n    lintState,\n    /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.compute([\n        lintState\n    ], (state)=>{\n        let { selected, panel } = state.field(lintState);\n        return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set([\n            activeMark.range(selected.from, selected.to)\n        ]);\n    }),\n    /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.hoverTooltip)(lintTooltip, {\n        hideOn: hideTooltip\n    }),\n    baseTheme\n];\nconst lintGutterConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            hoverTime: 300 /* Hover.Time */ ,\n            markerFilter: null,\n            tooltipFilter: null\n        });\n    }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/ function lintGutter(config = {}) {\n    return [\n        lintGutterConfig.of(config),\n        lintGutterMarkers,\n        lintGutterExtension,\n        lintGutterTheme,\n        lintGutterTooltip\n    ];\n}\n/**\nIterate over the marked diagnostics for the given editor state,\ncalling `f` for each of them. Note that, if the document changed\nsince the diagnostics were created, the `Diagnostic` object will\nhold the original outdated position, whereas the `to` and `from`\narguments hold the diagnostic's current position.\n*/ function forEachDiagnostic(state, f) {\n    let lState = state.field(lintState, false);\n    if (lState && lState.diagnostics.size) {\n        let pending = [], pendingStart = [], lastEnd = -1;\n        for(let iter = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.iter([\n            lState.diagnostics\n        ]);; iter.next()){\n            for(let i = 0; i < pending.length; i++)if (!iter.value || iter.value.spec.diagnostics.indexOf(pending[i]) < 0) {\n                f(pending[i], pendingStart[i], lastEnd);\n                pending.splice(i, 1);\n                pendingStart.splice(i--, 1);\n            }\n            if (!iter.value) break;\n            for (let d of iter.value.spec.diagnostics)if (pending.indexOf(d) < 0) {\n                pending.push(d);\n                pendingStart.push(iter.from);\n            }\n            lastEnd = iter.to;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSztBQUN6RDtBQUNyRjtBQUV4QixNQUFNa0I7SUFDRkMsWUFBWUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLFVBQVUsQ0FBRTtRQUM5QixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUNBLE1BQU1DO0lBQ0ZKLFlBQVlLLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDdEMsSUFBSSxDQUFDRixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNwQjtJQUNBLE9BQU9DLEtBQUtILFdBQVcsRUFBRUMsS0FBSyxFQUFFRyxLQUFLLEVBQUU7UUFDbkMsNkRBQTZEO1FBQzdELElBQUlDLG1CQUFtQkQsTUFBTUUsS0FBSyxDQUFDQyxZQUFZQyxZQUFZO1FBQzNELElBQUlILGtCQUNBTCxjQUFjSyxpQkFBaUJMLGFBQWFJO1FBQ2hELElBQUlLLFNBQVNULFlBQVlVLEtBQUssR0FBR0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVoQixJQUFJLEdBQUdpQixFQUFFakIsSUFBSSxJQUFJZ0IsRUFBRWYsRUFBRSxHQUFHZ0IsRUFBRWhCLEVBQUU7UUFDOUUsSUFBSWlCLE9BQU8sSUFBSXRCLDhEQUFlQSxJQUFJdUIsU0FBUyxFQUFFLEVBQUVDLE1BQU07UUFDckQsSUFBSUMsT0FBT2IsTUFBTWMsR0FBRyxDQUFDQyxJQUFJLElBQUlDLFVBQVUsR0FBR0MsU0FBU2pCLE1BQU1jLEdBQUcsQ0FBQ0ksTUFBTTtRQUNuRSxJQUFLLElBQUlDLElBQUksSUFBSztZQUNkLElBQUlDLE9BQU9ELEtBQUtkLE9BQU9hLE1B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dlQsRUFBRSxFQUFFd1Q7Z0JBQy9CRixRQUFRL1IsTUFBTSxDQUFDdkIsR0FBRztnQkFDbEJ1VCxhQUFhaFMsTUFBTSxDQUFDdkIsS0FBSztZQUM3QjtZQUNKLElBQUksQ0FBQ0osS0FBS2UsS0FBSyxFQUNYO1lBQ0osS0FBSyxJQUFJUCxLQUFLUixLQUFLZSxLQUFLLENBQUNtQixJQUFJLENBQUNyRCxXQUFXLENBQ3JDLElBQUk2VSxRQUFRdlIsT0FBTyxDQUFDM0IsS0FBSyxHQUFHO2dCQUN4QmtULFFBQVEvUyxJQUFJLENBQUNIO2dCQUNibVQsYUFBYWhULElBQUksQ0FBQ1gsS0FBS3ZCLElBQUk7WUFDL0I7WUFDSm1WLFVBQVU1VCxLQUFLdEIsRUFBRTtRQUNyQjtJQUNKO0FBQ0o7QUFFcU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybmNvZGUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzP2Y5ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVjb3JhdGlvbiwgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBndXR0ZXIsIHNob3dUb29sdGlwLCBob3ZlclRvb2x0aXAsIGdldFBhbmVsLCBsb2dFeGNlcHRpb24sIFdpZGdldFR5cGUsIEd1dHRlck1hcmtlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XG5cbmNsYXNzIFNlbGVjdGVkRGlhZ25vc3RpYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpYWdub3N0aWMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgIH1cbn1cbmNsYXNzIExpbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpY3MsIHBhbmVsLCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChkaWFnbm9zdGljcywgcGFuZWwsIHN0YXRlKSB7XG4gICAgICAgIC8vIEZpbHRlciB0aGUgbGlzdCBvZiBkaWFnbm9zdGljcyBmb3Igd2hpY2ggdG8gY3JlYXRlIG1hcmtlcnNcbiAgICAgICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSBzdGF0ZS5mYWNldChsaW50Q29uZmlnKS5tYXJrZXJGaWx0ZXI7XG4gICAgICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljRmlsdGVyKGRpYWdub3N0aWNzLCBzdGF0ZSk7XG4gICAgICAgIGxldCBzb3J0ZWQgPSBkaWFnbm9zdGljcy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50byk7XG4gICAgICAgIGxldCBkZWNvID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpLCBhY3RpdmUgPSBbXSwgcG9zID0gMDtcbiAgICAgICAgbGV0IHNjYW4gPSBzdGF0ZS5kb2MuaXRlcigpLCBzY2FuUG9zID0gMCwgZG9jTGVuID0gc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHNvcnRlZC5sZW5ndGggPyBudWxsIDogc29ydGVkW2ldO1xuICAgICAgICAgICAgaWYgKCFuZXh0ICYmICFhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gcG9zO1xuICAgICAgICAgICAgICAgIHRvID0gYWN0aXZlLnJlZHVjZSgocCwgZCkgPT4gTWF0aC5taW4ocCwgZC50byksIG5leHQgJiYgbmV4dC5mcm9tID4gZnJvbSA/IG5leHQuZnJvbSA6IDFlOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gbmV4dC5mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gZG9jTGVuKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0byA9IG5leHQudG87XG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBzb3J0ZWRbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA9PSBmcm9tICYmIChuZXh0LnRvID4gbmV4dC5mcm9tIHx8IG5leHQudG8gPT0gZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbihuZXh0LnRvLCB0byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKG5leHQuZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkb2NMZW4pO1xuICAgICAgICAgICAgbGV0IHdpZGdldCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5zb21lKGQgPT4gZC5mcm9tID09IGZyb20gJiYgKGQudG8gPT0gdG8gfHwgdG8gPT0gZG9jTGVuKSkpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXQgPSBmcm9tID09IHRvO1xuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0ICYmIHRvIC0gZnJvbSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWhpbmQgPSBmcm9tIC0gKHNjYW5Qb3MgKyBzY2FuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWhpbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuLm5leHQoYmVoaW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5Qb3MgPSBmcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNoZWNrID0gZnJvbTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sgPj0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2FuLmxpbmVCcmVhayAmJiBzY2FuUG9zICsgc2Nhbi52YWx1ZS5sZW5ndGggPiBjaGVjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrID0gc2NhblBvcyArIHNjYW4udmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhblBvcyArPSBzY2FuLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW4ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNldiA9IG1heFNldmVyaXR5KGFjdGl2ZSk7XG4gICAgICAgICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgZGVjby5hZGQoZnJvbSwgZnJvbSwgRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBEaWFnbm9zdGljV2lkZ2V0KHNldiksXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzOiBhY3RpdmUuc2xpY2UoKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrQ2xhc3MgPSBhY3RpdmUucmVkdWNlKChjLCBkKSA9PiBkLm1hcmtDbGFzcyA/IGMgKyBcIiBcIiArIGQubWFya0NsYXNzIDogYywgXCJcIik7XG4gICAgICAgICAgICAgICAgZGVjby5hZGQoZnJvbSwgdG8sIERlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtXCIgKyBzZXYgKyBtYXJrQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzOiBhY3RpdmUuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlRW5kOiBhY3RpdmUuc29tZShhID0+IGEudG8gPiB0bylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgICAgIGlmIChwb3MgPT0gZG9jTGVuKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2V0ID0gZGVjby5maW5pc2goKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW50U3RhdGUoc2V0LCBwYW5lbCwgZmluZERpYWdub3N0aWMoc2V0KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMgPSBudWxsLCBhZnRlciA9IDApIHtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4oYWZ0ZXIsIDFlOSwgKGZyb20sIHRvLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICBpZiAoZGlhZ25vc3RpYyAmJiBzcGVjLmRpYWdub3N0aWNzLmluZGV4T2YoZGlhZ25vc3RpYykgPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgZm91bmQgPSBuZXcgU2VsZWN0ZWREaWFnbm9zdGljKGZyb20sIHRvLCBkaWFnbm9zdGljIHx8IHNwZWMuZGlhZ25vc3RpY3NbMF0pO1xuICAgICAgICBlbHNlIGlmIChzcGVjLmRpYWdub3N0aWNzLmluZGV4T2YoZm91bmQuZGlhZ25vc3RpYykgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3VuZCA9IG5ldyBTZWxlY3RlZERpYWdub3N0aWMoZm91bmQuZnJvbSwgdG8sIGZvdW5kLmRpYWdub3N0aWMpO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGhpZGVUb29sdGlwKHRyLCB0b29sdGlwKSB7XG4gICAgbGV0IGZyb20gPSB0b29sdGlwLnBvcywgdG8gPSB0b29sdGlwLmVuZCB8fCBmcm9tO1xuICAgIGxldCByZXN1bHQgPSB0ci5zdGF0ZS5mYWNldChsaW50Q29uZmlnKS5oaWRlT24odHIsIGZyb20sIHRvKTtcbiAgICBpZiAocmVzdWx0ICE9IG51bGwpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgbGV0IGxpbmUgPSB0ci5zdGFydFN0YXRlLmRvYy5saW5lQXQodG9vbHRpcC5wb3MpO1xuICAgIHJldHVybiAhISh0ci5lZmZlY3RzLnNvbWUoZSA9PiBlLmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkgfHwgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UobGluZS5mcm9tLCBNYXRoLm1heChsaW5lLnRvLCB0bykpKTtcbn1cbmZ1bmN0aW9uIG1heWJlRW5hYmxlTGludChzdGF0ZSwgZWZmZWN0cykge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKSA/IGVmZmVjdHMgOiBlZmZlY3RzLmNvbmNhdChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YobGludEV4dGVuc2lvbnMpKTtcbn1cbi8qKlxuUmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggdXBkYXRlcyB0aGUgY3VycmVudCBzZXQgb2ZcbmRpYWdub3N0aWNzLCBhbmQgZW5hYmxlcyB0aGUgbGludCBleHRlbnNpb24gaWYgaWYgd2Fzbid0IGFscmVhZHlcbmFjdGl2ZS5cbiovXG5mdW5jdGlvbiBzZXREaWFnbm9zdGljcyhzdGF0ZSwgZGlhZ25vc3RpY3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlZmZlY3RzOiBtYXliZUVuYWJsZUxpbnQoc3RhdGUsIFtzZXREaWFnbm9zdGljc0VmZmVjdC5vZihkaWFnbm9zdGljcyldKVxuICAgIH07XG59XG4vKipcblRoZSBzdGF0ZSBlZmZlY3QgdGhhdCB1cGRhdGVzIHRoZSBzZXQgb2YgYWN0aXZlIGRpYWdub3N0aWNzLiBDYW5cbmJlIHVzZWZ1bCB3aGVuIHdyaXRpbmcgYW4gZXh0ZW5zaW9uIHRoYXQgbmVlZHMgdG8gdHJhY2sgdGhlc2UuXG4qL1xuY29uc3Qgc2V0RGlhZ25vc3RpY3NFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IG1vdmVQYW5lbFNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGxpbnRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbnRTdGF0ZShEZWNvcmF0aW9uLm5vbmUsIG51bGwsIG51bGwpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCAmJiB2YWx1ZS5kaWFnbm9zdGljcy5zaXplKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdmFsdWUuZGlhZ25vc3RpY3MubWFwKHRyLmNoYW5nZXMpLCBzZWxlY3RlZCA9IG51bGwsIHBhbmVsID0gdmFsdWUucGFuZWw7XG4gICAgICAgICAgICBpZiAodmFsdWUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsUG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuc2VsZWN0ZWQuZnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBmaW5kRGlhZ25vc3RpYyhtYXBwZWQsIHZhbHVlLnNlbGVjdGVkLmRpYWdub3N0aWMsIHNlbFBvcykgfHwgZmluZERpYWdub3N0aWMobWFwcGVkLCBudWxsLCBzZWxQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXBwZWQuc2l6ZSAmJiBwYW5lbCAmJiB0ci5zdGF0ZS5mYWNldChsaW50Q29uZmlnKS5hdXRvUGFuZWwpXG4gICAgICAgICAgICAgICAgcGFuZWwgPSBudWxsO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKG1hcHBlZCwgcGFuZWwsIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFuZWwgPSAhdHIuc3RhdGUuZmFjZXQobGludENvbmZpZykuYXV0b1BhbmVsID8gdmFsdWUucGFuZWwgOiBlZmZlY3QudmFsdWUubGVuZ3RoID8gTGludFBhbmVsLm9wZW4gOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTGludFN0YXRlLmluaXQoZWZmZWN0LnZhbHVlLCBwYW5lbCwgdHIuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZSh2YWx1ZS5kaWFnbm9zdGljcywgZWZmZWN0LnZhbHVlID8gTGludFBhbmVsLm9wZW4gOiBudWxsLCB2YWx1ZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMobW92ZVBhbmVsU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZSh2YWx1ZS5kaWFnbm9zdGljcywgdmFsdWUucGFuZWwsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBbc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbCksXG4gICAgICAgIEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmLCBzID0+IHMuZGlhZ25vc3RpY3MpXVxufSk7XG4vKipcblJldHVybnMgdGhlIG51bWJlciBvZiBhY3RpdmUgbGludCBkaWFnbm9zdGljcyBpbiB0aGUgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gZGlhZ25vc3RpY0NvdW50KHN0YXRlKSB7XG4gICAgbGV0IGxpbnQgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gbGludCA/IGxpbnQuZGlhZ25vc3RpY3Muc2l6ZSA6IDA7XG59XG5jb25zdCBhY3RpdmVNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtYWN0aXZlXCIgfSk7XG5mdW5jdGlvbiBsaW50VG9vbHRpcCh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBkaWFnbm9zdGljcyB9ID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgIGxldCBmb3VuZCwgc3RhcnQgPSAtMSwgZW5kID0gLTE7XG4gICAgZGlhZ25vc3RpY3MuYmV0d2Vlbihwb3MgLSAoc2lkZSA8IDAgPyAxIDogMCksIHBvcyArIChzaWRlID4gMCA/IDEgOiAwKSwgKGZyb20sIHRvLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICBpZiAocG9zID49IGZyb20gJiYgcG9zIDw9IHRvICYmXG4gICAgICAgICAgICAoZnJvbSA9PSB0byB8fCAoKHBvcyA+IGZyb20gfHwgc2lkZSA+IDApICYmIChwb3MgPCB0byB8fCBzaWRlIDwgMCkpKSkge1xuICAgICAgICAgICAgZm91bmQgPSBzcGVjLmRpYWdub3N0aWNzO1xuICAgICAgICAgICAgc3RhcnQgPSBmcm9tO1xuICAgICAgICAgICAgZW5kID0gdG87XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgZGlhZ25vc3RpY0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludENvbmZpZykudG9vbHRpcEZpbHRlcjtcbiAgICBpZiAoZm91bmQgJiYgZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgZm91bmQgPSBkaWFnbm9zdGljRmlsdGVyKGZvdW5kLCB2aWV3LnN0YXRlKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgYWJvdmU6IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydCkudG8gPCBlbmQsXG4gICAgICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGZvdW5kKSB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpYWdub3N0aWNzVG9vbHRpcCh2aWV3LCBkaWFnbm9zdGljcykge1xuICAgIHJldHVybiBlbHQoXCJ1bFwiLCB7IGNsYXNzOiBcImNtLXRvb2x0aXAtbGludFwiIH0sIGRpYWdub3N0aWNzLm1hcChkID0+IHJlbmRlckRpYWdub3N0aWModmlldywgZCwgZmFsc2UpKSk7XG59XG4vKipcbkNvbW1hbmQgdG8gb3BlbiBhbmQgZm9jdXMgdGhlIGxpbnQgcGFuZWwuXG4qL1xuY29uc3Qgb3BlbkxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlTGludCh2aWV3LnN0YXRlLCBbdG9nZ2xlUGFuZWwub2YodHJ1ZSldKSB9KTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBMaW50UGFuZWwub3Blbik7XG4gICAgaWYgKHBhbmVsKVxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS1wYW5lbC1saW50IHVsXCIpLmZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Db21tYW5kIHRvIGNsb3NlIHRoZSBsaW50IHBhbmVsLCB3aGVuIG9wZW4uXG4qL1xuY29uc3QgY2xvc2VMaW50UGFuZWwgPSAodmlldykgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGRpYWdub3N0aWMuXG4qL1xuY29uc3QgbmV4dERpYWdub3N0aWMgPSAodmlldykgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLCBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcihzZWwudG8gKyAxKTtcbiAgICBpZiAoIW5leHQudmFsdWUpIHtcbiAgICAgICAgbmV4dCA9IGZpZWxkLmRpYWdub3N0aWNzLml0ZXIoMCk7XG4gICAgICAgIGlmICghbmV4dC52YWx1ZSB8fCBuZXh0LmZyb20gPT0gc2VsLmZyb20gJiYgbmV4dC50byA9PSBzZWwudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IHsgYW5jaG9yOiBuZXh0LmZyb20sIGhlYWQ6IG5leHQudG8gfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIGRpYWdub3N0aWMuXG4qL1xuY29uc3QgcHJldmlvdXNEaWFnbm9zdGljID0gKHZpZXcpID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBwcmV2RnJvbSwgcHJldlRvLCBsYXN0RnJvbSwgbGFzdFRvO1xuICAgIGZpZWxkLmRpYWdub3N0aWNzLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGlmICh0byA8IHNlbC50byAmJiAocHJldkZyb20gPT0gbnVsbCB8fCBwcmV2RnJvbSA8IGZyb20pKSB7XG4gICAgICAgICAgICBwcmV2RnJvbSA9IGZyb207XG4gICAgICAgICAgICBwcmV2VG8gPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEZyb20gPT0gbnVsbCB8fCBmcm9tID4gbGFzdEZyb20pIHtcbiAgICAgICAgICAgIGxhc3RGcm9tID0gZnJvbTtcbiAgICAgICAgICAgIGxhc3RUbyA9IHRvO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGxhc3RGcm9tID09IG51bGwgfHwgcHJldkZyb20gPT0gbnVsbCAmJiBsYXN0RnJvbSA9PSBzZWwuZnJvbSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IHsgYW5jaG9yOiBwcmV2RnJvbSAhPT0gbnVsbCAmJiBwcmV2RnJvbSAhPT0gdm9pZCAwID8gcHJldkZyb20gOiBsYXN0RnJvbSwgaGVhZDogcHJldlRvICE9PSBudWxsICYmIHByZXZUbyAhPT0gdm9pZCAwID8gcHJldlRvIDogbGFzdFRvIH0sIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQSBzZXQgb2YgZGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSBsaW50IGZ1bmN0aW9uYWxpdHkuXG5cbi0gQ3RybC1TaGlmdC1tIChDbWQtU2hpZnQtbSBvbiBtYWNPUyk6IFtgb3BlbkxpbnRQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5vcGVuTGludFBhbmVsKVxuLSBGODogW2BuZXh0RGlhZ25vc3RpY2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5uZXh0RGlhZ25vc3RpYylcbiovXG5jb25zdCBsaW50S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIk1vZC1TaGlmdC1tXCIsIHJ1bjogb3BlbkxpbnRQYW5lbCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJGOFwiLCBydW46IG5leHREaWFnbm9zdGljIH1cbl07XG5jb25zdCBsaW50UGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgIGxldCB7IGRlbGF5IH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGRlbGF5O1xuICAgICAgICB0aGlzLnJ1biA9IHRoaXMucnVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ydW4sIGRlbGF5KTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgPCB0aGlzLmxpbnRUaW1lIC0gMTApIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ydW4sIHRoaXMubGludFRpbWUgLSBub3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIHsgc291cmNlcyB9ID0gc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgICAgICBpZiAoc291cmNlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYmF0Y2hSZXN1bHRzKHNvdXJjZXMubWFwKHMgPT4gUHJvbWlzZS5yZXNvbHZlKHModGhpcy52aWV3KSkpLCBhbm5vdGF0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jID09IHN0YXRlLmRvYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChzZXREaWFnbm9zdGljcyh0aGlzLnZpZXcuc3RhdGUsIGFubm90YXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpKSk7XG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4geyBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnJvcik7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IGNvbmZpZyAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsaW50Q29uZmlnKSB8fFxuICAgICAgICAgICAgY29uZmlnLm5lZWRzUmVmcmVzaCAmJiBjb25maWcubmVlZHNSZWZyZXNoKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpICsgY29uZmlnLmRlbGF5O1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCBjb25maWcuZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvcmNlKCkge1xuICAgICAgICBpZiAodGhpcy5zZXQpIHtcbiAgICAgICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGJhdGNoUmVzdWx0cyhwcm9taXNlcywgc2luaywgZXJyb3IpIHtcbiAgICBsZXQgY29sbGVjdGVkID0gW10sIHRpbWVvdXQgPSAtMTtcbiAgICBmb3IgKGxldCBwIG9mIHByb21pc2VzKVxuICAgICAgICBwLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgY29sbGVjdGVkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKGNvbGxlY3RlZC5sZW5ndGggPT0gcHJvbWlzZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHNpbmsoY29sbGVjdGVkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzaW5rKGNvbGxlY3RlZCksIDIwMCk7XG4gICAgICAgIH0sIGVycm9yKTtcbn1cbmNvbnN0IGxpbnRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2VzOiBpbnB1dC5tYXAoaSA9PiBpLnNvdXJjZSkuZmlsdGVyKHggPT4geCAhPSBudWxsKSxcbiAgICAgICAgICAgIC4uLmNvbWJpbmVDb25maWcoaW5wdXQubWFwKGkgPT4gaS5jb25maWcpLCB7XG4gICAgICAgICAgICAgICAgZGVsYXk6IDc1MCxcbiAgICAgICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgdG9vbHRpcEZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICBuZWVkc1JlZnJlc2g6IG51bGwsXG4gICAgICAgICAgICAgICAgaGlkZU9uOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGRlbGF5OiBNYXRoLm1heCxcbiAgICAgICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IGNvbWJpbmVGaWx0ZXIsXG4gICAgICAgICAgICAgICAgdG9vbHRpcEZpbHRlcjogY29tYmluZUZpbHRlcixcbiAgICAgICAgICAgICAgICBuZWVkc1JlZnJlc2g6IChhLCBiKSA9PiAhYSA/IGIgOiAhYiA/IGEgOiB1ID0+IGEodSkgfHwgYih1KSxcbiAgICAgICAgICAgICAgICBoaWRlT246IChhLCBiKSA9PiAhYSA/IGIgOiAhYiA/IGEgOiAodCwgeCwgeSkgPT4gYSh0LCB4LCB5KSB8fCBiKHQsIHgsIHkpLFxuICAgICAgICAgICAgICAgIGF1dG9QYW5lbDogKGEsIGIpID0+IGEgfHwgYlxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGNvbWJpbmVGaWx0ZXIoYSwgYikge1xuICAgIHJldHVybiAhYSA/IGIgOiAhYiA/IGEgOiAoZCwgcykgPT4gYihhKGQsIHMpLCBzKTtcbn1cbi8qKlxuR2l2ZW4gYSBkaWFnbm9zdGljIHNvdXJjZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0XG5lbmFibGVzIGxpbnRpbmcgd2l0aCB0aGF0IHNvdXJjZS4gSXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlXG5lZGl0b3IgaXMgaWRsZSAoYWZ0ZXIgaXRzIGNvbnRlbnQgY2hhbmdlZCkuXG5cbk5vdGUgdGhhdCBzZXR0aW5ncyBnaXZlbiBoZXJlIHdpbGwgYXBwbHkgdG8gYWxsIGxpbnRlcnMgYWN0aXZlIGluXG50aGUgZWRpdG9yLiBJZiBgbnVsbGAgaXMgZ2l2ZW4gYXMgc291cmNlLCB0aGlzIG9ubHkgY29uZmlndXJlcyB0aGVcbmxpbnQgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbnRlcihzb3VyY2UsIGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGludENvbmZpZy5vZih7IHNvdXJjZSwgY29uZmlnIH0pLFxuICAgICAgICBsaW50UGx1Z2luLFxuICAgICAgICBsaW50RXh0ZW5zaW9uc1xuICAgIF07XG59XG4vKipcbkZvcmNlcyBhbnkgbGludGVycyBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50LmxpbnRlcikgdG8gcnVuIHdoZW4gdGhlXG5lZGl0b3IgaXMgaWRsZSB0byBydW4gcmlnaHQgYXdheS5cbiovXG5mdW5jdGlvbiBmb3JjZUxpbnRpbmcodmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihsaW50UGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4uZm9yY2UoKTtcbn1cbmZ1bmN0aW9uIGFzc2lnbktleXMoYWN0aW9ucykge1xuICAgIGxldCBhc3NpZ25lZCA9IFtdO1xuICAgIGlmIChhY3Rpb25zKVxuICAgICAgICBhY3Rpb25zOiBmb3IgKGxldCB7IG5hbWUgfSBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBuYW1lW2ldO1xuICAgICAgICAgICAgICAgIGlmICgvW2EtekEtWl0vLnRlc3QoY2gpICYmICFhc3NpZ25lZC5zb21lKGMgPT4gYy50b0xvd2VyQ2FzZSgpID09IGNoLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBhY3Rpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnbmVkLnB1c2goXCJcIik7XG4gICAgICAgIH1cbiAgICByZXR1cm4gYXNzaWduZWQ7XG59XG5mdW5jdGlvbiByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGRpYWdub3N0aWMsIGluUGFuZWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGtleXMgPSBpblBhbmVsID8gYXNzaWduS2V5cyhkaWFnbm9zdGljLmFjdGlvbnMpIDogW107XG4gICAgcmV0dXJuIGVsdChcImxpXCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpYyBjbS1kaWFnbm9zdGljLVwiICsgZGlhZ25vc3RpYy5zZXZlcml0eSB9LCBlbHQoXCJzcGFuXCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1RleHRcIiB9LCBkaWFnbm9zdGljLnJlbmRlck1lc3NhZ2UgPyBkaWFnbm9zdGljLnJlbmRlck1lc3NhZ2UodmlldykgOiBkaWFnbm9zdGljLm1lc3NhZ2UpLCAoX2EgPSBkaWFnbm9zdGljLmFjdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGFjdGlvbiwgaSkgPT4ge1xuICAgICAgICBsZXQgZmlyZWQgPSBmYWxzZSwgY2xpY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGZpcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgYWN0aW9uLmFwcGx5KHZpZXcsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgbmFtZSB9ID0gYWN0aW9uLCBrZXlJbmRleCA9IGtleXNbaV0gPyBuYW1lLmluZGV4T2Yoa2V5c1tpXSkgOiAtMTtcbiAgICAgICAgbGV0IG5hbWVFbHQgPSBrZXlJbmRleCA8IDAgPyBuYW1lIDogW25hbWUuc2xpY2UoMCwga2V5SW5kZXgpLFxuICAgICAgICAgICAgZWx0KFwidVwiLCBuYW1lLnNsaWNlKGtleUluZGV4LCBrZXlJbmRleCArIDEpKSxcbiAgICAgICAgICAgIG5hbWUuc2xpY2Uoa2V5SW5kZXggKyAxKV07XG4gICAgICAgIGxldCBtYXJrQ2xhc3MgPSBhY3Rpb24ubWFya0NsYXNzID8gXCIgXCIgKyBhY3Rpb24ubWFya0NsYXNzIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tZGlhZ25vc3RpY0FjdGlvblwiICsgbWFya0NsYXNzLFxuICAgICAgICAgICAgb25jbGljazogY2xpY2ssXG4gICAgICAgICAgICBvbm1vdXNlZG93bjogY2xpY2ssXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogYCBBY3Rpb246ICR7bmFtZX0ke2tleUluZGV4IDwgMCA/IFwiXCIgOiBgIChhY2Nlc3Mga2V5IFwiJHtrZXlzW2ldfSlcImB9LmBcbiAgICAgICAgfSwgbmFtZUVsdCk7XG4gICAgfSksIGRpYWdub3N0aWMuc291cmNlICYmIGVsdChcImRpdlwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWNTb3VyY2VcIiB9LCBkaWFnbm9zdGljLnNvdXJjZSkpO1xufVxuY2xhc3MgRGlhZ25vc3RpY1dpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNldikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNldiA9IHNldjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNldiA9PSB0aGlzLnNldjsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICByZXR1cm4gZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWxpbnRQb2ludCBjbS1saW50UG9pbnQtXCIgKyB0aGlzLnNldiB9KTtcbiAgICB9XG59XG5jbGFzcyBQYW5lbEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGRpYWdub3N0aWMpIHtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gZGlhZ25vc3RpYztcbiAgICAgICAgdGhpcy5pZCA9IFwiaXRlbV9cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdGhpcy5kb20gPSByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGRpYWdub3N0aWMsIHRydWUpO1xuICAgICAgICB0aGlzLmRvbS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgfVxufVxuY2xhc3MgTGludFBhbmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgbGV0IG9ua2V5ZG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgY2xvc2VMaW50UGFuZWwodGhpcy52aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzggfHwgZXZlbnQua2V5Q29kZSA9PSAzMykgeyAvLyBBcnJvd1VwLCBQYWdlVXBcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oKHRoaXMuc2VsZWN0ZWRJbmRleCAtIDEgKyB0aGlzLml0ZW1zLmxlbmd0aCkgJSB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDQwIHx8IGV2ZW50LmtleUNvZGUgPT0gMzQpIHsgLy8gQXJyb3dEb3duLCBQYWdlRG93blxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigodGhpcy5zZWxlY3RlZEluZGV4ICsgMSkgJSB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM2KSB7IC8vIEhvbWVcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM1KSB7IC8vIEVuZFxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbih0aGlzLml0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA+PSA2NSAmJiBldmVudC5rZXlDb2RlIDw9IDkwICYmIHRoaXMuc2VsZWN0ZWRJbmRleCA+PSAwKSB7IC8vIEEtWlxuICAgICAgICAgICAgICAgIGxldCB7IGRpYWdub3N0aWMgfSA9IHRoaXMuaXRlbXNbdGhpcy5zZWxlY3RlZEluZGV4XSwga2V5cyA9IGFzc2lnbktleXMoZGlhZ25vc3RpYy5hY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzW2ldLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKSA9PSBldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5kaWFnbm9zdGljcywgZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpYy5hY3Rpb25zW2ldLmFwcGx5KHZpZXcsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdCA9IGVsdChcInVsXCIsIHtcbiAgICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgICAgcm9sZTogXCJsaXN0Ym94XCIsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkRpYWdub3N0aWNzXCIpLFxuICAgICAgICAgICAgb25rZXlkb3duLFxuICAgICAgICAgICAgb25jbGlja1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb20gPSBlbHQoXCJkaXZcIiwgeyBjbGFzczogXCJjbS1wYW5lbC1saW50XCIgfSwgdGhpcy5saXN0LCBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIG5hbWU6IFwiY2xvc2VcIixcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiY2xvc2VcIiksXG4gICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZUxpbnRQYW5lbCh0aGlzLnZpZXcpXG4gICAgICAgIH0sIFwiw5dcIikpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRJbmRleCgpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuc2VsZWN0ZWQ7XG4gICAgICAgIGlmICghc2VsZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ldLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGxldCB7IGRpYWdub3N0aWNzLCBzZWxlY3RlZCB9ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIGxldCBpID0gMCwgbmVlZHNTeW5jID0gZmFsc2UsIG5ld1NlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgIGxldCBzZWVuID0gbmV3IFNldCgpO1xuICAgICAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKDAsIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAoX3N0YXJ0LCBfZW5kLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZGlhZ25vc3RpYyBvZiBzcGVjLmRpYWdub3N0aWNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaGFzKGRpYWdub3N0aWMpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBzZWVuLmFkZChkaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSAtMSwgaXRlbTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuaXRlbXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2pdLmRpYWdub3N0aWMgPT0gZGlhZ25vc3RpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXcgUGFuZWxJdGVtKHRoaXMudmlldywgZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbZm91bmRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCBmb3VuZCAtIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgaXRlbS5kaWFnbm9zdGljID09IHNlbGVjdGVkLmRpYWdub3N0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5kb20uaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuaXRlbXMubGVuZ3RoICYmICEodGhpcy5pdGVtcy5sZW5ndGggPT0gMSAmJiB0aGlzLml0ZW1zWzBdLmRpYWdub3N0aWMuZnJvbSA8IDApKSB7XG4gICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBQYW5lbEl0ZW0odGhpcy52aWV3LCB7XG4gICAgICAgICAgICAgICAgZnJvbTogLTEsIHRvOiAtMSxcbiAgICAgICAgICAgICAgICBzZXZlcml0eTogXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIk5vIGRpYWdub3N0aWNzXCIpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgbmV3U2VsZWN0ZWRJdGVtLmlkKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh7XG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLFxuICAgICAgICAgICAgICAgIHJlYWQ6ICgpID0+ICh7IHNlbDogbmV3U2VsZWN0ZWRJdGVtLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgcGFuZWw6IHRoaXMubGlzdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9KSxcbiAgICAgICAgICAgICAgICB3cml0ZTogKHsgc2VsLCBwYW5lbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZVkgPSBwYW5lbC5oZWlnaHQgLyB0aGlzLmxpc3Qub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsLnRvcCA8IHBhbmVsLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgLT0gKHBhbmVsLnRvcCAtIHNlbC50b3ApIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWwuYm90dG9tID4gcGFuZWwuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCArPSAoc2VsLmJvdHRvbSAtIHBhbmVsLmJvdHRvbSkgLyBzY2FsZVk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZHNTeW5jKVxuICAgICAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGxldCBkb21Qb3MgPSB0aGlzLmxpc3QuZmlyc3RDaGlsZDtcbiAgICAgICAgZnVuY3Rpb24gcm0oKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGRvbVBvcztcbiAgICAgICAgICAgIGRvbVBvcyA9IHByZXYubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBwcmV2LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5saXN0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbVBvcyAhPSBpdGVtLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICAgICAgICBkb21Qb3MgPSBpdGVtLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5pbnNlcnRCZWZvcmUoaXRlbS5kb20sIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRvbVBvcylcbiAgICAgICAgICAgIHJtKCk7XG4gICAgfVxuICAgIG1vdmVTZWxlY3Rpb24oc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGZpZWxkID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBmaW5kRGlhZ25vc3RpYyhmaWVsZC5kaWFnbm9zdGljcywgdGhpcy5pdGVtc1tzZWxlY3RlZEluZGV4XS5kaWFnbm9zdGljKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBzZWxlY3Rpb24uZnJvbSwgaGVhZDogc2VsZWN0aW9uLnRvIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIGVmZmVjdHM6IG1vdmVQYW5lbFNlbGVjdGlvbi5vZihzZWxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgb3Blbih2aWV3KSB7IHJldHVybiBuZXcgTGludFBhbmVsKHZpZXcpOyB9XG59XG5mdW5jdGlvbiBzdmcoY29udGVudCwgYXR0cnMgPSBgdmlld0JveD1cIjAgMCA0MCA0MFwiYCkge1xuICAgIHJldHVybiBgdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJHthdHRyc30+JHtlbmNvZGVVUklDb21wb25lbnQoY29udGVudCl9PC9zdmc+JylgO1xufVxuZnVuY3Rpb24gdW5kZXJsaW5lKGNvbG9yKSB7XG4gICAgcmV0dXJuIHN2ZyhgPHBhdGggZD1cIm0wIDIuNSBsMiAtMS41IGwxIDAgbDIgMS41IGwxIDBcIiBzdHJva2U9XCIke2NvbG9yfVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiLjdcIi8+YCwgYHdpZHRoPVwiNlwiIGhlaWdodD1cIjNcImApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1kaWFnbm9zdGljXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIzcHggNnB4IDNweCA4cHhcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMXB4XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiXG4gICAgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWVycm9yXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgI2QxMVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy13YXJuaW5nXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgb3JhbmdlXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWluZm9cIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjOTk5XCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWhpbnRcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjNjZkXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljQWN0aW9uXCI6IHtcbiAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzQ0NFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiM3B4XCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiOHB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWNTb3VyY2VcIjoge1xuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgb3BhY2l0eTogLjdcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJsZWZ0IGJvdHRvbVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcInJlcGVhdC14XCIsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IFwiMC43cHhcIixcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1lcnJvclwiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIiNkMTFcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2Utd2FybmluZ1wiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIm9yYW5nZVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1pbmZvXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiIzk5OVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1oaW50XCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiIzY2ZFwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1hY3RpdmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZGQ5OTgwXCIgfSxcbiAgICBcIi5jbS10b29sdGlwLWxpbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBtYXJnaW46IDBcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgbGVmdDogXCItMnB4XCIsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBcIjNweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IFwiM3B4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b206IFwiNHB4IHNvbGlkICNkMTFcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnQtd2FybmluZ1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIm9yYW5nZVwiIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC1pbmZvXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzk5OVwiIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC1oaW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzY2ZFwiIH1cbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsLmNtLXBhbmVsLWxpbnRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgdWxcIjoge1xuICAgICAgICAgICAgbWF4SGVpZ2h0OiBcIjEwMHB4XCIsXG4gICAgICAgICAgICBvdmVyZmxvd1k6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCImIFthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNkZGRcIixcbiAgICAgICAgICAgICAgICBcIiYgdVwiOiB7IHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6Zm9jdXMgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kX2ZhbGxiYWNrOiBcIiNiZGZcIixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiSGlnaGxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgY29sb3JfZmFsbGJhY2s6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJIaWdobGlnaHRUZXh0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgdVwiOiB7IHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiMnB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuZnVuY3Rpb24gc2V2ZXJpdHlXZWlnaHQoc2V2KSB7XG4gICAgcmV0dXJuIHNldiA9PSBcImVycm9yXCIgPyA0IDogc2V2ID09IFwid2FybmluZ1wiID8gMyA6IHNldiA9PSBcImluZm9cIiA/IDIgOiAxO1xufVxuZnVuY3Rpb24gbWF4U2V2ZXJpdHkoZGlhZ25vc3RpY3MpIHtcbiAgICBsZXQgc2V2ID0gXCJoaW50XCIsIHdlaWdodCA9IDE7XG4gICAgZm9yIChsZXQgZCBvZiBkaWFnbm9zdGljcykge1xuICAgICAgICBsZXQgdyA9IHNldmVyaXR5V2VpZ2h0KGQuc2V2ZXJpdHkpO1xuICAgICAgICBpZiAodyA+IHdlaWdodCkge1xuICAgICAgICAgICAgd2VpZ2h0ID0gdztcbiAgICAgICAgICAgIHNldiA9IGQuc2V2ZXJpdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldjtcbn1cbmNsYXNzIExpbnRHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKGRpYWdub3N0aWNzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgdGhpcy5zZXZlcml0eSA9IG1heFNldmVyaXR5KGRpYWdub3N0aWNzKTtcbiAgICB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IFwiY20tbGludC1tYXJrZXIgY20tbGludC1tYXJrZXItXCIgKyB0aGlzLnNldmVyaXR5O1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSB0aGlzLmRpYWdub3N0aWNzO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3NGaWx0ZXIgPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpLnRvb2x0aXBGaWx0ZXI7XG4gICAgICAgIGlmIChkaWFnbm9zdGljc0ZpbHRlcilcbiAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3NGaWx0ZXIoZGlhZ25vc3RpY3MsIHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoKVxuICAgICAgICAgICAgZWx0Lm9ubW91c2VvdmVyID0gKCkgPT4gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIGVsdCwgZGlhZ25vc3RpY3MpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpIHtcbiAgICBsZXQgbW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCByZWN0ID0gbWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCA+IHJlY3QubGVmdCAtIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJiBldmVudC5jbGllbnRYIDwgcmVjdC5yaWdodCArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJlxuICAgICAgICAgICAgZXZlbnQuY2xpZW50WSA+IHJlY3QudG9wIC0gMTAgLyogSG92ZXIuTWFyZ2luICovICYmIGV2ZW50LmNsaWVudFkgPCByZWN0LmJvdHRvbSArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OyB0YXJnZXQ7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImNtLXRvb2x0aXAtbGludFwiKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlKTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQobGludEd1dHRlclRvb2x0aXApKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKG51bGwpIH0pO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlKTtcbn1cbmZ1bmN0aW9uIGd1dHRlck1hcmtlck1vdXNlT3Zlcih2aWV3LCBtYXJrZXIsIGRpYWdub3N0aWNzKSB7XG4gICAgZnVuY3Rpb24gaG92ZXJlZCgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmVsZW1lbnRBdEhlaWdodChtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgNSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICBjb25zdCBsaW5lUG9zID0gdmlldy5jb29yZHNBdFBvcyhsaW5lLmZyb20pO1xuICAgICAgICBpZiAobGluZVBvcykge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBsaW5lLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGFib3ZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xpcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZGlhZ25vc3RpY3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldENvb3JkczogKCkgPT4gbWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLm9ubW91c2VvdXQgPSBtYXJrZXIub25tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgICB0cmFja0hvdmVyT24odmlldywgbWFya2VyKTtcbiAgICB9XG4gICAgbGV0IHsgaG92ZXJUaW1lIH0gPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpO1xuICAgIGxldCBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGhvdmVyZWQsIGhvdmVyVGltZSk7XG4gICAgbWFya2VyLm9ubW91c2VvdXQgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICBtYXJrZXIub25tb3VzZW91dCA9IG1hcmtlci5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgfTtcbiAgICBtYXJrZXIub25tb3VzZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVvdXQpO1xuICAgICAgICBob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KGhvdmVyZWQsIGhvdmVyVGltZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtlcnNGb3JEaWFnbm9zdGljcyhkb2MsIGRpYWdub3N0aWNzKSB7XG4gICAgbGV0IGJ5TGluZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgZGlhZ25vc3RpYyBvZiBkaWFnbm9zdGljcykge1xuICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQoZGlhZ25vc3RpYy5mcm9tKTtcbiAgICAgICAgKGJ5TGluZVtsaW5lLmZyb21dIHx8IChieUxpbmVbbGluZS5mcm9tXSA9IFtdKSkucHVzaChkaWFnbm9zdGljKTtcbiAgICB9XG4gICAgbGV0IG1hcmtlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIGluIGJ5TGluZSkge1xuICAgICAgICBtYXJrZXJzLnB1c2gobmV3IExpbnRHdXR0ZXJNYXJrZXIoYnlMaW5lW2xpbmVdKS5yYW5nZSgrbGluZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUmFuZ2VTZXQub2YobWFya2VycywgdHJ1ZSk7XG59XG5jb25zdCBsaW50R3V0dGVyRXh0ZW5zaW9uID0gLypAX19QVVJFX18qL2d1dHRlcih7XG4gICAgY2xhc3M6IFwiY20tZ3V0dGVyLWxpbnRcIixcbiAgICBtYXJrZXJzOiB2aWV3ID0+IHZpZXcuc3RhdGUuZmllbGQobGludEd1dHRlck1hcmtlcnMpLFxuICAgIHdpZGdldE1hcmtlcjogKHZpZXcsIHdpZGdldCwgYmxvY2spID0+IHtcbiAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gW107XG4gICAgICAgIHZpZXcuc3RhdGUuZmllbGQobGludEd1dHRlck1hcmtlcnMpLmJldHdlZW4oYmxvY2suZnJvbSwgYmxvY2sudG8sIChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gYmxvY2suZnJvbSAmJiBmcm9tIDwgYmxvY2sudG8pXG4gICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MucHVzaCguLi52YWx1ZS5kaWFnbm9zdGljcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3MubGVuZ3RoID8gbmV3IExpbnRHdXR0ZXJNYXJrZXIoZGlhZ25vc3RpY3MpIDogbnVsbDtcbiAgICB9XG59KTtcbmNvbnN0IGxpbnRHdXR0ZXJNYXJrZXJzID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShtYXJrZXJzLCB0cikge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdHIuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykubWFya2VyRmlsdGVyO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY0ZpbHRlcihkaWFnbm9zdGljcyB8fCBbXSwgdHIuc3RhdGUpO1xuICAgICAgICAgICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzRm9yRGlhZ25vc3RpY3ModHIuc3RhdGUuZG9jLCBkaWFnbm9zdGljcy5zbGljZSgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfVxufSk7XG5jb25zdCBzZXRMaW50R3V0dGVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGxpbnRHdXR0ZXJUb29sdGlwID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZSh0b29sdGlwLCB0cikge1xuICAgICAgICBpZiAodG9vbHRpcCAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdG9vbHRpcCA9IGhpZGVUb29sdGlwKHRyLCB0b29sdGlwKSA/IG51bGwgOiB7IC4uLnRvb2x0aXAsIHBvczogdHIuY2hhbmdlcy5tYXBQb3ModG9vbHRpcC5wb3MpIH07XG4gICAgICAgIHJldHVybiB0ci5lZmZlY3RzLnJlZHVjZSgodCwgZSkgPT4gZS5pcyhzZXRMaW50R3V0dGVyVG9vbHRpcCkgPyBlLnZhbHVlIDogdCwgdG9vbHRpcCk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmaWVsZCA9PiBzaG93VG9vbHRpcC5mcm9tKGZpZWxkKVxufSk7XG5jb25zdCBsaW50R3V0dGVyVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWd1dHRlci1saW50XCI6IHtcbiAgICAgICAgd2lkdGg6IFwiMS40ZW1cIixcbiAgICAgICAgXCImIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiLjJlbVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyXCI6IHtcbiAgICAgICAgd2lkdGg6IFwiMWVtXCIsXG4gICAgICAgIGhlaWdodDogXCIxZW1cIlxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItaW5mb1wiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxwYXRoIGZpbGw9XCIjYWFmXCIgc3Ryb2tlPVwiIzc3ZVwiIHN0cm9rZS13aWR0aD1cIjZcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNSA1TDM1IDVMMzUgMzVMNSAzNVpcIi8+YClcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLXdhcm5pbmdcIjoge1xuICAgICAgICBjb250ZW50OiAvKkBfX1BVUkVfXyovc3ZnKGA8cGF0aCBmaWxsPVwiI2ZlOFwiIHN0cm9rZT1cIiNmZDdcIiBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTIwIDZMMzcgMzVMMyAzNVpcIi8+YCksXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1lcnJvclwiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxjaXJjbGUgY3g9XCIyMFwiIGN5PVwiMjBcIiByPVwiMTVcIiBmaWxsPVwiI2Y4N1wiIHN0cm9rZT1cIiNmNDNcIiBzdHJva2Utd2lkdGg9XCI2XCIvPmApXG4gICAgfSxcbn0pO1xuY29uc3QgbGludEV4dGVuc2lvbnMgPSBbXG4gICAgbGludFN0YXRlLFxuICAgIC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRlY29yYXRpb25zLmNvbXB1dGUoW2xpbnRTdGF0ZV0sIHN0YXRlID0+IHtcbiAgICAgICAgbGV0IHsgc2VsZWN0ZWQsIHBhbmVsIH0gPSBzdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICByZXR1cm4gIXNlbGVjdGVkIHx8ICFwYW5lbCB8fCBzZWxlY3RlZC5mcm9tID09IHNlbGVjdGVkLnRvID8gRGVjb3JhdGlvbi5ub25lIDogRGVjb3JhdGlvbi5zZXQoW1xuICAgICAgICAgICAgYWN0aXZlTWFyay5yYW5nZShzZWxlY3RlZC5mcm9tLCBzZWxlY3RlZC50bylcbiAgICAgICAgXSk7XG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL2hvdmVyVG9vbHRpcChsaW50VG9vbHRpcCwgeyBoaWRlT246IGhpZGVUb29sdGlwIH0pLFxuICAgIGJhc2VUaGVtZVxuXTtcbmNvbnN0IGxpbnRHdXR0ZXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgaG92ZXJUaW1lOiAzMDAgLyogSG92ZXIuVGltZSAqLyxcbiAgICAgICAgICAgIG1hcmtlckZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgYSBndXR0ZXIgc2hvd2luZyBtYXJrZXJzIGZvclxuZWFjaCBsaW5lIHRoYXQgaGFzIGRpYWdub3N0aWNzLCB3aGljaCBjYW4gYmUgaG92ZXJlZCBvdmVyIHRvIHNlZVxudGhlIGRpYWdub3N0aWNzLlxuKi9cbmZ1bmN0aW9uIGxpbnRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2xpbnRHdXR0ZXJDb25maWcub2YoY29uZmlnKSwgbGludEd1dHRlck1hcmtlcnMsIGxpbnRHdXR0ZXJFeHRlbnNpb24sIGxpbnRHdXR0ZXJUaGVtZSwgbGludEd1dHRlclRvb2x0aXBdO1xufVxuLyoqXG5JdGVyYXRlIG92ZXIgdGhlIG1hcmtlZCBkaWFnbm9zdGljcyBmb3IgdGhlIGdpdmVuIGVkaXRvciBzdGF0ZSxcbmNhbGxpbmcgYGZgIGZvciBlYWNoIG9mIHRoZW0uIE5vdGUgdGhhdCwgaWYgdGhlIGRvY3VtZW50IGNoYW5nZWRcbnNpbmNlIHRoZSBkaWFnbm9zdGljcyB3ZXJlIGNyZWF0ZWQsIHRoZSBgRGlhZ25vc3RpY2Agb2JqZWN0IHdpbGxcbmhvbGQgdGhlIG9yaWdpbmFsIG91dGRhdGVkIHBvc2l0aW9uLCB3aGVyZWFzIHRoZSBgdG9gIGFuZCBgZnJvbWBcbmFyZ3VtZW50cyBob2xkIHRoZSBkaWFnbm9zdGljJ3MgY3VycmVudCBwb3NpdGlvbi5cbiovXG5mdW5jdGlvbiBmb3JFYWNoRGlhZ25vc3RpYyhzdGF0ZSwgZikge1xuICAgIGxldCBsU3RhdGUgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAobFN0YXRlICYmIGxTdGF0ZS5kaWFnbm9zdGljcy5zaXplKSB7XG4gICAgICAgIGxldCBwZW5kaW5nID0gW10sIHBlbmRpbmdTdGFydCA9IFtdLCBsYXN0RW5kID0gLTE7XG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSBSYW5nZVNldC5pdGVyKFtsU3RhdGUuZGlhZ25vc3RpY3NdKTs7IGl0ZXIubmV4dCgpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVyLnZhbHVlIHx8IGl0ZXIudmFsdWUuc3BlYy5kaWFnbm9zdGljcy5pbmRleE9mKHBlbmRpbmdbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBmKHBlbmRpbmdbaV0sIHBlbmRpbmdTdGFydFtpXSwgbGFzdEVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nU3RhcnQuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpdGVyLnZhbHVlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBpdGVyLnZhbHVlLnNwZWMuZGlhZ25vc3RpY3MpXG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcuaW5kZXhPZihkKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5wdXNoKGQpO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nU3RhcnQucHVzaChpdGVyLmZyb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RFbmQgPSBpdGVyLnRvO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBjbG9zZUxpbnRQYW5lbCwgZGlhZ25vc3RpY0NvdW50LCBmb3JFYWNoRGlhZ25vc3RpYywgZm9yY2VMaW50aW5nLCBsaW50R3V0dGVyLCBsaW50S2V5bWFwLCBsaW50ZXIsIG5leHREaWFnbm9zdGljLCBvcGVuTGludFBhbmVsLCBwcmV2aW91c0RpYWdub3N0aWMsIHNldERpYWdub3N0aWNzLCBzZXREaWFnbm9zdGljc0VmZmVjdCB9O1xuIl0sIm5hbWVzIjpbIkRlY29yYXRpb24iLCJzaG93UGFuZWwiLCJFZGl0b3JWaWV3IiwiVmlld1BsdWdpbiIsImd1dHRlciIsInNob3dUb29sdGlwIiwiaG92ZXJUb29sdGlwIiwiZ2V0UGFuZWwiLCJsb2dFeGNlcHRpb24iLCJXaWRnZXRUeXBlIiwiR3V0dGVyTWFya2VyIiwiU3RhdGVFZmZlY3QiLCJTdGF0ZUZpZWxkIiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiUmFuZ2VTZXQiLCJSYW5nZVNldEJ1aWxkZXIiLCJlbHQiLCJTZWxlY3RlZERpYWdub3N0aWMiLCJjb25zdHJ1Y3RvciIsImZyb20iLCJ0byIsImRpYWdub3N0aWMiLCJMaW50U3RhdGUiLCJkaWFnbm9zdGljcyIsInBhbmVsIiwic2VsZWN0ZWQiLCJpbml0Iiwic3RhdGUiLCJkaWFnbm9zdGljRmlsdGVyIiwiZmFjZXQiLCJsaW50Q29uZmlnIiwibWFya2VyRmlsdGVyIiwic29ydGVkIiwic2xpY2UiLCJzb3J0IiwiYSIsImIiLCJkZWNvIiwiYWN0aXZlIiwicG9zIiwic2NhbiIsImRvYyIsIml0ZXIiLCJzY2FuUG9zIiwiZG9jTGVuIiwibGVuZ3RoIiwiaSIsIm5leHQiLCJyZWR1Y2UiLCJwIiwiZCIsIk1hdGgiLCJtaW4iLCJwdXNoIiwid2lkZ2V0Iiwic29tZSIsImJlaGluZCIsInZhbHVlIiwiY2hlY2siLCJsaW5lQnJlYWsiLCJzZXYiLCJtYXhTZXZlcml0eSIsImFkZCIsIkRpYWdub3N0aWNXaWRnZXQiLCJtYXJrQ2xhc3MiLCJjIiwibWFyayIsImNsYXNzIiwiaW5jbHVzaXZlRW5kIiwic3BsaWNlIiwic2V0IiwiZmluaXNoIiwiZmluZERpYWdub3N0aWMiLCJhZnRlciIsImZvdW5kIiwiYmV0d2VlbiIsInNwZWMiLCJpbmRleE9mIiwiaGlkZVRvb2x0aXAiLCJ0ciIsInRvb2x0aXAiLCJlbmQiLCJyZXN1bHQiLCJoaWRlT24iLCJsaW5lIiwic3RhcnRTdGF0ZSIsImxpbmVBdCIsImVmZmVjdHMiLCJlIiwiaXMiLCJzZXREaWFnbm9zdGljc0VmZmVjdCIsImNoYW5nZXMiLCJ0b3VjaGVzUmFuZ2UiLCJtYXgiLCJtYXliZUVuYWJsZUxpbnQiLCJmaWVsZCIsImxpbnRTdGF0ZSIsImNvbmNhdCIsImFwcGVuZENvbmZpZyIsIm9mIiwibGludEV4dGVuc2lvbnMiLCJzZXREaWFnbm9zdGljcyIsImRlZmluZSIsInRvZ2dsZVBhbmVsIiwibW92ZVBhbmVsU2VsZWN0aW9uIiwiY3JlYXRlIiwibm9uZSIsInVwZGF0ZSIsImRvY0NoYW5nZWQiLCJzaXplIiwibWFwcGVkIiwibWFwIiwic2VsUG9zIiwibWFwUG9zIiwiYXV0b1BhbmVsIiwiZWZmZWN0IiwiTGludFBhbmVsIiwib3BlbiIsInByb3ZpZGUiLCJmIiwidmFsIiwiZGVjb3JhdGlvbnMiLCJzIiwiZGlhZ25vc3RpY0NvdW50IiwibGludCIsImFjdGl2ZU1hcmsiLCJsaW50VG9vbHRpcCIsInZpZXciLCJzaWRlIiwic3RhcnQiLCJ0b29sdGlwRmlsdGVyIiwiYWJvdmUiLCJkb20iLCJkaWFnbm9zdGljc1Rvb2x0aXAiLCJyZW5kZXJEaWFnbm9zdGljIiwib3BlbkxpbnRQYW5lbCIsImRpc3BhdGNoIiwicXVlcnlTZWxlY3RvciIsImZvY3VzIiwiY2xvc2VMaW50UGFuZWwiLCJuZXh0RGlhZ25vc3RpYyIsInNlbCIsInNlbGVjdGlvbiIsIm1haW4iLCJhbmNob3IiLCJoZWFkIiwic2Nyb2xsSW50b1ZpZXciLCJwcmV2aW91c0RpYWdub3N0aWMiLCJwcmV2RnJvbSIsInByZXZUbyIsImxhc3RGcm9tIiwibGFzdFRvIiwibGludEtleW1hcCIsImtleSIsInJ1biIsInByZXZlbnREZWZhdWx0IiwibGludFBsdWdpbiIsImZyb21DbGFzcyIsInRpbWVvdXQiLCJkZWxheSIsImxpbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImJpbmQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic291cmNlcyIsImJhdGNoUmVzdWx0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwiYW5ub3RhdGlvbnMiLCJlcnJvciIsImNvbmZpZyIsIm5lZWRzUmVmcmVzaCIsImZvcmNlIiwiZGVzdHJveSIsInByb21pc2VzIiwic2luayIsImNvbGxlY3RlZCIsInRoZW4iLCJjb21iaW5lIiwiaW5wdXQiLCJzb3VyY2UiLCJmaWx0ZXIiLCJ4IiwiY29tYmluZUZpbHRlciIsInUiLCJ0IiwieSIsImxpbnRlciIsImZvcmNlTGludGluZyIsInBsdWdpbiIsImFzc2lnbktleXMiLCJhY3Rpb25zIiwiYXNzaWduZWQiLCJuYW1lIiwiY2giLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJpblBhbmVsIiwiX2EiLCJrZXlzIiwic2V2ZXJpdHkiLCJyZW5kZXJNZXNzYWdlIiwibWVzc2FnZSIsImFjdGlvbiIsImZpcmVkIiwiY2xpY2siLCJhcHBseSIsImtleUluZGV4IiwibmFtZUVsdCIsInR5cGUiLCJvbmNsaWNrIiwib25tb3VzZWRvd24iLCJlcSIsIm90aGVyIiwidG9ET00iLCJQYW5lbEl0ZW0iLCJpZCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJzZXRBdHRyaWJ1dGUiLCJpdGVtcyIsIm9ua2V5ZG93biIsImV2ZW50Iiwia2V5Q29kZSIsIm1vdmVTZWxlY3Rpb24iLCJzZWxlY3RlZEluZGV4IiwidG9VcHBlckNhc2UiLCJjaGFyQ29kZUF0IiwiY29udGFpbnMiLCJ0YXJnZXQiLCJsaXN0IiwidGFiSW5kZXgiLCJyb2xlIiwicGhyYXNlIiwibmVlZHNTeW5jIiwibmV3U2VsZWN0ZWRJdGVtIiwic2VlbiIsIlNldCIsIl9zdGFydCIsIl9lbmQiLCJoYXMiLCJpdGVtIiwiaiIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInBvcCIsInJlcXVlc3RNZWFzdXJlIiwicmVhZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndyaXRlIiwic2NhbGVZIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwidG9wIiwic2Nyb2xsVG9wIiwiYm90dG9tIiwic3luYyIsImRvbVBvcyIsImZpcnN0Q2hpbGQiLCJybSIsInByZXYiLCJuZXh0U2libGluZyIsInJlbW92ZSIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJzdmciLCJjb250ZW50IiwiYXR0cnMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ1bmRlcmxpbmUiLCJjb2xvciIsImJhc2VUaGVtZSIsInBhZGRpbmciLCJtYXJnaW5MZWZ0IiwiZGlzcGxheSIsIndoaXRlU3BhY2UiLCJib3JkZXJMZWZ0IiwiZm9udCIsImJvcmRlciIsImJhY2tncm91bmRDb2xvciIsImJvcmRlclJhZGl1cyIsImN1cnNvciIsImZvbnRTaXplIiwib3BhY2l0eSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJwYWRkaW5nQm90dG9tIiwiYmFja2dyb3VuZEltYWdlIiwibWFyZ2luIiwicG9zaXRpb24iLCJsZWZ0IiwiYm9yZGVyUmlnaHQiLCJib3JkZXJCb3R0b20iLCJib3JkZXJCb3R0b21Db2xvciIsIm1heEhlaWdodCIsIm92ZXJmbG93WSIsInRleHREZWNvcmF0aW9uIiwiYmFja2dyb3VuZF9mYWxsYmFjayIsImNvbG9yX2ZhbGxiYWNrIiwicmlnaHQiLCJiYWNrZ3JvdW5kIiwic2V2ZXJpdHlXZWlnaHQiLCJ3ZWlnaHQiLCJ3IiwiTGludEd1dHRlck1hcmtlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImRpYWdub3N0aWNzRmlsdGVyIiwibGludEd1dHRlckNvbmZpZyIsIm9ubW91c2VvdmVyIiwiZ3V0dGVyTWFya2VyTW91c2VPdmVyIiwidHJhY2tIb3Zlck9uIiwibWFya2VyIiwibW91c2Vtb3ZlIiwicmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwibm9kZVR5cGUiLCJjbGFzc0xpc3QiLCJ3aW5kb3ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGludEd1dHRlclRvb2x0aXAiLCJzZXRMaW50R3V0dGVyVG9vbHRpcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJob3ZlcmVkIiwiZWxlbWVudEF0SGVpZ2h0IiwiZG9jdW1lbnRUb3AiLCJsaW5lUG9zIiwiY29vcmRzQXRQb3MiLCJjbGlwIiwiZ2V0Q29vcmRzIiwib25tb3VzZW91dCIsIm9ubW91c2Vtb3ZlIiwiaG92ZXJUaW1lIiwiaG92ZXJUaW1lb3V0IiwibWFya2Vyc0ZvckRpYWdub3N0aWNzIiwiYnlMaW5lIiwiT2JqZWN0IiwibWFya2VycyIsInJhbmdlIiwibGludEd1dHRlckV4dGVuc2lvbiIsImxpbnRHdXR0ZXJNYXJrZXJzIiwid2lkZ2V0TWFya2VyIiwiYmxvY2siLCJlbXB0eSIsImxpbnRHdXR0ZXJUaGVtZSIsIndpZHRoIiwiY29tcHV0ZSIsImNvbmZpZ3MiLCJsaW50R3V0dGVyIiwiZm9yRWFjaERpYWdub3N0aWMiLCJsU3RhdGUiLCJwZW5kaW5nIiwicGVuZGluZ1N0YXJ0IiwibGFzdEVuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lint/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpCursor: () => (/* binding */ RegExpCursor),\n/* harmony export */   SearchCursor: () => (/* binding */ SearchCursor),\n/* harmony export */   SearchQuery: () => (/* binding */ SearchQuery),\n/* harmony export */   closeSearchPanel: () => (/* binding */ closeSearchPanel),\n/* harmony export */   findNext: () => (/* binding */ findNext),\n/* harmony export */   findPrevious: () => (/* binding */ findPrevious),\n/* harmony export */   getSearchQuery: () => (/* binding */ getSearchQuery),\n/* harmony export */   gotoLine: () => (/* binding */ gotoLine),\n/* harmony export */   highlightSelectionMatches: () => (/* binding */ highlightSelectionMatches),\n/* harmony export */   openSearchPanel: () => (/* binding */ openSearchPanel),\n/* harmony export */   replaceAll: () => (/* binding */ replaceAll),\n/* harmony export */   replaceNext: () => (/* binding */ replaceNext),\n/* harmony export */   search: () => (/* binding */ search),\n/* harmony export */   searchKeymap: () => (/* binding */ searchKeymap),\n/* harmony export */   searchPanelOpen: () => (/* binding */ searchPanelOpen),\n/* harmony export */   selectMatches: () => (/* binding */ selectMatches),\n/* harmony export */   selectNextOccurrence: () => (/* binding */ selectNextOccurrence),\n/* harmony export */   selectSelectionMatches: () => (/* binding */ selectSelectionMatches),\n/* harmony export */   setSearchQuery: () => (/* binding */ setSearchQuery)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? (x)=>x.normalize(\"NFKD\") : (x)=>x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/ class SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */ constructor(text, query, from = 0, to = text.length, normalize, test){\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */ this.value = {\n            from: 0,\n            to: 0\n        };\n        /**\n        Whether the end of the iterated region has been reached.\n        */ this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? (x)=>normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done) return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */ next() {\n        while(this.matches.length)this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */ nextOverlapping() {\n        for(;;){\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            let norm = this.normalize(str);\n            if (norm.length) for(let i = 0, pos = start;; i++){\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n            }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for(let i = 0; i < this.matches.length; i += 2){\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = {\n                        from: this.matches[i + 1],\n                        to: end\n                    };\n                } else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1) match = {\n                from: pos,\n                to: end\n            };\n            else this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function() {\n    return this;\n};\nconst empty = {\n    from: -1,\n    to: -1,\n    match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/ class RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */ constructor(text, query, options, from = 0, to = text.length){\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */ this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */ this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        } else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to) this.curLine = \"\";\n        else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */ next() {\n        for(let off = this.matchPos - this.curLineStart;;){\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length) this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            } else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            } else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/ new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text){\n        this.from = from;\n        this.text = text;\n    }\n    get to() {\n        return this.from + this.text.length;\n    }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to) return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to) text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to){\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */ ));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for(;;){\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length) return pos;\n    let line = text.lineAt(pos), next;\n    while(pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)pos++;\n    return pos;\n}\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        class: \"cm-textfield\",\n        name: \"line\",\n        value: line\n    });\n    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event)=>{\n            if (event.keyCode == 27) {\n                event.preventDefault();\n                view.dispatch({\n                    effects: dialogEffect.of(false)\n                });\n                view.focus();\n            } else if (event.keyCode == 13) {\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event)=>{\n            event.preventDefault();\n            go();\n        }\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        class: \"cm-button\",\n        type: \"submit\"\n    }, view.state.phrase(\"go\")), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        name: \"close\",\n        onclick: ()=>{\n            view.dispatch({\n                effects: dialogEffect.of(false)\n            });\n            view.focus();\n        },\n        \"aria-label\": view.state.phrase(\"close\"),\n        type: \"button\"\n    }, [\n        \"\\xd7\"\n    ]));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match) return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n            line = Math.round(state.doc.lines * pc);\n        } else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [\n                dialogEffect.of(false),\n                _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.from, {\n                    y: \"center\"\n                })\n            ],\n            selection\n        });\n        view.focus();\n    }\n    return {\n        dom\n    };\n}\nconst dialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst dialogField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return true;\n    },\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(dialogEffect)) value = e.value;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/ const gotoLine = (view)=>{\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    if (!panel) {\n        let effects = [\n            dialogEffect.of(true)\n        ];\n        if (view.state.field(dialogField, false) == null) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n            dialogField,\n            baseTheme$1\n        ]));\n        view.dispatch({\n            effects\n        });\n        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    }\n    if (panel) panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& label\": {\n            fontSize: \"80%\"\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            bottom: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: \"0\"\n        }\n    }\n});\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (options) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b)=>a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/ function highlightSelectionMatches(options) {\n    let ext = [\n        defaultTheme,\n        matchHighlighter\n    ];\n    if (options) ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        } else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            } else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges){\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while(!cursor.next().done){\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n                }\n            }\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nconst defaultTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#99ff7780\"\n    },\n    \".cm-searchMatch .cm-selectionMatch\": {\n        backgroundColor: \"transparent\"\n    }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch })=>{\n    let { selection } = state;\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map((range)=>state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection)) return false;\n    dispatch(state.update({\n        selection: newSel\n    }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for(let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;){\n        cursor.next();\n        if (cursor.done) {\n            if (cycled) return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        } else {\n            if (cycled && ranges.some((r)=>r.from == cursor.value.from)) continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/ const selectNextOccurrence = ({ state, dispatch })=>{\n    let { ranges } = state.selection;\n    if (ranges.some((sel)=>sel.from === sel.to)) return selectWord({\n        state,\n        dispatch\n    });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some((r)=>state.sliceDoc(r.from, r.to) != searchedText)) return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range) return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\nconst searchConfigFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: (view)=>new SearchPanel(view),\n            scrollToMatch: (range)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/ function search(config) {\n    return config ? [\n        searchConfigFacet.of(config),\n        searchExtensions\n    ] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/ class SearchQuery {\n    /**\n    Create a query object.\n    */ constructor(config){\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */ unquote(text) {\n        return this.literal ? text : text.replace(/\\\\([nrt\\\\])/g, (_, ch)=>ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */ eq(other) {\n        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */ create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */ getCursor(state, from = 0, to) {\n        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({\n            doc: state\n        });\n        if (to == null) to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec){\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : (x)=>x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos)=>{\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec){\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) {\n            let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);\n            cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();\n        }\n        return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for(let pos = to;;){\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */  - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while(!cursor.nextOverlapping().done)range = cursor.value;\n            if (range) return range;\n            if (start == from) return null;\n            pos -= 10000 /* FindPrev.ChunkSize */ ;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        let found = this.prevMatchInRange(state, 0, curFrom);\n        if (!found) found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);\n        return found && (found.from != curFrom || found.to != curTo) ? found : null;\n    }\n    getReplacement(_result) {\n        return this.spec.unquote(this.spec.replace);\n    }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match)=>!match[0].length || (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for(let size = 1;; size++){\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */ );\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while(!cursor.next().done)range = cursor.value;\n            if (range && (start == from || range.from > start + 10)) return range;\n            if (start == from) return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&]|\\d+)/g, (m, i)=>{\n            if (i == \"&\") return result.match[0];\n            if (i == \"$\") return \"$\";\n            for(let l = i.length; l > 0; l--){\n                let n = +i.slice(0, l);\n                if (n > 0 && n < result.match.length) return result.match[n] + i.slice(l);\n            }\n            return m;\n        });\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */ ), Math.min(to + 250 /* RegExp.HighlightMargin */ , state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/ const setSearchQuery = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst searchState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create (state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/ function getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/ function searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel){\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch\"\n}), selectedMatchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let { view } = this;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n        for(let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++){\n            let { from, to } = ranges[i];\n            while(i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */ )to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to)=>{\n                let selected = view.state.selection.ranges.some((r)=>r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nfunction searchCommand(f) {\n    return (view)=>{\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/ const findNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, next),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/ const findPrevious = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, prev),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/ const selectMatches = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length) return false;\n    view.dispatch({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/ const selectSelectionMatches = ({ state, dispatch })=>{\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty) return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for(let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;){\n        if (ranges.length > 1000) return false;\n        if (cur.value.from == from) main = ranges.length;\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/ const replaceNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly) return false;\n    let match = query.nextMatch(state, from, from);\n    if (!match) return false;\n    let next = match;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({\n            from: next.from,\n            to: next.to,\n            insert: replacement\n        });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    let changeSet = view.state.changes(changes);\n    if (next) {\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to).map(changeSet);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes: changeSet,\n        selection,\n        effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/ const replaceAll = /*@__PURE__*/ searchCommand((view, { query })=>{\n    if (view.state.readOnly) return false;\n    let changes = query.matchAll(view.state, 1e9).map((match)=>{\n        let { from, to } = match;\n        return {\n            from,\n            to,\n            insert: query.getReplacement(match)\n        };\n    });\n    if (!changes.length) return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText) return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement) input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/ const openSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid) view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n            searchInput.focus();\n            searchInput.select();\n        }\n    } else {\n        view.dispatch({\n            effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)\n            ]\n        });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/ const closeSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel) return false;\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/ const searchKeymap = [\n    {\n        key: \"Mod-f\",\n        run: openSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"F3\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Mod-g\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Escape\",\n        run: closeSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"Mod-Shift-l\",\n        run: selectSelectionMatches\n    },\n    {\n        key: \"Mod-Alt-g\",\n        run: gotoLine\n    },\n    {\n        key: \"Mod-d\",\n        run: selectNextOccurrence,\n        preventDefault: true\n    }\n];\nclass SearchPanel {\n    constructor(view){\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                class: \"cm-button\",\n                name,\n                onclick,\n                type: \"button\"\n            }, content);\n        }\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            onkeydown: (e)=>this.keydown(e),\n            class: \"cm-search\"\n        }, [\n            this.searchField,\n            button(\"next\", ()=>findNext(view), [\n                phrase(view, \"next\")\n            ]),\n            button(\"prev\", ()=>findPrevious(view), [\n                phrase(view, \"previous\")\n            ]),\n            button(\"select\", ()=>selectMatches(view), [\n                phrase(view, \"all\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.caseField,\n                phrase(view, \"match case\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.reField,\n                phrase(view, \"regexp\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.wordField,\n                phrase(view, \"by word\")\n            ]),\n            ...view.state.readOnly ? [] : [\n                (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\n                this.replaceField,\n                button(\"replace\", ()=>replaceNext(view), [\n                    phrase(view, \"replace\")\n                ]),\n                button(\"replaceAll\", ()=>replaceAll(view), [\n                    phrase(view, \"replace all\")\n                ])\n            ],\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                name: \"close\",\n                onclick: ()=>closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\n                \"\\xd7\"\n            ])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n        }\n    }\n    keydown(e) {\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        } else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        } else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)for (let effect of tr.effects){\n            if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n        }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() {\n        return 80;\n    }\n    get top() {\n        return this.view.state.facet(searchConfigFacet).top;\n    }\n}\nfunction phrase(view, phrase) {\n    return view.state.phrase(phrase);\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for(let i = 0; i < AnnounceMargin; i++)if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n            text = text.slice(i);\n            break;\n        }\n    }\n    if (end != lineEnd) {\n        for(let i = text.length - 1; i > text.length - AnnounceMargin; i--)if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n            text = text.slice(0, i);\n            break;\n        }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": {\n        backgroundColor: \"#ffff0054\"\n    },\n    \"&dark .cm-searchMatch\": {\n        backgroundColor: \"#00ffff8a\"\n    },\n    \"&light .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff6a0054\"\n    },\n    \"&dark .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff00ff8a\"\n    }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.low(searchHighlighter),\n    baseTheme\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUNxRztBQUMxTDtBQUV4QixNQUFNb0IsaUJBQWlCLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsU0FBUyxJQUFJLGFBQ3REQyxDQUFBQSxJQUFLQSxFQUFFRCxTQUFTLENBQUMsVUFBVUMsQ0FBQUEsSUFBS0E7QUFDdEM7OztBQUdBLEdBQ0EsTUFBTUM7SUFDRjs7Ozs7Ozs7Ozs7O0lBWUEsR0FDQUMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sQ0FBQyxFQUFFQyxLQUFLSCxLQUFLSSxNQUFNLEVBQUVSLFNBQVMsRUFBRVMsSUFBSSxDQUFFO1FBQ2xFLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNaOzs7O1FBSUEsR0FDQSxJQUFJLENBQUNDLEtBQUssR0FBRztZQUFFSixNQUFNO1lBQUdDLElBQUk7UUFBRTtRQUM5Qjs7UUFFQSxHQUNBLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHWCxLQUFLWSxTQUFTLENBQUNWLE1BQU1DO1FBQ2pDLElBQUksQ0FBQ1UsV0FBVyxHQUFHWDtRQUNuQixJQUFJLENBQUNOLFNBQVMsR0FBR0EsWUFBWUMsQ0FBQUEsSUFBS0QsVUFBVUgsZUFBZUksTUFBTUo7UUFDakUsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDTCxTQUFTLENBQUNLO0lBQ2hDO0lBQ0FhLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQ0osU0FBUyxJQUFJLElBQUksQ0FBQ0QsTUFBTSxDQUFDTCxNQUFNLEVBQUU7WUFDdEMsSUFBSSxDQUFDUyxXQUFXLElBQUksSUFBSSxDQUFD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O0lBQ2xFLGtDQUFrQztRQUFFQSxpQkFBaUI7SUFBWTtBQUNyRTtBQUNBLE1BQU1vRSxtQkFBbUI7SUFDckIrQztJQUNBLFdBQVcsR0FBRXJRLG1EQUFJQSxDQUFDcVYsR0FBRyxDQUFDdEU7SUFDdEJwSTtDQUNIO0FBRStTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm5jb2RlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzP2NkMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBnZXRQYW5lbCwgRGVjb3JhdGlvbiwgVmlld1BsdWdpbiwgcnVuU2NvcGVIYW5kbGVycyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgY29kZVBvaW50QXQsIGZyb21Db2RlUG9pbnQsIGNvZGVQb2ludFNpemUsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBDaGFyQ2F0ZWdvcnksIFJhbmdlU2V0QnVpbGRlciwgUHJlYywgRWRpdG9yU3RhdGUsIGZpbmRDbHVzdGVyQnJlYWsgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxuY29uc3QgYmFzaWNOb3JtYWxpemUgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPT0gXCJmdW5jdGlvblwiXG4gICAgPyB4ID0+IHgubm9ybWFsaXplKFwiTkZLRFwiKSA6IHggPT4geDtcbi8qKlxuQSBzZWFyY2ggY3Vyc29yIHByb3ZpZGVzIGFuIGl0ZXJhdG9yIG92ZXIgdGV4dCBtYXRjaGVzIGluIGFcbmRvY3VtZW50LlxuKi9cbmNsYXNzIFNlYXJjaEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBjdXJzb3IuIFRoZSBxdWVyeSBpcyB0aGUgc2VhcmNoIHN0cmluZywgYGZyb21gIHRvXG4gICAgYHRvYCBwcm92aWRlcyB0aGUgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICBcbiAgICBXaGVuIGBub3JtYWxpemVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGNhbGxlZCwgb24gYm90aCB0aGUgcXVlcnlcbiAgICBzdHJpbmcgYW5kIHRoZSBjb250ZW50IGl0IGlzIG1hdGNoZWQgYWdhaW5zdCwgYmVmb3JlIGNvbXBhcmluZy5cbiAgICBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgY3JlYXRlIGEgY2FzZS1pbnNlbnNpdGl2ZSBzZWFyY2ggYnlcbiAgICBwYXNzaW5nIGBzID0+IHMudG9Mb3dlckNhc2UoKWAuXG4gICAgXG4gICAgVGV4dCBpcyBhbHdheXMgbm9ybWFsaXplZCB3aXRoXG4gICAgW2Aubm9ybWFsaXplKFwiTkZLRFwiKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemUpXG4gICAgKHdoZW4gc3VwcG9ydGVkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCwgbm9ybWFsaXplLCB0ZXN0KSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBtYXRjaCAob25seSBob2xkcyBhIG1lYW5pbmdmdWwgdmFsdWUgYWZ0ZXJcbiAgICAgICAgW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLm5leHQpIGhhcyBiZWVuIGNhbGxlZCBhbmQgd2hlblxuICAgICAgICBgZG9uZWAgaXMgZmFsc2UpLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByZWdpb24gaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemUgPyB4ID0+IG5vcm1hbGl6ZShiYXNpY05vcm1hbGl6ZSh4KSkgOiBiYXNpY05vcm1hbGl6ZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHF1ZXJ5KTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyUG9zID09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJTdGFydCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnRBdCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciB0aGUgbmV4dCBtYXRjaC4gVXBkYXRlcyB0aGUgaXRlcmF0b3Inc1xuICAgIFtgdmFsdWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IudmFsdWUpIGFuZFxuICAgIFtgZG9uZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5kb25lKSBwcm9wZXJ0aWVzLiBTaG91bGQgYmUgY2FsbGVkXG4gICAgYXQgbGVhc3Qgb25jZSBiZWZvcmUgdXNpbmcgdGhlIGN1cnNvci5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1hdGNoZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGBuZXh0YCBtZXRob2Qgd2lsbCBpZ25vcmUgbWF0Y2hlcyB0aGF0IHBhcnRpYWxseSBvdmVybGFwIGFcbiAgICBwcmV2aW91cyBtYXRjaC4gVGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIGBuZXh0YCwgYnV0IGluY2x1ZGVzXG4gICAgc3VjaCBtYXRjaGVzLlxuICAgICovXG4gICAgbmV4dE92ZXJsYXBwaW5nKCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdHIgPSBmcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBsZXQgbm9ybSA9IHRoaXMubm9ybWFsaXplKHN0cik7XG4gICAgICAgICAgICBpZiAobm9ybS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gbm9ybS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoKGNvZGUsIHBvcywgdGhpcy5idWZmZXJQb3MgKyB0aGlzLmJ1ZmZlclN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gbm9ybS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0ICYmIGkgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGkpID09IGNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goY29kZSwgcG9zLCBlbmQpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMubWF0Y2hlc1tpXSwga2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdChpbmRleCkgPT0gY29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnF1ZXJ5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHRoaXMubWF0Y2hlc1tpICsgMV0sIHRvOiBlbmQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc1tpXSsrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KDApID09IGNvZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiBwb3MsIHRvOiBlbmQgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMucHVzaCgxLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCAmJiB0aGlzLnRlc3QgJiYgIXRoaXMudGVzdChtYXRjaC5mcm9tLCBtYXRjaC50bywgdGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyU3RhcnQpKVxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIilcbiAgICBTZWFyY2hDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5jb25zdCBlbXB0eSA9IHsgZnJvbTogLTEsIHRvOiAtMSwgbWF0Y2g6IC8qQF9fUFVSRV9fKi8vLiovLmV4ZWMoXCJcIikgfTtcbmNvbnN0IGJhc2VGbGFncyA9IFwiZ21cIiArICgveC8udW5pY29kZSA9PSBudWxsID8gXCJcIiA6IFwidVwiKTtcbi8qKlxuVGhpcyBjbGFzcyBpcyBzaW1pbGFyIHRvIFtgU2VhcmNoQ3Vyc29yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yKVxuYnV0IHNlYXJjaGVzIGZvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIGluc3RlYWQgb2YgYSBwbGFpblxuc3RyaW5nLlxuKi9cbmNsYXNzIFJlZ0V4cEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGdpdmVuIHJhbmdlIGluIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBgcXVlcnlgIHNob3VsZCBiZSB0aGUgcmF3IHBhdHRlcm4gKGFzIHlvdSdkIHBhc3MgaXQgdG9cbiAgICBgbmV3IFJlZ0V4cGApLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIFNldCB0byBgdHJ1ZWAgd2hlbiB0aGUgY3Vyc29yIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlYXJjaFxuICAgICAgICByYW5nZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaWxsIGNvbnRhaW4gYW4gb2JqZWN0IHdpdGggdGhlIGV4dGVudCBvZiB0aGUgbWF0Y2ggYW5kIHRoZVxuICAgICAgICBtYXRjaCBvYmplY3Qgd2hlbiBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5SZWdFeHBDdXJzb3IubmV4dClcbiAgICAgICAgc3VjZXNzZnVsbHkgZmluZHMgYSBtYXRjaC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICBpZiAoL1xcXFxbc1dEbnJdfFxcbnxcXHJ8XFxbXFxeLy50ZXN0KHF1ZXJ5KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0byk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyKCk7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSB0ZXh0LmxpbmVBdChmcm9tKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSBzdGFydExpbmUuZnJvbTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5nZXRMaW5lKHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0TGluZShza2lwKSB7XG4gICAgICAgIHRoaXMuaXRlci5uZXh0KHNraXApO1xuICAgICAgICBpZiAodGhpcy5pdGVyLmxpbmVCcmVhaykge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuY3VyTGluZS5zbGljZSgwLCB0aGlzLnRvIC0gdGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgPiB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKDApO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG1hdGNoLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmY7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoUG9zIDw9IHRoaXMudG8gJiYgdGhpcy5yZS5leGVjKHRoaXMuY3VyTGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgdG8gfHwgZnJvbSA+IHRoaXMudmFsdWUudG8pICYmICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBmbGF0dGVuZWQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFJldXNhYmxlIChwYXJ0aWFsbHkpIGZsYXR0ZW5lZCBkb2N1bWVudCBzdHJpbmdzXG5jbGFzcyBGbGF0dGVuZWREb2Mge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIHN0YXRpYyBnZXQoZG9jLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgY2FjaGVkID0gZmxhdHRlbmVkLmdldChkb2MpO1xuICAgICAgICBpZiAoIWNhY2hlZCB8fCBjYWNoZWQuZnJvbSA+PSB0byB8fCBjYWNoZWQudG8gPD0gZnJvbSkge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIGRvYy5zbGljZVN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC5mcm9tID09IGZyb20gJiYgY2FjaGVkLnRvID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbTogY2FjaGVkRnJvbSB9ID0gY2FjaGVkO1xuICAgICAgICBpZiAoY2FjaGVkRnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgIHRleHQgPSBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgY2FjaGVkRnJvbSkgKyB0ZXh0O1xuICAgICAgICAgICAgY2FjaGVkRnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC50byA8IHRvKVxuICAgICAgICAgICAgdGV4dCArPSBkb2Muc2xpY2VTdHJpbmcoY2FjaGVkLnRvLCB0byk7XG4gICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBuZXcgRmxhdHRlbmVkRG9jKGNhY2hlZEZyb20sIHRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgdGV4dC5zbGljZShmcm9tIC0gY2FjaGVkRnJvbSwgdG8gLSBjYWNoZWRGcm9tKSk7XG4gICAgfVxufVxuY2xhc3MgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGV4dCwgZnJvbSwgdGhpcy5jaHVua0VuZChmcm9tICsgNTAwMCAvKiBDaHVuay5CYXNlICovKSk7XG4gICAgfVxuICAgIGNodW5rRW5kKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID49IHRoaXMudG8gPyB0aGlzLnRvIDogdGhpcy50ZXh0LmxpbmVBdChwb3MpLnRvO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgb2ZmID0gdGhpcy5yZS5sYXN0SW5kZXggPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5mbGF0LmZyb207XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBtYXRjaGVzIGRpcmVjdGx5IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgIW1hdGNoWzBdICYmIG1hdGNoLmluZGV4ID09IG9mZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmICsgMTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZmxhdC5mcm9tICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoIGdvZXMgYWxtb3N0IHRvIHRoZSBlbmQgb2YgYSBub25jb21wbGV0ZSBjaHVuaywgdHJ5XG4gICAgICAgICAgICAgICAgLy8gYWdhaW4sIHNpbmNlIGl0J2xsIGxpa2VseSBiZSBhYmxlIHRvIG1hdGNoIG1vcmVcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZmxhdC50byA+PSB0aGlzLnRvIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDw9IHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAtIDEwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxhdC50byA9PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdyb3cgdGhlIGZsYXR0ZW5lZCBkb2NcbiAgICAgICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGhpcy50ZXh0LCB0aGlzLmZsYXQuZnJvbSwgdGhpcy5jaHVua0VuZCh0aGlzLmZsYXQuZnJvbSArIHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAqIDIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBNdWx0aWxpbmVSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuZnVuY3Rpb24gdmFsaWRSZWdFeHAoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzb3VyY2UsIGJhc2VGbGFncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQ2hhckVuZCh0ZXh0LCBwb3MpIHtcbiAgICBpZiAocG9zID49IHRleHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBsaW5lID0gdGV4dC5saW5lQXQocG9zKSwgbmV4dDtcbiAgICB3aGlsZSAocG9zIDwgbGluZS50byAmJiAobmV4dCA9IGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcyAtIGxpbmUuZnJvbSkpID49IDB4REMwMCAmJiBuZXh0IDwgMHhFMDAwKVxuICAgICAgICBwb3MrKztcbiAgICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lRGlhbG9nKHZpZXcpIHtcbiAgICBsZXQgbGluZSA9IFN0cmluZyh2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKS5udW1iZXIpO1xuICAgIGxldCBpbnB1dCA9IGVsdChcImlucHV0XCIsIHsgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsIG5hbWU6IFwibGluZVwiLCB2YWx1ZTogbGluZSB9KTtcbiAgICBsZXQgZG9tID0gZWx0KFwiZm9ybVwiLCB7XG4gICAgICAgIGNsYXNzOiBcImNtLWdvdG9MaW5lXCIsXG4gICAgICAgIG9ua2V5ZG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9XG4gICAgfSwgZWx0KFwibGFiZWxcIiwgdmlldy5zdGF0ZS5waHJhc2UoXCJHbyB0byBsaW5lXCIpLCBcIjogXCIsIGlucHV0KSwgXCIgXCIsIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIHZpZXcuc3RhdGUucGhyYXNlKFwiZ29cIikpLCBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB9LFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogdmlldy5zdGF0ZS5waHJhc2UoXCJjbG9zZVwiKSxcbiAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgIH0sIFtcIsOXXCJdKSk7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IC9eKFsrLV0pPyhcXGQrKT8oOlxcZCspPyglKT8kLy5leGVjKGlucHV0LnZhbHVlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGxldCBbLCBzaWduLCBsbiwgY2wsIHBlcmNlbnRdID0gbWF0Y2g7XG4gICAgICAgIGxldCBjb2wgPSBjbCA/ICtjbC5zbGljZSgxKSA6IDA7XG4gICAgICAgIGxldCBsaW5lID0gbG4gPyArbG4gOiBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICBpZiAobG4gJiYgcGVyY2VudCkge1xuICAgICAgICAgICAgbGV0IHBjID0gbGluZSAvIDEwMDtcbiAgICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAgICAgIHBjID0gcGMgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyAoc3RhcnRMaW5lLm51bWJlciAvIHN0YXRlLmRvYy5saW5lcyk7XG4gICAgICAgICAgICBsaW5lID0gTWF0aC5yb3VuZChzdGF0ZS5kb2MubGluZXMgKiBwYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG4gJiYgc2lnbikge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb2NMaW5lID0gc3RhdGUuZG9jLmxpbmUoTWF0aC5tYXgoMSwgTWF0aC5taW4oc3RhdGUuZG9jLmxpbmVzLCBsaW5lKSkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihkb2NMaW5lLmZyb20gKyBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2wsIGRvY0xpbmUubGVuZ3RoKSkpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGVmZmVjdHM6IFtkaWFsb2dFZmZlY3Qub2YoZmFsc2UpLCBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5mcm9tLCB7IHk6ICdjZW50ZXInIH0pXSxcbiAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tIH07XG59XG5jb25zdCBkaWFsb2dFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBkaWFsb2dGaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKGRpYWxvZ0VmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwgPyBjcmVhdGVMaW5lRGlhbG9nIDogbnVsbClcbn0pO1xuLyoqXG5Db21tYW5kIHRoYXQgc2hvd3MgYSBkaWFsb2cgYXNraW5nIHRoZSB1c2VyIGZvciBhIGxpbmUgbnVtYmVyLCBhbmRcbndoZW4gYSB2YWxpZCBwb3NpdGlvbiBpcyBwcm92aWRlZCwgbW92ZXMgdGhlIGN1cnNvciB0byB0aGF0IGxpbmUuXG5cblN1cHBvcnRzIGxpbmUgbnVtYmVycywgcmVsYXRpdmUgbGluZSBvZmZzZXRzIHByZWZpeGVkIHdpdGggYCtgIG9yXG5gLWAsIGRvY3VtZW50IHBlcmNlbnRhZ2VzIHN1ZmZpeGVkIHdpdGggYCVgLCBhbmQgYW4gb3B0aW9uYWxcbmNvbHVtbiBwb3NpdGlvbiBieSBhZGRpbmcgYDpgIGFuZCBhIHNlY29uZCBudW1iZXIgYWZ0ZXIgdGhlIGxpbmVcbm51bWJlci5cbiovXG5jb25zdCBnb3RvTGluZSA9IHZpZXcgPT4ge1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIGlmICghcGFuZWwpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBbZGlhbG9nRWZmZWN0Lm9mKHRydWUpXTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQoZGlhbG9nRmllbGQsIGZhbHNlKSA9PSBudWxsKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbZGlhbG9nRmllbGQsIGJhc2VUaGVtZSQxXSkpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICAgICAgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICB9XG4gICAgaWYgKHBhbmVsKVxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpLnNlbGVjdCgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1nb3RvTGluZVwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIGxhYmVsXCI6IHsgZm9udFNpemU6IFwiODAlXCIgfSxcbiAgICAgICAgXCImIFtuYW1lPWNsb3NlXVwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiBcIjBcIiwgYm90dG9tOiBcIjBcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjRweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiMFwiXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMgPSB7XG4gICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogZmFsc2UsXG4gICAgbWluU2VsZWN0aW9uTGVuZ3RoOiAxLFxuICAgIG1heE1hdGNoZXM6IDEwMCxcbiAgICB3aG9sZVdvcmRzOiBmYWxzZVxufTtcbmNvbnN0IGhpZ2hsaWdodENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhvcHRpb25zLCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucywge1xuICAgICAgICAgICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogKGEsIGIpID0+IGEgfHwgYixcbiAgICAgICAgICAgIG1pblNlbGVjdGlvbkxlbmd0aDogTWF0aC5taW4sXG4gICAgICAgICAgICBtYXhNYXRjaGVzOiBNYXRoLm1pblxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuVGhpcyBleHRlbnNpb24gaGlnaGxpZ2h0cyB0ZXh0IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0aW9uLiBJdCB1c2VzXG50aGUgYFwiY20tc2VsZWN0aW9uTWF0Y2hcImAgY2xhc3MgZm9yIHRoZSBoaWdobGlnaHRpbmcuIFdoZW5cbmBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yYCBpcyBlbmFibGVkLCB0aGUgd29yZCBhdCB0aGUgY3Vyc29yXG5pdHNlbGYgd2lsbCBiZSBoaWdobGlnaHRlZCB3aXRoIGBcImNtLXNlbGVjdGlvbk1hdGNoLW1haW5cImAuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyhvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFtkZWZhdWx0VGhlbWUsIG1hdGNoSGlnaGxpZ2h0ZXJdO1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRDb25maWcub2Yob3B0aW9ucykpO1xuICAgIHJldHVybiBleHQ7XG59XG5jb25zdCBtYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2hcIiB9KTtcbmNvbnN0IG1haW5NYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2ggY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiIH0pO1xuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBvdXRzaWRlIHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIG5vbi13b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gKGZyb20gPT0gMCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tIC0gMSwgZnJvbSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAodG8gPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyh0bywgdG8gKyAxKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSB3b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkXG4gICAgICAgICYmIGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvIC0gMSwgdG8pKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZDtcbn1cbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoaGlnaGxpZ2h0Q29uZmlnKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5tYWluLCBxdWVyeSwgY2hlY2sgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGlmICghd29yZClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHdvcmQuZnJvbSwgd29yZC50byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gcmFuZ2UudG8gLSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxlbiA8IGNvbmYubWluU2VsZWN0aW9uTGVuZ3RoIHx8IGxlbiA+IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgaWYgKGNvbmYud2hvbGVXb3Jkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pOyAvLyBUT0RPOiBhbGxvdyBhbmQgaW5jbHVkZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlP1xuICAgICAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgICAgIGlmICghKGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pICYmXG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bykpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcGFydC5mcm9tLCBwYXJ0LnRvKTtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8IGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5jb25zdCBkZWZhdWx0VGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWZmNzc4MFwiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2ggLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIgfVxufSk7XG4vLyBTZWxlY3QgdGhlIHdvcmRzIGFyb3VuZCB0aGUgY3Vyc29ycy5cbmNvbnN0IHNlbGVjdFdvcmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpIHx8IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcbiAgICBpZiAobmV3U2VsLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IG5ld1NlbCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCBuZXh0IG9jY3VycmVuY2Ugb2YgcXVlcnkgcmVsYXRpdmUgdG8gbGFzdCBjdXJzb3IuIFdyYXAgYXJvdW5kXG4vLyB0aGUgZG9jdW1lbnQgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbWF0Y2hlcy5cbmZ1bmN0aW9uIGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgcXVlcnkpIHtcbiAgICBsZXQgeyBtYWluLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChtYWluLmhlYWQpLCBmdWxsV29yZCA9IHdvcmQgJiYgd29yZC5mcm9tID09IG1haW4uZnJvbSAmJiB3b3JkLnRvID09IG1haW4udG87XG4gICAgZm9yIChsZXQgY3ljbGVkID0gZmFsc2UsIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50byk7Oykge1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIDAsIE1hdGgubWF4KDAsIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIGN5Y2xlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkICYmIHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGN1cnNvci52YWx1ZS5mcm9tKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmdWxsV29yZCkge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KGN1cnNvci52YWx1ZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQgfHwgd29yZC5mcm9tICE9IGN1cnNvci52YWx1ZS5mcm9tIHx8IHdvcmQudG8gIT0gY3Vyc29yLnZhbHVlLnRvKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblNlbGVjdCBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBFeHBhbmQgc2VsZWN0aW9uXG50byB0aGUgc3Vycm91bmRpbmcgd29yZCB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4qL1xuY29uc3Qgc2VsZWN0TmV4dE9jY3VycmVuY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChyYW5nZXMuc29tZShzZWwgPT4gc2VsLmZyb20gPT09IHNlbC50bykpXG4gICAgICAgIHJldHVybiBzZWxlY3RXb3JkKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGxldCBzZWFyY2hlZFRleHQgPSBzdGF0ZS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gc3RhdGUuc2xpY2VEb2Moci5mcm9tLCByLnRvKSAhPSBzZWFyY2hlZFRleHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHJhbmdlID0gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBzZWFyY2hlZFRleHQpO1xuICAgIGlmICghcmFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5hZGRSYW5nZShFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLCBmYWxzZSksXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UudG8pXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VhcmNoQ29uZmlnRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICAgICAgICByZWdleHA6IGZhbHNlLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiBmYWxzZSxcbiAgICAgICAgICAgIGNyZWF0ZVBhbmVsOiB2aWV3ID0+IG5ldyBTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgIHNjcm9sbFRvTWF0Y2g6IHJhbmdlID0+IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5BZGQgc2VhcmNoIHN0YXRlIHRvIHRoZSBlZGl0b3IgY29uZmlndXJhdGlvbiwgYW5kIG9wdGlvbmFsbHlcbmNvbmZpZ3VyZSB0aGUgc2VhcmNoIGV4dGVuc2lvbi5cbihbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgd2lsbCBhdXRvbWF0aWNhbGx5XG5lbmFibGUgdGhpcyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uKS5cbiovXG5mdW5jdGlvbiBzZWFyY2goY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtzZWFyY2hDb25maWdGYWNldC5vZihjb25maWcpLCBzZWFyY2hFeHRlbnNpb25zXSA6IHNlYXJjaEV4dGVuc2lvbnM7XG59XG4vKipcbkEgc2VhcmNoIHF1ZXJ5LiBQYXJ0IG9mIHRoZSBlZGl0b3IncyBzZWFyY2ggc3RhdGUuXG4qL1xuY2xhc3MgU2VhcmNoUXVlcnkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHF1ZXJ5IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IGNvbmZpZy5zZWFyY2g7XG4gICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9ICEhY29uZmlnLmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMubGl0ZXJhbCA9ICEhY29uZmlnLmxpdGVyYWw7XG4gICAgICAgIHRoaXMucmVnZXhwID0gISFjb25maWcucmVnZXhwO1xuICAgICAgICB0aGlzLnJlcGxhY2UgPSBjb25maWcucmVwbGFjZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnZhbGlkID0gISF0aGlzLnNlYXJjaCAmJiAoIXRoaXMucmVnZXhwIHx8IHZhbGlkUmVnRXhwKHRoaXMuc2VhcmNoKSk7XG4gICAgICAgIHRoaXMudW5xdW90ZWQgPSB0aGlzLnVucXVvdGUodGhpcy5zZWFyY2gpO1xuICAgICAgICB0aGlzLndob2xlV29yZCA9ICEhY29uZmlnLndob2xlV29yZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1bnF1b3RlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbCA/IHRleHQgOlxuICAgICAgICAgICAgdGV4dC5yZXBsYWNlKC9cXFxcKFtucnRcXFxcXSkvZywgKF8sIGNoKSA9PiBjaCA9PSBcIm5cIiA/IFwiXFxuXCIgOiBjaCA9PSBcInJcIiA/IFwiXFxyXCIgOiBjaCA9PSBcInRcIiA/IFwiXFx0XCIgOiBcIlxcXFxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBxdWVyeSB0byBhbm90aGVyIHF1ZXJ5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoID09IG90aGVyLnNlYXJjaCAmJiB0aGlzLnJlcGxhY2UgPT0gb3RoZXIucmVwbGFjZSAmJlxuICAgICAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID09IG90aGVyLmNhc2VTZW5zaXRpdmUgJiYgdGhpcy5yZWdleHAgPT0gb3RoZXIucmVnZXhwICYmXG4gICAgICAgICAgICB0aGlzLndob2xlV29yZCA9PSBvdGhlci53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIHNlYXJjaCBjdXJzb3IgZm9yIHRoaXMgcXVlcnksIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBnaXZlblxuICAgIHJhbmdlIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldEN1cnNvcihzdGF0ZSwgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGxldCBzdCA9IHN0YXRlLmRvYyA/IHN0YXRlIDogRWRpdG9yU3RhdGUuY3JlYXRlKHsgZG9jOiBzdGF0ZSB9KTtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHJlZ2V4cEN1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pIDogc3RyaW5nQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy51bnF1b3RlZCwgZnJvbSwgdG8sIHNwZWMuY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IHggPT4geC50b0xvd2VyQ2FzZSgpLCBzcGVjLndob2xlV29yZCA/IHN0cmluZ1dvcmRUZXN0KHN0YXRlLmRvYywgc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzdHJpbmdXb3JkVGVzdChkb2MsIGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChmcm9tLCB0bywgYnVmLCBidWZQb3MpID0+IHtcbiAgICAgICAgaWYgKGJ1ZlBvcyA+IGZyb20gfHwgYnVmUG9zICsgYnVmLmxlbmd0aCA8IHRvKSB7XG4gICAgICAgICAgICBidWZQb3MgPSBNYXRoLm1heCgwLCBmcm9tIC0gMik7XG4gICAgICAgICAgICBidWYgPSBkb2Muc2xpY2VTdHJpbmcoYnVmUG9zLCBNYXRoLm1pbihkb2MubGVuZ3RoLCB0byArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xuICAgIH07XG59XG5jbGFzcyBTdHJpbmdRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcihzcGVjKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgY3VyRnJvbSArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGVuZCkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lIHx8IGN1cnNvci52YWx1ZS5mcm9tID09IGN1ckZyb20gJiYgY3Vyc29yLnZhbHVlLnRvID09IGN1clRvID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgLy8gU2VhcmNoaW5nIGluIHJldmVyc2UgaXMsIHJhdGhlciB0aGFuIGltcGxlbWVudGluZyBhbiBpbnZlcnRlZCBzZWFyY2hcbiAgICAvLyBjdXJzb3IsIGRvbmUgYnkgc2Nhbm5pbmcgY2h1bmsgYWZ0ZXIgY2h1bmsgZm9yd2FyZC5cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0bzs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCBwb3MgLSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHBvcyksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHRPdmVybGFwcGluZygpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwb3MgLT0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBNYXRoLm1heCgwLCBjdXJUbyAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kICYmIChmb3VuZC5mcm9tICE9IGN1ckZyb20gfHwgZm91bmQudG8gIT0gY3VyVG8pID8gZm91bmQgOiBudWxsO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChfcmVzdWx0KSB7IHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSk7IH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBNYXRoLm1pbih0byArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgsIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnZXhwQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy5zZWFyY2gsIHtcbiAgICAgICAgaWdub3JlQ2FzZTogIXNwZWMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgdGVzdDogc3BlYy53aG9sZVdvcmQgPyByZWdleHBXb3JkVGVzdChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkXG4gICAgfSwgZnJvbSwgdG8pO1xufVxuZnVuY3Rpb24gY2hhckJlZm9yZShzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgsIGZhbHNlKSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gY2hhckFmdGVyKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGluZGV4LCBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHJlZ2V4cFdvcmRUZXN0KGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChfZnJvbSwgX3RvLCBtYXRjaCkgPT4gIW1hdGNoWzBdLmxlbmd0aCB8fFxuICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuY2xhc3MgUmVnRXhwUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dCgpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBzaXplID0gMTs7IHNpemUrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgdG8gLSBzaXplICogMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKS5yZXBsYWNlKC9cXCQoWyQmXXxcXGQrKS9nLCAobSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXRjaFswXTtcbiAgICAgICAgICAgIGlmIChpID09IFwiJFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGwgPSBpLmxlbmd0aDsgbCA+IDA7IGwtLSkge1xuICAgICAgICAgICAgICAgIGxldCBuID0gK2kuc2xpY2UoMCwgbCk7XG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwICYmIG4gPCByZXN1bHQubWF0Y2gubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hdGNoW25dICsgaS5zbGljZShsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLyksIE1hdGgubWluKHRvICsgMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8sIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuLyoqXG5BIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5LiBOb3RlIHRoYXRcbnRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGlmIHRoZSBzZWFyY2ggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbihieSBpbmNsdWRpbmcgW2BzZWFyY2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2gpIGluIHlvdXIgY29uZmlndXJhdGlvbiBvclxuYnkgcnVubmluZyBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgYXQgbGVhc3Rcbm9uY2UpLlxuKi9cbmNvbnN0IHNldFNlYXJjaFF1ZXJ5ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZWFyY2hTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoU3RhdGUoZGVmYXVsdFF1ZXJ5KHN0YXRlKS5jcmVhdGUoKSwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZShlZmZlY3QudmFsdWUuY3JlYXRlKCksIHZhbHVlLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUodmFsdWUucXVlcnksIGVmZmVjdC52YWx1ZSA/IGNyZWF0ZVNlYXJjaFBhbmVsIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKVxufSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gZ2V0U2VhcmNoUXVlcnkoc3RhdGUpIHtcbiAgICBsZXQgY3VyU3RhdGUgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjdXJTdGF0ZSA/IGN1clN0YXRlLnF1ZXJ5LnNwZWMgOiBkZWZhdWx0UXVlcnkoc3RhdGUpO1xufVxuLyoqXG5RdWVyeSB3aGV0aGVyIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBpbiB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaFBhbmVsT3BlbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYW5lbCkgIT0gbnVsbDtcbn1cbmNsYXNzIFNlYXJjaFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoIGNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCIgfSk7XG5jb25zdCBzZWFyY2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQodmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHsgcXVlcnksIHBhbmVsIH0pIHtcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkuc3BlYy52YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzLCBsID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCAtIDEgJiYgdG8gPiByYW5nZXNbaSArIDFdLmZyb20gLSAyICogMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bztcbiAgICAgICAgICAgIHF1ZXJ5LmhpZ2hsaWdodCh2aWV3LnN0YXRlLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgc2VsZWN0ZWQgPyBzZWxlY3RlZE1hdGNoTWFyayA6IG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcbiAgICByZXR1cm4gdmlldyA9PiB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHZpZXcuc3RhdGUsIHRvLCB0byk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogW2Fubm91bmNlTWF0Y2godmlldywgbmV4dCksIGNvbmZpZy5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KV0sXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIGluc3RhbmNlIG9mIHRoZSBzZWFyY2ggcXVlcnksXG5iZWZvcmUgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uIFdpbGwgd3JhcCBwYXN0IHRoZSBzdGFydFxub2YgdGhlIGRvY3VtZW50IHRvIHN0YXJ0IHNlYXJjaGluZyBhdCB0aGUgZW5kIGFnYWluLlxuKi9cbmNvbnN0IGZpbmRQcmV2aW91cyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgcHJldiA9IHF1ZXJ5LnByZXZNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFwcmV2KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUocHJldi5mcm9tLCBwcmV2LnRvKTtcbiAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogW2Fubm91bmNlTWF0Y2godmlldywgcHJldiksIGNvbmZpZy5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KV0sXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoZXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDEwMDApO1xuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxuKi9cbmNvbnN0IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpOyAhY3VyLm5leHQoKS5kb25lOykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjdXIudmFsdWUuZnJvbSA9PSBmcm9tKVxuICAgICAgICAgICAgbWFpbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShjdXIudmFsdWUuZnJvbSwgY3VyLnZhbHVlLnRvKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3QgcmVwbGFjZU5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBtYXRjaCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gbWF0Y2g7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgc2VsZWN0aW9uLCByZXBsYWNlbWVudDtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gc3RhdGUudG9UZXh0KHF1ZXJ5LmdldFJlcGxhY2VtZW50KG5leHQpKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dC5mcm9tLCB0bzogbmV4dC50bywgaW5zZXJ0OiByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgbmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgbWF0Y2ggb24gbGluZSAkXCIsIHN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyKSArIFwiLlwiKSk7XG4gICAgfVxuICAgIGxldCBjaGFuZ2VTZXQgPSB2aWV3LnN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXh0LmZyb20sIG5leHQudG8pLm1hcChjaGFuZ2VTZXQpO1xuICAgICAgICBlZmZlY3RzLnB1c2goYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSk7XG4gICAgICAgIGVmZmVjdHMucHVzaChzdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbiwgdmlldykpO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlczogY2hhbmdlU2V0LFxuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5SZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeSB3aXRoIHRoZSBnaXZlblxucmVwbGFjZW1lbnQuXG4qL1xuY29uc3QgcmVwbGFjZUFsbCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMWU5KS5tYXAobWF0Y2ggPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gbWF0Y2g7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCBpbnNlcnQ6IHF1ZXJ5LmdldFJlcGxhY2VtZW50KG1hdGNoKSB9O1xuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYW5ub3VuY2VUZXh0ID0gdmlldy5zdGF0ZS5waHJhc2UoXCJyZXBsYWNlZCAkIG1hdGNoZXNcIiwgY2hhbmdlcy5sZW5ndGgpICsgXCIuXCI7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYW5ub3VuY2VUZXh0KSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2UuYWxsXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFuZWwodmlldykge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS5jcmVhdGVQYW5lbCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRRdWVyeShzdGF0ZSwgZmFsbGJhY2spIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgc2VsVGV4dCA9IHNlbC5lbXB0eSB8fCBzZWwudG8gPiBzZWwuZnJvbSArIDEwMCA/IFwiXCIgOiBzdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgc2VsLnRvKTtcbiAgICBpZiAoZmFsbGJhY2sgJiYgIXNlbFRleHQpXG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICBsZXQgY29uZmlnID0gc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHJldHVybiBuZXcgU2VhcmNoUXVlcnkoe1xuICAgICAgICBzZWFyY2g6ICgoX2EgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2subGl0ZXJhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uZmlnLmxpdGVyYWwpID8gc2VsVGV4dCA6IHNlbFRleHQucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksXG4gICAgICAgIGNhc2VTZW5zaXRpdmU6IChfYiA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5jYXNlU2Vuc2l0aXZlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb25maWcuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgbGl0ZXJhbDogKF9jID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvbmZpZy5saXRlcmFsLFxuICAgICAgICByZWdleHA6IChfZCA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5yZWdleHApICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGNvbmZpZy5yZWdleHAsXG4gICAgICAgIHdob2xlV29yZDogKF9lID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLndob2xlV29yZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogY29uZmlnLndob2xlV29yZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VhcmNoSW5wdXQodmlldykge1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZVNlYXJjaFBhbmVsKTtcbiAgICByZXR1cm4gcGFuZWwgJiYgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbbWFpbi1maWVsZF1cIik7XG59XG5mdW5jdGlvbiBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KSB7XG4gICAgbGV0IGlucHV0ID0gZ2V0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgaWYgKGlucHV0ICYmIGlucHV0ID09IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KVxuICAgICAgICBpbnB1dC5zZWxlY3QoKTtcbn1cbi8qKlxuTWFrZSBzdXJlIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBhbmQgZm9jdXNlZC5cbiovXG5jb25zdCBvcGVuU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnBhbmVsKSB7XG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IGdldFNlYXJjaElucHV0KHZpZXcpO1xuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlID8gc2V0U2VhcmNoUXVlcnkub2YoZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpKSA6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKVxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgc2VhcmNoIHBhbmVsLlxuKi9cbmNvbnN0IGNsb3NlU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIE1vZC1BbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxuIC0gTW9kLWQ6IFtgc2VsZWN0TmV4dE9jY3VycmVuY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWxlY3ROZXh0T2NjdXJyZW5jZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VTZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LWxcIiwgcnVuOiBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1nXCIsIHJ1bjogZ290b0xpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtZFwiLCBydW46IHNlbGVjdE5leHRPY2N1cnJlbmNlLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuXTtcbmNsYXNzIFNlYXJjaFBhbmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMucXVlcnkgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKS5xdWVyeS5zcGVjO1xuICAgICAgICB0aGlzLmNvbW1pdCA9IHRoaXMuY29tbWl0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkuc2VhcmNoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJzZWFyY2hcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBcIm1haW4tZmllbGRcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkucmVwbGFjZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwiY2FzZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5yZWdleHAsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29yZEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJ3b3JkXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkud2hvbGVXb3JkLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBidXR0b24obmFtZSwgb25jbGljaywgY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCBuYW1lLCBvbmNsaWNrLCB0eXBlOiBcImJ1dHRvblwiIH0sIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgb25rZXlkb3duOiAoZSkgPT4gdGhpcy5rZXlkb3duKGUpLCBjbGFzczogXCJjbS1zZWFyY2hcIiB9LCBbXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLFxuICAgICAgICAgICAgYnV0dG9uKFwibmV4dFwiLCAoKSA9PiBmaW5kTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcIm5leHRcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInByZXZcIiwgKCkgPT4gZmluZFByZXZpb3VzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicHJldmlvdXNcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInNlbGVjdFwiLCAoKSA9PiBzZWxlY3RNYXRjaGVzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwiYWxsXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5jYXNlRmllbGQsIHBocmFzZSh2aWV3LCBcIm1hdGNoIGNhc2VcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLnJlRmllbGQsIHBocmFzZSh2aWV3LCBcInJlZ2V4cFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMud29yZEZpZWxkLCBwaHJhc2UodmlldywgXCJieSB3b3JkXCIpXSksXG4gICAgICAgICAgICAuLi52aWV3LnN0YXRlLnJlYWRPbmx5ID8gW10gOiBbXG4gICAgICAgICAgICAgICAgZWx0KFwiYnJcIiksXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQsXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZVwiLCAoKSA9PiByZXBsYWNlTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2VcIildKSxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlQWxsXCIsICgpID0+IHJlcGxhY2VBbGwodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlIGFsbFwiKV0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiY2xvc2VcIiksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgICAgICAgICAgfSwgW1wiw5dcIl0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoRmllbGQudmFsdWUsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiB0aGlzLmNhc2VGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVnZXhwOiB0aGlzLnJlRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHdob2xlV29yZDogdGhpcy53b3JkRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFxdWVyeS5lcSh0aGlzLnF1ZXJ5KSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24oZSkge1xuICAgICAgICBpZiAocnVuU2NvcGVIYW5kbGVycyh0aGlzLnZpZXcsIGUsIFwic2VhcmNoLXBhbmVsXCIpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMuc2VhcmNoRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIChlLnNoaWZ0S2V5ID8gZmluZFByZXZpb3VzIDogZmluZE5leHQpKHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMucmVwbGFjZUZpZWxkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXBsYWNlTmV4dCh0aGlzLnZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkgJiYgIWVmZmVjdC52YWx1ZS5lcSh0aGlzLnF1ZXJ5KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRRdWVyeShlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzZXRRdWVyeShxdWVyeSkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQudmFsdWUgPSBxdWVyeS5zZWFyY2g7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlID0gcXVlcnkucmVwbGFjZTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQuY2hlY2tlZCA9IHF1ZXJ5LmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMucmVGaWVsZC5jaGVja2VkID0gcXVlcnkucmVnZXhwO1xuICAgICAgICB0aGlzLndvcmRGaWVsZC5jaGVja2VkID0gcXVlcnkud2hvbGVXb3JkO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC5zZWxlY3QoKTtcbiAgICB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIDgwOyB9XG4gICAgZ2V0IHRvcCgpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkudG9wOyB9XG59XG5mdW5jdGlvbiBwaHJhc2UodmlldywgcGhyYXNlKSB7IHJldHVybiB2aWV3LnN0YXRlLnBocmFzZShwaHJhc2UpOyB9XG5jb25zdCBBbm5vdW5jZU1hcmdpbiA9IDMwO1xuY29uc3QgQnJlYWsgPSAvW1xcc1xcLiw6Oz8hXS87XG5mdW5jdGlvbiBhbm5vdW5jZU1hdGNoKHZpZXcsIHsgZnJvbSwgdG8gfSkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCBsaW5lRW5kID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bztcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIGZyb20gLSBBbm5vdW5jZU1hcmdpbiksIGVuZCA9IE1hdGgubWluKGxpbmVFbmQsIHRvICsgQW5ub3VuY2VNYXJnaW4pO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zdGF0ZS5zbGljZURvYyhzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RhcnQgIT0gbGluZS5mcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQW5ub3VuY2VNYXJnaW47IGkrKylcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgKyAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kICE9IGxpbmVFbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+IHRleHQubGVuZ3RoIC0gQW5ub3VuY2VNYXJnaW47IGktLSlcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgLSAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShcImN1cnJlbnQgbWF0Y2hcIil9LiAke3RleHR9ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJvbiBsaW5lXCIpfSAke2xpbmUubnVtYmVyfS5gKTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tc2VhcmNoXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXQsICYgYnV0dG9uLCAmIGxhYmVsXCI6IHtcbiAgICAgICAgICAgIG1hcmdpbjogXCIuMmVtIC42ZW0gLjJlbSAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGlucHV0W3R5cGU9Y2hlY2tib3hdXCI6IHtcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBcIi4yZW1cIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgbGFiZWxcIjoge1xuICAgICAgICAgICAgZm9udFNpemU6IFwiODAlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZjAwNTRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMGZmZmY4YVwiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZjZhMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMDBmZjhhXCIgfVxufSk7XG5jb25zdCBzZWFyY2hFeHRlbnNpb25zID0gW1xuICAgIHNlYXJjaFN0YXRlLFxuICAgIC8qQF9fUFVSRV9fKi9QcmVjLmxvdyhzZWFyY2hIaWdobGlnaHRlciksXG4gICAgYmFzZVRoZW1lXG5dO1xuXG5leHBvcnQgeyBSZWdFeHBDdXJzb3IsIFNlYXJjaEN1cnNvciwgU2VhcmNoUXVlcnksIGNsb3NlU2VhcmNoUGFuZWwsIGZpbmROZXh0LCBmaW5kUHJldmlvdXMsIGdldFNlYXJjaFF1ZXJ5LCBnb3RvTGluZSwgaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcywgb3BlblNlYXJjaFBhbmVsLCByZXBsYWNlQWxsLCByZXBsYWNlTmV4dCwgc2VhcmNoLCBzZWFyY2hLZXltYXAsIHNlYXJjaFBhbmVsT3Blbiwgc2VsZWN0TWF0Y2hlcywgc2VsZWN0TmV4dE9jY3VycmVuY2UsIHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMsIHNldFNlYXJjaFF1ZXJ5IH07XG4iXSwibmFtZXMiOlsic2hvd1BhbmVsIiwiRWRpdG9yVmlldyIsImdldFBhbmVsIiwiRGVjb3JhdGlvbiIsIlZpZXdQbHVnaW4iLCJydW5TY29wZUhhbmRsZXJzIiwiY29kZVBvaW50QXQiLCJmcm9tQ29kZVBvaW50IiwiY29kZVBvaW50U2l6ZSIsIlN0YXRlRWZmZWN0IiwiU3RhdGVGaWVsZCIsIkVkaXRvclNlbGVjdGlvbiIsIkZhY2V0IiwiY29tYmluZUNvbmZpZyIsIkNoYXJDYXRlZ29yeSIsIlJhbmdlU2V0QnVpbGRlciIsIlByZWMiLCJFZGl0b3JTdGF0ZSIsImZpbmRDbHVzdGVyQnJlYWsiLCJlbHQiLCJiYXNpY05vcm1hbGl6ZSIsIlN0cmluZyIsInByb3RvdHlwZSIsIm5vcm1hbGl6ZSIsIngiLCJTZWFyY2hDdXJzb3IiLCJjb25zdHJ1Y3RvciIsInRleHQiLCJxdWVyeSIsImZyb20iLCJ0byIsImxlbmd0aCIsInRlc3QiLCJ2YWx1ZSIsImRvbmUiLCJtYXRjaGVzIiwiYnVmZmVyIiwiYnVmZmVyUG9zIiwiaXRlciIsIml0ZXJSYW5nZSIsImJ1ZmZlclN0YXJ0IiwicGVlayIsIm5leHQiLCJwb3AiLCJuZXh0T3ZlcmxhcHBpbmciLCJzdHIiLCJzdGFydCIsIm5vcm0iLCJpIiwicG9zIiwiY29kZSIsImNoYXJDb2RlQXQiLCJtYXRjaCIsImVuZCIsImluZGV4Iiwia2VlcCIsInNwbGljZSIsInB1c2giLCJTeW1ib2wiLCJpdGVyYXRvciIsImVtcHR5IiwiZXhlYyIsImJhc2VGbGFncyIsInVuaWNvZGUiLCJSZWdFeHBDdXJzb3IiLCJvcHRpb25zIiwiY3VyTGluZSIsIk11bHRpbGluZVJlZ0V4cEN1cnNvciIsInJlIiwiUmVnRXhwIiwiaWdub3JlQ2FzZSIsInN0YXJ0TGluZSIsImxpbmVBdCIsImN1ckxpbmVTdGFydCIsIm1hdGNoUG9zIiwidG9DaGFyRW5kIiwiZ2V0TGluZSIsInNraXAiLCJsaW5lQnJlYWsiLCJzbGljZSIsIm5leHRMaW5lIiwib2ZmIiwibGFzdEluZGV4IiwiZmxhdHRlbmVkIiwiV2Vha01hcCIsIkZsYXR0ZW5lZERvYyIsImdldCIsImRvYyIsImNhY2hlZCIsImZsYXQiLCJzbGljZVN0cmluZyIsInNldCIsImNhY2hlZEZyb20iLCJjaHVua0VuZCIsInZhbGlkUmVnRXhwIiwic291cmNlIiwiX2EiLCJsaW5lIiwiY3JlYXRlTGluZURpYWxvZyIsInZpZXciLCJzdGF0ZSIsInNlbGVjdGlvbiIsIm1haW4iLCJoZWFkIiwibnVtYmVyIiwiaW5wdXQiLCJjbGFzcyIsIm5hbWUiLCJkb20iLCJvbmtleWRvd24iLCJldmVudCIsImtleUNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsImRpc3BhdGNoIiwiZWZmZWN0cyIsImRpYWxvZ0VmZmVjdCIsIm9mIiwiZm9jdXMiLCJnbyIsIm9uc3VibWl0IiwicGhyYXNlIiwidHlwZSIsIm9uY2xpY2siLCJzaWduIiwibG4iLCJjbCIsInBlcmNlbnQiLCJjb2wiLCJwYyIsImxpbmVzIiwiTWF0aCIsInJvdW5kIiwiZG9jTGluZSIsIm1heCIsIm1pbiIsImN1cnNvciIsInNjcm9sbEludG9WaWV3IiwieSIsImRlZmluZSIsImRpYWxvZ0ZpZWxkIiwiY3JlYXRlIiwidXBkYXRlIiwidHIiLCJlIiwiaXMiLCJwcm92aWRlIiwiZiIsInZhbCIsImdvdG9MaW5lIiwicGFuZWwiLCJmaWVsZCIsImFwcGVuZENvbmZpZyIsImJhc2VUaGVtZSQxIiwicXVlcnlTZWxlY3RvciIsInNlbGVjdCIsImJhc2VUaGVtZSIsInBhZGRpbmciLCJwb3NpdGlvbiIsImZvbnRTaXplIiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJmb250IiwiZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMiLCJoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yIiwibWluU2VsZWN0aW9uTGVuZ3RoIiwibWF4TWF0Y2hlcyIsIndob2xlV29yZHMiLCJoaWdobGlnaHRDb25maWciLCJjb21iaW5lIiwiYSIsImIiLCJoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzIiwiZXh0IiwiZGVmYXVsdFRoZW1lIiwibWF0Y2hIaWdobGlnaHRlciIsIm1hdGNoRGVjbyIsIm1hcmsiLCJtYWluTWF0Y2hEZWNvIiwiaW5zaWRlV29yZEJvdW5kYXJpZXMiLCJjaGVjayIsInNsaWNlRG9jIiwiV29yZCIsImluc2lkZVdvcmQiLCJmcm9tQ2xhc3MiLCJkZWNvcmF0aW9ucyIsImdldERlY28iLCJzZWxlY3Rpb25TZXQiLCJkb2NDaGFuZ2VkIiwidmlld3BvcnRDaGFuZ2VkIiwiY29uZiIsImZhY2V0Iiwic2VsIiwicmFuZ2VzIiwibm9uZSIsInJhbmdlIiwid29yZCIsIndvcmRBdCIsImNoYXJDYXRlZ29yaXplciIsImxlbiIsImRlY28iLCJwYXJ0IiwidmlzaWJsZVJhbmdlcyIsInYiLCJzZWxlY3RXb3JkIiwibmV3U2VsIiwibWFwIiwibWFpbkluZGV4IiwiZXEiLCJmaW5kTmV4dE9jY3VycmVuY2UiLCJmdWxsV29yZCIsImN5Y2xlZCIsInNvbWUiLCJyIiwic2VsZWN0TmV4dE9jY3VycmVuY2UiLCJzZWFyY2hlZFRleHQiLCJhZGRSYW5nZSIsInNlYXJjaENvbmZpZ0ZhY2V0IiwiY29uZmlncyIsImNhc2VTZW5zaXRpdmUiLCJsaXRlcmFsIiwicmVnZXhwIiwid2hvbGVXb3JkIiwiY3JlYXRlUGFuZWwiLCJTZWFyY2hQYW5lbCIsInNjcm9sbFRvTWF0Y2giLCJzZWFyY2giLCJjb25maWciLCJzZWFyY2hFeHRlbnNpb25zIiwiU2VhcmNoUXVlcnkiLCJyZXBsYWNlIiwidmFsaWQiLCJ1bnF1b3RlZCIsInVucXVvdGUiLCJfIiwiY2giLCJvdGhlciIsIlJlZ0V4cFF1ZXJ5IiwiU3RyaW5nUXVlcnkiLCJnZXRDdXJzb3IiLCJzdCIsInJlZ2V4cEN1cnNvciIsInN0cmluZ0N1cnNvciIsIlF1ZXJ5VHlwZSIsInNwZWMiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsInN0cmluZ1dvcmRUZXN0IiwiY2F0ZWdvcml6ZXIiLCJidWYiLCJidWZQb3MiLCJjaGFyQmVmb3JlIiwiY2hhckFmdGVyIiwibmV4dE1hdGNoIiwiY3VyRnJvbSIsImN1clRvIiwicHJldk1hdGNoSW5SYW5nZSIsInByZXZNYXRjaCIsImZvdW5kIiwiZ2V0UmVwbGFjZW1lbnQiLCJfcmVzdWx0IiwibWF0Y2hBbGwiLCJsaW1pdCIsImhpZ2hsaWdodCIsImFkZCIsInJlZ2V4cFdvcmRUZXN0IiwiX2Zyb20iLCJfdG8iLCJzaXplIiwicmVzdWx0IiwibSIsImwiLCJuIiwic2V0U2VhcmNoUXVlcnkiLCJ0b2dnbGVQYW5lbCIsInNlYXJjaFN0YXRlIiwiU2VhcmNoU3RhdGUiLCJkZWZhdWx0UXVlcnkiLCJlZmZlY3QiLCJjcmVhdGVTZWFyY2hQYW5lbCIsImdldFNlYXJjaFF1ZXJ5IiwiY3VyU3RhdGUiLCJzZWFyY2hQYW5lbE9wZW4iLCJtYXRjaE1hcmsiLCJzZWxlY3RlZE1hdGNoTWFyayIsInNlYXJjaEhpZ2hsaWdodGVyIiwic3RhcnRTdGF0ZSIsImJ1aWxkZXIiLCJzZWxlY3RlZCIsImZpbmlzaCIsInNlYXJjaENvbW1hbmQiLCJvcGVuU2VhcmNoUGFuZWwiLCJmaW5kTmV4dCIsInNpbmdsZSIsImFubm91bmNlTWF0Y2giLCJ1c2VyRXZlbnQiLCJzZWxlY3RTZWFyY2hJbnB1dCIsImZpbmRQcmV2aW91cyIsInByZXYiLCJzZWxlY3RNYXRjaGVzIiwic2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyIsImN1ciIsInJlcGxhY2VOZXh0IiwicmVhZE9ubHkiLCJjaGFuZ2VzIiwicmVwbGFjZW1lbnQiLCJ0b1RleHQiLCJpbnNlcnQiLCJhbm5vdW5jZSIsImNoYW5nZVNldCIsInJlcGxhY2VBbGwiLCJhbm5vdW5jZVRleHQiLCJmYWxsYmFjayIsIl9iIiwiX2MiLCJfZCIsIl9lIiwic2VsVGV4dCIsImdldFNlYXJjaElucHV0Iiwicm9vdCIsImFjdGl2ZUVsZW1lbnQiLCJzZWFyY2hJbnB1dCIsImNsb3NlU2VhcmNoUGFuZWwiLCJjb250YWlucyIsInNlYXJjaEtleW1hcCIsImtleSIsInJ1biIsInNjb3BlIiwic2hpZnQiLCJjb21taXQiLCJiaW5kIiwic2VhcmNoRmllbGQiLCJwbGFjZWhvbGRlciIsImZvcm0iLCJvbmNoYW5nZSIsIm9ua2V5dXAiLCJyZXBsYWNlRmllbGQiLCJjYXNlRmllbGQiLCJjaGVja2VkIiwicmVGaWVsZCIsIndvcmRGaWVsZCIsImJ1dHRvbiIsImNvbnRlbnQiLCJrZXlkb3duIiwidGFyZ2V0Iiwic2hpZnRLZXkiLCJ0cmFuc2FjdGlvbnMiLCJzZXRRdWVyeSIsIm1vdW50IiwiQW5ub3VuY2VNYXJnaW4iLCJCcmVhayIsImxpbmVFbmQiLCJtYXJnaW4iLCJtYXJnaW5SaWdodCIsIndoaXRlU3BhY2UiLCJsb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/search/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),\n/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),\n/* harmony export */   CharCategory: () => (/* binding */ CharCategory),\n/* harmony export */   Compartment: () => (/* binding */ Compartment),\n/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   Facet: () => (/* binding */ Facet),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MapMode: () => (/* binding */ MapMode),\n/* harmony export */   Prec: () => (/* binding */ Prec),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),\n/* harmony export */   RangeValue: () => (/* binding */ RangeValue),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   StateEffect: () => (/* binding */ StateEffect),\n/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),\n/* harmony export */   StateField: () => (/* binding */ StateField),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   codePointAt: () => (/* binding */ codePointAt),\n/* harmony export */   codePointSize: () => (/* binding */ codePointSize),\n/* harmony export */   combineConfig: () => (/* binding */ combineConfig),\n/* harmony export */   countColumn: () => (/* binding */ countColumn),\n/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),\n/* harmony export */   findColumn: () => (/* binding */ findColumn),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/* harmony import */ var _marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @marijn/find-cluster-break */ \"(ssr)/./node_modules/@marijn/find-cluster-break/src/index.js\");\n\n/**\nThe data structure for documents. @nonabstract\n*/ class Text {\n    /**\n    Get the line description around the given position.\n    */ lineAt(pos) {\n        if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */ line(n) {\n        if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */ replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* Open.To */ );\n        if (text.length) text.decompose(0, text.length, parts, 1 /* Open.From */  | 2 /* Open.To */ );\n        this.decompose(to, this.length, parts, 1 /* Open.From */ );\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */ append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */ slice(from, to = this.length) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */ eq(other) {\n        if (other == this) return true;\n        if (other.length != this.length || other.lines != this.lines) return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for(let skip = start, pos = start;;){\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n            pos += a.value.length;\n            if (a.done || pos >= end) return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings.\n    */ iter(dir = 1) {\n        return new RawTextCursor(this, dir);\n    }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */ iterRange(from, to = this.length) {\n        return new PartialTextCursor(this, from, to);\n    }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */ iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        } else {\n            if (to == null) to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    Return the document as a string, using newline characters to\n    separate lines.\n    */ toString() {\n        return this.sliceString(0);\n    }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n    */ toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    @internal\n    */ constructor(){}\n    /**\n    Create a `Text` instance for the given array of lines.\n    */ static of(text) {\n        if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0]) return Text.empty;\n        return text.length <= 32 /* Tree.Branch */  ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)){\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() {\n        return this.text.length;\n    }\n    get children() {\n        return null;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* Open.From */ ) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            } else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        } else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n        [from, to] = clip(this, from, to);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Tree.Branch */ ) return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for(let pos = 0, i = 0; pos <= to && i < this.text.length; i++){\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)target.push(line);\n    }\n    scanIdentical() {\n        return 0;\n    }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text){\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1) target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length){\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for(let i = 0, pos = 0; pos <= to && i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */  : 0) | (end >= to ? 2 /* Open.To */  : 0));\n                if (pos >= from && end <= to && !childOpen) target.push(child);\n                else child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        if (text.lines < this.lines) for(let i = 0, pos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            // Fast path: if the change only affects one child and the\n            // child's size remains in the acceptable range, only update\n            // that child\n            if (from >= pos && to <= end) {\n                let updated = child.replace(from - pos, to - pos, text);\n                let totalLines = this.lines - child.lines + updated.lines;\n                if (updated.lines < totalLines >> 5 /* Tree.BranchShift */  - 1 && updated.lines > totalLines >> 5 /* Tree.BranchShift */  + 1) {\n                    let copy = this.children.slice();\n                    copy[i] = updated;\n                    return new TextNode(copy, this.length - (to - from) + text.length);\n                }\n                return super.replace(pos, end, updated);\n            }\n            pos = end + 1;\n        }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for(let i = 0, pos = 0; i < this.children.length && pos <= to; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode)) return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [\n            0,\n            0,\n            this.children.length,\n            other.children.length\n        ] : [\n            this.children.length - 1,\n            other.children.length - 1,\n            -1,\n            -1\n        ];\n        for(;; iA += dir, iB += dir){\n            if (iA == eA || iB == eB) return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB) return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch)=>l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)lines += ch.lines;\n        if (lines < 32 /* Tree.Branch */ ) {\n            let flat = [];\n            for (let ch of children)ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Tree.Branch */ , lines >> 5 /* Tree.BranchShift */ ), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)add(node);\n            } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32 /* Tree.Branch */ ) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            } else {\n                if (currentLines + child.lines > chunk) flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0) return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/ new TextLeaf([\n    \"\"\n], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for(let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++){\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to) line = line.slice(0, to - pos);\n            if (pos < from) line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            } else target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\n        \"\"\n    ], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1){\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [\n            text\n        ];\n        this.offsets = [\n            dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1\n        ];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for(;;){\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0) this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            } else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            } else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                } else {\n                    if (dir < 0) this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, -this.dir);\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end){\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit) skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0) skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0) skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() {\n        return this.cursor.lineBreak && this.value != \"\";\n    }\n}\nclass LineCursor {\n    constructor(inner){\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done && this.afterBreak) {\n            this.value = \"\";\n            this.afterBreak = false;\n        } else if (done) {\n            this.done = true;\n            this.value = \"\";\n        } else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            } else {\n                this.afterBreak = true;\n                this.next();\n            }\n        } else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() {\n        return false;\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function() {\n        return this.iter();\n    };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/ class Line {\n    /**\n    @internal\n    */ constructor(/**\n    The position of the start of the line.\n    */ from, /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */ to, /**\n    This line's line number (1-based).\n    */ number, /**\n    The line's content.\n    */ text){\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */ get length() {\n        return this.to - this.from;\n    }\n}\nfunction clip(text, from, to) {\n    from = Math.max(0, Math.min(text.length, from));\n    return [\n        from,\n        Math.max(from, Math.min(text.length, to))\n    ];\n}\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/ function findClusterBreak(str, pos, forward = true, includeExtending = true) {\n    return (0,_marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(str, pos, forward, includeExtending);\n}\nfunction surrogateLow(ch) {\n    return ch >= 0xDC00 && ch < 0xE000;\n}\nfunction surrogateHigh(ch) {\n    return ch >= 0xD800 && ch < 0xDC00;\n}\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/ function codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1)) return code0;\n    return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/ function fromCodePoint(code) {\n    if (code <= 0xffff) return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up in a JavaScript string.\n*/ function codePointSize(code) {\n    return code < 0x10000 ? 1 : 2;\n}\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/ var MapMode = /*@__PURE__*/ function(MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */ MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */ MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */ MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */ MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n    return MapMode;\n}(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/ class ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ sections){\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */ get length() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2)result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */ get newLength() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2){\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */ get empty() {\n        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n    }\n    /**\n    Iterate over the unchanged parts left by these changes. `posA`\n    provides the position of the range in the old document, `posB`\n    the new position in the changed document.\n    */ iterGaps(f) {\n        for(let i = 0, posA = 0, posB = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            } else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    `fromA`/`toA` provides the extent of the change in the starting\n    document, `fromB`/`toB` the extent of the replacement in the\n    changed document.\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */ iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */ get invertedDesc() {\n        let sections = [];\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) sections.push(len, ins);\n            else sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */ composeDesc(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other);\n    }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `this` happened before the ones in `other`.\n    */ mapDesc(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before);\n    }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos) return posB + (pos - posA);\n                posB += len;\n            } else {\n                if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */ touchesRange(from, to = from) {\n        for(let i = 0, pos = 0; i < this.sections.length && pos <= to;){\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = \"\";\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */ toJSON() {\n        return this.sections;\n    }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some((a)=>typeof a != \"number\")) throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n    /**\n    @internal\n    */ static create(sections) {\n        return new ChangeDesc(sections);\n    }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/ class ChangeSet extends ChangeDesc {\n    constructor(sections, /**\n    @internal\n    */ inserted){\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */ apply(doc) {\n        if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text)=>doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) {\n        return mapSet(this, other, before, true);\n    }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */ invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for(let i = 0, pos = 0; i < sections.length; i += 2){\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while(inserted.length < index)inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` â†’ `docB` and `other` represents `docB` â†’ `docC`, the\n    returned value will represent the change `docA` â†’ `docC`.\n    */ compose(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n    }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */ map(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before, true);\n    }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each, with the range in the original document (`fromA`-`toA`)\n    and the range that replaces it in the new document\n    (`fromB`-`toB`).\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */ iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */ get desc() {\n        return ChangeDesc.create(this.sections);\n    }\n    /**\n    @internal\n    */ filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for(let i = 0, pos = 0;;){\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while(pos < next || pos == next && iter.len == 0){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while(pos < end){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return {\n            changes: new ChangeSet(resultSections, resultInserted),\n            filtered: ChangeDesc.create(filteredSections)\n        };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */ toJSON() {\n        let parts = [];\n        for(let i = 0; i < this.sections.length; i += 2){\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0) parts.push(len);\n            else if (ins == 0) parts.push([\n                len\n            ]);\n            else parts.push([\n                len\n            ].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */ static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length) return;\n            if (pos < length) addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)process(sub);\n            } else if (spec instanceof ChangeSet) {\n                if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            } else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0) return;\n                if (from < pos) flush();\n                if (from > pos) addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */ static empty(length) {\n        return new ChangeSet(length ? [\n            length,\n            -1\n        ] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for(let i = 0; i < json.length; i++){\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i)=>i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            } else if (part.length == 1) {\n                sections.push(part[0], 0);\n            } else {\n                while(inserted.length < i)inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    @internal\n    */ static createSet(sections, inserted) {\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0) return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;\n    else if (last >= 0 && len == 0 && sections[last] == 0) sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    } else sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0) return;\n    let index = sections.length - 2 >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    } else {\n        while(values.length < index)values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for(let posA = 0, posB = 0, i = 0; i < desc.sections.length;){\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        } else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for(;;){\n                endA += len;\n                endB += ins;\n                if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    // Produce a copy of setA that applies to the document after setB\n    // has been applied (assuming both start at the same document).\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    // Iterate over both sets in parallel. inserted tracks, for changes\n    // in A that have to be processed piece-by-piece, whether their\n    // content has been inserted already, and refers to the section\n    // index.\n    for(let inserted = -1;;){\n        if (a.done && b.len || b.done && a.len) {\n            throw new Error(\"Mismatched change set lengths\");\n        } else if (a.ins == -1 && b.ins == -1) {\n            // Move across ranges skipped by both sets.\n            let len = Math.min(a.len, b.len);\n            addSection(sections, len, -1);\n            a.forward(len);\n            b.forward(len);\n        } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n            // If there's a change in B that comes before the next change in\n            // A (ordered by start pos, then len, then before flag), skip\n            // that (and process any changes in A it covers).\n            let len = b.len;\n            addSection(sections, b.ins, -1);\n            while(len){\n                let piece = Math.min(a.len, len);\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n                    addSection(sections, 0, a.ins);\n                    if (insert) addInsert(insert, sections, a.text);\n                    inserted = a.i;\n                }\n                a.forward(piece);\n                len -= piece;\n            }\n            b.next();\n        } else if (a.ins >= 0) {\n            // Process the part of a change in A up to the start of the next\n            // non-deletion change in B (if overlapping).\n            let len = 0, left = a.len;\n            while(left){\n                if (b.ins == -1) {\n                    let piece = Math.min(left, b.len);\n                    len += piece;\n                    left -= piece;\n                    b.forward(piece);\n                } else if (b.ins == 0 && b.len < left) {\n                    left -= b.len;\n                    b.next();\n                } else {\n                    break;\n                }\n            }\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\n            if (insert && inserted < a.i) addInsert(insert, sections, a.text);\n            inserted = a.i;\n            a.forward(a.len - left);\n        } else if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for(let open = false;;){\n        if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else if (a.ins == 0) {\n            addSection(sections, a.len, 0, open);\n            a.next();\n        } else if (b.len == 0 && !b.done) {\n            addSection(sections, 0, b.ins, open);\n            if (insert) addInsert(insert, sections, b.text);\n            b.next();\n        } else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        } else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB) addInsert(insert, sections, b.text);\n            } else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert) addInsert(insert, sections, a.textBit(len));\n            } else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off) addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set){\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        } else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() {\n        return this.ins == -2;\n    }\n    get len2() {\n        return this.ins < 0 ? this.len : this.ins;\n    }\n    get text() {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len) this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1) this.forward(len);\n        else if (len == this.ins) this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/ class SelectionRange {\n    constructor(/**\n    The lower boundary of the range.\n    */ from, /**\n    The upper boundary of the range.\n    */ to, flags){\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the rangeâ€”the side that doesn't move when you\n    extend it.\n    */ get anchor() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.to : this.from;\n    }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */ get head() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.from : this.to;\n    }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */ get empty() {\n        return this.from == this.to;\n    }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */ get assoc() {\n        return this.flags & 8 /* RangeFlag.AssocBefore */  ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */  ? 1 : 0;\n    }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */ get bidiLevel() {\n        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */ ;\n        return level == 7 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */ get goalColumn() {\n        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */ ;\n        return value == 16777215 /* RangeFlag.NoGoalColumn */  ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */ map(change, assoc = -1) {\n        let from, to;\n        if (this.empty) {\n            from = to = change.mapPos(this.from, assoc);\n        } else {\n            from = change.mapPos(this.from, 1);\n            to = change.mapPos(this.to, -1);\n        }\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */ extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */ eq(other, includeAssoc = false) {\n        return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */ toJSON() {\n        return {\n            anchor: this.anchor,\n            head: this.head\n        };\n    }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */ static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n    /**\n    @internal\n    */ static create(from, to, flags) {\n        return new SelectionRange(from, to, flags);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/ class EditorSelection {\n    constructor(/**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */ ranges, /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */ mainIndex){\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */ map(change, assoc = -1) {\n        if (change.empty) return this;\n        return EditorSelection.create(this.ranges.map((r)=>r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection. By default, ranges\n    are compared only by position. When `includeAssoc` is true,\n    cursor ranges must also have the same\n    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.\n    */ eq(other, includeAssoc = false) {\n        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n        for(let i = 0; i < this.ranges.length; i++)if (!this.ranges[i].eq(other.ranges[i], includeAssoc)) return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */ get main() {\n        return this.ranges[this.mainIndex];\n    }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */ asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([\n            this.main\n        ], 0);\n    }\n    /**\n    Extend this selection with an extra range.\n    */ addRange(range, main = true) {\n        return EditorSelection.create([\n            range\n        ].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */ replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */ toJSON() {\n        return {\n            ranges: this.ranges.map((r)=>r.toJSON()),\n            main: this.mainIndex\n        };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */ static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r)=>SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */ static single(anchor, head = anchor) {\n        return new EditorSelection([\n            EditorSelection.range(anchor, head)\n        ], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */ static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n        for(let pos = 0, i = 0; i < ranges.length; i++){\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */ static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */  : 16 /* RangeFlag.AssocAfter */ ) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */ );\n    }\n    /**\n    Create a selection range.\n    */ static range(anchor, head, goalColumn, bidiLevel) {\n        let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */  | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));\n        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */  | 16 /* RangeFlag.AssocAfter */  | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */  : 0) | flags);\n    }\n    /**\n    @internal\n    */ static normalized(ranges, mainIndex = 0) {\n        let main = ranges[mainIndex];\n        ranges.sort((a, b)=>a.from - b.from);\n        mainIndex = ranges.indexOf(main);\n        for(let i = 1; i < ranges.length; i++){\n            let range = ranges[i], prev = ranges[i - 1];\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n                let from = prev.from, to = Math.max(range.to, prev.to);\n                if (i <= mainIndex) mainIndex--;\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n            }\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n}\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n\nNote that `Facet` instances can be used anywhere where\n[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.\n*/ class Facet {\n    constructor(/**\n    @internal\n    */ combine, /**\n    @internal\n    */ compareInput, /**\n    @internal\n    */ compare, isStatic, enables){\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /**\n        @internal\n        */ this.id = nextID++;\n        this.default = combine([]);\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n    }\n    /**\n    Returns a facet reader for this facet, which can be used to\n    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n    */ get reader() {\n        return this;\n    }\n    /**\n    Define a new facet.\n    */ static define(config = {}) {\n        return new Facet(config.combine || ((a)=>a), config.compareInput || ((a, b)=>a === b), config.compare || (!config.combine ? sameArray : (a, b)=>a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value to this facet.\n    */ of(value) {\n        return new FacetProvider([], this, 0 /* Provider.Static */ , value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In cases where your value depends only on a single field, you'll\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n    */ compute(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Provider.Single */ , get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */ computeN(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */ , get);\n    }\n    from(field, get) {\n        if (!get) get = (x)=>x;\n        return this.compute([\n            field\n        ], (state)=>get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i)=>e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value){\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */ ;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies){\n            if (dep == \"doc\") depDoc = true;\n            else if (dep == \"selection\") depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n        }\n        return {\n            create (state) {\n                state.values[idx] = getter(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update (state, tr) {\n                if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {\n                    let newVal = getter(state);\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n                        state.values[idx] = newVal;\n                        return 1 /* SlotStatus.Changed */ ;\n                    }\n                }\n                return 0;\n            },\n            reconfigure: (state, oldState)=>{\n                let newVal, oldAddr = oldState.config.address[id];\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (this.dependencies.every((dep)=>{\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n                        state.values[idx] = oldVal;\n                        return 0;\n                    }\n                } else {\n                    newVal = getter(state);\n                }\n                state.values[idx] = newVal;\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!compare(a[i], b[i])) return false;\n    return true;\n}\nfunction ensureAll(state, addrs) {\n    let changed = false;\n    for (let addr of addrs)if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */ ) changed = true;\n    return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map((p)=>addresses[p.id]);\n    let providerTypes = providers.map((p)=>p.type);\n    let dynamic = providerAddrs.filter((p)=>!(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    function get(state) {\n        let values = [];\n        for(let i = 0; i < providerAddrs.length; i++){\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Provider.Multi */ ) for (let val of value)values.push(val);\n            else values.push(value);\n        }\n        return facet.combine(values);\n    }\n    return {\n        create (state) {\n            for (let addr of providerAddrs)ensureAddr(state, addr);\n            state.values[idx] = get(state);\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        update (state, tr) {\n            if (!ensureAll(state, dynamic)) return 0;\n            let value = get(state);\n            if (facet.compare(value, state.values[idx])) return 0;\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        reconfigure (state, oldState) {\n            let depChanged = ensureAll(state, providerAddrs);\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            let value = get(state);\n            if (facet.compare(value, oldValue)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        }\n    };\n}\nconst initField = /*@__PURE__*/ Facet.define({\n    static: true\n});\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/ class StateField {\n    constructor(/**\n    @internal\n    */ id, createF, updateF, compareF, /**\n    @internal\n    */ spec){\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */ this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */ static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b)=>a === b), config);\n        if (config.provide) field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find((i)=>i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */ slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return {\n            create: (state)=>{\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update: (state, tr)=>{\n                let oldVal = state.values[idx];\n                let value = this.updateF(oldVal, tr);\n                if (this.compareF(oldVal, value)) return 0;\n                state.values[idx] = value;\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            reconfigure: (state, oldState)=>{\n                let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;\n                if ((reInit = init.find((i)=>i.field == this)) && reInit != oldInit.find((i)=>i.field == this)) {\n                    state.values[idx] = reInit.create(state);\n                    return 1 /* SlotStatus.Changed */ ;\n                }\n                if (oldState.config.address[this.id] != null) {\n                    state.values[idx] = oldState.field(this);\n                    return 0;\n                }\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */ init(create) {\n        return [\n            this,\n            initField.of({\n                field: this,\n                create\n            })\n        ];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */ get extension() {\n        return this;\n    }\n}\nconst Prec_ = {\n    lowest: 4,\n    low: 3,\n    default: 2,\n    high: 1,\n    highest: 0\n};\nfunction prec(value) {\n    return (ext)=>new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/ const Prec = {\n    /**\n    The highest precedence level, for extensions that should end up\n    near the start of the precedence ordering.\n    */ highest: /*@__PURE__*/ prec(Prec_.highest),\n    /**\n    A higher-than-default precedence, for extensions that should\n    come before those with default precedence.\n    */ high: /*@__PURE__*/ prec(Prec_.high),\n    /**\n    The default precedence, which is also used for extensions\n    without an explicit precedence.\n    */ default: /*@__PURE__*/ prec(Prec_.default),\n    /**\n    A lower-than-default precedence.\n    */ low: /*@__PURE__*/ prec(Prec_.low),\n    /**\n    The lowest precedence level. Meant for things that should end up\n    near the end of the extension order.\n    */ lowest: /*@__PURE__*/ prec(Prec_.lowest)\n};\nclass PrecExtension {\n    constructor(inner, prec){\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/ class Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */ of(ext) {\n        return new CompartmentInstance(this, ext);\n    }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */ reconfigure(content) {\n        return Compartment.reconfigure.of({\n            compartment: this,\n            extension: content\n        });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */ get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner){\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets){\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.facets = facets;\n        this.statusTemplate = [];\n        while(this.statusTemplate.length < dynamicSlots.length)this.statusTemplate.push(0 /* SlotStatus.Unresolved */ );\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)){\n            if (ext instanceof StateField) fields.push(ext);\n            else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields){\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push((a)=>field.slot(a));\n        }\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n        for(let id in facets){\n            let providers = facets[id], facet = providers[0].facet;\n            let oldProviders = oldFacets && oldFacets[id] || [];\n            if (providers.every((p)=>p.type == 0 /* Provider.Static */ )) {\n                address[facet.id] = staticValues.length << 1 | 1;\n                if (sameArray(oldProviders, providers)) {\n                    staticValues.push(oldState.facet(facet));\n                } else {\n                    let value = facet.combine(providers.map((p)=>p.value));\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n                }\n            } else {\n                for (let p of providers){\n                    if (p.type == 0 /* Provider.Static */ ) {\n                        address[p.id] = staticValues.length << 1 | 1;\n                        staticValues.push(p.value);\n                    } else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push((a)=>p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push((a)=>dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        let dynamic = dynamicSlots.map((f)=>f(address));\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [\n        [],\n        [],\n        [],\n        [],\n        []\n    ];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known <= prec) return;\n            let found = result[known].indexOf(ext);\n            if (found > -1) result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)inner(e, prec);\n        } else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        } else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        } else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides) inner(ext.provides, prec);\n        } else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);\n        } else {\n            let content = ext.extension;\n            if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b)=>a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1) return 2 /* SlotStatus.Computed */ ;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* SlotStatus.Computing */ ) throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* SlotStatus.Computed */ ) return status;\n    state.status[idx] = 4 /* SlotStatus.Computing */ ;\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n    return state.status[idx] = 2 /* SlotStatus.Computed */  | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\nconst languageData = /*@__PURE__*/ Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.some((v)=>v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/ Facet.define();\nconst transactionFilter = /*@__PURE__*/ Facet.define();\nconst transactionExtender = /*@__PURE__*/ Facet.define();\nconst readOnly = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : false\n});\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/ class Annotation {\n    /**\n    @internal\n    */ constructor(/**\n    The annotation type.\n    */ type, /**\n    The value of this annotation.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */ static define() {\n        return new AnnotationType();\n    }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/ class AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */ of(value) {\n        return new Annotation(this, value);\n    }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/ class StateEffectType {\n    /**\n    @internal\n    */ constructor(// The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */ map){\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */ of(value) {\n        return new StateEffect(this, value);\n    }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/ class StateEffect {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ type, /**\n    The value of this effect.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */ map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */ is(type) {\n        return this.type == type;\n    }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds. It should be a type that\n    doesn't include `undefined`, since that is used in\n    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n    removed.\n    */ static define(spec = {}) {\n        return new StateEffectType(spec.map || ((v)=>v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */ static mapEffects(effects, mapping) {\n        if (!effects.length) return effects;\n        let result = [];\n        for (let effect of effects){\n            let mapped = effect.map(mapping);\n            if (mapped) result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/ StateEffect.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/ StateEffect.appendConfig = /*@__PURE__*/ StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/ class Transaction {\n    constructor(/**\n    The state from which the transaction starts.\n    */ startState, /**\n    The document changes made by this transaction.\n    */ changes, /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */ selection, /**\n    The effects added to the transaction.\n    */ effects, /**\n    @internal\n    */ annotations, /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */ scrollIntoView){\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */ this._doc = null;\n        /**\n        @internal\n        */ this._state = null;\n        if (selection) checkSelection(selection, changes.newLength);\n        if (!annotations.some((a)=>a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    @internal\n    */ static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */ get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */ get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so it is recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */ get state() {\n        if (!this._state) this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */ annotation(type) {\n        for (let ann of this.annotations)if (ann.type == type) return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */ get reconfigured() {\n        return this.startState.config != this.state.config;\n    }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */ isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/ Transaction.time = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/ Transaction.userEvent = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/ Transaction.addToHistory = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/ Transaction.remote = /*@__PURE__*/ Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for(let iA = 0, iB = 0;;){\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        } else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        } else return result;\n        if (!result.length || result[result.length - 1] < from) result.push(from, to);\n        else if (result[result.length - 1] < to) result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    } else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false) filter = false;\n    for(let i = 1; i < specs.length; i++){\n        if (specs[i].filter === false) filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)){\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        } else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n        }\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for(let i = filters.length - 1; i >= 0; i--){\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction) tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];\n        else tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for(let i = extenders.length - 1; i >= 0; i--){\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [\n        value\n    ];\n}\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/ var CharCategory = /*@__PURE__*/ function(CharCategory) {\n    /**\n    Word characters.\n    */ CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */ CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */ CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n    return CharCategory;\n}(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/ new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\nfunction hasWordChar(str) {\n    if (wordChar) return wordChar.test(str);\n    for(let i = 0; i < str.length; i++){\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char)=>{\n        if (!/\\S/.test(char)) return CharCategory.Space;\n        if (hasWordChar(char)) return CharCategory.Word;\n        for(let i = 0; i < wordChars.length; i++)if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/ class EditorState {\n    constructor(/**\n    @internal\n    */ config, /**\n    The current document.\n    */ doc, /**\n    The current selection.\n    */ selection, /**\n    @internal\n    */ values, computeSlot, tr){\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        this.values = values;\n        this.status = config.statusTemplate.slice();\n        this.computeSlot = computeSlot;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr) tr._state = this;\n        for(let i = 0; i < this.config.dynamicSlots.length; i++)ensureAddr(this, i << 1);\n        this.computeSlot = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require) throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */ update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */ applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects){\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key)=>compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            } else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            } else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        let startValues;\n        if (!conf) {\n            conf = Configuration.resolve(base, compartments, this);\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(()=>null), (state, slot)=>slot.reconfigure(state, this), null);\n            startValues = intermediateState.values;\n        } else {\n            startValues = tr.startState.values.slice();\n        }\n        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();\n        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot)=>slot.update(state, tr), tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */ replaceSelection(text) {\n        if (typeof text == \"string\") text = this.toText(text);\n        return this.changeByRange((range)=>({\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: text\n                },\n                range: EditorSelection.cursor(range.from + text.length)\n            }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */ changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [\n            result1.range\n        ];\n        let effects = asArray(result1.effects);\n        for(let i = 1; i < sel.ranges.length; i++){\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for(let j = 0; j < i; j++)ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */ changes(spec = []) {\n        if (spec instanceof ChangeSet) return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n    */ toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */ sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */ facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null) return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */ toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields) for(let prop in fields){\n            let value = fields[prop];\n            if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n        }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */ static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields) for(let prop in fields){\n            if (Object.prototype.hasOwnProperty.call(json, prop)) {\n                let field = fields[prop], value = json[prop];\n                fieldInit.push(field.init((state)=>field.spec.fromJSON(value, state)));\n            }\n        }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([\n                config.extensions\n            ]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editorâ€”updated states are created by applying\n    transactions.\n    */ static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(()=>null), (state, slot)=>slot.create(state), null);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */ get tabSize() {\n        return this.facet(EditorState.tabSize);\n    }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */ get lineBreak() {\n        return this.facet(EditorState.lineSeparator) || \"\\n\";\n    }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */ get readOnly() {\n        return this.facet(readOnly);\n    }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    \n    If additional arguments are passed, they will be inserted in\n    place of markers like `$1` (for the first value) and `$2`, etc.\n    A single `$` is equivalent to `$1`, and `$$` will produce a\n    literal dollar sign.\n    */ phrase(phrase, ...insert) {\n        for (let map of this.facet(EditorState.phrases))if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n            phrase = map[phrase];\n            break;\n        }\n        if (insert.length) phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i)=>{\n            if (i == \"$\") return \"$\";\n            let n = +(i || 1);\n            return !n || n > insert.length ? m : insert[n - 1];\n        });\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    \n    Examples of language data fields are...\n    \n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n      comment syntax.\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n      for providing language-specific completion sources.\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n      characters that should be considered part of words in this\n      language.\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n      bracket closing behavior.\n    */ languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)){\n            for (let result of provider(this, pos, side)){\n                if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */ charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */ wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while(start > 0){\n            let prev = findClusterBreak(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word) break;\n            start = prev;\n        }\n        while(end < length){\n            let next = findClusterBreak(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word) break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/ EditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/ EditorState.tabSize = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/ EditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/ EditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/ EditorState.phrases = /*@__PURE__*/ Facet.define({\n    compare (a, b) {\n        let kA = Object.keys(a), kB = Object.keys(b);\n        return kA.length == kB.length && kA.every((k)=>a[k] == b[k]);\n    }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/ EditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/ EditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/ EditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/ EditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/ function combineConfig(configs, defaults, combine = {}) {\n    let result = {};\n    for (let config of configs)for (let key of Object.keys(config)){\n        let value = config[key], current = result[key];\n        if (current === undefined) result[key] = value;\n        else if (current === value || value === undefined) ; // No conflict\n        else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);\n        else throw new Error(\"Config merge conflict for field \" + key);\n    }\n    for(let key in defaults)if (result[key] === undefined) result[key] = defaults[key];\n    return result;\n}\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/ class RangeValue {\n    /**\n    Compare this value with another value. Used when comparing\n    rangesets. The default implementation compares by identity.\n    Unless you are only creating a fixed number of unique instances\n    of your value type, it is a good idea to implement this\n    properly.\n    */ eq(other) {\n        return this == other;\n    }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n    */ range(from, to = from) {\n        return Range.create(from, to, this);\n    }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/ class Range {\n    constructor(/**\n    The range's start position.\n    */ from, /**\n    Its end position.\n    */ to, /**\n    The value associated with this range.\n    */ value){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /**\n    @internal\n    */ static create(from, to, value) {\n        return new Range(from, to, value);\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() {\n        return this.to[this.to.length - 1];\n    }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for(let lo = startAt, hi = arr.length;;){\n            if (lo == hi) return lo;\n            let mid = lo + hi >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo) return diff >= 0 ? lo : hi;\n            if (diff >= 0) hi = mid;\n            else lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for(let i = this.findIndex(from, -1000000000 /* C.Far */ , true), e = this.findIndex(to, 1000000000 /* C.Far */ , false, i); i < e; i++)if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for(let i = 0; i < this.value.length; i++){\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null) continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom) continue;\n                }\n            } else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n            if (newPos < 0) newPos = newFrom;\n            if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return {\n            mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n            pos: newPos\n        };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/ class RangeSet {\n    constructor(/**\n    @internal\n    */ chunkPos, /**\n    @internal\n    */ chunk, /**\n    @internal\n    */ nextLayer, /**\n    @internal\n    */ maxPoint){\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */ static create(chunkPos, chunk, nextLayer, maxPoint) {\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n    }\n    /**\n    @internal\n    */ get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */ get size() {\n        if (this.isEmpty) return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */ chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (Note: The type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */ update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter) return this;\n        if (sort) add = add.slice().sort(cmpRange);\n        if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while(cur.value || i < add.length){\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n            } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            } else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n            add: spill,\n            filter,\n            filterFrom,\n            filterTo\n        }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */ map(changes) {\n        if (changes.empty || this.isEmpty) return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            } else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */ between(from, to, f) {\n        if (this.isEmpty) return;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */ iter(from = 0) {\n        return HeapCursor.from([\n            this\n        ]).goto(from);\n    }\n    /**\n    @internal\n    */ get isEmpty() {\n        return this.nextLayer == this;\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */ static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */ static compare(oldSets, newSets, /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration.\n    */ textDiff, comparator, /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */ minPointSize = -1) {\n        let a = oldSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length)=>compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */ static eq(oldSets, newSets, from = 0, to) {\n        if (to == null) to = 1000000000 /* C.Far */  - 1;\n        let a = oldSets.filter((set)=>!set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter((set)=>!set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length) return false;\n        if (!a.length) return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for(;;){\n            if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n            if (sideA.to > to) return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n    of the iteration.\n    */ static spans(sets, from, to, iterator, /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */ minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let openRanges = cursor.openStart;\n        for(;;){\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                let active = cursor.activeForPoint(cursor.to);\n                let openCount = cursor.pointFrom < from ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\n            } else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, openRanges);\n                openRanges = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */ static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [\n            ranges\n        ] : sort ? lazySort(ranges) : ranges)build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n    /**\n    Join an array of range sets into a single set.\n    */ static join(sets) {\n        if (!sets.length) return RangeSet.empty;\n        let result = sets[sets.length - 1];\n        for(let i = sets.length - 2; i >= 0; i--){\n            for(let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));\n        }\n        return result;\n    }\n}\n/**\nThe empty set of ranges.\n*/ RangeSet.empty = /*@__PURE__*/ new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1) for(let prev = ranges[0], i = 1; i < ranges.length; i++){\n        let cur = ranges[i];\n        if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n        prev = cur;\n    }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/ class RangeSetBuilder {\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Create an empty builder.\n    */ constructor(){\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* C.Far */ ;\n        this.lastTo = -1000000000 /* C.Far */ ;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */ add(from, to, value) {\n        if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */ addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0) return false;\n        if (this.from.length == 250 /* C.ChunkSize */ ) this.finishChunk(true);\n        if (this.chunkStart < 0) this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */ addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n        if (this.from.length) this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */ finish() {\n        return this.finishInner(RangeSet.empty);\n    }\n    /**\n    @internal\n    */ finishInner(next) {\n        if (this.from.length) this.finishChunk(false);\n        if (this.chunks.length == 0) return next;\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)for(let i = 0; i < set.chunk.length; i++)if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)for(let i = 0; i < set.chunk.length; i++){\n        let known = inA.get(set.chunk[i]);\n        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n    }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0){\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    get endSide() {\n        return this.value ? this.value.endSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while(this.chunkIndex < this.layer.chunk.length){\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n    }\n    next() {\n        for(;;){\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* C.Far */ ;\n                this.value = null;\n                break;\n            } else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while(this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        } else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap){\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for(let i = 0; i < sets.length; i++){\n            for(let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer){\n                if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        for (let cur of this.heap)cur.goto(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)cur.forward(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* C.Far */ ;\n            this.value = null;\n            this.rank = -1;\n        } else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value) top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for(let cur = heap[index];;){\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length) break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0) break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint){\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* C.Far */ ;\n        this.endSide = 0;\n        // The amount of open active ranges at the start of the iterator.\n        // Not including points.\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while(this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        // Organize active marks by rank first, then by size\n        while(i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen) insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null;\n        for(;;){\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen) remove(trackOpen, a);\n            } else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* C.Far */ ;\n                break;\n            } else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            } else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) {\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                } else {\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            this.openStart = 0;\n            for(let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)this.openStart++;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length) return this.active;\n        let active = [];\n        for(let i = this.active.length - 1; i >= 0; i--){\n            if (this.activeRank[i] < this.pointRank) break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for(let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for(;;){\n        let dEnd = a.to + dPos - b.to, diff = dEnd || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        } else {\n            if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB) break;\n        if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange) comparator.boundChange(end);\n        pos = end;\n        if (diff <= 0) a.next();\n        if (diff >= 0) b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n    return true;\n}\nfunction remove(array, index) {\n    for(let i = index, e = array.length - 1; i < e; i++)array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for(let i = array.length - 1; i >= index; i--)array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* C.Far */ ;\n    for(let i = 0; i < array.length; i++)if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n        found = i;\n        foundPos = array[i];\n    }\n    return found;\n}\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/ function countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for(let i = 0; i < to && i < string.length;){\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - n % tabSize;\n            i++;\n        } else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/ function findColumn(string, col, tabSize, strict) {\n    for(let i = 0, n = 0;;){\n        if (n >= col) return i;\n        if (i == string.length) break;\n        n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Y7QUFFcEY7O0FBRUEsR0FDQSxNQUFNRTtJQUNGOztJQUVBLEdBQ0FDLE9BQU9DLEdBQUcsRUFBRTtRQUNSLElBQUlBLE1BQU0sS0FBS0EsTUFBTSxJQUFJLENBQUNDLE1BQU0sRUFDNUIsTUFBTSxJQUFJQyxXQUFXLENBQUMsaUJBQWlCLEVBQUVGLElBQUksdUJBQXVCLEVBQUUsSUFBSSxDQUFDQyxNQUFNLENBQUMsQ0FBQztRQUN2RixPQUFPLElBQUksQ0FBQ0UsU0FBUyxDQUFDSCxLQUFLLE9BQU8sR0FBRztJQUN6QztJQUNBOztJQUVBLEdBQ0FJLEtBQUtDLENBQUMsRUFBRTtRQUNKLElBQUlBLElBQUksS0FBS0EsSUFBSSxJQUFJLENBQUNDLEtBQUssRUFDdkIsTUFBTSxJQUFJSixXQUFXLENBQUMsb0JBQW9CLEVBQUVHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxDQUFDLGNBQWMsQ0FBQztRQUNsRixPQUFPLElBQUksQ0FBQ0gsU0FBUyxDQUFDRSxHQUFHLE1BQU0sR0FBRztJQUN0QztJQUNBOztJQUVBLEdBQ0FFLFFBQVFDLElBQUksRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQUU7UUFDcEIsQ0FBQ0YsTUFBTUMsR0FBRyxHQUFHRSxLQUFLLElBQUksRUFBRUgsTUFBTUM7UUFDOUIsSUFBSUcsUUFBUSxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxTQUFTLENBQUMsR0FBR0wsTUFBTUksT0FBTyxFQUFFLFdBQVc7UUFDNUMsSUFBSUYsS0FBS1QsTUFBTSxFQUNYUyxLQUFLRyxTQUFTLENBQUMsR0FBR0gsS0FBS1QsTUFBTSxFQUFFVyxPQUFPLEVBQUUsYUFBYSxNQUFLLEVBQUUsV0FBVztRQUMzRSxJQUFJLENBQUNDLFNBQVMsQ0FBQ0osSUFBSSxJQUFJLENBQUNS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LE1BQU0sSUFBSXNZLFVBQVd0YixJQUFJc2IsVUFBVztRQUMzRHRZLElBQUl6RCxpQkFBaUIwRCxRQUFRRDtJQUNqQztJQUNBLE9BQU93Z0IsV0FBVyxPQUFPLENBQUMsSUFBSXZnQixPQUFPckQsTUFBTTtBQUMvQztBQUVrWCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYXJuY29kZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmpzPzhjOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmluZENsdXN0ZXJCcmVhayBhcyBmaW5kQ2x1c3RlckJyZWFrJDEgfSBmcm9tICdAbWFyaWpuL2ZpbmQtY2x1c3Rlci1icmVhayc7XG5cbi8qKlxuVGhlIGRhdGEgc3RydWN0dXJlIGZvciBkb2N1bWVudHMuIEBub25hYnN0cmFjdFxuKi9cbmNsYXNzIFRleHQge1xuICAgIC8qKlxuICAgIEdldCB0aGUgbGluZSBkZXNjcmlwdGlvbiBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbGluZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgMCB8fCBwb3MgPiB0aGlzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHBvc2l0aW9uICR7cG9zfSBpbiBkb2N1bWVudCBvZiBsZW5ndGggJHt0aGlzLmxlbmd0aH1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKHBvcywgZmFsc2UsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gKDEtYmFzZWQpIGxpbmUgbnVtYmVyLlxuICAgICovXG4gICAgbGluZShuKSB7XG4gICAgICAgIGlmIChuIDwgMSB8fCBuID4gdGhpcy5saW5lcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGxpbmUgbnVtYmVyICR7bn0gaW4gJHt0aGlzLmxpbmVzfS1saW5lIGRvY3VtZW50YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihuLCB0cnVlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSB0ZXh0IHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKDAsIGZyb20sIHBhcnRzLCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0ZXh0LmRlY29tcG9zZSgwLCB0ZXh0Lmxlbmd0aCwgcGFydHMsIDEgLyogT3Blbi5Gcm9tICovIHwgMiAvKiBPcGVuLlRvICovKTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UodG8sIHRoaXMubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwZW5kIGFub3RoZXIgZG9jdW1lbnQgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHRleHQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgdGV4dCBpcyBlcXVhbCB0byBhbm90aGVyIGluc3RhbmNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIDEpLCBlbmQgPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgLTEpO1xuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xuICAgICAgICBmb3IgKGxldCBza2lwID0gc3RhcnQsIHBvcyA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIGEubmV4dChza2lwKTtcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgaWYgKGEubGluZUJyZWFrICE9IGIubGluZUJyZWFrIHx8IGEuZG9uZSAhPSBiLmRvbmUgfHwgYS52YWx1ZSAhPSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmRvbmUgfHwgcG9zID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRleHQuIFdoZW4gYGRpcmAgaXMgYC0xYCwgaXRlcmF0aW9uIGhhcHBlbnNcbiAgICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLlxuICAgICovXG4gICAgaXRlcihkaXIgPSAxKSB7IHJldHVybiBuZXcgUmF3VGV4dEN1cnNvcih0aGlzLCBkaXIpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgaXRlcmF0b3Igd2lsbCBydW4gaW4gcmV2ZXJzZS5cbiAgICAqL1xuICAgIGl0ZXJSYW5nZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7IHJldHVybiBuZXcgUGFydGlhbFRleHRDdXJzb3IodGhpcywgZnJvbSwgdG8pOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gICAgX3dpdGhvdXRfIHJldHVybmluZyB0aGUgbGluZSBicmVha3MgYmV0d2VlbiwgYW5kIHlpZWxkaW5nIGVtcHR5XG4gICAgc3RyaW5ncyBmb3IgZW1wdHkgbGluZXMuXG4gICAgXG4gICAgV2hlbiBgZnJvbWAgYW5kIGB0b2AgYXJlIGdpdmVuLCB0aGV5IHNob3VsZCBiZSAxLWJhc2VkIGxpbmUgbnVtYmVycy5cbiAgICAqL1xuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMubGluZXMgKyAxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5saW5lKGZyb20pLmZyb207XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJzb3IoaW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLCB1c2luZyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICBzZXBhcmF0ZSBsaW5lcy5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dF5vZikpLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGF0dGVuKGxpbmVzKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYFRleHRgIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YodGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBkb2N1bWVudCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGxpbmVcIik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmICF0ZXh0WzBdKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLyA/IG5ldyBUZXh0TGVhZih0ZXh0KSA6IFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQodGV4dCwgW10pKTtcbiAgICB9XG59XG4vLyBMZWF2ZXMgc3RvcmUgYW4gYXJyYXkgb2YgbGluZSBzdHJpbmdzLiBUaGVyZSBhcmUgYWx3YXlzIGxpbmUgYnJlYWtzXG4vLyBiZXR3ZWVuIHRoZXNlIHN0cmluZ3MuIExlYXZlcyBhcmUgbGltaXRlZCBpbiBzaXplIGFuZCBoYXZlIHRvIGJlXG4vLyBjb250YWluZWQgaW4gVGV4dE5vZGUgaW5zdGFuY2VzIGZvciBiaWdnZXIgZG9jdW1lbnRzLlxuY2xhc3MgVGV4dExlYWYgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBsZW5ndGggPSB0ZXh0TGVuZ3RoKHRleHQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGluZXMoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBsaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKG9mZnNldCwgZW5kLCBsaW5lLCBzdHJpbmcpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBsZXQgdGV4dCA9IGZyb20gPD0gMCAmJiB0byA+PSB0aGlzLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IFRleHRMZWFmKHNsaWNlVGV4dCh0aGlzLnRleHQsIGZyb20sIHRvKSwgTWF0aC5taW4odG8sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGZyb20pKTtcbiAgICAgICAgaWYgKG9wZW4gJiAxIC8qIE9wZW4uRnJvbSAqLykge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0YXJnZXQucG9wKCk7XG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoam9pbmVkLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQsIHByZXYubGVuZ3RoICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtaWQgPSBqb2luZWQubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZikpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGxpbmVzID0gYXBwZW5kVGV4dCh0aGlzLnRleHQsIGFwcGVuZFRleHQodGV4dC50ZXh0LCBzbGljZVRleHQodGhpcy50ZXh0LCAwLCBmcm9tKSksIHRvKTtcbiAgICAgICAgbGV0IG5ld0xlbiA9IHRoaXMubGVuZ3RoICsgdGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLylcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYobGluZXMsIG5ld0xlbik7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKFRleHRMZWFmLnNwbGl0KGxpbmVzLCBbXSksIG5ld0xlbik7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBwb3MgPD0gdG8gJiYgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy50ZXh0KVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgfVxuICAgIHNjYW5JZGVudGljYWwoKSB7IHJldHVybiAwOyB9XG4gICAgc3RhdGljIHNwbGl0KHRleHQsIHRhcmdldCkge1xuICAgICAgICBsZXQgcGFydCA9IFtdLCBsZW4gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KSB7XG4gICAgICAgICAgICBwYXJ0LnB1c2gobGluZSk7XG4gICAgICAgICAgICBsZW4gKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKHBhcnQsIGxlbikpO1xuICAgICAgICAgICAgICAgIHBhcnQgPSBbXTtcbiAgICAgICAgICAgICAgICBsZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gLTEpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufVxuLy8gTm9kZXMgcHJvdmlkZSB0aGUgdHJlZSBzdHJ1Y3R1cmUgb2YgdGhlIGBUZXh0YCB0eXBlLiBUaGV5IHN0b3JlIGFcbi8vIG51bWJlciBvZiBvdGhlciBub2RlcyBvciBsZWF2ZXMsIHRha2luZyBjYXJlIHRvIGJhbGFuY2UgdGhlbXNlbHZlc1xuLy8gb24gY2hhbmdlcy4gVGhlcmUgYXJlIGltcGxpZWQgbGluZSBicmVha3MgX2JldHdlZW5fIHRoZSBjaGlsZHJlbiBvZlxuLy8gYSBub2RlIChidXQgbm90IGJlZm9yZSB0aGUgZmlyc3Qgb3IgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQpLlxuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgbGVuZ3RoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMubGluZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIHRoaXMubGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5sZW5ndGgsIGVuZExpbmUgPSBsaW5lICsgY2hpbGQubGluZXMgLSAxO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBlbmRMaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZCArIDE7XG4gICAgICAgICAgICBsaW5lID0gZW5kTGluZSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb21wb3NlKGZyb20sIHRvLCB0YXJnZXQsIG9wZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZyb20gPD0gZW5kICYmIHRvID49IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9wZW4gPSBvcGVuICYgKChwb3MgPD0gZnJvbSA/IDEgLyogT3Blbi5Gcm9tICovIDogMCkgfCAoZW5kID49IHRvID8gMiAvKiBPcGVuLlRvICovIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBlbmQgPD0gdG8gJiYgIWNoaWxkT3BlbilcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVjb21wb3NlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0YXJnZXQsIGNoaWxkT3Blbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGV4dC5saW5lcyA8IHRoaXMubGluZXMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiBpZiB0aGUgY2hhbmdlIG9ubHkgYWZmZWN0cyBvbmUgY2hpbGQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoaWxkJ3Mgc2l6ZSByZW1haW5zIGluIHRoZSBhY2NlcHRhYmxlIHJhbmdlLCBvbmx5IHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY2hpbGRcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBwb3MgJiYgdG8gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gY2hpbGQucmVwbGFjZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbExpbmVzID0gdGhpcy5saW5lcyAtIGNoaWxkLmxpbmVzICsgdXBkYXRlZC5saW5lcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQubGluZXMgPCAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoY29weSwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShwb3MsIGVuZCwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGlsZC5zbGljZVN0cmluZyhmcm9tIC0gcG9zLCB0byAtIHBvcywgbGluZVNlcCk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBjaGlsZC5mbGF0dGVuKHRhcmdldCk7XG4gICAgfVxuICAgIHNjYW5JZGVudGljYWwob3RoZXIsIGRpcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFRleHROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IFtpQSwgaUIsIGVBLCBlQl0gPSBkaXIgPiAwID8gWzAsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCBvdGhlci5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgICA6IFt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEsIG90aGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAtMV07XG4gICAgICAgIGZvciAoOzsgaUEgKz0gZGlyLCBpQiArPSBkaXIpIHtcbiAgICAgICAgICAgIGlmIChpQSA9PSBlQSB8fCBpQiA9PSBlQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNoQSA9IHRoaXMuY2hpbGRyZW5baUFdLCBjaEIgPSBvdGhlci5jaGlsZHJlbltpQl07XG4gICAgICAgICAgICBpZiAoY2hBICE9IGNoQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgY2hBLnNjYW5JZGVudGljYWwoY2hCLCBkaXIpO1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNoQS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGNoaWxkcmVuLCBsZW5ndGggPSBjaGlsZHJlbi5yZWR1Y2UoKGwsIGNoKSA9PiBsICsgY2gubGVuZ3RoICsgMSwgLTEpKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgbGluZXMgKz0gY2gubGluZXM7XG4gICAgICAgIGlmIChsaW5lcyA8IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2guZmxhdHRlbihmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYoZmxhdCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2h1bmsgPSBNYXRoLm1heCgzMiAvKiBUcmVlLkJyYW5jaCAqLywgbGluZXMgPj4gNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovKSwgbWF4Q2h1bmsgPSBjaHVuayA8PCAxLCBtaW5DaHVuayA9IGNodW5rID4+IDE7XG4gICAgICAgIGxldCBjaHVua2VkID0gW10sIGN1cnJlbnRMaW5lcyA9IDAsIGN1cnJlbnRMZW4gPSAtMSwgY3VycmVudENodW5rID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZChjaGlsZCkge1xuICAgICAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGluZXMgPiBtYXhDaHVuayAmJiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBjaGlsZC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgYWRkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubGluZXMgPiBtaW5DaHVuayAmJiAoY3VycmVudExpbmVzID4gbWluQ2h1bmsgfHwgIWN1cnJlbnRMaW5lcykpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGNodW5rZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHRMZWFmICYmIGN1cnJlbnRMaW5lcyAmJlxuICAgICAgICAgICAgICAgIChsYXN0ID0gY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLmxpbmVzICsgbGFzdC5saW5lcyA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSA9IG5ldyBUZXh0TGVhZihsYXN0LnRleHQuY29uY2F0KGNoaWxkLnRleHQpLCBsYXN0Lmxlbmd0aCArIDEgKyBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyArIGNoaWxkLmxpbmVzID4gY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVzID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGN1cnJlbnRDaHVuay5sZW5ndGggPT0gMSA/IGN1cnJlbnRDaHVua1swXSA6IFRleHROb2RlLmZyb20oY3VycmVudENodW5rLCBjdXJyZW50TGVuKSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuID0gLTE7XG4gICAgICAgICAgICBjdXJyZW50TGluZXMgPSBjdXJyZW50Q2h1bmsubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGFkZChjaGlsZCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICAgIHJldHVybiBjaHVua2VkLmxlbmd0aCA9PSAxID8gY2h1bmtlZFswXSA6IG5ldyBUZXh0Tm9kZShjaHVua2VkLCBsZW5ndGgpO1xuICAgIH1cbn1cblRleHQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFRleHRMZWFmKFtcIlwiXSwgMCk7XG5mdW5jdGlvbiB0ZXh0TGVuZ3RoKHRleHQpIHtcbiAgICBsZXQgbGVuZ3RoID0gLTE7XG4gICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KVxuICAgICAgICBsZW5ndGggKz0gbGluZS5sZW5ndGggKyAxO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRleHQsIHRhcmdldCwgZnJvbSA9IDAsIHRvID0gMWU5KSB7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDAsIGZpcnN0ID0gdHJ1ZTsgaSA8IHRleHQubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGZyb20gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3RhcmdldC5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHNsaWNlVGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIHJldHVybiBhcHBlbmRUZXh0KHRleHQsIFtcIlwiXSwgZnJvbSwgdG8pO1xufVxuY2xhc3MgUmF3VGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgZGlyID0gMSkge1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RleHRdO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBbZGlyID4gMCA/IDEgOiAodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdGV4dC50ZXh0Lmxlbmd0aCA6IHRleHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxXTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICB0aGlzLmRvbmUgPSB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLm5vZGVzW2xhc3RdLCBvZmZzZXRWYWx1ZSA9IHRoaXMub2Zmc2V0c1tsYXN0XSwgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgPj4gMTtcbiAgICAgICAgICAgIGxldCBzaXplID0gdG9wIGluc3RhbmNlb2YgVGV4dExlYWYgPyB0b3AudGV4dC5sZW5ndGggOiB0b3AuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAoZGlyID4gMCA/IHNpemUgOiAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3QgLSAxXSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKG9mZnNldFZhbHVlICYgMSkgPT0gKGRpciA+IDAgPyAwIDogMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC50ZXh0W29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPiBNYXRoLm1heCgwLCBza2lwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2tpcCA9PSAwID8gbmV4dCA6IGRpciA+IDAgPyBuZXh0LnNsaWNlKHNraXApIDogbmV4dC5zbGljZSgwLCBuZXh0Lmxlbmd0aCAtIHNraXApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPiBuZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0tLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucHVzaChkaXIgPiAwID8gMSA6IChuZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyBuZXh0LnRleHQubGVuZ3RoIDogbmV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0SW5uZXIoLXNraXAsICgtdGhpcy5kaXIpKTtcbiAgICAgICAgICAgIHNraXAgPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5kaXIpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnRpYWxUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBuZXcgUmF3VGV4dEN1cnNvcih0ZXh0LCBzdGFydCA+IGVuZCA/IC0xIDogMSk7XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnQgPiBlbmQgPyB0ZXh0Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMuZnJvbSA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnRvID0gTWF0aC5tYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgPyB0aGlzLnBvcyA8PSB0aGlzLmZyb20gOiB0aGlzLnBvcyA+PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBza2lwICs9IE1hdGgubWF4KDAsIGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMudG8gOiB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGxldCBsaW1pdCA9IGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMuZnJvbSA6IHRoaXMudG8gLSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHNraXAgPiBsaW1pdClcbiAgICAgICAgICAgIHNraXAgPSBsaW1pdDtcbiAgICAgICAgbGltaXQgLT0gc2tpcDtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IHRoaXMuY3Vyc29yLm5leHQoc2tpcCk7XG4gICAgICAgIHRoaXMucG9zICs9ICh2YWx1ZS5sZW5ndGggKyBza2lwKSAqIGRpcjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLmxlbmd0aCA8PSBsaW1pdCA/IHZhbHVlIDogZGlyIDwgMCA/IHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIGxpbWl0KSA6IHZhbHVlLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgdGhpcy5kb25lID0gIXRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1heChza2lwLCB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKHNraXAgPiAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWluKHNraXAsIHRoaXMudG8gLSB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmN1cnNvci5kaXIpO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5jdXJzb3IubGluZUJyZWFrICYmIHRoaXMudmFsdWUgIT0gXCJcIjsgfVxufVxuY2xhc3MgTGluZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgbGV0IHsgZG9uZSwgbGluZUJyZWFrLCB2YWx1ZSB9ID0gdGhpcy5pbm5lci5uZXh0KHNraXApO1xuICAgICAgICBpZiAoZG9uZSAmJiB0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBUZXh0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pdGVyKCk7IH07XG4gICAgUmF3VGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IFBhcnRpYWxUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgTGluZUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG4vKipcblRoaXMgdHlwZSBkZXNjcmliZXMgYSBsaW5lIGluIHRoZSBkb2N1bWVudC4gSXQgaXMgY3JlYXRlZFxub24tZGVtYW5kIHdoZW4gbGluZXMgYXJlIFtxdWVyaWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQubGluZUF0KS5cbiovXG5jbGFzcyBMaW5lIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGluZSAoX2JlZm9yZV8gdGhlIGxpbmUgYnJlYWssXG4gICAgb3IgYXQgdGhlIGVuZCBvZiBkb2N1bWVudCBmb3IgdGhlIGxhc3QgbGluZSkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhpcyBsaW5lJ3MgbGluZSBudW1iZXIgKDEtYmFzZWQpLlxuICAgICovXG4gICAgbnVtYmVyLCBcbiAgICAvKipcbiAgICBUaGUgbGluZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGxpbmUgKG5vdCBpbmNsdWRpbmcgYW55IGxpbmUgYnJlYWsgYWZ0ZXIgaXQpLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG8gLSB0aGlzLmZyb207IH1cbn1cbmZ1bmN0aW9uIGNsaXAodGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmcm9tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGV4dC5sZW5ndGgsIGZyb20pKTtcbiAgICByZXR1cm4gW2Zyb20sIE1hdGgubWF4KGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCB0bykpXTtcbn1cblxuLyoqXG5SZXR1cm5zIGEgbmV4dCBncmFwaGVtZSBjbHVzdGVyIGJyZWFrIF9hZnRlcl8gKG5vdCBlcXVhbCB0bylcbmBwb3NgLCBpZiBgZm9yd2FyZGAgaXMgdHJ1ZSwgb3IgYmVmb3JlIG90aGVyd2lzZS4gUmV0dXJucyBgcG9zYFxuaXRzZWxmIGlmIG5vIGZ1cnRoZXIgY2x1c3RlciBicmVhayBpcyBhdmFpbGFibGUgaW4gdGhlIHN0cmluZy5cbk1vdmVzIGFjcm9zcyBzdXJyb2dhdGUgcGFpcnMsIGV4dGVuZGluZyBjaGFyYWN0ZXJzICh3aGVuXG5gaW5jbHVkZUV4dGVuZGluZ2AgaXMgdHJ1ZSksIGNoYXJhY3RlcnMgam9pbmVkIHdpdGggemVyby13aWR0aFxuam9pbmVycywgYW5kIGZsYWcgZW1vamkuXG4qL1xuZnVuY3Rpb24gZmluZENsdXN0ZXJCcmVhayhzdHIsIHBvcywgZm9yd2FyZCA9IHRydWUsIGluY2x1ZGVFeHRlbmRpbmcgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGZpbmRDbHVzdGVyQnJlYWskMShzdHIsIHBvcywgZm9yd2FyZCwgaW5jbHVkZUV4dGVuZGluZyk7XG59XG5mdW5jdGlvbiBzdXJyb2dhdGVMb3coY2gpIHsgcmV0dXJuIGNoID49IDB4REMwMCAmJiBjaCA8IDB4RTAwMDsgfVxuZnVuY3Rpb24gc3Vycm9nYXRlSGlnaChjaCkgeyByZXR1cm4gY2ggPj0gMHhEODAwICYmIGNoIDwgMHhEQzAwOyB9XG4vKipcbkZpbmQgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGluIGEgc3RyaW5nIChsaWtlIHRoZVxuW2Bjb2RlUG9pbnRBdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9jb2RlUG9pbnRBdClcbnN0cmluZyBtZXRob2QpLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludEF0KHN0ciwgcG9zKSB7XG4gICAgbGV0IGNvZGUwID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUhpZ2goY29kZTApIHx8IHBvcyArIDEgPT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGNvZGUwO1xuICAgIGxldCBjb2RlMSA9IHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmICghc3Vycm9nYXRlTG93KGNvZGUxKSlcbiAgICAgICAgcmV0dXJuIGNvZGUwO1xuICAgIHJldHVybiAoKGNvZGUwIC0gMHhkODAwKSA8PCAxMCkgKyAoY29kZTEgLSAweGRjMDApICsgMHgxMDAwMDtcbn1cbi8qKlxuR2l2ZW4gYSBVbmljb2RlIGNvZGVwb2ludCwgcmV0dXJuIHRoZSBKYXZhU2NyaXB0IHN0cmluZyB0aGF0XG5yZXNwcmVzZW50cyBpdCAobGlrZVxuW2BTdHJpbmcuZnJvbUNvZGVQb2ludGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9mcm9tQ29kZVBvaW50KSkuXG4qL1xuZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhkODAwLCAoY29kZSAmIDEwMjMpICsgMHhkYzAwKTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiBwb3NpdGlvbnMgYSBjaGFyYWN0ZXIgdGFrZXMgdXAgaW4gYSBKYXZhU2NyaXB0IHN0cmluZy5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRTaXplKGNvZGUpIHsgcmV0dXJuIGNvZGUgPCAweDEwMDAwID8gMSA6IDI7IH1cblxuY29uc3QgRGVmYXVsdFNwbGl0ID0gL1xcclxcbj98XFxuLztcbi8qKlxuRGlzdGluZ3Vpc2hlcyBkaWZmZXJlbnQgd2F5cyBpbiB3aGljaCBwb3NpdGlvbnMgY2FuIGJlIG1hcHBlZC5cbiovXG52YXIgTWFwTW9kZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcE1vZGUpIHtcbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0byBhIHZhbGlkIG5ldyBwb3NpdGlvbiwgZXZlbiB3aGVuIGl0cyBjb250ZXh0XG4gICAgd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJTaW1wbGVcIl0gPSAwXSA9IFwiU2ltcGxlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgZGVsZXRpb24gaGFwcGVucyBhY3Jvc3MgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tEZWxcIl0gPSAxXSA9IFwiVHJhY2tEZWxcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9iZWZvcmVfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tCZWZvcmVcIl0gPSAyXSA9IFwiVHJhY2tCZWZvcmVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9hZnRlcl8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0FmdGVyXCJdID0gM10gPSBcIlRyYWNrQWZ0ZXJcIjtcbnJldHVybiBNYXBNb2RlfSkoTWFwTW9kZSB8fCAoTWFwTW9kZSA9IHt9KSk7XG4vKipcbkEgY2hhbmdlIGRlc2NyaXB0aW9uIGlzIGEgdmFyaWFudCBvZiBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpXG50aGF0IGRvZXNuJ3Qgc3RvcmUgdGhlIGluc2VydGVkIHRleHQuIEFzIHN1Y2gsIGl0IGNhbid0IGJlXG5hcHBsaWVkLCBidXQgaXMgY2hlYXBlciB0byBzdG9yZSBhbmQgbWFuaXB1bGF0ZS5cbiovXG5jbGFzcyBDaGFuZ2VEZXNjIHtcbiAgICAvLyBTZWN0aW9ucyBhcmUgZW5jb2RlZCBhcyBwYWlycyBvZiBpbnRlZ2Vycy4gVGhlIGZpcnN0IGlzIHRoZVxuICAgIC8vIGxlbmd0aCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCwgYW5kIHRoZSBzZWNvbmQgaXMgLTEgZm9yXG4gICAgLy8gdW5hZmZlY3RlZCBzZWN0aW9ucywgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHJlcGxhY2VtZW50IGNvbnRlbnRcbiAgICAvLyBvdGhlcndpc2UuIFNvIGFuIGluc2VydGlvbiB3b3VsZCBiZSAoMCwgbj4wKSwgYSBkZWxldGlvbiAobj4wLFxuICAgIC8vIDApLCBhbmQgYSByZXBsYWNlbWVudCB0d28gcG9zaXRpdmUgbnVtYmVycy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zZWN0aW9uc1tpXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBuZXdMZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbnMgPCAwID8gdGhpcy5zZWN0aW9uc1tpXSA6IGlucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGYWxzZSB3aGVuIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcyBpbiB0aGlzIHNldC5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMiAmJiB0aGlzLnNlY3Rpb25zWzFdIDwgMDsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdW5jaGFuZ2VkIHBhcnRzIGxlZnQgYnkgdGhlc2UgY2hhbmdlcy4gYHBvc0FgXG4gICAgcHJvdmlkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSByYW5nZSBpbiB0aGUgb2xkIGRvY3VtZW50LCBgcG9zQmBcbiAgICB0aGUgbmV3IHBvc2l0aW9uIGluIHRoZSBjaGFuZ2VkIGRvY3VtZW50LlxuICAgICovXG4gICAgaXRlckdhcHMoZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGYocG9zQSwgcG9zQiwgbGVuKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgY2hhbmdlZCBieSB0aGVzZSBjaGFuZ2VzLiAoU2VlXG4gICAgW2BDaGFuZ2VTZXQuaXRlckNoYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC5pdGVyQ2hhbmdlcykgZm9yIGFcbiAgICB2YXJpYW50IHRoYXQgYWxzbyBwcm92aWRlcyB5b3Ugd2l0aCB0aGUgaW5zZXJ0ZWQgdGV4dC4pXG4gICAgYGZyb21BYC9gdG9BYCBwcm92aWRlcyB0aGUgZXh0ZW50IG9mIHRoZSBjaGFuZ2UgaW4gdGhlIHN0YXJ0aW5nXG4gICAgZG9jdW1lbnQsIGBmcm9tQmAvYHRvQmAgdGhlIGV4dGVudCBvZiB0aGUgcmVwbGFjZW1lbnQgaW4gdGhlXG4gICAgY2hhbmdlZCBkb2N1bWVudC5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzICh3aGljaCBhcmUga2VwdFxuICAgIHNlcGFyYXRlIGZvciBbcG9zaXRpb24gbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLm1hcFBvcykpIGFyZVxuICAgIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlZFJhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnZlcnRlZCBmb3JtIG9mIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgaW52ZXJ0ZWREZXNjKCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goaW5zLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhcHBseWluZyBhbm90aGVyIHNldCBvZiBjaGFuZ2VzXG4gICAgYWZ0ZXIgdGhpcyBvbmUuIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoaXMgc2V0IHNob3VsZFxuICAgIG1hdGNoIHRoZSBsZW5ndGggYmVmb3JlIGBvdGhlcmAuXG4gICAgKi9cbiAgICBjb21wb3NlRGVzYyhvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIpOyB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZGVzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGFwcGxpZWQgYWZ0ZXIgaXQuIFdoZW4gYGJlZm9yZWAgaXMgdHJ1ZSwgbWFwIGFzIGlmIHRoZSBjaGFuZ2VzXG4gICAgaW4gYHRoaXNgIGhhcHBlbmVkIGJlZm9yZSB0aGUgb25lcyBpbiBgb3RoZXJgLlxuICAgICovXG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlKTsgfVxuICAgIG1hcFBvcyhwb3MsIGFzc29jID0gLTEsIG1vZGUgPSBNYXBNb2RlLlNpbXBsZSkge1xuICAgICAgICBsZXQgcG9zQSA9IDAsIHBvc0IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmRBID0gcG9zQSArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NCICsgKHBvcyAtIHBvc0EpO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT0gTWFwTW9kZS5TaW1wbGUgJiYgZW5kQSA+PSBwb3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1vZGUgPT0gTWFwTW9kZS5UcmFja0RlbCAmJiBwb3NBIDwgcG9zICYmIGVuZEEgPiBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0JlZm9yZSAmJiBwb3NBIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tBZnRlciAmJiBlbmRBID4gcG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MgfHwgZW5kQSA9PSBwb3MgJiYgYXNzb2MgPCAwICYmICFsZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPT0gcG9zQSB8fCBhc3NvYyA8IDAgPyBwb3NCIDogcG9zQiArIGlucztcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPiBwb3NBKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBpcyBvdXQgb2YgcmFuZ2UgZm9yIGNoYW5nZXNldCBvZiBsZW5ndGggJHtwb3NBfWApO1xuICAgICAgICByZXR1cm4gcG9zQjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGVzZSBjaGFuZ2VzIHRvdWNoIGEgZ2l2ZW4gcmFuZ2UuIFdoZW4gb25lIG9mIHRoZVxuICAgIGNoYW5nZXMgZW50aXJlbHkgY292ZXJzIHRoZSByYW5nZSwgdGhlIHN0cmluZyBgXCJjb3ZlclwiYCBpc1xuICAgIHJldHVybmVkLlxuICAgICovXG4gICAgdG91Y2hlc1JhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kID0gcG9zICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwICYmIHBvcyA8PSB0byAmJiBlbmQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zIDwgZnJvbSAmJiBlbmQgPiB0byA/IFwiY292ZXJcIiA6IHRydWU7XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAocmVzdWx0ID8gXCIgXCIgOiBcIlwiKSArIGxlbiArIChpbnMgPj0gMCA/IFwiOlwiICsgaW5zIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIGRlc2MgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIGRlc2MgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWRcbiAgICBieSBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pIHx8IGpzb24ubGVuZ3RoICUgMiB8fCBqc29uLnNvbWUoYSA9PiB0eXBlb2YgYSAhPSBcIm51bWJlclwiKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZURlc2NcIik7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHNlY3Rpb25zKSB7IHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7IH1cbn1cbi8qKlxuQSBjaGFuZ2Ugc2V0IHJlcHJlc2VudHMgYSBncm91cCBvZiBtb2RpZmljYXRpb25zIHRvIGEgZG9jdW1lbnQuIEl0XG5zdG9yZXMgdGhlIGRvY3VtZW50IGxlbmd0aCwgYW5kIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gZG9jdW1lbnRzXG53aXRoIGV4YWN0bHkgdGhhdCBsZW5ndGguXG4qL1xuY2xhc3MgQ2hhbmdlU2V0IGV4dGVuZHMgQ2hhbmdlRGVzYyB7XG4gICAgY29uc3RydWN0b3Ioc2VjdGlvbnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0ZWQpIHtcbiAgICAgICAgc3VwZXIoc2VjdGlvbnMpO1xuICAgICAgICB0aGlzLmluc2VydGVkID0gaW5zZXJ0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBjaGFuZ2VzIHRvIGEgZG9jdW1lbnQsIHJldHVybmluZyB0aGUgbW9kaWZpZWRcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT0gZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgY2hhbmdlIHNldCB0byBhIGRvY3VtZW50IHdpdGggdGhlIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgKGZyb21BLCB0b0EsIGZyb21CLCBfdG9CLCB0ZXh0KSA9PiBkb2MgPSBkb2MucmVwbGFjZShmcm9tQiwgZnJvbUIgKyAodG9BIC0gZnJvbUEpLCB0ZXh0KSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgX2JlZm9yZV8gdGhlIGNoYW5nZXMsIHJldHVybiBhXG4gICAgY2hhbmdlIHNldCB0aGF0IHJlcHJlc2VudHMgdGhlIGludmVyc2Ugb2YgdGhpcyBzZXQsIHdoaWNoIGNvdWxkXG4gICAgYmUgdXNlZCB0byBnbyBmcm9tIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IHRoZSBjaGFuZ2VzIGJhY2sgdG9cbiAgICB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBiZWZvcmUgdGhlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMuc2xpY2UoKSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHNlY3Rpb25zW2ldLCBpbnMgPSBzZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpXSA9IGlucztcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpICsgMV0gPSBsZW47XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaSA+PiAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKGxlbiA/IGRvYy5zbGljZShwb3MsIHBvcyArIGxlbikgOiBUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tYmluZSB0d28gc3Vic2VxdWVudCBjaGFuZ2Ugc2V0cyBpbnRvIGEgc2luZ2xlIHNldC4gYG90aGVyYFxuICAgIG11c3Qgc3RhcnQgaW4gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGB0aGlzYC4gSWYgYHRoaXNgIGdvZXNcbiAgICBgZG9jQWAg4oaSIGBkb2NCYCBhbmQgYG90aGVyYCByZXByZXNlbnRzIGBkb2NCYCDihpIgYGRvY0NgLCB0aGVcbiAgICByZXR1cm5lZCB2YWx1ZSB3aWxsIHJlcHJlc2VudCB0aGUgY2hhbmdlIGBkb2NBYCDihpIgYGRvY0NgLlxuICAgICovXG4gICAgY29tcG9zZShvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYW5vdGhlciBjaGFuZ2Ugc2V0IHN0YXJ0aW5nIGluIHRoZSBzYW1lIGRvY3VtZW50LCBtYXBzIHRoaXNcbiAgICBjaGFuZ2Ugc2V0IG92ZXIgdGhlIG90aGVyLCBwcm9kdWNpbmcgYSBuZXcgY2hhbmdlIHNldCB0aGF0IGNhbiBiZVxuICAgIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGFwcGx5aW5nIGBvdGhlcmAuIFdoZW5cbiAgICBgYmVmb3JlYCBpcyBgdHJ1ZWAsIG9yZGVyIGNoYW5nZXMgYXMgaWYgYHRoaXNgIGNvbWVzIGJlZm9yZVxuICAgIGBvdGhlcmAsIG90aGVyd2lzZSAodGhlIGRlZmF1bHQpIHRyZWF0IGBvdGhlcmAgYXMgY29taW5nIGZpcnN0LlxuICAgIFxuICAgIEdpdmVuIHR3byBjaGFuZ2VzIGBBYCBhbmQgYEJgLCBgQS5jb21wb3NlKEIubWFwKEEpKWAgYW5kXG4gICAgYEIuY29tcG9zZShBLm1hcChCLCB0cnVlKSlgIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBkb2N1bWVudC4gVGhpc1xuICAgIHByb3ZpZGVzIGEgYmFzaWMgZm9ybSBvZiBbb3BlcmF0aW9uYWxcbiAgICB0cmFuc2Zvcm1hdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0aW9uYWxfdHJhbnNmb3JtYXRpb24pLFxuICAgIGFuZCBjYW4gYmUgdXNlZCBmb3IgY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuICAgICovXG4gICAgbWFwKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbiB0aGUgZG9jdW1lbnQsIGNhbGxpbmcgYGZgIGZvclxuICAgIGVhY2gsIHdpdGggdGhlIHJhbmdlIGluIHRoZSBvcmlnaW5hbCBkb2N1bWVudCAoYGZyb21BYC1gdG9BYClcbiAgICBhbmQgdGhlIHJhbmdlIHRoYXQgcmVwbGFjZXMgaXQgaW4gdGhlIG5ldyBkb2N1bWVudFxuICAgIChgZnJvbUJgLWB0b0JgKS5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzIGFyZSByZXBvcnRlZFxuICAgIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtjaGFuZ2UgZGVzY3JpcHRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYykgZm9yIHRoaXMgY2hhbmdlXG4gICAgc2V0LlxuICAgICovXG4gICAgZ2V0IGRlc2MoKSB7IHJldHVybiBDaGFuZ2VEZXNjLmNyZWF0ZSh0aGlzLnNlY3Rpb25zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyKHJhbmdlcykge1xuICAgICAgICBsZXQgcmVzdWx0U2VjdGlvbnMgPSBbXSwgcmVzdWx0SW5zZXJ0ZWQgPSBbXSwgZmlsdGVyZWRTZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgaXRlciA9IG5ldyBTZWN0aW9uSXRlcih0aGlzKTtcbiAgICAgICAgZG9uZTogZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHJhbmdlcy5sZW5ndGggPyAxZTkgOiByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBuZXh0IHx8IHBvcyA9PSBuZXh0ICYmIGl0ZXIubGVuID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgbmV4dCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zID0gaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDA7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCBpbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgPiAwKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQocmVzdWx0SW5zZXJ0ZWQsIHJlc3VsdFNlY3Rpb25zLCBpdGVyLnRleHQpO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW5kID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIGVuZCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwKTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IG5ldyBDaGFuZ2VTZXQocmVzdWx0U2VjdGlvbnMsIHJlc3VsdEluc2VydGVkKSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBDaGFuZ2VEZXNjLmNyZWF0ZShmaWx0ZXJlZFNlY3Rpb25zKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2Ugc2V0IHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGxlbik7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnMgPT0gMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dLmNvbmNhdCh0aGlzLmluc2VydGVkW2kgPj4gMV0udG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiBjaGFuZ2VzLCBmb3IgYSBkb2N1bWVudCBvZiB0aGVcbiAgICBnaXZlbiBsZW5ndGgsIHVzaW5nIGBsaW5lU2VwYCBhcyBsaW5lIHNlcGFyYXRvci5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihjaGFuZ2VzLCBsZW5ndGgsIGxpbmVTZXApIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW10sIHBvcyA9IDA7XG4gICAgICAgIGxldCB0b3RhbCA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2UgJiYgIXNlY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbmd0aCAtIHBvcywgLTEpO1xuICAgICAgICAgICAgbGV0IHNldCA9IG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNldC5tYXAodG90YWwpKSA6IHNldDtcbiAgICAgICAgICAgIHNlY3Rpb25zID0gW107XG4gICAgICAgICAgICBpbnNlcnRlZCA9IFtdO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzKHNwZWMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHNwZWMpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Moc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5sZW5ndGggIT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aCAoZ290ICR7c3BlYy5sZW5ndGh9LCBleHBlY3RlZCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzcGVjLm1hcCh0b3RhbCkpIDogc3BlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvID0gZnJvbSwgaW5zZXJ0IH0gPSBzcGVjO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gdG8gfHwgZnJvbSA8IDAgfHwgdG8gPiBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNoYW5nZSByYW5nZSAke2Zyb219IHRvICR7dG99IChpbiBkb2Mgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zVGV4dCA9ICFpbnNlcnQgPyBUZXh0LmVtcHR5IDogdHlwZW9mIGluc2VydCA9PSBcInN0cmluZ1wiID8gVGV4dC5vZihpbnNlcnQuc3BsaXQobGluZVNlcCB8fCBEZWZhdWx0U3BsaXQpKSA6IGluc2VydDtcbiAgICAgICAgICAgICAgICBsZXQgaW5zTGVuID0gaW5zVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgaW5zTGVuID09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgZnJvbSAtIHBvcywgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIHRvIC0gZnJvbSwgaW5zTGVuKTtcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0ZWQsIHNlY3Rpb25zLCBpbnNUZXh0KTtcbiAgICAgICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzKGNoYW5nZXMpO1xuICAgICAgICBmbHVzaCghdG90YWwpO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBjaGFuZ2VzZXQgb2YgdGhlIGdpdmVuIGxlbmd0aC5cbiAgICAqL1xuICAgIHN0YXRpYyBlbXB0eShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQobGVuZ3RoID8gW2xlbmd0aCwgLTFdIDogW10sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlc2V0IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkIGJ5XG4gICAgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IGpzb25baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGFydCkgfHwgdHlwZW9mIHBhcnRbMF0gIT0gXCJudW1iZXJcIiB8fCBwYXJ0LnNvbWUoKGUsIGkpID0+IGkgJiYgdHlwZW9mIGUgIT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpKVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkW2ldID0gVGV4dC5vZihwYXJ0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIGluc2VydGVkW2ldLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zLCBmb3JjZUpvaW4gPSBmYWxzZSkge1xuICAgIGlmIChsZW4gPT0gMCAmJiBpbnMgPD0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsYXN0ID0gc2VjdGlvbnMubGVuZ3RoIC0gMjtcbiAgICBpZiAobGFzdCA+PSAwICYmIGlucyA8PSAwICYmIGlucyA9PSBzZWN0aW9uc1tsYXN0ICsgMV0pXG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICBlbHNlIGlmIChsYXN0ID49IDAgJiYgbGVuID09IDAgJiYgc2VjdGlvbnNbbGFzdF0gPT0gMClcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICBlbHNlIGlmIChmb3JjZUpvaW4pIHtcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xufVxuZnVuY3Rpb24gYWRkSW5zZXJ0KHZhbHVlcywgc2VjdGlvbnMsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGluZGV4ID0gKHNlY3Rpb25zLmxlbmd0aCAtIDIpID4+IDE7XG4gICAgaWYgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXS5hcHBlbmQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHZhbHVlcy5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlckNoYW5nZXMoZGVzYywgZiwgaW5kaXZpZHVhbCkge1xuICAgIGxldCBpbnNlcnRlZCA9IGRlc2MuaW5zZXJ0ZWQ7XG4gICAgZm9yIChsZXQgcG9zQSA9IDAsIHBvc0IgPSAwLCBpID0gMDsgaSA8IGRlc2Muc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdLCBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVuZEEgPSBwb3NBLCBlbmRCID0gcG9zQiwgdGV4dCA9IFRleHQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgZW5kQSArPSBsZW47XG4gICAgICAgICAgICAgICAgZW5kQiArPSBpbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlucyAmJiBpbnNlcnRlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuYXBwZW5kKGluc2VydGVkWyhpIC0gMikgPj4gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpdmlkdWFsIHx8IGkgPT0gZGVzYy5zZWN0aW9ucy5sZW5ndGggfHwgZGVzYy5zZWN0aW9uc1tpICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICAgICAgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihwb3NBLCBlbmRBLCBwb3NCLCBlbmRCLCB0ZXh0KTtcbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICAgICAgcG9zQiA9IGVuZEI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBTZXQoc2V0QSwgc2V0QiwgYmVmb3JlLCBta1NldCA9IGZhbHNlKSB7XG4gICAgLy8gUHJvZHVjZSBhIGNvcHkgb2Ygc2V0QSB0aGF0IGFwcGxpZXMgdG8gdGhlIGRvY3VtZW50IGFmdGVyIHNldEJcbiAgICAvLyBoYXMgYmVlbiBhcHBsaWVkIChhc3N1bWluZyBib3RoIHN0YXJ0IGF0IHRoZSBzYW1lIGRvY3VtZW50KS5cbiAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGJvdGggc2V0cyBpbiBwYXJhbGxlbC4gaW5zZXJ0ZWQgdHJhY2tzLCBmb3IgY2hhbmdlc1xuICAgIC8vIGluIEEgdGhhdCBoYXZlIHRvIGJlIHByb2Nlc3NlZCBwaWVjZS1ieS1waWVjZSwgd2hldGhlciB0aGVpclxuICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gaW5zZXJ0ZWQgYWxyZWFkeSwgYW5kIHJlZmVycyB0byB0aGUgc2VjdGlvblxuICAgIC8vIGluZGV4LlxuICAgIGZvciAobGV0IGluc2VydGVkID0gLTE7Oykge1xuICAgICAgICBpZiAoYS5kb25lICYmIGIubGVuIHx8IGIuZG9uZSAmJiBhLmxlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPT0gLTEgJiYgYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgYWNyb3NzIHJhbmdlcyBza2lwcGVkIGJ5IGJvdGggc2V0cy5cbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbiwgYi5sZW4pO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICBhLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuaW5zID49IDAgJiYgKGEuaW5zIDwgMCB8fCBpbnNlcnRlZCA9PSBhLmkgfHwgYS5vZmYgPT0gMCAmJiAoYi5sZW4gPCBhLmxlbiB8fCBiLmxlbiA9PSBhLmxlbiAmJiAhYmVmb3JlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjaGFuZ2UgaW4gQiB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgbmV4dCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIEEgKG9yZGVyZWQgYnkgc3RhcnQgcG9zLCB0aGVuIGxlbiwgdGhlbiBiZWZvcmUgZmxhZyksIHNraXBcbiAgICAgICAgICAgIC8vIHRoYXQgKGFuZCBwcm9jZXNzIGFueSBjaGFuZ2VzIGluIEEgaXQgY292ZXJzKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSBiLmxlbjtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGIuaW5zLCAtMSk7XG4gICAgICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4oYS5sZW4sIGxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGEuaW5zID49IDAgJiYgaW5zZXJ0ZWQgPCBhLmkgJiYgYS5sZW4gPD0gcGllY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYS5pbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBwaWVjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID49IDApIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhcnQgb2YgYSBjaGFuZ2UgaW4gQSB1cCB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIG5vbi1kZWxldGlvbiBjaGFuZ2UgaW4gQiAoaWYgb3ZlcmxhcHBpbmcpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IDAsIGxlZnQgPSBhLmxlbjtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGxlZnQsIGIubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBiLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAwICYmIGIubGVuIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IGIubGVuO1xuICAgICAgICAgICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zZXJ0ZWQgPCBhLmkgPyBhLmlucyA6IDApO1xuICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNlcnRlZCA8IGEuaSlcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGEubGVuIC0gbGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTZXRzKHNldEEsIHNldEIsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBsZXQgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgZm9yIChsZXQgb3BlbiA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID09IDApIHsgLy8gRGVsZXRpb24gaW4gQVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5sZW4sIDAsIG9wZW4pO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5sZW4gPT0gMCAmJiAhYi5kb25lKSB7IC8vIEluc2VydGlvbiBpbiBCXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBiLmlucywgb3Blbik7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lIHx8IGIuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4yLCBiLmxlbiksIHNlY3Rpb25MZW4gPSBzZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zQiA9IGIuaW5zID09IC0xID8gLTEgOiBiLm9mZiA/IDAgOiBiLmlucztcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc0IsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zQilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBsZW4sIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHRCaXQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgYi5vZmYgPyAwIDogYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgIWIub2ZmKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW4gPSAoYS5pbnMgPiBsZW4gfHwgYi5pbnMgPj0gMCAmJiBiLmxlbiA+IGxlbikgJiYgKG9wZW4gfHwgc2VjdGlvbnMubGVuZ3RoID4gc2VjdGlvbkxlbik7XG4gICAgICAgICAgICBhLmZvcndhcmQyKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNlY3Rpb25JdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgeyBzZWN0aW9ucyB9ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICh0aGlzLmkgPCBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmlucyA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvbmUoKSB7IHJldHVybiB0aGlzLmlucyA9PSAtMjsgfVxuICAgIGdldCBsZW4yKCkgeyByZXR1cm4gdGhpcy5pbnMgPCAwID8gdGhpcy5sZW4gOiB0aGlzLmluczsgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggPyBUZXh0LmVtcHR5IDogaW5zZXJ0ZWRbaW5kZXhdO1xuICAgIH1cbiAgICB0ZXh0Qml0KGxlbikge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggJiYgIWxlbiA/IFRleHQuZW1wdHlcbiAgICAgICAgICAgIDogaW5zZXJ0ZWRbaW5kZXhdLnNsaWNlKHRoaXMub2ZmLCBsZW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMub2ZmICsgbGVuKTtcbiAgICB9XG4gICAgZm9yd2FyZChsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3J3YXJkMihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zID09IC0xKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PSB0aGlzLmlucylcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG5BIHNpbmdsZSBzZWxlY3Rpb24gcmFuZ2UuIFdoZW5cbltgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuaXMgZW5hYmxlZCwgYSBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbikgbWF5IGhvbGRcbm11bHRpcGxlIHJhbmdlcy4gQnkgZGVmYXVsdCwgc2VsZWN0aW9ucyBob2xkIGV4YWN0bHkgb25lIHJhbmdlLlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBmbGFncykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2hvciBvZiB0aGUgcmFuZ2XigJR0aGUgc2lkZSB0aGF0IGRvZXNuJ3QgbW92ZSB3aGVuIHlvdVxuICAgIGV4dGVuZCBpdC5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBoZWFkIG9mIHRoZSByYW5nZSwgd2hpY2ggaXMgbW92ZWQgd2hlbiB0aGUgcmFuZ2UgaXNcbiAgICBbZXh0ZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZXh0ZW5kKS5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMuZnJvbSA6IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gYGFuY2hvcmAgYW5kIGBoZWFkYCBhcmUgYXQgdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZyb20gPT0gdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSBjdXJzb3IgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICBjaGFyYWN0ZXIgb24gb25lIG9mIGl0cyBzaWRlcywgdGhpcyByZXR1cm5zIHRoZSBzaWRlLiAtMSBtZWFuc1xuICAgIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGl0cyBwb3NpdGlvbiwgMSB0aGUgY2hhcmFjdGVyIGFmdGVyLCBhbmQgMFxuICAgIG1lYW5zIG5vIGFzc29jaWF0aW9uLlxuICAgICovXG4gICAgZ2V0IGFzc29jKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovID8gLTEgOiB0aGlzLmZsYWdzICYgMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxuICAgIC8qKlxuICAgIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICAgIGFueS5cbiAgICAqL1xuICAgIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiA3IC8qIFJhbmdlRmxhZy5CaWRpTGV2ZWxNYXNrICovO1xuICAgICAgICByZXR1cm4gbGV2ZWwgPT0gNyA/IG51bGwgOiBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGdvYWwgY29sdW1uIChzdG9yZWQgdmVydGljYWwgb2Zmc2V0KSBhc3NvY2lhdGVkIHdpdGggYVxuICAgIGN1cnNvci4gVGhpcyBpcyB1c2VkIHRvIHByZXNlcnZlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aGVuXG4gICAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xuICAgIGxpbmVzIG9mIGRpZmZlcmVudCBsZW5ndGguXG4gICAgKi9cbiAgICBnZXQgZ29hbENvbHVtbigpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5mbGFncyA+PiA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSB0aHJvdWdoIGEgY2hhbmdlLCBwcm9kdWNpbmcgYSB2YWxpZCByYW5nZSBpbiB0aGVcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICBmcm9tID0gdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgYXNzb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCAxKTtcbiAgICAgICAgICAgIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdGhpcy5mcm9tICYmIHRvID09IHRoaXMudG8gPyB0aGlzIDogbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgcmFuZ2UgdG8gY292ZXIgYXQgbGVhc3QgYGZyb21gIHRvIGB0b2AuXG4gICAgKi9cbiAgICBleHRlbmQoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuYW5jaG9yICYmIHRvID49IHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGxldCBoZWFkID0gTWF0aC5hYnMoZnJvbSAtIHRoaXMuYW5jaG9yKSA+IE1hdGguYWJzKHRvIC0gdGhpcy5hbmNob3IpID8gZnJvbSA6IHRvO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRoaXMuYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICAgKi9cbiAgICBlcShvdGhlciwgaW5jbHVkZUFzc29jID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yID09IG90aGVyLmFuY2hvciAmJiB0aGlzLmhlYWQgPT0gb3RoZXIuaGVhZCAmJlxuICAgICAgICAgICAgKCFpbmNsdWRlQXNzb2MgfHwgIXRoaXMuZW1wdHkgfHwgdGhpcy5hc3NvYyA9PSBvdGhlci5hc3NvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4geyBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgcmFuZ2UgdG8gYSBgU2VsZWN0aW9uUmFuZ2VgXG4gICAgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIFNlbGVjdGlvblJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGpzb24uYW5jaG9yLCBqc29uLmhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIGZsYWdzKTtcbiAgICB9XG59XG4vKipcbkFuIGVkaXRvciBzZWxlY3Rpb24gaG9sZHMgb25lIG9yIG1vcmUgc2VsZWN0aW9uIHJhbmdlcy5cbiovXG5jbGFzcyBFZGl0b3JTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZXMgaW4gdGhlIHNlbGVjdGlvbiwgc29ydGVkIGJ5IHBvc2l0aW9uLiBSYW5nZXMgY2Fubm90XG4gICAgb3ZlcmxhcCAoYnV0IHRoZXkgbWF5IHRvdWNoLCBpZiB0aGV5IGFyZW4ndCBlbXB0eSkuXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBvZiB0aGUgX21haW5fIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24gKHdoaWNoIGlzXG4gICAgdXN1YWxseSB0aGUgcmFuZ2UgdGhhdCB3YXMgYWRkZWQgbGFzdCkuXG4gICAgKi9cbiAgICBtYWluSW5kZXgpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubWFpbkluZGV4ID0gbWFpbkluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxuICAgIHBvc2l0aW9uIGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBpZiAoY2hhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZSwgYXNzb2MpKSwgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLiBCeSBkZWZhdWx0LCByYW5nZXNcbiAgICBhcmUgY29tcGFyZWQgb25seSBieSBwb3NpdGlvbi4gV2hlbiBgaW5jbHVkZUFzc29jYCBpcyB0cnVlLFxuICAgIGN1cnNvciByYW5nZXMgbXVzdCBhbHNvIGhhdmUgdGhlIHNhbWVcbiAgICBbYGFzc29jYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5hc3NvYykgdmFsdWUuXG4gICAgKi9cbiAgICBlcShvdGhlciwgaW5jbHVkZUFzc29jID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCAhPSBvdGhlci5yYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLm1haW5JbmRleCAhPSBvdGhlci5tYWluSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMucmFuZ2VzW2ldLmVxKG90aGVyLnJhbmdlc1tpXSwgaW5jbHVkZUFzc29jKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByaW1hcnkgc2VsZWN0aW9uIHJhbmdlLiBVc3VhbGx5LCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZVxuICAgIHlvdXIgY29kZSBhcHBsaWVzIHRvIF9hbGxfIHJhbmdlcywgYnkgdXNpbmcgbWV0aG9kcyBsaWtlXG4gICAgW2BjaGFuZ2VCeVJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFuZ2VCeVJhbmdlKS5cbiAgICAqL1xuICAgIGdldCBtYWluKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5tYWluSW5kZXhdOyB9XG4gICAgLyoqXG4gICAgTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gb25seSBoYXMgb25lIHJhbmdlLiBSZXR1cm5zIGEgc2VsZWN0aW9uXG4gICAgaG9sZGluZyBvbmx5IHRoZSBtYWluIHJhbmdlIGZyb20gdGhpcyBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBhc1NpbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmxlbmd0aCA9PSAxID8gdGhpcyA6IG5ldyBFZGl0b3JTZWxlY3Rpb24oW3RoaXMubWFpbl0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyBzZWxlY3Rpb24gd2l0aCBhbiBleHRyYSByYW5nZS5cbiAgICAqL1xuICAgIGFkZFJhbmdlKHJhbmdlLCBtYWluID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdLmNvbmNhdCh0aGlzLnJhbmdlcyksIG1haW4gPyAwIDogdGhpcy5tYWluSW5kZXggKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYW5vdGhlciByYW5nZSwgYW5kIHRoZW4gbm9ybWFsaXplIHRoZVxuICAgIHNlbGVjdGlvbiB0byBtZXJnZSBhbmQgc29ydCByYW5nZXMgaWYgbmVjZXNzYXJ5LlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKHJhbmdlLCB3aGljaCA9IHRoaXMubWFpbkluZGV4KSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICByYW5nZXNbd2hpY2hdID0gcmFuZ2U7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc2VsZWN0aW9uIHRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIHRvXG4gICAgSlNPTi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2VzOiB0aGlzLnJhbmdlcy5tYXAociA9PiByLnRvSlNPTigpKSwgbWFpbjogdGhpcy5tYWluSW5kZXggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFBcnJheS5pc0FycmF5KGpzb24ucmFuZ2VzKSB8fCB0eXBlb2YganNvbi5tYWluICE9IFwibnVtYmVyXCIgfHwganNvbi5tYWluID49IGpzb24ucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTZWxlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKGpzb24ucmFuZ2VzLm1hcCgocikgPT4gU2VsZWN0aW9uUmFuZ2UuZnJvbUpTT04ocikpLCBqc29uLm1haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gaG9sZGluZyBhIHNpbmdsZSByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBzaW5nbGUoYW5jaG9yLCBoZWFkID0gYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKFtFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoYW5jaG9yLCBoZWFkKV0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBTb3J0IGFuZCBtZXJnZSB0aGUgZ2l2ZW4gc2V0IG9mIHJhbmdlcywgY3JlYXRpbmcgYSB2YWxpZFxuICAgIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc2VsZWN0aW9uIG5lZWRzIGF0IGxlYXN0IG9uZSByYW5nZVwiKTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcG9zIDogcmFuZ2UuZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLm5vcm1hbGl6ZWQocmFuZ2VzLnNsaWNlKCksIG1haW5JbmRleCk7XG4gICAgICAgICAgICBwb3MgPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciBzZWxlY3Rpb24gcmFuZ2UgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgc2FmZWx5IGlnbm9yZSB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjdXJzb3IocG9zLCBhc3NvYyA9IDAsIGJpZGlMZXZlbCwgZ29hbENvbHVtbikge1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKHBvcywgcG9zLCAoYXNzb2MgPT0gMCA/IDAgOiBhc3NvYyA8IDAgPyA4IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA6IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyA3IDogTWF0aC5taW4oNiwgYmlkaUxldmVsKSkgfFxuICAgICAgICAgICAgKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyByYW5nZShhbmNob3IsIGhlYWQsIGdvYWxDb2x1bW4sIGJpZGlMZXZlbCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoaGVhZCwgYW5jaG9yLCAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gfCAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyB8IGZsYWdzKVxuICAgICAgICAgICAgOiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoYW5jaG9yLCBoZWFkLCAoaGVhZCA+IGFuY2hvciA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMCkgfCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWQocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICBtYWluSW5kZXggPSByYW5nZXMuaW5kZXhPZihtYWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHByZXYudG8gOiByYW5nZS5mcm9tIDwgcHJldi50bykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIG1haW5JbmRleC0tO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiB1c2VzIG9mIGZhY2V0cyBhcmUgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcbmF0dHJpYnV0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRvckF0dHJpYnV0ZXMpLCBhbmQgW3VwZGF0ZVxubGlzdGVuZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld151cGRhdGVMaXN0ZW5lcikuXG5cbk5vdGUgdGhhdCBgRmFjZXRgIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhbnl3aGVyZSB3aGVyZVxuW2BGYWNldFJlYWRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXRSZWFkZXIpIGlzIGV4cGVjdGVkLlxuKi9cbmNsYXNzIEZhY2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbWJpbmUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZUlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUsIGlzU3RhdGljLCBlbmFibGVzKSB7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICAgIHRoaXMuY29tcGFyZUlucHV0ID0gY29tcGFyZUlucHV0O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb21iaW5lKFtdKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gdHlwZW9mIGVuYWJsZXMgPT0gXCJmdW5jdGlvblwiID8gZW5hYmxlcyh0aGlzKSA6IGVuYWJsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBmYWNldCByZWFkZXIgZm9yIHRoaXMgZmFjZXQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAgW3JlYWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuZmFjZXQpIGl0IGJ1dCBub3QgdG8gZGVmaW5lIHZhbHVlcyBmb3IgaXQuXG4gICAgKi9cbiAgICBnZXQgcmVhZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBmYWNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldChjb25maWcuY29tYmluZSB8fCAoKGEpID0+IGEpLCBjb25maWcuY29tcGFyZUlucHV0IHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZy5jb21wYXJlIHx8ICghY29uZmlnLmNvbWJpbmUgPyBzYW1lQXJyYXkgOiAoYSwgYikgPT4gYSA9PT0gYiksICEhY29uZmlnLnN0YXRpYywgY29uZmlnLmVuYWJsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoaXMgZmFjZXQuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoW10sIHRoaXMsIDAgLyogUHJvdmlkZXIuU3RhdGljICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyBhIHZhbHVlIGZvciB0aGUgZmFjZXQgZnJvbSBhXG4gICAgc3RhdGUuIFlvdSBtdXN0IHRha2UgY2FyZSB0byBkZWNsYXJlIHRoZSBwYXJ0cyBvZiB0aGUgc3RhdGUgdGhhdFxuICAgIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxuICAgIGZvciBhIG5ldyBzdGF0ZSB3aGVuIG9uZSBvZiB0aG9zZSBwYXJ0cyBjaGFuZ2VkLlxuICAgIFxuICAgIEluIGNhc2VzIHdoZXJlIHlvdXIgdmFsdWUgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLCB5b3UnbGxcbiAgICB3YW50IHRvIHVzZSB0aGUgW2Bmcm9tYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldC5mcm9tKSBtZXRob2QgaW5zdGVhZC5cbiAgICAqL1xuICAgIGNvbXB1dGUoZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDEgLyogUHJvdmlkZXIuU2luZ2xlICovLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xuICAgIGZhY2V0IGZyb20gYSBzdGF0ZS5cbiAgICAqL1xuICAgIGNvbXB1dGVOKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAyIC8qIFByb3ZpZGVyLk11bHRpICovLCBnZXQpO1xuICAgIH1cbiAgICBmcm9tKGZpZWxkLCBnZXQpIHtcbiAgICAgICAgaWYgKCFnZXQpXG4gICAgICAgICAgICBnZXQgPSB4ID0+IHg7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUoW2ZpZWxkXSwgc3RhdGUgPT4gZ2V0KHN0YXRlLmZpZWxkKGZpZWxkKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiBlID09PSBiW2ldKTtcbn1cbmNsYXNzIEZhY2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcywgZmFjZXQsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgIH1cbiAgICBkeW5hbWljU2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLmZhY2V0LmNvbXBhcmVJbnB1dDtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5pZCwgaWR4ID0gYWRkcmVzc2VzW2lkXSA+PiAxLCBtdWx0aSA9IHRoaXMudHlwZSA9PSAyIC8qIFByb3ZpZGVyLk11bHRpICovO1xuICAgICAgICBsZXQgZGVwRG9jID0gZmFsc2UsIGRlcFNlbCA9IGZhbHNlLCBkZXBBZGRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkZXAgb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmIChkZXAgPT0gXCJkb2NcIilcbiAgICAgICAgICAgICAgICBkZXBEb2MgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVwID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgZGVwU2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCgoKF9hID0gYWRkcmVzc2VzW2RlcC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpICYgMSkgPT0gMClcbiAgICAgICAgICAgICAgICBkZXBBZGRycy5wdXNoKGFkZHJlc3Nlc1tkZXAuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChkZXBEb2MgJiYgdHIuZG9jQ2hhbmdlZCkgfHwgKGRlcFNlbCAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKSB8fCBlbnN1cmVBbGwoc3RhdGUsIGRlcEFkZHJzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpID8gIWNvbXBhcmVBcnJheShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdLCBjb21wYXJlKSA6ICFjb21wYXJlKG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuZXdWYWwsIG9sZEFkZHIgPSBvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gZ2V0QWRkcihvbGRTdGF0ZSwgb2xkQWRkcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5ldmVyeShkZXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcCBpbnN0YW5jZW9mIEZhY2V0ID8gb2xkU3RhdGUuZmFjZXQoZGVwKSA9PT0gc3RhdGUuZmFjZXQoZGVwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwIGluc3RhbmNlb2YgU3RhdGVGaWVsZCA/IG9sZFN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpID09IHN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfHwgKG11bHRpID8gY29tcGFyZUFycmF5KG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCwgY29tcGFyZSkgOiBjb21wYXJlKG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGEsIGIsIGNvbXBhcmUpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghY29tcGFyZShhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFsbChzdGF0ZSwgYWRkcnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGFkZHIgb2YgYWRkcnMpXG4gICAgICAgIGlmIChlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSAmIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBkeW5hbWljRmFjZXRTbG90KGFkZHJlc3NlcywgZmFjZXQsIHByb3ZpZGVycykge1xuICAgIGxldCBwcm92aWRlckFkZHJzID0gcHJvdmlkZXJzLm1hcChwID0+IGFkZHJlc3Nlc1twLmlkXSk7XG4gICAgbGV0IHByb3ZpZGVyVHlwZXMgPSBwcm92aWRlcnMubWFwKHAgPT4gcC50eXBlKTtcbiAgICBsZXQgZHluYW1pYyA9IHByb3ZpZGVyQWRkcnMuZmlsdGVyKHAgPT4gIShwICYgMSkpO1xuICAgIGxldCBpZHggPSBhZGRyZXNzZXNbZmFjZXQuaWRdID4+IDE7XG4gICAgZnVuY3Rpb24gZ2V0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm92aWRlckFkZHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRBZGRyKHN0YXRlLCBwcm92aWRlckFkZHJzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclR5cGVzW2ldID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFkZHIgb2YgcHJvdmlkZXJBZGRycylcbiAgICAgICAgICAgICAgICBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKTtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICAgICAgaWYgKCFlbnN1cmVBbGwoc3RhdGUsIGR5bmFtaWMpKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBzdGF0ZS52YWx1ZXNbaWR4XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICByZWNvbmZpZ3VyZShzdGF0ZSwgb2xkU3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBkZXBDaGFuZ2VkID0gZW5zdXJlQWxsKHN0YXRlLCBwcm92aWRlckFkZHJzKTtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRTdGF0ZS5jb25maWcuZmFjZXRzW2ZhY2V0LmlkXSwgb2xkVmFsdWUgPSBvbGRTdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgICAgICBpZiAob2xkUHJvdmlkZXJzICYmICFkZXBDaGFuZ2VkICYmIHNhbWVBcnJheShwcm92aWRlcnMsIG9sZFByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBpbml0RmllbGQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgc3RhdGljOiB0cnVlIH0pO1xuLyoqXG5GaWVsZHMgY2FuIHN0b3JlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW4gYW4gZWRpdG9yIHN0YXRlLCBhbmRcbmtlZXAgaXQgaW4gc3luYyB3aXRoIHRoZSByZXN0IG9mIHRoZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGF0ZUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBjcmVhdGVGLCB1cGRhdGVGLCBjb21wYXJlRiwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGVGID0gY3JlYXRlRjtcbiAgICAgICAgdGhpcy51cGRhdGVGID0gdXBkYXRlRjtcbiAgICAgICAgdGhpcy5jb21wYXJlRiA9IGNvbXBhcmVGO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvdmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0YXRlIGZpZWxkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gbmV3IFN0YXRlRmllbGQobmV4dElEKyssIGNvbmZpZy5jcmVhdGUsIGNvbmZpZy51cGRhdGUsIGNvbmZpZy5jb21wYXJlIHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcucHJvdmlkZSlcbiAgICAgICAgICAgIGZpZWxkLnByb3ZpZGVzID0gY29uZmlnLnByb3ZpZGUoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICBsZXQgaW5pdCA9IHN0YXRlLmZhY2V0KGluaXRGaWVsZCkuZmluZChpID0+IGkuZmllbGQgPT0gdGhpcyk7XG4gICAgICAgIHJldHVybiAoKGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5jcmVhdGUpIHx8IHRoaXMuY3JlYXRlRikoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNsb3QoYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBpZHggPSBhZGRyZXNzZXNbdGhpcy5pZF0gPj4gMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZTogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogKHN0YXRlLCB0cikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBzdGF0ZS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnVwZGF0ZUYob2xkVmFsLCB0cik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZUYob2xkVmFsLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGluaXQgPSBzdGF0ZS5mYWNldChpbml0RmllbGQpLCBvbGRJbml0ID0gb2xkU3RhdGUuZmFjZXQoaW5pdEZpZWxkKSwgcmVJbml0O1xuICAgICAgICAgICAgICAgIGlmICgocmVJbml0ID0gaW5pdC5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKSkgJiYgcmVJbml0ICE9IG9sZEluaXQuZmluZChpID0+IGkuZmllbGQgPT0gdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSByZUluaXQuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFN0YXRlLmZpZWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgdGhpcyBmaWVsZCBhbmQgb3ZlcnJpZGVzIHRoZVxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxuICAgIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICAgKi9cbiAgICBpbml0KGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gW3RoaXMsIGluaXRGaWVsZC5vZih7IGZpZWxkOiB0aGlzLCBjcmVhdGUgfSldO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGF0ZSBmaWVsZCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYXNcbiAgICBbYEV4dGVuc2lvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKSB2YWx1ZXMgdG8gZW5hYmxlIHRoZSBmaWVsZCBpbiBhXG4gICAgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgZXh0ZW5zaW9uKCkgeyByZXR1cm4gdGhpczsgfVxufVxuY29uc3QgUHJlY18gPSB7IGxvd2VzdDogNCwgbG93OiAzLCBkZWZhdWx0OiAyLCBoaWdoOiAxLCBoaWdoZXN0OiAwIH07XG5mdW5jdGlvbiBwcmVjKHZhbHVlKSB7XG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xufVxuLyoqXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXG5pbiB0aGUgZmxhdHRlbmVkIGZvcm0gb2YgbmVzdGVkIGFycmF5IHRoYXQgd2FzIHByb3ZpZGVkLlxuSW5kaXZpZHVhbCBleHRlbnNpb24gdmFsdWVzIGNhbiBiZSBhc3NpZ25lZCBhIHByZWNlZGVuY2UgdG9cbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxudGhlIHByZWNlZGVuY2Ugb2YgdGhlIG5lYXJlc3QgcGFyZW50IHdpdGggYSBwcmVjZWRlbmNlLCBvclxuW2BkZWZhdWx0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5QcmVjLmRlZmF1bHQpIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcGFyZW50LiBUaGVcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XG5wcmVjZWRlbmNlIGFuZCB0aGVuIGJ5IG9yZGVyIHdpdGhpbiBlYWNoIHByZWNlZGVuY2UuXG4qL1xuY29uc3QgUHJlYyA9IHtcbiAgICAvKipcbiAgICBUaGUgaGlnaGVzdCBwcmVjZWRlbmNlIGxldmVsLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cbiAgICAqL1xuICAgIGhpZ2hlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2hlc3QpLFxuICAgIC8qKlxuICAgIEEgaGlnaGVyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZFxuICAgIGNvbWUgYmVmb3JlIHRob3NlIHdpdGggZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgaGlnaDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaCksXG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgcHJlY2VkZW5jZSwgd2hpY2ggaXMgYWxzbyB1c2VkIGZvciBleHRlbnNpb25zXG4gICAgd2l0aG91dCBhbiBleHBsaWNpdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgZGVmYXVsdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBsb3dlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGxvdzogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93KSxcbiAgICAvKipcbiAgICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgZW5kIG9mIHRoZSBleHRlbnNpb24gb3JkZXIuXG4gICAgKi9cbiAgICBsb3dlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdClcbn07XG5jbGFzcyBQcmVjRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lciwgcHJlYykge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMucHJlYyA9IHByZWM7XG4gICAgfVxufVxuLyoqXG5FeHRlbnNpb24gY29tcGFydG1lbnRzIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb25maWd1cmF0aW9uXG5keW5hbWljLiBCeSBbd3JhcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQub2YpIHBhcnQgb2YgeW91clxuY29uZmlndXJhdGlvbiBpbiBhIGNvbXBhcnRtZW50LCB5b3UgY2FuIGxhdGVyXG5bcmVwbGFjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkgdGhhdCBwYXJ0IHRocm91Z2ggYVxudHJhbnNhY3Rpb24uXG4qL1xuY2xhc3MgQ29tcGFydG1lbnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBhcnRtZW50IHRvIGFkZCB0byB5b3VyIFtzdGF0ZVxuICAgIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVDb25maWcuZXh0ZW5zaW9ucykuXG4gICAgKi9cbiAgICBvZihleHQpIHsgcmV0dXJuIG5ldyBDb21wYXJ0bWVudEluc3RhbmNlKHRoaXMsIGV4dCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdGhhdFxuICAgIHJlY29uZmlndXJlcyB0aGlzIGNvbXBhcnRtZW50LlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gQ29tcGFydG1lbnQucmVjb25maWd1cmUub2YoeyBjb21wYXJ0bWVudDogdGhpcywgZXh0ZW5zaW9uOiBjb250ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgY29tcGFydG1lbnQgaW4gdGhlIHN0YXRlLCBvclxuICAgIGB1bmRlZmluZWRgIGlmIGl0IGlzbid0IHByZXNlbnQuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBhcnRtZW50SW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcnRtZW50LCBpbm5lcikge1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50ID0gY29tcGFydG1lbnQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBjb21wYXJ0bWVudHMsIGR5bmFtaWNTbG90cywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpIHtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudHMgPSBjb21wYXJ0bWVudHM7XG4gICAgICAgIHRoaXMuZHluYW1pY1Nsb3RzID0gZHluYW1pY1Nsb3RzO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnN0YXRpY1ZhbHVlcyA9IHN0YXRpY1ZhbHVlcztcbiAgICAgICAgdGhpcy5mYWNldHMgPSBmYWNldHM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgZHluYW1pY1Nsb3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUucHVzaCgwIC8qIFNsb3RTdGF0dXMuVW5yZXNvbHZlZCAqLyk7XG4gICAgfVxuICAgIHN0YXRpY0ZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgcmV0dXJuIGFkZHIgPT0gbnVsbCA/IGZhY2V0LmRlZmF1bHQgOiB0aGlzLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIG9sZFN0YXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGZhY2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBuZXdDb21wYXJ0bWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGV4dCBvZiBmbGF0dGVuKGJhc2UsIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSkge1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAoZmFjZXRzW2V4dC5mYWNldC5pZF0gfHwgKGZhY2V0c1tleHQuZmFjZXQuaWRdID0gW10pKS5wdXNoKGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZHJlc3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgc3RhdGljVmFsdWVzID0gW107XG4gICAgICAgIGxldCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZmllbGQuc2xvdChhKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZEZhY2V0cyA9IG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5jb25maWcuZmFjZXRzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRGYWNldHMgJiYgb2xkRmFjZXRzW2lkXSB8fCBbXTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVBcnJheShvbGRQcm92aWRlcnMsIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUuZmFjZXQoZmFjZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZhY2V0LmNvbWJpbmUocHJvdmlkZXJzLm1hcChwID0+IHAudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUgJiYgZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkU3RhdGUuZmFjZXQoZmFjZXQpKSA/IG9sZFN0YXRlLmZhY2V0KGZhY2V0KSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGR5bmFtaWNGYWNldFNsb3QoYSwgZmFjZXQsIHByb3ZpZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY1Nsb3RzLm1hcChmID0+IGYoYWRkcmVzcykpO1xuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmxhdHRlbihleHRlbnNpb24sIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtbXSwgW10sIFtdLCBbXSwgW11dO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGlubmVyKGV4dCwgcHJlYykge1xuICAgICAgICBsZXQga25vd24gPSBzZWVuLmdldChleHQpO1xuICAgICAgICBpZiAoa25vd24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtub3duIDw9IHByZWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gcmVzdWx0W2tub3duXS5pbmRleE9mKGV4dCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSlcbiAgICAgICAgICAgICAgICByZXN1bHRba25vd25dLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuZGVsZXRlKGV4dC5jb21wYXJ0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5zZXQoZXh0LCBwcmVjKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBleHQpXG4gICAgICAgICAgICAgICAgaW5uZXIoZSwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NvbXBhcnRtZW50cy5oYXMoZXh0LmNvbXBhcnRtZW50KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zYCk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGNvbXBhcnRtZW50cy5nZXQoZXh0LmNvbXBhcnRtZW50KSB8fCBleHQuaW5uZXI7XG4gICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuc2V0KGV4dC5jb21wYXJ0bWVudCwgY29udGVudCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBQcmVjRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpbm5lcihleHQuaW5uZXIsIGV4dC5wcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5wcm92aWRlcylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQucHJvdmlkZXMsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIEZhY2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LmZhY2V0LmV4dGVuc2lvbnMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LmZhY2V0LmV4dGVuc2lvbnMsIFByZWNfLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBleHQuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGV4dGVuc2lvbiB2YWx1ZSBpbiBleHRlbnNpb24gc2V0ICgke2V4dH0pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIoZXh0ZW5zaW9uLCBQcmVjXy5kZWZhdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikge1xuICAgIGlmIChhZGRyICYgMSlcbiAgICAgICAgcmV0dXJuIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLztcbiAgICBsZXQgaWR4ID0gYWRkciA+PiAxO1xuICAgIGxldCBzdGF0dXMgPSBzdGF0ZS5zdGF0dXNbaWR4XTtcbiAgICBpZiAoc3RhdHVzID09IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGJldHdlZW4gZmllbGRzIGFuZC9vciBmYWNldHNcIik7XG4gICAgaWYgKHN0YXR1cyAmIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLylcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICBzdGF0ZS5zdGF0dXNbaWR4XSA9IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi87XG4gICAgbGV0IGNoYW5nZWQgPSBzdGF0ZS5jb21wdXRlU2xvdChzdGF0ZSwgc3RhdGUuY29uZmlnLmR5bmFtaWNTbG90c1tpZHhdKTtcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QWRkcihzdGF0ZSwgYWRkcikge1xuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xufVxuXG5jb25zdCBsYW5ndWFnZURhdGEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh2ID0+IHYpLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBsaW5lU2VwYXJhdG9yID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGNoYW5nZUZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25FeHRlbmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHJlYWRPbmx5ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBmYWxzZVxufSk7XG5cbi8qKlxuQW5ub3RhdGlvbnMgYXJlIHRhZ2dlZCB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBhZGQgbWV0YWRhdGEgdG9cbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxudGhpbmdzIHRoYXQgZWZmZWN0IHRoZSBlbnRpcmUgdHJhbnNhY3Rpb24gKHN1Y2ggYXMgaXRzIFt0aW1lXG5zdGFtcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl50aW1lKSBvciBpbmZvcm1hdGlvbiBhYm91dCBpdHNcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXG5fYWxvbmdzaWRlXyB0aGUgb3RoZXIgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbiwgW3N0YXRlXG5lZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBhcmUgbW9yZSBhcHByb3ByaWF0ZS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhbm5vdGF0aW9uIHR5cGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uVHlwZSgpOyB9XG59XG4vKipcbk1hcmtlciB0aGF0IGlkZW50aWZpZXMgYSB0eXBlIG9mIFthbm5vdGF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkFubm90YXRpb24pLlxuKi9cbmNsYXNzIEFubm90YXRpb25UeXBlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5SZXByZXNlbnRhdGlvbiBvZiBhIHR5cGUgb2Ygc3RhdGUgZWZmZWN0LiBEZWZpbmVkIHdpdGhcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0VHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgYGFueWAgdHlwZXMgaW4gdGhlc2UgZnVuY3Rpb24gdHlwZXMgYXJlIHRoZXJlIHRvIHdvcmtcbiAgICAvLyBhcm91bmQgVHlwZVNjcmlwdCBpc3N1ZSAjMzc2MzEsIHdoZXJlIHRoZSB0eXBlIGd1YXJkIG9uXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XG4gICAgLy8gaGF2ZSB0eXBlIGBWYWx1ZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgICB0eXBlLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXG5hc3NvY2lhdGVkIHdpdGggYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uZWZmZWN0cykuIFRoZXlcbmFyZSBvZnRlbiB1c2VmdWwgdG8gbW9kZWwgY2hhbmdlcyB0byBjdXN0b20gW3N0YXRlXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cbmRvY3VtZW50IG9yIHNlbGVjdGlvbiBjaGFuZ2VzLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgZWZmZWN0LlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBlZmZlY3QgdGhyb3VnaCBhIHBvc2l0aW9uIG1hcHBpbmcuIFdpbGwgcmV0dXJuXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBwZWQgPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgU3RhdGVFZmZlY3QodGhpcy50eXBlLCBtYXBwZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGVmZmVjdCBvYmplY3QgaXMgb2YgYSBnaXZlblxuICAgIFt0eXBlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0VHlwZSkuXG4gICAgKi9cbiAgICBpcyh0eXBlKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZTsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxuICAgIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuIEl0IHNob3VsZCBiZSBhIHR5cGUgdGhhdFxuICAgIGRvZXNuJ3QgaW5jbHVkZSBgdW5kZWZpbmVkYCwgc2luY2UgdGhhdCBpcyB1c2VkIGluXG4gICAgW21hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0byBpbmRpY2F0ZSB0aGF0IGFuIGVmZmVjdCBpc1xuICAgIHJlbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlRWZmZWN0VHlwZShzcGVjLm1hcCB8fCAodiA9PiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhbiBhcnJheSBvZiBlZmZlY3RzIHRocm91Z2ggYSBjaGFuZ2Ugc2V0LlxuICAgICovXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBlZmZlY3QubWFwKG1hcHBpbmcpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGlzIGVmZmVjdCBjYW4gYmUgdXNlZCB0byByZWNvbmZpZ3VyZSB0aGUgcm9vdCBleHRlbnNpb25zIG9mXG50aGUgZWRpdG9yLiBEb2luZyB0aGlzIHdpbGwgZGlzY2FyZCBhbnkgZXh0ZW5zaW9uc1xuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxudGhlIGNvbnRlbnQgb2YgW3JlY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSlcbmNvbXBhcnRtZW50cy5cbiovXG5TdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQXBwZW5kIGV4dGVuc2lvbnMgdG8gdGhlIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBlZGl0b3IuXG4qL1xuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5DaGFuZ2VzIHRvIHRoZSBlZGl0b3Igc3RhdGUgYXJlIGdyb3VwZWQgaW50byB0cmFuc2FjdGlvbnMuXG5UeXBpY2FsbHksIGEgdXNlciBhY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgd2hpY2ggbWF5XG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxub3IgaGF2ZSBvdGhlciBlZmZlY3RzLiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSwgb3IgaW1tZWRpYXRlbHlcbmRpc3BhdGNoIG9uZSBieSBjYWxsaW5nXG5bYEVkaXRvclZpZXcuZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGF0ZSBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBzdGFydHMuXG4gICAgKi9cbiAgICBzdGFydFN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBjaGFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uIHNldCBieSB0aGlzIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgaXRcbiAgICBkb2Vzbid0IGV4cGxpY2l0bHkgc2V0IGEgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBUaGUgZWZmZWN0cyBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlZmZlY3RzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFubm90YXRpb25zLCBcbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlciB0aGlzXG4gICAgdHJhbnNhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb2MgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgY2hhbmdlcy5uZXdMZW5ndGgpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25zLnNvbWUoKGEpID0+IGEudHlwZSA9PSBUcmFuc2FjdGlvbi50aW1lKSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udGltZS5vZihEYXRlLm5vdygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gICAgW2Auc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKWAuZG9jYCwgYWNjZXNzaW5nIHRoaXMgd29uJ3RcbiAgICBmb3JjZSB0aGUgZW50aXJlIG5ldyBzdGF0ZSB0byBiZSBjb21wdXRlZCByaWdodCBhd2F5LCBzbyBpdCBpc1xuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgdXNlIHRoaXMgZ2V0dGVyXG4gICAgd2hlbiB0aGV5IG5lZWQgdG8gbG9vayBhdCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IG5ld0RvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxuICAgIHRoaXMgd2lsbCBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbi5tYXApIHRoZSBzdGFydCBzdGF0ZSdzXG4gICAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBuZXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiB8fCB0aGlzLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1hcCh0aGlzLmNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHN0YXRlIGNyZWF0ZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb21wdXRlZCBvbiBkZW1hbmRcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0IGlzIHJlY29tbWVuZGVkIG5vdCB0b1xuICAgIGFjY2VzcyBpdCBpbiBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB3aGVuIHBvc3NpYmxlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlKVxuICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYW5ub3RhdGlvbiB0eXBlLCBpZiBhbnkuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgYW5uIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG4gICAgICAgICAgICBpZiAoYW5uLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5uLnZhbHVlO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlZCB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHsgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIHJlY29uZmlndXJlcyB0aGUgc3RhdGVcbiAgICAodGhyb3VnaCBhIFtjb25maWd1cmF0aW9uIGNvbXBhcnRtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50KSBvclxuICAgIHdpdGggYSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvblxuICAgIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RecmVjb25maWd1cmUpLlxuICAgICovXG4gICAgZ2V0IHJlY29uZmlndXJlZCgpIHsgcmV0dXJuIHRoaXMuc3RhcnRTdGF0ZS5jb25maWcgIT0gdGhpcy5zdGF0ZS5jb25maWc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXG4gICAgZXZlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSBhbm5vdGF0aW9uIHRoYXQgaXMgZXF1YWwgdG9cbiAgICBvciBtb3JlIHNwZWNpZmljIHRoYW4gYGV2ZW50YC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0cmFuc2FjdGlvblxuICAgIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXG4gICAgYFwic2VsZWN0LnBvaW50ZXJcImAgd2lsbCBtYXRjaCBpdC5cbiAgICAqL1xuICAgIGlzVXNlckV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIHJldHVybiAhIShlICYmIChlID09IGV2ZW50IHx8IGUubGVuZ3RoID4gZXZlbnQubGVuZ3RoICYmIGUuc2xpY2UoMCwgZXZlbnQubGVuZ3RoKSA9PSBldmVudCAmJiBlW2V2ZW50Lmxlbmd0aF0gPT0gXCIuXCIpKTtcbiAgICB9XG59XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLiBBdXRvbWF0aWNhbGx5XG5hZGRlZCB0byBldmVyeSB0cmFuc2FjdGlvbiwgaG9sZGluZyBgRGF0ZS5ub3coKWAuXG4qL1xuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyAod2hlbiBwcmVzZW50IGFuZCB0cnVlKSB0aGF0IGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudHMgYSBjaGFuZ2UgbWFkZSBieSBzb21lIG90aGVyIGFjdG9yLCBub3QgdGhlIHVzZXIuIFRoaXNcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxuY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuKi9cblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5tYXBEZXNjKGZpbHRlcmVkLmNoYW5nZXMpLmludmVydGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGZpbHRlcnNcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICBmb3IgKGxldCBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBmaWx0ZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcmVkKSAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiBmaWx0ZXJlZFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIgPSByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIGFzQXJyYXkoZmlsdGVyZWQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZSwgZXh0ZW5kZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25FeHRlbmRlciksIHNwZWMgPSB0cjtcbiAgICBmb3IgKGxldCBpID0gZXh0ZW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIE9iamVjdC5rZXlzKGV4dGVuc2lvbikubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYyA9IG1lcmdlVHJhbnNhY3Rpb24oc3BlYywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIGV4dGVuc2lvbiwgdHIuY2hhbmdlcy5uZXdMZW5ndGgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMgPT0gdHIgPyB0ciA6IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgdHIuY2hhbmdlcywgdHIuc2VsZWN0aW9uLCBzcGVjLmVmZmVjdHMsIHNwZWMuYW5ub3RhdGlvbnMsIHNwZWMuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbm9uZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vKipcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxuY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKS4gVGhlc2UgYXJlIHVzZWRcbmRvIHRoaW5ncyBsaWtlIHNlbGVjdGluZyBieSB3b3JkLlxuKi9cbnZhciBDaGFyQ2F0ZWdvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDaGFyQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICBXb3JkIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiV29yZFwiXSA9IDBdID0gXCJXb3JkXCI7XG4gICAgLyoqXG4gICAgV2hpdGVzcGFjZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xuICAgIC8qKlxuICAgIEFueXRoaW5nIGVsc2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiT3RoZXJcIl0gPSAyXSA9IFwiT3RoZXJcIjtcbnJldHVybiBDaGFyQ2F0ZWdvcnl9KShDaGFyQ2F0ZWdvcnkgfHwgKENoYXJDYXRlZ29yeSA9IHt9KSk7XG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXVwiLCBcInVcIik7XG59XG5jYXRjaCAoXykgeyB9XG5mdW5jdGlvbiBoYXNXb3JkQ2hhcihzdHIpIHtcbiAgICBpZiAod29yZENoYXIpXG4gICAgICAgIHJldHVybiB3b3JkQ2hhci50ZXN0KHN0cik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoID0gc3RyW2ldO1xuICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgfHwgY2ggPiBcIlxceDgwXCIgJiYgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFrZUNhdGVnb3JpemVyKHdvcmRDaGFycykge1xuICAgIHJldHVybiAoY2hhcikgPT4ge1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgICAgICBpZiAoaGFzV29yZENoYXIoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoYXIuaW5kZXhPZih3b3JkQ2hhcnNbaV0pID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5Lk90aGVyO1xuICAgIH07XG59XG5cbi8qKlxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXG5UbyB1cGRhdGUgYSBzdGF0ZSwgeW91IFtjcmVhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSBhXG5bdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pLCB3aGljaCBwcm9kdWNlcyBhIF9uZXdfIHN0YXRlXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cblxuQXMgc3VjaCwgX25ldmVyXyBtdXRhdGUgcHJvcGVydGllcyBvZiBhIHN0YXRlIGRpcmVjdGx5LiBUaGF0J2xsXG5qdXN0IGJyZWFrIHRoaW5ncy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsdWVzLCBjb21wdXRlU2xvdCwgdHIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBjb21wdXRlU2xvdDtcbiAgICAgICAgLy8gRmlsbCBpbiB0aGUgY29tcHV0ZWQgc3RhdGUgaW1tZWRpYXRlbHksIHNvIHRoYXQgZnVydGhlciBxdWVyaWVzXG4gICAgICAgIC8vIGZvciBpdCBtYWRlIGR1cmluZyB0aGUgdXBkYXRlIHJldHVybiB0aGlzIHN0YXRlXG4gICAgICAgIGlmICh0cilcbiAgICAgICAgICAgIHRyLl9zdGF0ZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBpIDw8IDEpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gbnVsbDtcbiAgICB9XG4gICAgZmllbGQoZmllbGQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmaWVsZC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmllbGQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcbiAgICBzdGF0ZS4gQW55IG51bWJlciBvZiBbdHJhbnNhY3Rpb24gc3BlY3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKVxuICAgIGNhbiBiZSBwYXNzZWQuIFVubGVzc1xuICAgIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXG4gICAgW2NoYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmNoYW5nZXMpIChpZiBhbnkpIG9mIGVhY2ggc3BlY1xuICAgIGFyZSBhc3N1bWVkIHRvIHN0YXJ0IGluIHRoZSBfY3VycmVudF8gZG9jdW1lbnQgKG5vdCB0aGUgZG9jdW1lbnRcbiAgICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcbiAgICBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGFuZFxuICAgIFtlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSBhcmUgYXNzdW1lZCB0byByZWZlclxuICAgIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXG4gICAgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhbGwgdGhlIGRpZmZlcmVudFxuICAgIHNwZWNzLiBGb3IgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSwgbGF0ZXJcbiAgICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXG4gICAgKi9cbiAgICB1cGRhdGUoLi4uc3BlY3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2FjdGlvbih0aGlzLCBzcGVjcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbih0cikge1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnLCB7IGJhc2UsIGNvbXBhcnRtZW50cyB9ID0gY29uZjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoQ29tcGFydG1lbnQucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFydG1lbnRzID0gbmV3IE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY29uZi5jb21wYXJ0bWVudHMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGNvbXBhcnRtZW50cy5zZXQoa2V5LCB2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cy5zZXQoZWZmZWN0LnZhbHVlLmNvbXBhcnRtZW50LCBlZmZlY3QudmFsdWUuZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gYXNBcnJheShiYXNlKS5jb25jYXQoZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRWYWx1ZXM7XG4gICAgICAgIGlmICghY29uZikge1xuICAgICAgICAgICAgY29uZiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgbGV0IGludGVybWVkaWF0ZVN0YXRlID0gbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRoaXMuZG9jLCB0aGlzLnNlbGVjdGlvbiwgY29uZi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QucmVjb25maWd1cmUoc3RhdGUsIHRoaXMpLCBudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gaW50ZXJtZWRpYXRlU3RhdGUudmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB0ci5zdGFydFN0YXRlLnZhbHVlcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0ci5zdGFydFN0YXRlLmZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSA/IHRyLm5ld1NlbGVjdGlvbiA6IHRyLm5ld1NlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdHIubmV3RG9jLCBzZWxlY3Rpb24sIHN0YXJ0VmFsdWVzLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QudXBkYXRlKHN0YXRlLCB0ciksIHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3RyYW5zYWN0aW9uIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSB0aGF0XG4gICAgcmVwbGFjZXMgZXZlcnkgc2VsZWN0aW9uIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy50b1RleHQodGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4gKHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIHRleHQubGVuZ3RoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBjaGFuZ2VzIGFuZCBhIG5ldyBzZWxlY3Rpb24gYnkgcnVubmluZyB0aGUgZ2l2ZW5cbiAgICBmdW5jdGlvbiBmb3IgZWFjaCByYW5nZSBpbiB0aGUgYWN0aXZlIHNlbGVjdGlvbi4gVGhlIGZ1bmN0aW9uXG4gICAgY2FuIHJldHVybiBhbiBvcHRpb25hbCBzZXQgb2YgY2hhbmdlcyAoaW4gdGhlIGNvb3JkaW5hdGUgc3BhY2VcbiAgICBvZiB0aGUgc3RhcnQgZG9jdW1lbnQpLCBwbHVzIGFuIHVwZGF0ZWQgcmFuZ2UgKGluIHRoZSBjb29yZGluYXRlXG4gICAgc3BhY2Ugb2YgdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSBjYWxsJ3Mgb3duIGNoYW5nZXMpLiBUaGlzXG4gICAgbWV0aG9kIHdpbGwgbWVyZ2UgYWxsIHRoZSBjaGFuZ2VzIGFuZCByYW5nZXMgaW50byBhIHNpbmdsZVxuICAgIGNoYW5nZXNldCBhbmQgc2VsZWN0aW9uLCBhbmQgcmV0dXJuIGl0IGFzIGEgW3RyYW5zYWN0aW9uXG4gICAgc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpLCB3aGljaCBjYW4gYmUgcGFzc2VkIHRvXG4gICAgW2B1cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkuXG4gICAgKi9cbiAgICBjaGFuZ2VCeVJhbmdlKGYpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmVzdWx0MSA9IGYoc2VsLnJhbmdlc1swXSk7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdDEuY2hhbmdlcyksIHJhbmdlcyA9IFtyZXN1bHQxLnJhbmdlXTtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBhc0FycmF5KHJlc3VsdDEuZWZmZWN0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGYoc2VsLnJhbmdlc1tpXSk7XG4gICAgICAgICAgICBsZXQgbmV3Q2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQuY2hhbmdlcyksIG5ld01hcHBlZCA9IG5ld0NoYW5nZXMubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gcmFuZ2VzW2pdLm1hcChuZXdNYXBwZWQpO1xuICAgICAgICAgICAgbGV0IG1hcEJ5ID0gY2hhbmdlcy5tYXBEZXNjKG5ld0NoYW5nZXMsIHRydWUpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmVzdWx0LnJhbmdlLm1hcChtYXBCeSkpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29tcG9zZShuZXdNYXBwZWQpO1xuICAgICAgICAgICAgZWZmZWN0cyA9IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZWZmZWN0cywgbmV3TWFwcGVkKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhc0FycmF5KHJlc3VsdC5lZmZlY3RzKSwgbWFwQnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpLFxuICAgICAgICAgICAgZWZmZWN0c1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpIGZyb20gdGhlIGdpdmVuIGNoYW5nZVxuICAgIGRlc2NyaXB0aW9uLCB0YWtpbmcgdGhlIHN0YXRlJ3MgZG9jdW1lbnQgbGVuZ3RoIGFuZCBsaW5lXG4gICAgc2VwYXJhdG9yIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIGNoYW5nZXMoc3BlYyA9IFtdKSB7XG4gICAgICAgIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KVxuICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgIHJldHVybiBDaGFuZ2VTZXQub2Yoc3BlYywgdGhpcy5kb2MubGVuZ3RoLCB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNpbmcgdGhlIHN0YXRlJ3MgW2xpbmVcbiAgICBzZXBhcmF0b3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvciksIGNyZWF0ZSBhXG4gICAgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICB0b1RleHQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBUZXh0Lm9mKHN0cmluZy5zcGxpdCh0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdpdmVuIHJhbmdlIG9mIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZy5cbiAgICAqL1xuICAgIHNsaWNlRG9jKGZyb20gPSAwLCB0byA9IHRoaXMuZG9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIHRoaXMubGluZUJyZWFrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHN0YXRlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldCkuXG4gICAgKi9cbiAgICBmYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhY2V0LmRlZmF1bHQ7XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc3RhdGUgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBzZXJpYWxpemVkLCB5b3UgY2FuIHBhc3MgdGhlbSBpbiBhcyBhbiBvYmplY3RcbiAgICBtYXBwaW5nIHByb3BlcnR5IG5hbWVzIChpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCwgd2hpY2ggc2hvdWxkXG4gICAgbm90IHVzZSBgZG9jYCBvciBgc2VsZWN0aW9uYCkgdG8gZmllbGRzLlxuICAgICovXG4gICAgdG9KU09OKGZpZWxkcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZG9jOiB0aGlzLnNsaWNlRG9jKCksXG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZpZWxkc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkICYmIHRoaXMuY29uZmlnLmFkZHJlc3NbdmFsdWUuaWRdICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHZhbHVlLnNwZWMudG9KU09OKHRoaXMuZmllbGQoZmllbGRzW3Byb3BdKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIGRlc2VyaWFsaXplZCwgcGFzcyB0aGUgc2FtZSBvYmplY3QgeW91IHBhc3NlZFxuICAgIHRvIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIHdoZW4gc2VyaWFsaXppbmcgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uLCBjb25maWcgPSB7fSwgZmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5kb2MgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTdGF0ZVwiKTtcbiAgICAgICAgbGV0IGZpZWxkSW5pdCA9IFtdO1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1twcm9wXSwgdmFsdWUgPSBqc29uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluaXQucHVzaChmaWVsZC5pbml0KHN0YXRlID0+IGZpZWxkLnNwZWMuZnJvbUpTT04odmFsdWUsIHN0YXRlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICBkb2M6IGpzb24uZG9jLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zZWxlY3Rpb24pLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogY29uZmlnLmV4dGVuc2lvbnMgPyBmaWVsZEluaXQuY29uY2F0KFtjb25maWcuZXh0ZW5zaW9uc10pIDogZmllbGRJbml0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuIFlvdSdsbCB1c3VhbGx5IG9ubHkgbmVlZCB0aGlzIHdoZW5cbiAgICBpbml0aWFsaXppbmcgYW4gZWRpdG9y4oCUdXBkYXRlZCBzdGF0ZXMgYXJlIGNyZWF0ZWQgYnkgYXBwbHlpbmdcbiAgICB0cmFuc2FjdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGxldCBjb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbi5yZXNvbHZlKGNvbmZpZy5leHRlbnNpb25zIHx8IFtdLCBuZXcgTWFwKTtcbiAgICAgICAgbGV0IGRvYyA9IGNvbmZpZy5kb2MgaW5zdGFuY2VvZiBUZXh0ID8gY29uZmlnLmRvY1xuICAgICAgICAgICAgOiBUZXh0Lm9mKChjb25maWcuZG9jIHx8IFwiXCIpLnNwbGl0KGNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSAhY29uZmlnLnNlbGVjdGlvbiA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoMClcbiAgICAgICAgICAgIDogY29uZmlnLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IGNvbmZpZy5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY29uZmlnLnNlbGVjdGlvbi5hbmNob3IsIGNvbmZpZy5zZWxlY3Rpb24uaGVhZCk7XG4gICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jLmxlbmd0aCk7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykpXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShjb25maWd1cmF0aW9uLCBkb2MsIHNlbGVjdGlvbiwgY29uZmlndXJhdGlvbi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QuY3JlYXRlKHN0YXRlKSwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIChpbiBjb2x1bW5zKSBvZiBhIHRhYiBpbiB0aGUgZG9jdW1lbnQsIGRldGVybWluZWQgYnlcbiAgICB0aGUgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSBmYWNldC5cbiAgICAqL1xuICAgIGdldCB0YWJTaXplKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS50YWJTaXplKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJvcGVyIFtsaW5lLWJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpXG4gICAgc3RyaW5nIGZvciB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgXCJcXG5cIjsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5yZWFkT25seSkgdG8gYmUgcmVhZC1vbmx5LlxuICAgICovXG4gICAgZ2V0IHJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5mYWNldChyZWFkT25seSk7IH1cbiAgICAvKipcbiAgICBMb29rIHVwIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBnaXZlbiBwaHJhc2UgKHZpYSB0aGVcbiAgICBbYHBocmFzZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnBocmFzZXMpIGZhY2V0KSwgb3IgcmV0dXJuIHRoZVxuICAgIG9yaWdpbmFsIHN0cmluZyBpZiBubyB0cmFuc2xhdGlvbiBpcyBmb3VuZC5cbiAgICBcbiAgICBJZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcGFzc2VkLCB0aGV5IHdpbGwgYmUgaW5zZXJ0ZWQgaW5cbiAgICBwbGFjZSBvZiBtYXJrZXJzIGxpa2UgYCQxYCAoZm9yIHRoZSBmaXJzdCB2YWx1ZSkgYW5kIGAkMmAsIGV0Yy5cbiAgICBBIHNpbmdsZSBgJGAgaXMgZXF1aXZhbGVudCB0byBgJDFgLCBhbmQgYCQkYCB3aWxsIHByb2R1Y2UgYVxuICAgIGxpdGVyYWwgZG9sbGFyIHNpZ24uXG4gICAgKi9cbiAgICBwaHJhc2UocGhyYXNlLCAuLi5pbnNlcnQpIHtcbiAgICAgICAgZm9yIChsZXQgbWFwIG9mIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgcGhyYXNlKSkge1xuICAgICAgICAgICAgICAgIHBocmFzZSA9IG1hcFtwaHJhc2VdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0Lmxlbmd0aClcbiAgICAgICAgICAgIHBocmFzZSA9IHBocmFzZS5yZXBsYWNlKC9cXCQoXFwkfFxcZCopL2csIChtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gXCIkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICsoaSB8fCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW4gfHwgbiA+IGluc2VydC5sZW5ndGggPyBtIDogaW5zZXJ0W24gLSAxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGhyYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UgZGF0YSBmaWVsZCwgcHJvdmlkZWQgYnkgdGhlXG4gICAgdGhlIFtgbGFuZ3VhZ2VEYXRhYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5sYW5ndWFnZURhdGEpIGZhY2V0LlxuICAgIFxuICAgIEV4YW1wbGVzIG9mIGxhbmd1YWdlIGRhdGEgZmllbGRzIGFyZS4uLlxuICAgIFxuICAgIC0gW2BcImNvbW1lbnRUb2tlbnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgZm9yIHNwZWNpZnlpbmdcbiAgICAgIGNvbW1lbnQgc3ludGF4LlxuICAgIC0gW2BcImF1dG9jb21wbGV0ZVwiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb25eY29uZmlnLm92ZXJyaWRlKVxuICAgICAgZm9yIHByb3ZpZGluZyBsYW5ndWFnZS1zcGVjaWZpYyBjb21wbGV0aW9uIHNvdXJjZXMuXG4gICAgLSBbYFwid29yZENoYXJzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgZm9yIGFkZGluZ1xuICAgICAgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2Ygd29yZHMgaW4gdGhpc1xuICAgICAgbGFuZ3VhZ2UuXG4gICAgLSBbYFwiY2xvc2VCcmFja2V0c1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ2xvc2VCcmFja2V0Q29uZmlnKSBjb250cm9sc1xuICAgICAgYnJhY2tldCBjbG9zaW5nIGJlaGF2aW9yLlxuICAgICovXG4gICAgbGFuZ3VhZ2VEYXRhQXQobmFtZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwcm92aWRlciBvZiB0aGlzLmZhY2V0KGxhbmd1YWdlRGF0YSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlc3VsdCBvZiBwcm92aWRlcih0aGlzLCBwb3MsIHNpZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChyZXN1bHRbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGNhdGVnb3JpemUgc3RyaW5ncyAoZXhwZWN0ZWQgdG9cbiAgICByZXByZXNlbnQgYSBzaW5nbGUgW2dyYXBoZW1lIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykpXG4gICAgaW50byBvbmUgb2Y6XG4gICAgXG4gICAgIC0gV29yZCAoY29udGFpbnMgYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlciBvciBhIGNoYXJhY3RlclxuICAgICAgIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSBsb2NhbCBsYW5ndWFnZSdzIGBcIndvcmRDaGFyc1wiYFxuICAgICAgIGxhbmd1YWdlIGRhdGEsIHdoaWNoIHNob3VsZCBiZSBhIHN0cmluZylcbiAgICAgLSBTcGFjZSAoY29udGFpbnMgb25seSB3aGl0ZXNwYWNlKVxuICAgICAtIE90aGVyIChhbnl0aGluZyBlbHNlKVxuICAgICovXG4gICAgY2hhckNhdGVnb3JpemVyKGF0KSB7XG4gICAgICAgIHJldHVybiBtYWtlQ2F0ZWdvcml6ZXIodGhpcy5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBhdCkuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBtZWFuaW5nIHRoZSByYW5nZVxuICAgIGNvbnRhaW5pbmcgYWxsIFt3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkKSBjaGFyYWN0ZXJzXG4gICAgYXJvdW5kIGl0LiBJZiBubyB3b3JkIGNoYXJhY3RlcnMgYXJlIGFkamFjZW50IHRvIHRoZSBwb3NpdGlvbixcbiAgICB0aGlzIHJldHVybnMgbnVsbC5cbiAgICAqL1xuICAgIHdvcmRBdChwb3MpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSwgbGVuZ3RoIH0gPSB0aGlzLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGNhdCA9IHRoaXMuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIGZyb20sIGVuZCA9IHBvcyAtIGZyb207XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKHByZXYsIHN0YXJ0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGFydCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVuZCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIGVuZCk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UoZW5kLCBuZXh0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbmQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydCA9PSBlbmQgPyBudWxsIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHN0YXJ0ICsgZnJvbSwgZW5kICsgZnJvbSk7XG4gICAgfVxufVxuLyoqXG5BIGZhY2V0IHRoYXQsIHdoZW4gZW5hYmxlZCwgY2F1c2VzIHRoZSBlZGl0b3IgdG8gYWxsb3cgbXVsdGlwbGVcbnJhbmdlcyB0byBiZSBzZWxlY3RlZC4gQmUgY2FyZWZ1bCB0aG91Z2gsIGJlY2F1c2UgYnkgZGVmYXVsdCB0aGVcbmVkaXRvciByZWxpZXMgb24gdGhlIG5hdGl2ZSBET00gc2VsZWN0aW9uLCB3aGljaCBjYW5ub3QgaGFuZGxlXG5tdWx0aXBsZSBzZWxlY3Rpb25zLiBBbiBleHRlbnNpb24gbGlrZVxuW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNhbiBiZSB1c2VkIHRvIG1ha2VcbnNlY29uZGFyeSBzZWxlY3Rpb25zIHZpc2libGUgdG8gdGhlIHVzZXIuXG4qL1xuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBhbGxvd011bHRpcGxlU2VsZWN0aW9ucztcbi8qKlxuQ29uZmlndXJlcyB0aGUgdGFiIHNpemUgdG8gdXNlIGluIHRoaXMgc3RhdGUuIFRoZSBmaXJzdFxuKGhpZ2hlc3QtcHJlY2VkZW5jZSkgdmFsdWUgb2YgdGhlIGZhY2V0IGlzIHVzZWQuIElmIG5vIHZhbHVlIGlzXG5naXZlbiwgdGhpcyBkZWZhdWx0cyB0byA0LlxuKi9cbkVkaXRvclN0YXRlLnRhYlNpemUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IDRcbn0pO1xuLyoqXG5UaGUgbGluZSBzZXBhcmF0b3IgdG8gdXNlLiBCeSBkZWZhdWx0LCBhbnkgb2YgYFwiXFxuXCJgLCBgXCJcXHJcXG5cImBcbmFuZCBgXCJcXHJcImAgaXMgdHJlYXRlZCBhcyBhIHNlcGFyYXRvciB3aGVuIHNwbGl0dGluZyBsaW5lcywgYW5kXG5saW5lcyBhcmUgam9pbmVkIHdpdGggYFwiXFxuXCJgLlxuXG5XaGVuIHlvdSBjb25maWd1cmUgYSB2YWx1ZSBoZXJlLCBvbmx5IHRoYXQgcHJlY2lzZSBzZXBhcmF0b3JcbndpbGwgYmUgdXNlZCwgYWxsb3dpbmcgeW91IHRvIHJvdW5kLXRyaXAgZG9jdW1lbnRzIHRocm91Z2ggdGhlXG5lZGl0b3Igd2l0aG91dCBub3JtYWxpemluZyBsaW5lIHNlcGFyYXRvcnMuXG4qL1xuRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvciA9IGxpbmVTZXBhcmF0b3I7XG4vKipcblRoaXMgZmFjZXQgY29udHJvbHMgdGhlIHZhbHVlIG9mIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGdldHRlciwgd2hpY2ggaXNcbmNvbnN1bHRlZCBieSBjb21tYW5kcyBhbmQgZXh0ZW5zaW9ucyB0aGF0IGltcGxlbWVudCBlZGl0aW5nXG5mdW5jdGlvbmFsaXR5IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgc2hvdWxkIGFwcGx5LiBJdFxuZGVmYXVsdHMgdG8gZmFsc2UsIGJ1dCB3aGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXNcbmB0cnVlYCwgc3VjaCBmdW5jdGlvbmFsaXR5IGRpc2FibGVzIGl0c2VsZi5cblxuTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGhcbltgRWRpdG9yVmlldy5lZGl0YWJsZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRhYmxlKSwgd2hpY2hcbmNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvcidzIERPTSBpcyBzZXQgdG8gYmUgZWRpdGFibGUgKGFuZFxudGh1cyBmb2N1c2FibGUpLlxuKi9cbkVkaXRvclN0YXRlLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4vKipcblJlZ2lzdGVycyB0cmFuc2xhdGlvbiBwaHJhc2VzLiBUaGVcbltgcGhyYXNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5waHJhc2UpIG1ldGhvZCB3aWxsIGxvb2sgdGhyb3VnaFxuYWxsIG9iamVjdHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZmFjZXQgdG8gZmluZCB0cmFuc2xhdGlvbnMgZm9yXG5pdHMgYXJndW1lbnQuXG4qL1xuRWRpdG9yU3RhdGUucGhyYXNlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBsZXQga0EgPSBPYmplY3Qua2V5cyhhKSwga0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtBLmxlbmd0aCA9PSBrQi5sZW5ndGggJiYga0EuZXZlcnkoayA9PiBhW2tdID09IGJba10pO1xuICAgIH1cbn0pO1xuLyoqXG5BIGZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBwcm92aWRlcnMuXG4qL1xuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhID0gbGFuZ3VhZ2VEYXRhO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGNoYW5nZSBmaWx0ZXJzLCB3aGljaCBhcmUgY2FsbGVkIGZvciBlYWNoXG50cmFuc2FjdGlvbiAodW5sZXNzIGV4cGxpY2l0bHlcbltkaXNhYmxlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSksIGFuZCBjYW4gc3VwcHJlc3NcbnBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgY2hhbmdlcy5cblxuU3VjaCBhIGZ1bmN0aW9uIGNhbiByZXR1cm4gYHRydWVgIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndFxud2FudCB0byBkbyBhbnl0aGluZywgYGZhbHNlYCB0byBjb21wbGV0ZWx5IHN0b3AgdGhlIGNoYW5nZXMgaW5cbnRoZSB0cmFuc2FjdGlvbiwgb3IgYSBzZXQgb2YgcmFuZ2VzIGluIHdoaWNoIGNoYW5nZXMgc2hvdWxkIGJlXG5zdXBwcmVzc2VkLiBTdWNoIHJhbmdlcyBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycyxcbndpdGggZWFjaCBwYWlyIG9mIHR3byBudW1iZXJzIGluZGljYXRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYVxucmFuZ2UuIFNvIGZvciBleGFtcGxlIGBbMTAsIDIwLCAxMDAsIDExMF1gIHN1cHByZXNzZXMgY2hhbmdlc1xuYmV0d2VlbiAxMCBhbmQgMjAsIGFuZCBiZXR3ZWVuIDEwMCBhbmQgMTEwLlxuKi9cbkVkaXRvclN0YXRlLmNoYW5nZUZpbHRlciA9IGNoYW5nZUZpbHRlcjtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBhIGhvb2sgdGhhdCBnZXRzIGEgY2hhbmNlIHRvIHVwZGF0ZSBvclxucmVwbGFjZSB0cmFuc2FjdGlvbiBzcGVjcyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZC4gVGhpcyB3aWxsXG5vbmx5IGJlIGFwcGxpZWQgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGRvbid0IGhhdmVcbltgZmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSBzZXQgdG8gYGZhbHNlYC4gWW91XG5jYW4gZWl0aGVyIHJldHVybiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBzcGVjIChwb3NzaWJseSB0aGUgaW5wdXRcbnRyYW5zYWN0aW9uKSwgb3IgYW4gYXJyYXkgb2Ygc3BlY3MgKHdoaWNoIHdpbGwgYmUgY29tYmluZWQgaW5cbnRoZSBzYW1lIHdheSBhcyB0aGUgYXJndW1lbnRzIHRvXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSkuXG5cbldoZW4gcG9zc2libGUsIGl0IGlzIHJlY29tbWVuZGVkIHRvIGF2b2lkIGFjY2Vzc2luZ1xuW2BUcmFuc2FjdGlvbi5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpIGluIGEgZmlsdGVyLFxuc2luY2UgaXQgd2lsbCBmb3JjZSBjcmVhdGlvbiBvZiBhIHN0YXRlIHRoYXQgd2lsbCB0aGVuIGJlXG5kaXNjYXJkZWQgYWdhaW4sIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhY3R1YWxseSBmaWx0ZXJlZC5cblxuKFRoaXMgZnVuY3Rpb25hbGl0eSBzaG91bGQgYmUgdXNlZCB3aXRoIGNhcmUuIEluZGlzY3JpbWluYXRlbHlcbm1vZGlmeWluZyB0cmFuc2FjdGlvbiBpcyBsaWtlbHkgdG8gYnJlYWsgc29tZXRoaW5nIG9yIGRlZ3JhZGVcbnRoZSB1c2VyIGV4cGVyaWVuY2UuKVxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyID0gdHJhbnNhY3Rpb25GaWx0ZXI7XG4vKipcblRoaXMgaXMgYSBtb3JlIGxpbWl0ZWQgZm9ybSBvZlxuW2B0cmFuc2FjdGlvbkZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpLFxud2hpY2ggY2FuIG9ubHkgYWRkXG5bYW5ub3RhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmFubm90YXRpb25zKSBhbmRcbltlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKS4gX0J1dF8sIHRoaXMgdHlwZVxub2YgZmlsdGVyIHJ1bnMgZXZlbiBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGRpc2FibGVkIHJlZ3VsYXJcbltmaWx0ZXJpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlciksIG1ha2luZyBpdCBzdWl0YWJsZVxuZm9yIGVmZmVjdHMgdGhhdCBkb24ndCBuZWVkIHRvIHRvdWNoIHRoZSBjaGFuZ2VzIG9yIHNlbGVjdGlvbixcbmJ1dCBkbyB3YW50IHRvIHByb2Nlc3MgZXZlcnkgdHJhbnNhY3Rpb24uXG5cbkV4dGVuZGVycyBydW4gX2FmdGVyXyBmaWx0ZXJzLCB3aGVuIGJvdGggYXJlIHByZXNlbnQuXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25FeHRlbmRlciA9IHRyYW5zYWN0aW9uRXh0ZW5kZXI7XG5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcblxuLyoqXG5VdGlsaXR5IGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgYmVoYXZpb3JzIHRvIGZpbGwgaW4gYSBjb25maWdcbm9iamVjdCBmcm9tIGFuIGFycmF5IG9mIHByb3ZpZGVkIGNvbmZpZ3MuIGBkZWZhdWx0c2Agc2hvdWxkIGhvbGRcbmRlZmF1bHQgdmFsdWVzIGZvciBhbGwgb3B0aW9uYWwgZmllbGRzIGluIGBDb25maWdgLlxuXG5UaGUgZnVuY3Rpb24gd2lsbCwgYnkgZGVmYXVsdCwgZXJyb3JcbndoZW4gYSBmaWVsZCBnZXRzIHR3byB2YWx1ZXMgdGhhdCBhcmVuJ3QgYD09PWAtZXF1YWwsIGJ1dCB5b3UgY2FuXG5wcm92aWRlIGNvbWJpbmUgZnVuY3Rpb25zIHBlciBmaWVsZCB0byBkbyBzb21ldGhpbmcgZWxzZS5cbiovXG5mdW5jdGlvbiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIGRlZmF1bHRzLCAvLyBTaG91bGQgaG9sZCBvbmx5IHRoZSBvcHRpb25hbCBwcm9wZXJ0aWVzIG9mIENvbmZpZywgYnV0IEkgaGF2ZW4ndCBtYW5hZ2VkIHRvIGV4cHJlc3MgdGhhdFxuY29tYmluZSA9IHt9KSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29uZmlnKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY29uZmlnW2tleV0sIGN1cnJlbnQgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgPT09IHZhbHVlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIDsgLy8gTm8gY29uZmxpY3RcbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbWJpbmUsIGtleSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb21iaW5lW2tleV0oY3VycmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZyBtZXJnZSBjb25mbGljdCBmb3IgZmllbGQgXCIgKyBrZXkpO1xuICAgICAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKVxuICAgICAgICBpZiAocmVzdWx0W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbkVhY2ggcmFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdmFsdWUsIHdoaWNoIG11c3QgaW5oZXJpdCBmcm9tXG50aGlzIGNsYXNzLlxuKi9cbmNsYXNzIFJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyB2YWx1ZSB3aXRoIGFub3RoZXIgdmFsdWUuIFVzZWQgd2hlbiBjb21wYXJpbmdcbiAgICByYW5nZXNldHMuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNvbXBhcmVzIGJ5IGlkZW50aXR5LlxuICAgIFVubGVzcyB5b3UgYXJlIG9ubHkgY3JlYXRpbmcgYSBmaXhlZCBudW1iZXIgb2YgdW5pcXVlIGluc3RhbmNlc1xuICAgIG9mIHlvdXIgdmFsdWUgdHlwZSwgaXQgaXMgYSBnb29kIGlkZWEgdG8gaW1wbGVtZW50IHRoaXNcbiAgICBwcm9wZXJseS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzID09IG90aGVyOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSB3aXRoIHRoaXMgdmFsdWUuXG4gICAgKi9cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHsgcmV0dXJuIFJhbmdlLmNyZWF0ZShmcm9tLCB0bywgdGhpcyk7IH1cbn1cblJhbmdlVmFsdWUucHJvdG90eXBlLnN0YXJ0U2lkZSA9IFJhbmdlVmFsdWUucHJvdG90eXBlLmVuZFNpZGUgPSAwO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcblJhbmdlVmFsdWUucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrRGVsO1xuLyoqXG5BIHJhbmdlIGFzc29jaWF0ZXMgYSB2YWx1ZSB3aXRoIGEgcmFuZ2Ugb2YgcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIEl0cyBlbmQgcG9zaXRpb24uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhbmdlLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcFJhbmdlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudmFsdWUuc3RhcnRTaWRlIC0gYi52YWx1ZS5zdGFydFNpZGU7XG59XG5jbGFzcyBDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHZhbHVlLCBcbiAgICAvLyBDaHVua3MgYXJlIG1hcmtlZCB3aXRoIHRoZSBsYXJnZXN0IHBvaW50IHRoYXQgb2NjdXJzXG4gICAgLy8gaW4gdGhlbSAob3IgLTEgZm9yIG5vIHBvaW50cyksIHNvIHRoYXQgc2NhbnMgdGhhdCBhcmVcbiAgICAvLyBvbmx5IGludGVyZXN0ZWQgaW4gcG9pbnRzIChzdWNoIGFzIHRoZVxuICAgIC8vIGhlaWdodG1hcC1yZWxhdGVkIGxvZ2ljKSBjYW4gc2tpcCByYW5nZS1vbmx5IGNodW5rcy5cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50b1t0aGlzLnRvLmxlbmd0aCAtIDFdOyB9XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLiBVc2UgdGhlIHJhbmdlcydcbiAgICAvLyBgZnJvbWAgcG9zIHdoZW4gYGVuZCA9PSBmYWxzZWAsIGB0b2Agd2hlbiBgZW5kID09IHRydWVgLlxuICAgIGZpbmRJbmRleChwb3MsIHNpZGUsIGVuZCwgc3RhcnRBdCA9IDApIHtcbiAgICAgICAgbGV0IGFyciA9IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207XG4gICAgICAgIGZvciAobGV0IGxvID0gc3RhcnRBdCwgaGkgPSBhcnIubGVuZ3RoOzspIHtcbiAgICAgICAgICAgIGlmIChsbyA9PSBoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbG87XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IGFyclttaWRdIC0gcG9zIHx8IChlbmQgPyB0aGlzLnZhbHVlW21pZF0uZW5kU2lkZSA6IHRoaXMudmFsdWVbbWlkXS5zdGFydFNpZGUpIC0gc2lkZTtcbiAgICAgICAgICAgIGlmIChtaWQgPT0gbG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPj0gMCA/IGxvIDogaGk7XG4gICAgICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiZXR3ZWVuKG9mZnNldCwgZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmluZEluZGV4KGZyb20sIC0xMDAwMDAwMDAwIC8qIEMuRmFyICovLCB0cnVlKSwgZSA9IHRoaXMuZmluZEluZGV4KHRvLCAxMDAwMDAwMDAwIC8qIEMuRmFyICovLCBmYWxzZSwgaSk7IGkgPCBlOyBpKyspXG4gICAgICAgICAgICBpZiAoZih0aGlzLmZyb21baV0gKyBvZmZzZXQsIHRoaXMudG9baV0gKyBvZmZzZXQsIHRoaXMudmFsdWVbaV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcChvZmZzZXQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gW10sIGZyb20gPSBbXSwgdG8gPSBbXSwgbmV3UG9zID0gLTEsIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWVbaV0sIGN1ckZyb20gPSB0aGlzLmZyb21baV0gKyBvZmZzZXQsIGN1clRvID0gdGhpcy50b1tpXSArIG9mZnNldCwgbmV3RnJvbSwgbmV3VG87XG4gICAgICAgICAgICBpZiAoY3VyRnJvbSA9PSBjdXJUbykge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlLCB2YWwubWFwTW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gbmV3VG8gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5zdGFydFNpZGUgIT0gdmFsLmVuZFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUbyA8IG5ld0Zyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSk7XG4gICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJUbywgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdGcm9tID4gbmV3VG8gfHwgbmV3RnJvbSA9PSBuZXdUbyAmJiB2YWwuc3RhcnRTaWRlID4gMCAmJiB2YWwuZW5kU2lkZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobmV3VG8gLSBuZXdGcm9tIHx8IHZhbC5lbmRTaWRlIC0gdmFsLnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5ld1BvcyA8IDApXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gbmV3RnJvbTtcbiAgICAgICAgICAgIGlmICh2YWwucG9pbnQpXG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbmV3VG8gLSBuZXdGcm9tKTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2godmFsKTtcbiAgICAgICAgICAgIGZyb20ucHVzaChuZXdGcm9tIC0gbmV3UG9zKTtcbiAgICAgICAgICAgIHRvLnB1c2gobmV3VG8gLSBuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcHBlZDogdmFsdWUubGVuZ3RoID8gbmV3IENodW5rKGZyb20sIHRvLCB2YWx1ZSwgbWF4UG9pbnQpIDogbnVsbCwgcG9zOiBuZXdQb3MgfTtcbiAgICB9XG59XG4vKipcbkEgcmFuZ2Ugc2V0IHN0b3JlcyBhIGNvbGxlY3Rpb24gb2YgW3Jhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgaW4gYVxud2F5IHRoYXQgbWFrZXMgdGhlbSBlZmZpY2llbnQgdG8gW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC5tYXApIGFuZFxuW3VwZGF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC51cGRhdGUpLiBUaGlzIGlzIGFuIGltbXV0YWJsZSBkYXRhXG5zdHJ1Y3R1cmUuXG4qL1xuY2xhc3MgUmFuZ2VTZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtQb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmssIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dExheWVyLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBjaHVua1BvcztcbiAgICAgICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG5leHRMYXllcjtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY2h1bmsubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGxhc3QgPCAwID8gMCA6IE1hdGgubWF4KHRoaXMuY2h1bmtFbmQobGFzdCksIHRoaXMubmV4dExheWVyLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgcmFuZ2VzIGluIHRoZSBzZXQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMubmV4dExheWVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IGNodW5rIG9mIHRoaXMuY2h1bmspXG4gICAgICAgICAgICBzaXplICs9IGNodW5rLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtFbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmtQb3NbaW5kZXhdICsgdGhpcy5jaHVua1tpbmRleF0ubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHJhbmdlIHNldCwgb3B0aW9uYWxseSBhZGRpbmcgbmV3IHJhbmdlcyBvciBmaWx0ZXJpbmdcbiAgICBvdXQgZXhpc3Rpbmcgb25lcy5cbiAgICBcbiAgICAoTm90ZTogVGhlIHR5cGUgcGFyYW1ldGVyIGlzIGp1c3QgdGhlcmUgYXMgYSBrbHVkZ2UgdG8gd29ya1xuICAgIGFyb3VuZCBUeXBlU2NyaXB0IHZhcmlhbmNlIGlzc3VlcyB0aGF0IHByZXZlbnRlZCBgUmFuZ2VTZXQ8WD5gXG4gICAgZnJvbSBiZWluZyBhIHN1YnR5cGUgb2YgYFJhbmdlU2V0PFk+YCB3aGVuIGBYYCBpcyBhIHN1YnR5cGUgb2ZcbiAgICBgWWAuKVxuICAgICovXG4gICAgdXBkYXRlKHVwZGF0ZVNwZWMpIHtcbiAgICAgICAgbGV0IHsgYWRkID0gW10sIHNvcnQgPSBmYWxzZSwgZmlsdGVyRnJvbSA9IDAsIGZpbHRlclRvID0gdGhpcy5sZW5ndGggfSA9IHVwZGF0ZVNwZWM7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB1cGRhdGVTcGVjLmZpbHRlcjtcbiAgICAgICAgaWYgKGFkZC5sZW5ndGggPT0gMCAmJiAhZmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChzb3J0KVxuICAgICAgICAgICAgYWRkID0gYWRkLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gYWRkLmxlbmd0aCA/IFJhbmdlU2V0Lm9mKGFkZCkgOiB0aGlzO1xuICAgICAgICBsZXQgY3VyID0gbmV3IExheWVyQ3Vyc29yKHRoaXMsIG51bGwsIC0xKS5nb3RvKDApLCBpID0gMCwgc3BpbGwgPSBbXTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlIChjdXIudmFsdWUgfHwgaSA8IGFkZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIDwgYWRkLmxlbmd0aCAmJiAoY3VyLmZyb20gLSBhZGRbaV0uZnJvbSB8fCBjdXIuc3RhcnRTaWRlIC0gYWRkW2ldLnZhbHVlLnN0YXJ0U2lkZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGFkZFtpKytdO1xuICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ci5yYW5nZUluZGV4ID09IDEgJiYgY3VyLmNodW5rSW5kZXggPCB0aGlzLmNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIChpID09IGFkZC5sZW5ndGggfHwgdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgPCBhZGRbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgfHwgZmlsdGVyVG8gPCB0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSkgJiZcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZENodW5rKHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdLCB0aGlzLmNodW5rW2N1ci5jaHVua0luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjdXIubmV4dENodW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gY3VyLnRvIHx8IGZpbHRlclRvIDwgY3VyLmZyb20gfHwgZmlsdGVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKFJhbmdlLmNyZWF0ZShjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2hJbm5lcih0aGlzLm5leHRMYXllci5pc0VtcHR5ICYmICFzcGlsbC5sZW5ndGggPyBSYW5nZVNldC5lbXB0eVxuICAgICAgICAgICAgOiB0aGlzLm5leHRMYXllci51cGRhdGUoeyBhZGQ6IHNwaWxsLCBmaWx0ZXIsIGZpbHRlckZyb20sIGZpbHRlclRvIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgcmFuZ2Ugc2V0IHRocm91Z2ggYSBzZXQgb2YgY2hhbmdlcywgcmV0dXJuIHRoZSBuZXcgc2V0LlxuICAgICovXG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgfHwgdGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjaHVua3MgPSBbXSwgY2h1bmtQb3MgPSBbXSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBjaGFuZ2VzLnRvdWNoZXNSYW5nZShzdGFydCwgc3RhcnQgKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRvdWNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChjaGFuZ2VzLm1hcFBvcyhzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXBwZWQsIHBvcyB9ID0gY2h1bmsubWFwKHN0YXJ0LCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG1hcHBlZC5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHRMYXllci5tYXAoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiBjaHVua3MubGVuZ3RoID09IDAgPyBuZXh0IDogbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVua3MsIG5leHQgfHwgUmFuZ2VTZXQuZW1wdHksIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgdGhhdCB0b3VjaCB0aGUgcmVnaW9uIGBmcm9tYCB0byBgdG9gLFxuICAgIGNhbGxpbmcgYGZgIGZvciBlYWNoLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2VzIHdpbGxcbiAgICBiZSByZXBvcnRlZCBpbiBhbnkgc3BlY2lmaWMgb3JkZXIuIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICBgZmFsc2VgLCBpdGVyYXRpb24gc3RvcHMuXG4gICAgKi9cbiAgICBiZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgaWYgKHRvID49IHN0YXJ0ICYmIGZyb20gPD0gc3RhcnQgKyBjaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjaHVuay5iZXR3ZWVuKHN0YXJ0LCBmcm9tIC0gc3RhcnQsIHRvIC0gc3RhcnQsIGYpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIuYmV0d2Vlbihmcm9tLCB0bywgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIHRoaXMgc2V0LCBpbiBvcmRlciwgaW5jbHVkaW5nIGFsbFxuICAgIHJhbmdlcyB0aGF0IGVuZCBhdCBvciBhZnRlciBgZnJvbWAuXG4gICAgKi9cbiAgICBpdGVyKGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oW3RoaXNdKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkgeyByZXR1cm4gdGhpcy5uZXh0TGF5ZXIgPT0gdGhpczsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIGEgY29sbGVjdGlvbiBvZiBzZXRzLCBpbiBvcmRlcixcbiAgICBzdGFydGluZyBmcm9tIGBmcm9tYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpdGVyKHNldHMsIGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oc2V0cykuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHR3byBncm91cHMgb2Ygc2V0cywgY2FsbGluZyBtZXRob2RzIG9uIGBjb21wYXJhdG9yYFxuICAgIHRvIG5vdGlmeSBpdCBvZiBwb3NzaWJsZSBkaWZmZXJlbmNlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlKG9sZFNldHMsIG5ld1NldHMsIFxuICAgIC8qKlxuICAgIFRoaXMgaW5kaWNhdGVzIGhvdyB0aGUgdW5kZXJseWluZyBkYXRhIGNoYW5nZWQgYmV0d2VlbiB0aGVzZVxuICAgIHJhbmdlcywgYW5kIGlzIG5lZWRlZCB0byBzeW5jaHJvbml6ZSB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgdGV4dERpZmYsIGNvbXBhcmF0b3IsIFxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGlnbm9yZSBhbGwgbm9uLXBvaW50IHJhbmdlcywgYW5kIHBvaW50cyBiZWxvd1xuICAgIHRoZSBnaXZlbiBzaXplLiBXaGVuIC0xLCBhbGwgcmFuZ2VzIGFyZSBjb21wYXJlZC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgdGV4dERpZmYuaXRlckdhcHMoKGZyb21BLCBmcm9tQiwgbGVuZ3RoKSA9PiBjb21wYXJlKHNpZGVBLCBmcm9tQSwgc2lkZUIsIGZyb21CLCBsZW5ndGgsIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgaWYgKHRleHREaWZmLmVtcHR5ICYmIHRleHREaWZmLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgY29tcGFyZShzaWRlQSwgMCwgc2lkZUIsIDAsIDAsIGNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoZSBjb250ZW50cyBvZiB0d28gZ3JvdXBzIG9mIHJhbmdlIHNldHMsIHJldHVybmluZyB0cnVlXG4gICAgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZXEob2xkU2V0cywgbmV3U2V0cywgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovIC0gMTtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG5ld1NldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBvbGRTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKSwgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byAhPSBzaWRlQi50byB8fFxuICAgICAgICAgICAgICAgICFzYW1lVmFsdWVzKHNpZGVBLmFjdGl2ZSwgc2lkZUIuYWN0aXZlKSB8fFxuICAgICAgICAgICAgICAgIHNpZGVBLnBvaW50ICYmICghc2lkZUIucG9pbnQgfHwgIXNpZGVBLnBvaW50LmVxKHNpZGVCLnBvaW50KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaWRlQS5uZXh0KCk7XG4gICAgICAgICAgICBzaWRlQi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgZ3JvdXAgb2YgcmFuZ2Ugc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCBub3RpZnlpbmdcbiAgICB0aGUgaXRlcmF0b3IgYWJvdXQgdGhlIHJhbmdlcyBjb3ZlcmluZyBldmVyeSBnaXZlbiBwaWVjZSBvZlxuICAgIGNvbnRlbnQuIFJldHVybnMgdGhlIG9wZW4gY291bnQgKHNlZVxuICAgIFtgU3Bhbkl0ZXJhdG9yLnNwYW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNwYW5JdGVyYXRvci5zcGFuKSkgYXQgdGhlIGVuZFxuICAgIG9mIHRoZSBpdGVyYXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgc3BhbnMoc2V0cywgZnJvbSwgdG8sIGl0ZXJhdG9yLCBcbiAgICAvKipcbiAgICBXaGVuIGdpdmVuIGFuZCBncmVhdGVyIHRoYW4gLTEsIG9ubHkgcG9pbnRzIG9mIGF0IGxlYXN0IHRoaXNcbiAgICBzaXplIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNwYW5DdXJzb3Ioc2V0cywgbnVsbCwgbWluUG9pbnRTaXplKS5nb3RvKGZyb20pLCBwb3MgPSBmcm9tO1xuICAgICAgICBsZXQgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBjdXJUbyA9IE1hdGgubWluKGN1cnNvci50bywgdG8pO1xuICAgICAgICAgICAgaWYgKGN1cnNvci5wb2ludCkge1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBjdXJzb3IuYWN0aXZlRm9yUG9pbnQoY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBsZXQgb3BlbkNvdW50ID0gY3Vyc29yLnBvaW50RnJvbSA8IGZyb20gPyBhY3RpdmUubGVuZ3RoICsgMVxuICAgICAgICAgICAgICAgICAgICA6IGN1cnNvci5wb2ludC5zdGFydFNpZGUgPCAwID8gYWN0aXZlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihhY3RpdmUubGVuZ3RoLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5wb2ludChwb3MsIGN1clRvLCBjdXJzb3IucG9pbnQsIGFjdGl2ZSwgb3BlbkNvdW50LCBjdXJzb3IucG9pbnRSYW5rKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gTWF0aC5taW4oY3Vyc29yLm9wZW5FbmQoY3VyVG8pLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1clRvID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3Bhbihwb3MsIGN1clRvLCBjdXJzb3IuYWN0aXZlLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5FbmQoY3VyVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuUmFuZ2VzICsgKGN1cnNvci5wb2ludCAmJiBjdXJzb3IudG8gPiB0byA/IDEgOiAwKTtcbiAgICAgICAgICAgIHBvcyA9IGN1cnNvci50bztcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gcmFuZ2Ugb3IgYXJyYXkgb2YgcmFuZ2VzLiBCeVxuICAgIGRlZmF1bHQsIHRoaXMgZXhwZWN0cyB0aGUgcmFuZ2VzIHRvIGJlIF9zb3J0ZWRfIChieSBzdGFydFxuICAgIHBvc2l0aW9uIGFuZCwgaWYgdHdvIHN0YXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKS4gWW91IGNhbiBwYXNzIGB0cnVlYCBhcyBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBjYXVzZSB0aGUgbWV0aG9kIHRvIHNvcnQgdGhlbS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihyYW5nZXMsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHJhbmdlcyBpbnN0YW5jZW9mIFJhbmdlID8gW3Jhbmdlc10gOiBzb3J0ID8gbGF6eVNvcnQocmFuZ2VzKSA6IHJhbmdlcylcbiAgICAgICAgICAgIGJ1aWxkLmFkZChyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEpvaW4gYW4gYXJyYXkgb2YgcmFuZ2Ugc2V0cyBpbnRvIGEgc2luZ2xlIHNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBqb2luKHNldHMpIHtcbiAgICAgICAgaWYgKCFzZXRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBSYW5nZVNldC5lbXB0eTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNldHNbc2V0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNldHMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGxheWVyID0gc2V0c1tpXTsgbGF5ZXIgIT0gUmFuZ2VTZXQuZW1wdHk7IGxheWVyID0gbGF5ZXIubmV4dExheWVyKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSYW5nZVNldChsYXllci5jaHVua1BvcywgbGF5ZXIuY2h1bmssIHJlc3VsdCwgTWF0aC5tYXgobGF5ZXIubWF4UG9pbnQsIHJlc3VsdC5tYXhQb2ludCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIHJhbmdlcy5cbiovXG5SYW5nZVNldC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgUmFuZ2VTZXQoW10sIFtdLCBudWxsLCAtMSk7XG5mdW5jdGlvbiBsYXp5U29ydChyYW5nZXMpIHtcbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIGZvciAobGV0IHByZXYgPSByYW5nZXNbMF0sIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNtcFJhbmdlKHByZXYsIGN1cikgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXMuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XG4vKipcbkEgcmFuZ2Ugc2V0IGJ1aWxkZXIgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhlbHBzIGJ1aWxkIHVwIGFcbltyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGRpcmVjdGx5LCB3aXRob3V0IGZpcnN0IGFsbG9jYXRpbmdcbmFuIGFycmF5IG9mIFtgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBvYmplY3RzLlxuKi9cbmNsYXNzIFJhbmdlU2V0QnVpbGRlciB7XG4gICAgZmluaXNoQ2h1bmsobmV3QXJyYXlzKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IENodW5rKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy52YWx1ZSwgdGhpcy5tYXhQb2ludCkpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCB0aGlzLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICBpZiAobmV3QXJyYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgYnVpbGRlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMubGFzdFRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAgICovXG4gICAgYWRkKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSlcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xuICAgICAgICBpZiAoZGlmZiA8PSAwICYmIChmcm9tIC0gdGhpcy5sYXN0RnJvbSB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCA9PSAyNTAgLyogQy5DaHVua1NpemUgKi8pXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMuZnJvbS5wdXNoKGZyb20gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLnRvLnB1c2godG8gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmxhc3QgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5wb2ludClcbiAgICAgICAgICAgIHRoaXMubWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLm1heFBvaW50LCB0byAtIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRDaHVuayhmcm9tLCBjaHVuaykge1xuICAgICAgICBpZiAoKGZyb20gLSB0aGlzLmxhc3RUbyB8fCBjaHVuay52YWx1ZVswXS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2goZnJvbSk7XG4gICAgICAgIGxldCBsYXN0ID0gY2h1bmsudmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gY2h1bmsudmFsdWVbbGFzdF07XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBjaHVuay5mcm9tW2xhc3RdICsgZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSBjaHVuay50b1tsYXN0XSArIGZyb207XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5pc2ggdGhlIHJhbmdlIHNldC4gUmV0dXJucyB0aGUgbmV3IHNldC4gVGhlIGJ1aWxkZXIgY2FuJ3QgYmVcbiAgICB1c2VkIGFueW1vcmUgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgKi9cbiAgICBmaW5pc2goKSB7IHJldHVybiB0aGlzLmZpbmlzaElubmVyKFJhbmdlU2V0LmVtcHR5KTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoSW5uZXIobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhbmdlU2V0LmNyZWF0ZSh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihuZXh0KSA6IG5leHQsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmZyb20gPSBudWxsOyAvLyBNYWtlIHN1cmUgZnVydGhlciBgYWRkYCBjYWxscyBwcm9kdWNlIGVycm9yc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpIHtcbiAgICBsZXQgaW5BID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBhKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXQuY2h1bmtbaV0ubWF4UG9pbnQgPD0gMClcbiAgICAgICAgICAgICAgICBpbkEuc2V0KHNldC5jaHVua1tpXSwgc2V0LmNodW5rUG9zW2ldKTtcbiAgICBsZXQgc2hhcmVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBiKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtub3duID0gaW5BLmdldChzZXQuY2h1bmtbaV0pO1xuICAgICAgICAgICAgaWYgKGtub3duICE9IG51bGwgJiYgKHRleHREaWZmID8gdGV4dERpZmYubWFwUG9zKGtub3duKSA6IGtub3duKSA9PSBzZXQuY2h1bmtQb3NbaV0gJiZcbiAgICAgICAgICAgICAgICAhKHRleHREaWZmID09PSBudWxsIHx8IHRleHREaWZmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RGlmZi50b3VjaGVzUmFuZ2Uoa25vd24sIGtub3duICsgc2V0LmNodW5rW2ldLmxlbmd0aCkpKVxuICAgICAgICAgICAgICAgIHNoYXJlZC5hZGQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBzaGFyZWQ7XG59XG5jbGFzcyBMYXllckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IobGF5ZXIsIHNraXAsIG1pblBvaW50LCByYW5rID0gMCkge1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnZXQgZW5kU2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXggPSB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbmV4dC5tYXhQb2ludCA8IHRoaXMubWluUG9pbnQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VJbmRleCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgocG9zIC0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleChyYW5nZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPT0gdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjaHVua1BvcyA9IHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgY2h1bmsgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSBjaHVua1BvcyArIGNodW5rLnRvW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHRoaXMucmFuZ2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoICYmIHRoaXMuc2tpcC5oYXModGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy5yYW5rIC0gb3RoZXIucmFuayB8fFxuICAgICAgICAgICAgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07ICFjdXIuaXNFbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMudmFsdWUuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdG9wLmZyb207XG4gICAgICAgICAgICB0aGlzLnRvID0gdG9wLnRvO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRvcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IHRvcC5yYW5rO1xuICAgICAgICAgICAgaWYgKHRvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0b3AubmV4dCgpO1xuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGVhcEJ1YmJsZShoZWFwLCBpbmRleCkge1xuICAgIGZvciAobGV0IGN1ciA9IGhlYXBbaW5kZXhdOzspIHtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSAoaW5kZXggPDwgMSkgKyAxO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+PSBoZWFwLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCArIDEgPCBoZWFwLmxlbmd0aCAmJiBjaGlsZC5jb21wYXJlKGhlYXBbY2hpbGRJbmRleCArIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIuY29tcGFyZShjaGlsZCkgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYXBbY2hpbGRJbmRleF0gPSBjdXI7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIGluZGV4ID0gY2hpbGRJbmRleDtcbiAgICB9XG59XG5jbGFzcyBTcGFuQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzZXRzLCBza2lwLCBtaW5Qb2ludCkge1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlVG8gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5rID0gW107XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIC8vIEEgY3VycmVudGx5IGFjdGl2ZSBwb2ludCByYW5nZSwgaWYgYW55XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRSYW5rID0gMDtcbiAgICAgICAgdGhpcy50byA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIG9wZW4gYWN0aXZlIHJhbmdlcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAvLyBOb3QgaW5jbHVkaW5nIHBvaW50cy5cbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBIZWFwQ3Vyc29yLmZyb20oc2V0cywgc2tpcCwgbWluUG9pbnQpO1xuICAgIH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgdGhpcy50byA9IHBvcztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5taW5BY3RpdmUgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1t0aGlzLm1pbkFjdGl2ZV0gLSBwb3MgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZSwgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVUbywgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xuICAgICAgICBsZXQgaSA9IDAsIHsgdmFsdWUsIHRvLCByYW5rIH0gPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgLy8gT3JnYW5pemUgYWN0aXZlIG1hcmtzIGJ5IHJhbmsgZmlyc3QsIHRoZW4gYnkgc2l6ZVxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggJiYgKHJhbmsgLSB0aGlzLmFjdGl2ZVJhbmtbaV0gfHwgdG8gLSB0aGlzLmFjdGl2ZVRvW2ldKSA+IDApXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZSwgaSwgdmFsdWUpO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVUbywgaSwgdG8pO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVSYW5rLCBpLCByYW5rKTtcbiAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgIGluc2VydCh0cmFja09wZW4sIGksIHRoaXMuY3Vyc29yLmZyb20pO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIC8vIEFmdGVyIGNhbGxpbmcgdGhpcywgaWYgYHRoaXMucG9pbnRgICE9IG51bGwsIHRoZSBuZXh0IHJhbmdlIGlzIGFcbiAgICAvLyBwb2ludC4gT3RoZXJ3aXNlLCBpdCdzIGEgcmVndWxhciByYW5nZSwgY292ZXJlZCBieSBgdGhpcy5hY3RpdmVgLlxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy50bywgd2FzUG9pbnQgPSB0aGlzLnBvaW50O1xuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgbGV0IHRyYWNrT3BlbiA9IHRoaXMub3BlblN0YXJ0IDwgMCA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGEgPSB0aGlzLm1pbkFjdGl2ZTtcbiAgICAgICAgICAgIGlmIChhID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bYV0gLSB0aGlzLmN1cnNvci5mcm9tIHx8IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGUgLSB0aGlzLmN1cnNvci5zdGFydFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2FdID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5hY3RpdmVUb1thXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5hY3RpdmVbYV0uZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKGEpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSh0cmFja09wZW4sIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY3Vyc29yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuZW5kU2lkZSA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnNvci5mcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuY3Vyc29yLnN0YXJ0U2lkZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VmFsID0gdGhpcy5jdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0VmFsLnBvaW50KSB7IC8vIE9wZW5pbmcgYSByYW5nZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEFjdGl2ZSh0cmFja09wZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc1BvaW50ICYmIHRoaXMuY3Vyc29yLnRvID09IHRoaXMudG8gJiYgdGhpcy5jdXJzb3IuZnJvbSA8IHRoaXMuY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgbm9uLWVtcHR5IHBvaW50cyB0aGF0IGVuZCBwcmVjaXNlbHkgYXQgdGhlIGVuZCBvZiB0aGUgcHJldiBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBOZXcgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCA9IG5leHRWYWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRGcm9tID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludFJhbmsgPSB0aGlzLmN1cnNvci5yYW5rO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IudG87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IG5leHRWYWwuZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmQodGhpcy50bywgdGhpcy5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0cmFja09wZW4ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRyYWNrT3BlbltpXSA8IGZyb207IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5TdGFydCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2ZUZvclBvaW50KHRvKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgYWN0aXZlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUmFua1tpXSA8IHRoaXMucG9pbnRSYW5rKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9baV0gPiB0byB8fCB0aGlzLmFjdGl2ZVRvW2ldID09IHRvICYmIHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgPj0gdGhpcy5wb2ludC5lbmRTaWRlKVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHRoaXMuYWN0aXZlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgb3BlbkVuZCh0bykge1xuICAgICAgICBsZXQgb3BlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0aGlzLmFjdGl2ZVRvW2ldID4gdG87IGktLSlcbiAgICAgICAgICAgIG9wZW4rKztcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZShhLCBzdGFydEEsIGIsIHN0YXJ0QiwgbGVuZ3RoLCBjb21wYXJhdG9yKSB7XG4gICAgYS5nb3RvKHN0YXJ0QSk7XG4gICAgYi5nb3RvKHN0YXJ0Qik7XG4gICAgbGV0IGVuZEIgPSBzdGFydEIgKyBsZW5ndGg7XG4gICAgbGV0IHBvcyA9IHN0YXJ0QiwgZFBvcyA9IHN0YXJ0QiAtIHN0YXJ0QTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBkRW5kID0gKGEudG8gKyBkUG9zKSAtIGIudG8sIGRpZmYgPSBkRW5kIHx8IGEuZW5kU2lkZSAtIGIuZW5kU2lkZTtcbiAgICAgICAgbGV0IGVuZCA9IGRpZmYgPCAwID8gYS50byArIGRQb3MgOiBiLnRvLCBjbGlwRW5kID0gTWF0aC5taW4oZW5kLCBlbmRCKTtcbiAgICAgICAgaWYgKGEucG9pbnQgfHwgYi5wb2ludCkge1xuICAgICAgICAgICAgaWYgKCEoYS5wb2ludCAmJiBiLnBvaW50ICYmIChhLnBvaW50ID09IGIucG9pbnQgfHwgYS5wb2ludC5lcShiLnBvaW50KSkgJiZcbiAgICAgICAgICAgICAgICBzYW1lVmFsdWVzKGEuYWN0aXZlRm9yUG9pbnQoYS50byksIGIuYWN0aXZlRm9yUG9pbnQoYi50bykpKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVQb2ludChwb3MsIGNsaXBFbmQsIGEucG9pbnQsIGIucG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsaXBFbmQgPiBwb3MgJiYgIXNhbWVWYWx1ZXMoYS5hY3RpdmUsIGIuYWN0aXZlKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVSYW5nZShwb3MsIGNsaXBFbmQsIGEuYWN0aXZlLCBiLmFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IGVuZEIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKChkRW5kIHx8IGEub3BlbkVuZCAhPSBiLm9wZW5FbmQpICYmIGNvbXBhcmF0b3IuYm91bmRDaGFuZ2UpXG4gICAgICAgICAgICBjb21wYXJhdG9yLmJvdW5kQ2hhbmdlKGVuZCk7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldICYmICFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgZSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPCBlOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIDFdO1xuICAgIGFycmF5LnBvcCgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaS0tKVxuICAgICAgICBhcnJheVtpICsgMV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5JbmRleCh2YWx1ZSwgYXJyYXkpIHtcbiAgICBsZXQgZm91bmQgPSAtMSwgZm91bmRQb3MgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICgoYXJyYXlbaV0gLSBmb3VuZFBvcyB8fCB2YWx1ZVtpXS5lbmRTaWRlIC0gdmFsdWVbZm91bmRdLmVuZFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgZm91bmRQb3MgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5Db3VudCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQgaW50byB0aGUgc3RyaW5nLFxudGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXG4qL1xuZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCB0YWJTaXplLCB0byA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0byAmJiBpIDwgc3RyaW5nLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpIHtcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5GaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gY29sdW1uIHBvc2l0aW9uIGluIGFcbnN0cmluZywgdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuIEJ5XG5kZWZhdWx0LCB0aGUgc3RyaW5nIGxlbmd0aCBpcyByZXR1cm5lZCB3aGVuIGl0IGlzIHRvbyBzaG9ydCB0b1xucmVhY2ggdGhlIGNvbHVtbi4gUGFzcyBgc3RyaWN0YCB0cnVlIHRvIG1ha2UgaXQgcmV0dXJuIC0xIGluIHRoYXRcbnNpdHVhdGlvbi5cbiovXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgY29sLCB0YWJTaXplLCBzdHJpY3QpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IDA7Oykge1xuICAgICAgICBpZiAobiA+PSBjb2wpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgaWYgKGkgPT0gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkgPyB0YWJTaXplIC0gKG4gJSB0YWJTaXplKSA6IDE7XG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpY3QgPT09IHRydWUgPyAtMSA6IHN0cmluZy5sZW5ndGg7XG59XG5cbmV4cG9ydCB7IEFubm90YXRpb24sIEFubm90YXRpb25UeXBlLCBDaGFuZ2VEZXNjLCBDaGFuZ2VTZXQsIENoYXJDYXRlZ29yeSwgQ29tcGFydG1lbnQsIEVkaXRvclNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIEZhY2V0LCBMaW5lLCBNYXBNb2RlLCBQcmVjLCBSYW5nZSwgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUmFuZ2VWYWx1ZSwgU2VsZWN0aW9uUmFuZ2UsIFN0YXRlRWZmZWN0LCBTdGF0ZUVmZmVjdFR5cGUsIFN0YXRlRmllbGQsIFRleHQsIFRyYW5zYWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgY291bnRDb2x1bW4sIGZpbmRDbHVzdGVyQnJlYWssIGZpbmRDb2x1bW4sIGZyb21Db2RlUG9pbnQgfTtcbiJdLCJuYW1lcyI6WyJmaW5kQ2x1c3RlckJyZWFrIiwiZmluZENsdXN0ZXJCcmVhayQxIiwiVGV4dCIsImxpbmVBdCIsInBvcyIsImxlbmd0aCIsIlJhbmdlRXJyb3IiLCJsaW5lSW5uZXIiLCJsaW5lIiwibiIsImxpbmVzIiwicmVwbGFjZSIsImZyb20iLCJ0byIsInRleHQiLCJjbGlwIiwicGFydHMiLCJkZWNvbXBvc2UiLCJUZXh0Tm9kZSIsImFwcGVuZCIsIm90aGVyIiwic2xpY2UiLCJlcSIsInN0YXJ0Iiwic2NhbklkZW50aWNhbCIsImVuZCIsImEiLCJSYXdUZXh0Q3Vyc29yIiwiYiIsInNraXAiLCJuZXh0IiwibGluZUJyZWFrIiwiZG9uZSIsInZhbHVlIiwiaXRlciIsImRpciIsIml0ZXJSYW5nZSIsIlBhcnRpYWxUZXh0Q3Vyc29yIiwiaXRlckxpbmVzIiwiaW5uZXIiLCJNYXRoIiwibWF4IiwiTGluZUN1cnNvciIsInRvU3RyaW5nIiwic2xpY2VTdHJpbmciLCJ0b0pTT04iLCJmbGF0dGVuIiwiY29uc3RydWN0b3IiLCJvZiIsImVtcHR5IiwiVGV4dExlYWYiLCJzcGxpdCIsInRleHRMZW5ndGgiLCJjaGlsZHJlbiIsInRhcmdldCIsImlzTGluZSIsIm9mZnNldCIsImkiLCJzdHJpbmciLCJMaW5lIiwib3BlbiIsInNsaWNlVGV4dCIsIm1pbiIsInByZXYiLCJwb3AiLCJqb2luZWQiLCJhcHBlbmRUZXh0IiwicHVzaCIsIm1pZCIsIm5ld0xlbiIsImxpbmVTZXAiLCJyZXN1bHQiLCJwYXJ0IiwibGVuIiwiY2hpbGQiLCJlbmRMaW5lIiwiY2hpbGRPcGVuIiwidXBkYXRlZCIsInRvdGFsTGluZXMiLCJjb3B5IiwiaUEiLCJpQiIsImVBIiwiZUIiLCJjaEEiLCJjaEIiLCJyZWR1Y2UiLCJsIiwiY2giLCJmbGF0IiwiY2h1bmsiLCJtYXhDaHVuayIsIm1pbkNodW5rIiwiY2h1bmtlZCIsImN1cnJlbnRMaW5lcyIsImN1cnJlbnRMZW4iLCJjdXJyZW50Q2h1bmsiLCJhZGQiLCJsYXN0Iiwibm9kZSIsImZsdXNoIiwiY29uY2F0IiwiZmlyc3QiLCJub2RlcyIsIm9mZnNldHMiLCJuZXh0SW5uZXIiLCJ0b3AiLCJvZmZzZXRWYWx1ZSIsInNpemUiLCJjdXJzb3IiLCJsaW1pdCIsImFmdGVyQnJlYWsiLCJTeW1ib2wiLCJwcm90b3R5cGUiLCJpdGVyYXRvciIsIm51bWJlciIsInN0ciIsImZvcndhcmQiLCJpbmNsdWRlRXh0ZW5kaW5nIiwic3Vycm9nYXRlTG93Iiwic3Vycm9nYXRlSGlnaCIsImNvZGVQb2ludEF0IiwiY29kZTAiLCJjaGFyQ29kZUF0IiwiY29kZTEiLCJmcm9tQ29kZVBvaW50IiwiY29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvZGVQb2ludFNpemUiLCJEZWZhdWx0U3BsaXQiLCJNYXBNb2RlIiwiQ2hhbmdlRGVzYyIsInNlY3Rpb25zIiwibmV3TGVuZ3RoIiwiaW5zIiwiaXRlckdhcHMiLCJmIiwicG9zQSIsInBvc0IiLCJpdGVyQ2hhbmdlZFJhbmdlcyIsImluZGl2aWR1YWwiLCJpdGVyQ2hhbmdlcyIsImludmVydGVkRGVzYyIsImNvbXBvc2VEZXNjIiwiY29tcG9zZVNldHMiLCJtYXBEZXNjIiwiYmVmb3JlIiwibWFwU2V0IiwibWFwUG9zIiwiYXNzb2MiLCJtb2RlIiwiU2ltcGxlIiwiZW5kQSIsIlRyYWNrRGVsIiwiVHJhY2tCZWZvcmUiLCJUcmFja0FmdGVyIiwidG91Y2hlc1JhbmdlIiwiZnJvbUpTT04iLCJqc29uIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsImNyZWF0ZSIsIkNoYW5nZVNldCIsImluc2VydGVkIiwiYXBwbHkiLCJkb2MiLCJmcm9tQSIsInRvQSIsImZyb21CIiwiX3RvQiIsImludmVydCIsImluZGV4IiwiY29tcG9zZSIsIm1hcCIsImRlc2MiLCJmaWx0ZXIiLCJyYW5nZXMiLCJyZXN1bHRTZWN0aW9ucyIsInJlc3VsdEluc2VydGVkIiwiZmlsdGVyZWRTZWN0aW9ucyIsIlNlY3Rpb25JdGVyIiwiYWRkU2VjdGlvbiIsIm9mZiIsImFkZEluc2VydCIsImNoYW5nZXMiLCJmaWx0ZXJlZCIsInRvdGFsIiwiZm9yY2UiLCJzZXQiLCJwcm9jZXNzIiwic3BlYyIsInN1YiIsImluc2VydCIsImluc1RleHQiLCJpbnNMZW4iLCJlIiwiY3JlYXRlU2V0IiwiZm9yY2VKb2luIiwidmFsdWVzIiwiZW5kQiIsInNldEEiLCJzZXRCIiwibWtTZXQiLCJFcnJvciIsInBpZWNlIiwibGVmdCIsImxlbjIiLCJzZWN0aW9uTGVuIiwiaW5zQiIsInRleHRCaXQiLCJmb3J3YXJkMiIsInVuZGVmaW5lZCIsIlNlbGVjdGlvblJhbmdlIiwiZmxhZ3MiLCJhbmNob3IiLCJoZWFkIiwiYmlkaUxldmVsIiwibGV2ZWwiLCJnb2FsQ29sdW1uIiwiY2hhbmdlIiwiZXh0ZW5kIiwiRWRpdG9yU2VsZWN0aW9uIiwicmFuZ2UiLCJhYnMiLCJpbmNsdWRlQXNzb2MiLCJtYWluSW5kZXgiLCJyIiwibWFpbiIsImFzU2luZ2xlIiwiYWRkUmFuZ2UiLCJyZXBsYWNlUmFuZ2UiLCJ3aGljaCIsInNpbmdsZSIsIm5vcm1hbGl6ZWQiLCJzb3J0IiwiaW5kZXhPZiIsInNwbGljZSIsImNoZWNrU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiZG9jTGVuZ3RoIiwibmV4dElEIiwiRmFjZXQiLCJjb21iaW5lIiwiY29tcGFyZUlucHV0IiwiY29tcGFyZSIsImlzU3RhdGljIiwiZW5hYmxlcyIsImlkIiwiZGVmYXVsdCIsImV4dGVuc2lvbnMiLCJyZWFkZXIiLCJkZWZpbmUiLCJjb25maWciLCJzYW1lQXJyYXkiLCJzdGF0aWMiLCJGYWNldFByb3ZpZGVyIiwiY29tcHV0ZSIsImRlcHMiLCJnZXQiLCJjb21wdXRlTiIsImZpZWxkIiwieCIsInN0YXRlIiwiZXZlcnkiLCJkZXBlbmRlbmNpZXMiLCJmYWNldCIsInR5cGUiLCJkeW5hbWljU2xvdCIsImFkZHJlc3NlcyIsIl9hIiwiZ2V0dGVyIiwiaWR4IiwibXVsdGkiLCJkZXBEb2MiLCJkZXBTZWwiLCJkZXBBZGRycyIsImRlcCIsInVwZGF0ZSIsInRyIiwiZG9jQ2hhbmdlZCIsImVuc3VyZUFsbCIsIm5ld1ZhbCIsImNvbXBhcmVBcnJheSIsInJlY29uZmlndXJlIiwib2xkU3RhdGUiLCJvbGRBZGRyIiwiYWRkcmVzcyIsIm9sZFZhbCIsImdldEFkZHIiLCJTdGF0ZUZpZWxkIiwiYWRkcnMiLCJjaGFuZ2VkIiwiYWRkciIsImVuc3VyZUFkZHIiLCJkeW5hbWljRmFjZXRTbG90IiwicHJvdmlkZXJzIiwicHJvdmlkZXJBZGRycyIsInAiLCJwcm92aWRlclR5cGVzIiwiZHluYW1pYyIsInZhbCIsImRlcENoYW5nZWQiLCJvbGRQcm92aWRlcnMiLCJmYWNldHMiLCJvbGRWYWx1ZSIsImluaXRGaWVsZCIsImNyZWF0ZUYiLCJ1cGRhdGVGIiwiY29tcGFyZUYiLCJwcm92aWRlcyIsInByb3ZpZGUiLCJpbml0IiwiZmluZCIsInNsb3QiLCJvbGRJbml0IiwicmVJbml0IiwiZXh0ZW5zaW9uIiwiUHJlY18iLCJsb3dlc3QiLCJsb3ciLCJoaWdoIiwiaGlnaGVzdCIsInByZWMiLCJleHQiLCJQcmVjRXh0ZW5zaW9uIiwiUHJlYyIsIkNvbXBhcnRtZW50IiwiQ29tcGFydG1lbnRJbnN0YW5jZSIsImNvbnRlbnQiLCJjb21wYXJ0bWVudCIsImNvbXBhcnRtZW50cyIsIkNvbmZpZ3VyYXRpb24iLCJiYXNlIiwiZHluYW1pY1Nsb3RzIiwic3RhdGljVmFsdWVzIiwic3RhdHVzVGVtcGxhdGUiLCJzdGF0aWNGYWNldCIsInJlc29sdmUiLCJmaWVsZHMiLCJPYmplY3QiLCJuZXdDb21wYXJ0bWVudHMiLCJNYXAiLCJvbGRGYWNldHMiLCJzZWVuIiwia25vd24iLCJmb3VuZCIsImRlbGV0ZSIsImhhcyIsInN0YXR1cyIsImNvbXB1dGVTbG90IiwibGFuZ3VhZ2VEYXRhIiwiYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMiLCJ2IiwibGluZVNlcGFyYXRvciIsImNoYW5nZUZpbHRlciIsInRyYW5zYWN0aW9uRmlsdGVyIiwidHJhbnNhY3Rpb25FeHRlbmRlciIsInJlYWRPbmx5IiwiQW5ub3RhdGlvbiIsIkFubm90YXRpb25UeXBlIiwiU3RhdGVFZmZlY3RUeXBlIiwiU3RhdGVFZmZlY3QiLCJtYXBwaW5nIiwibWFwcGVkIiwiaXMiLCJtYXBFZmZlY3RzIiwiZWZmZWN0cyIsImVmZmVjdCIsImFwcGVuZENvbmZpZyIsIlRyYW5zYWN0aW9uIiwic3RhcnRTdGF0ZSIsImFubm90YXRpb25zIiwic2Nyb2xsSW50b1ZpZXciLCJfZG9jIiwiX3N0YXRlIiwidGltZSIsIkRhdGUiLCJub3ciLCJuZXdEb2MiLCJuZXdTZWxlY3Rpb24iLCJhcHBseVRyYW5zYWN0aW9uIiwiYW5ub3RhdGlvbiIsImFubiIsInJlY29uZmlndXJlZCIsImlzVXNlckV2ZW50IiwiZXZlbnQiLCJ1c2VyRXZlbnQiLCJhZGRUb0hpc3RvcnkiLCJyZW1vdGUiLCJqb2luUmFuZ2VzIiwibWVyZ2VUcmFuc2FjdGlvbiIsInNlcXVlbnRpYWwiLCJtYXBGb3JBIiwibWFwRm9yQiIsInJlc29sdmVUcmFuc2FjdGlvbklubmVyIiwiZG9jU2l6ZSIsInNlbCIsImFzQXJyYXkiLCJyZXNvbHZlVHJhbnNhY3Rpb24iLCJzcGVjcyIsInMiLCJzZXEiLCJleHRlbmRUcmFuc2FjdGlvbiIsImZpbHRlclRyYW5zYWN0aW9uIiwiYmFjayIsImZpbHRlcnMiLCJleHRlbmRlcnMiLCJrZXlzIiwibm9uZSIsIkNoYXJDYXRlZ29yeSIsIm5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyIiwid29yZENoYXIiLCJSZWdFeHAiLCJfIiwiaGFzV29yZENoYXIiLCJ0ZXN0IiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsIm1ha2VDYXRlZ29yaXplciIsIndvcmRDaGFycyIsImNoYXIiLCJTcGFjZSIsIldvcmQiLCJPdGhlciIsIkVkaXRvclN0YXRlIiwicmVxdWlyZSIsImNvbmYiLCJmb3JFYWNoIiwia2V5Iiwic3RhcnRWYWx1ZXMiLCJpbnRlcm1lZGlhdGVTdGF0ZSIsInJlcGxhY2VTZWxlY3Rpb24iLCJ0b1RleHQiLCJjaGFuZ2VCeVJhbmdlIiwicmVzdWx0MSIsIm5ld0NoYW5nZXMiLCJuZXdNYXBwZWQiLCJqIiwibWFwQnkiLCJzbGljZURvYyIsInByb3AiLCJmaWVsZEluaXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjb25maWd1cmF0aW9uIiwidGFiU2l6ZSIsInBocmFzZSIsInBocmFzZXMiLCJtIiwibGFuZ3VhZ2VEYXRhQXQiLCJuYW1lIiwic2lkZSIsInByb3ZpZGVyIiwiY2hhckNhdGVnb3JpemVyIiwiYXQiLCJqb2luIiwid29yZEF0IiwiY2F0Iiwia0EiLCJrQiIsImsiLCJjb21iaW5lQ29uZmlnIiwiY29uZmlncyIsImRlZmF1bHRzIiwiY3VycmVudCIsIlJhbmdlVmFsdWUiLCJSYW5nZSIsInN0YXJ0U2lkZSIsImVuZFNpZGUiLCJwb2ludCIsIm1hcE1vZGUiLCJjbXBSYW5nZSIsIkNodW5rIiwibWF4UG9pbnQiLCJmaW5kSW5kZXgiLCJzdGFydEF0IiwiYXJyIiwibG8iLCJoaSIsImRpZmYiLCJiZXR3ZWVuIiwibmV3UG9zIiwiY3VyRnJvbSIsImN1clRvIiwibmV3RnJvbSIsIm5ld1RvIiwiUmFuZ2VTZXQiLCJjaHVua1BvcyIsIm5leHRMYXllciIsImNodW5rRW5kIiwiaXNFbXB0eSIsInVwZGF0ZVNwZWMiLCJmaWx0ZXJGcm9tIiwiZmlsdGVyVG8iLCJjdXIiLCJMYXllckN1cnNvciIsImdvdG8iLCJzcGlsbCIsImJ1aWxkZXIiLCJSYW5nZVNldEJ1aWxkZXIiLCJhZGRJbm5lciIsInJhbmdlSW5kZXgiLCJjaHVua0luZGV4IiwiYWRkQ2h1bmsiLCJuZXh0Q2h1bmsiLCJmaW5pc2hJbm5lciIsImNodW5rcyIsInRvdWNoIiwiSGVhcEN1cnNvciIsInNldHMiLCJvbGRTZXRzIiwibmV3U2V0cyIsInRleHREaWZmIiwiY29tcGFyYXRvciIsIm1pblBvaW50U2l6ZSIsInNoYXJlZENodW5rcyIsImZpbmRTaGFyZWRDaHVua3MiLCJzaWRlQSIsIlNwYW5DdXJzb3IiLCJzaWRlQiIsInNhbWVWYWx1ZXMiLCJhY3RpdmUiLCJzcGFucyIsIm9wZW5SYW5nZXMiLCJvcGVuU3RhcnQiLCJhY3RpdmVGb3JQb2ludCIsIm9wZW5Db3VudCIsInBvaW50RnJvbSIsInBvaW50UmFuayIsIm9wZW5FbmQiLCJzcGFuIiwiYnVpbGQiLCJsYXp5U29ydCIsImZpbmlzaCIsImxheWVyIiwiZmluaXNoQ2h1bmsiLCJuZXdBcnJheXMiLCJjaHVua1N0YXJ0Iiwic2V0TWF4UG9pbnQiLCJsYXN0RnJvbSIsImxhc3RUbyIsImluQSIsInNoYXJlZCIsIlNldCIsIm1pblBvaW50IiwicmFuayIsImdvdG9Jbm5lciIsInNldFJhbmdlSW5kZXgiLCJoZWFwIiwiaGVhcEJ1YmJsZSIsImNoaWxkSW5kZXgiLCJhY3RpdmVUbyIsImFjdGl2ZVJhbmsiLCJtaW5BY3RpdmUiLCJyZW1vdmVBY3RpdmUiLCJyZW1vdmUiLCJmaW5kTWluSW5kZXgiLCJhZGRBY3RpdmUiLCJ0cmFja09wZW4iLCJ3YXNQb2ludCIsIm5leHRWYWwiLCJyZXZlcnNlIiwic3RhcnRBIiwic3RhcnRCIiwiZFBvcyIsImRFbmQiLCJjbGlwRW5kIiwiY29tcGFyZVBvaW50IiwiY29tcGFyZVJhbmdlIiwiYm91bmRDaGFuZ2UiLCJhcnJheSIsImZvdW5kUG9zIiwiY291bnRDb2x1bW4iLCJmaW5kQ29sdW1uIiwiY29sIiwic3RyaWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/state/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/theme-one-dark/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: () => (/* binding */ color),\n/* harmony export */   oneDark: () => (/* binding */ oneDark),\n/* harmony export */   oneDarkHighlightStyle: () => (/* binding */ oneDarkHighlightStyle),\n/* harmony export */   oneDarkTheme: () => (/* binding */ oneDarkTheme)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// Using https://github.com/one-dark/vscode-one-dark-theme/ as reference for the colors\nconst chalky = \"#e5c07b\", coral = \"#e06c75\", cyan = \"#56b6c2\", invalid = \"#ffffff\", ivory = \"#abb2bf\", stone = \"#7d8799\", malibu = \"#61afef\", sage = \"#98c379\", whiskey = \"#d19a66\", violet = \"#c678dd\", darkBackground = \"#21252b\", highlightBackground = \"#2c313a\", background = \"#282c34\", tooltipBackground = \"#353a42\", selection = \"#3E4451\", cursor = \"#528bff\";\n/**\nThe colors used in the theme, as CSS color strings.\n*/ const color = {\n    chalky,\n    coral,\n    cyan,\n    invalid,\n    ivory,\n    stone,\n    malibu,\n    sage,\n    whiskey,\n    violet,\n    darkBackground,\n    highlightBackground,\n    background,\n    tooltipBackground,\n    selection,\n    cursor\n};\n/**\nThe editor theme styles for One Dark.\n*/ const oneDarkTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme({\n    \"&\": {\n        color: ivory,\n        backgroundColor: background\n    },\n    \".cm-content\": {\n        caretColor: cursor\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeftColor: cursor\n    },\n    \"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection\": {\n        backgroundColor: selection\n    },\n    \".cm-panels\": {\n        backgroundColor: darkBackground,\n        color: ivory\n    },\n    \".cm-panels.cm-panels-top\": {\n        borderBottom: \"2px solid black\"\n    },\n    \".cm-panels.cm-panels-bottom\": {\n        borderTop: \"2px solid black\"\n    },\n    \".cm-searchMatch\": {\n        backgroundColor: \"#72a1ff59\",\n        outline: \"1px solid #457dff\"\n    },\n    \".cm-searchMatch.cm-searchMatch-selected\": {\n        backgroundColor: \"#6199ff2f\"\n    },\n    \".cm-activeLine\": {\n        backgroundColor: \"#6699ff0b\"\n    },\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#aafe661a\"\n    },\n    \"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bad0f847\"\n    },\n    \".cm-gutters\": {\n        backgroundColor: background,\n        color: stone,\n        border: \"none\"\n    },\n    \".cm-activeLineGutter\": {\n        backgroundColor: highlightBackground\n    },\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"transparent\",\n        border: \"none\",\n        color: \"#ddd\"\n    },\n    \".cm-tooltip\": {\n        border: \"none\",\n        backgroundColor: tooltipBackground\n    },\n    \".cm-tooltip .cm-tooltip-arrow:before\": {\n        borderTopColor: \"transparent\",\n        borderBottomColor: \"transparent\"\n    },\n    \".cm-tooltip .cm-tooltip-arrow:after\": {\n        borderTopColor: tooltipBackground,\n        borderBottomColor: tooltipBackground\n    },\n    \".cm-tooltip-autocomplete\": {\n        \"& > ul > li[aria-selected]\": {\n            backgroundColor: highlightBackground,\n            color: ivory\n        }\n    }\n}, {\n    dark: true\n});\n/**\nThe highlighting style for code in the One Dark theme.\n*/ const oneDarkHighlightStyle = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.keyword,\n        color: violet\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.deleted,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.character,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.propertyName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.macroName\n        ],\n        color: coral\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.labelName\n        ],\n        color: malibu\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.color,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.separator\n        ],\n        color: ivory\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.className,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.number,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.changed,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.annotation,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.modifier,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.self,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.namespace\n        ],\n        color: chalky\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operatorKeyword,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.escape,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string)\n        ],\n        color: cyan\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.meta,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.comment\n        ],\n        color: stone\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n        color: stone,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.heading,\n        fontWeight: \"bold\",\n        color: coral\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.bool,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.processingInstruction,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.inserted\n        ],\n        color: sage\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.invalid,\n        color: invalid\n    }\n]);\n/**\nExtension to enable the One Dark theme (both the editor theme and\nthe highlight style).\n*/ const oneDark = [\n    oneDarkTheme,\n    /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxHighlighting)(oneDarkHighlightStyle)\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQzRCO0FBQ2xDO0FBRXhDLHVGQUF1RjtBQUN2RixNQUFNSSxTQUFTLFdBQVdDLFFBQVEsV0FBV0MsT0FBTyxXQUFXQyxVQUFVLFdBQVdDLFFBQVEsV0FBV0MsUUFBUSxXQUMvR0MsU0FBUyxXQUFXQyxPQUFPLFdBQVdDLFVBQVUsV0FBV0MsU0FBUyxXQUFXQyxpQkFBaUIsV0FBV0Msc0JBQXNCLFdBQVdDLGFBQWEsV0FBV0Msb0JBQW9CLFdBQVdDLFlBQVksV0FBV0MsU0FBUztBQUNuTzs7QUFFQSxHQUNBLE1BQU1DLFFBQVE7SUFDVmhCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1FLGVBQWUsV0FBVyxHQUFFckIsd0RBQVVBLENBQUNzQixLQUFLLENBQUM7SUFDL0MsS0FBSztRQUNERixPQUFPWjtRQUNQZSxpQkFBaUJQO0lBQ3JCO0lBQ0EsZUFBZTtRQUNYUSxZQUFZTDtJQUNoQjtJQUNBLDhCQUE4QjtRQUFFTSxpQkFBaUJOO0lBQU87SUFDeEQsOEhBQThIO1FBQUVJLGlCQUFpQkw7SUFBVTtJQUMzSixjQUFjO1FBQUVLLGlCQUFpQlQ7UUFBZ0JNLE9BQU9aO0lBQU07SUFDOUQsNEJBQTRCO1FBQUVrQixjQUFjO0lBQWtCO0lBQzlELCtCQUErQjtRQUFFQyxXQUFXO0lBQWtCO0lBQzlELG1CQUFtQjtRQUNmSixpQkFBaUI7UUFDakJLLFNBQVM7SUFDYjtJQUNBLDJDQUEyQztRQUN2Q0wsaUJBQWlCO0lBQ3JCO0lBQ0Esa0JBQWtCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ2pELHNCQUFzQjtRQUFFQSxpQkFBaUI7SUFBWTtJQUNyRCx5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Q3ZCO1FBQUVqQyxLQUFLaEMsa0RBQUlBLENBQUNrRSxRQUFRO1FBQ2hCQyxXQUFXO0lBQVM7SUFDeEI7UUFBRW5DLEtBQUtoQyxrREFBSUEsQ0FBQ29FLGFBQWE7UUFDckJDLGdCQUFnQjtJQUFlO0lBQ25DO1FBQUVyQyxLQUFLaEMsa0RBQUlBLENBQUMyRCxJQUFJO1FBQ1oxQyxPQUFPWDtRQUNQK0QsZ0JBQWdCO0lBQVk7SUFDaEM7UUFBRXJDLEtBQUtoQyxrREFBSUEsQ0FBQ3NFLE9BQU87UUFDZkwsWUFBWTtRQUNaaEQsT0FBT2Y7SUFBTTtJQUNqQjtRQUFFOEIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN1RSxJQUFJO1lBQUV2RSxrREFBSUEsQ0FBQ3dFLElBQUk7WUFBRSxXQUFXLEdBQUV4RSxrREFBSUEsQ0FBQzRELE9BQU8sQ0FBQzVELGtEQUFJQSxDQUFDd0MsWUFBWTtTQUFFO1FBQ3ZFdkIsT0FBT1I7SUFBUTtJQUNuQjtRQUFFdUIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN5RSxxQkFBcUI7WUFBRXpFLGtEQUFJQSxDQUFDNkQsTUFBTTtZQUFFN0Qsa0RBQUlBLENBQUMwRSxRQUFRO1NBQUM7UUFDM0R6RCxPQUFPVDtJQUFLO0lBQ2hCO1FBQUV3QixLQUFLaEMsa0RBQUlBLENBQUNJLE9BQU87UUFDZmEsT0FBT2I7SUFBUTtDQUN0QjtBQUNEOzs7QUFHQSxHQUNBLE1BQU11RSxVQUFVO0lBQUN6RDtJQUFjLFdBQVcsR0FBRW5CLHdFQUFrQkEsQ0FBQytCO0NBQXVCO0FBRXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm5jb2RlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3RoZW1lLW9uZS1kYXJrL2Rpc3QvaW5kZXguanM/Yjc4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBIaWdobGlnaHRTdHlsZSwgc3ludGF4SGlnaGxpZ2h0aW5nIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBVc2luZyBodHRwczovL2dpdGh1Yi5jb20vb25lLWRhcmsvdnNjb2RlLW9uZS1kYXJrLXRoZW1lLyBhcyByZWZlcmVuY2UgZm9yIHRoZSBjb2xvcnNcbmNvbnN0IGNoYWxreSA9IFwiI2U1YzA3YlwiLCBjb3JhbCA9IFwiI2UwNmM3NVwiLCBjeWFuID0gXCIjNTZiNmMyXCIsIGludmFsaWQgPSBcIiNmZmZmZmZcIiwgaXZvcnkgPSBcIiNhYmIyYmZcIiwgc3RvbmUgPSBcIiM3ZDg3OTlcIiwgLy8gQnJpZ2h0ZW5lZCBjb21wYXJlZCB0byBvcmlnaW5hbCB0byBpbmNyZWFzZSBjb250cmFzdFxubWFsaWJ1ID0gXCIjNjFhZmVmXCIsIHNhZ2UgPSBcIiM5OGMzNzlcIiwgd2hpc2tleSA9IFwiI2QxOWE2NlwiLCB2aW9sZXQgPSBcIiNjNjc4ZGRcIiwgZGFya0JhY2tncm91bmQgPSBcIiMyMTI1MmJcIiwgaGlnaGxpZ2h0QmFja2dyb3VuZCA9IFwiIzJjMzEzYVwiLCBiYWNrZ3JvdW5kID0gXCIjMjgyYzM0XCIsIHRvb2x0aXBCYWNrZ3JvdW5kID0gXCIjMzUzYTQyXCIsIHNlbGVjdGlvbiA9IFwiIzNFNDQ1MVwiLCBjdXJzb3IgPSBcIiM1MjhiZmZcIjtcbi8qKlxuVGhlIGNvbG9ycyB1c2VkIGluIHRoZSB0aGVtZSwgYXMgQ1NTIGNvbG9yIHN0cmluZ3MuXG4qL1xuY29uc3QgY29sb3IgPSB7XG4gICAgY2hhbGt5LFxuICAgIGNvcmFsLFxuICAgIGN5YW4sXG4gICAgaW52YWxpZCxcbiAgICBpdm9yeSxcbiAgICBzdG9uZSxcbiAgICBtYWxpYnUsXG4gICAgc2FnZSxcbiAgICB3aGlza2V5LFxuICAgIHZpb2xldCxcbiAgICBkYXJrQmFja2dyb3VuZCxcbiAgICBoaWdobGlnaHRCYWNrZ3JvdW5kLFxuICAgIGJhY2tncm91bmQsXG4gICAgdG9vbHRpcEJhY2tncm91bmQsXG4gICAgc2VsZWN0aW9uLFxuICAgIGN1cnNvclxufTtcbi8qKlxuVGhlIGVkaXRvciB0aGVtZSBzdHlsZXMgZm9yIE9uZSBEYXJrLlxuKi9cbmNvbnN0IG9uZURhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHtcbiAgICBcIiZcIjoge1xuICAgICAgICBjb2xvcjogaXZvcnksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IGN1cnNvclxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7IGJvcmRlckxlZnRDb2xvcjogY3Vyc29yIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tY29udGVudCA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0aW9uIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHsgYmFja2dyb3VuZENvbG9yOiBkYXJrQmFja2dyb3VuZCwgY29sb3I6IGl2b3J5IH0sXG4gICAgXCIuY20tcGFuZWxzLmNtLXBhbmVscy10b3BcIjogeyBib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkIGJsYWNrXCIgfSxcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLWJvdHRvbVwiOiB7IGJvcmRlclRvcDogXCIycHggc29saWQgYmxhY2tcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM3MmExZmY1OVwiLFxuICAgICAgICBvdXRsaW5lOiBcIjFweCBzb2xpZCAjNDU3ZGZmXCJcbiAgICB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM2MTk5ZmYyZlwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM2Njk5ZmYwYlwiIH0sXG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2FhZmU2NjFhXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0LCAmLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjYmFkMGY4NDdcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZCxcbiAgICAgICAgY29sb3I6IHN0b25lLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoaWdobGlnaHRCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgY29sb3I6IFwiI2RkZFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvdzpiZWZvcmVcIjoge1xuICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmFmdGVyXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdG9vbHRpcEJhY2tncm91bmRcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWwgPiBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgICAgICBjb2xvcjogaXZvcnlcbiAgICAgICAgfVxuICAgIH1cbn0sIHsgZGFyazogdHJ1ZSB9KTtcbi8qKlxuVGhlIGhpZ2hsaWdodGluZyBzdHlsZSBmb3IgY29kZSBpbiB0aGUgT25lIERhcmsgdGhlbWUuXG4qL1xuY29uc3Qgb25lRGFya0hpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IHZpb2xldCB9LFxuICAgIHsgdGFnOiBbdGFncy5uYW1lLCB0YWdzLmRlbGV0ZWQsIHRhZ3MuY2hhcmFjdGVyLCB0YWdzLnByb3BlcnR5TmFtZSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogY29yYWwgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmZ1bmN0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogbWFsaWJ1IH0sXG4gICAgeyB0YWc6IFt0YWdzLmNvbG9yLCAvKkBfX1BVUkVfXyovdGFncy5jb25zdGFudCh0YWdzLm5hbWUpLCAvKkBfX1BVUkVfXyovdGFncy5zdGFuZGFyZCh0YWdzLm5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5uYW1lKSwgdGFncy5zZXBhcmF0b3JdLFxuICAgICAgICBjb2xvcjogaXZvcnkgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MuY2xhc3NOYW1lLCB0YWdzLm51bWJlciwgdGFncy5jaGFuZ2VkLCB0YWdzLmFubm90YXRpb24sIHRhZ3MubW9kaWZpZXIsIHRhZ3Muc2VsZiwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogY2hhbGt5IH0sXG4gICAgeyB0YWc6IFt0YWdzLm9wZXJhdG9yLCB0YWdzLm9wZXJhdG9yS2V5d29yZCwgdGFncy51cmwsIHRhZ3MuZXNjYXBlLCB0YWdzLnJlZ2V4cCwgdGFncy5saW5rLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBjeWFuIH0sXG4gICAgeyB0YWc6IFt0YWdzLm1ldGEsIHRhZ3MuY29tbWVudF0sXG4gICAgICAgIGNvbG9yOiBzdG9uZSB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICBjb2xvcjogc3RvbmUsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgIGNvbG9yOiBjb3JhbCB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogW3RhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLCB0YWdzLnN0cmluZywgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBzYWdlIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IGludmFsaWQgfSxcbl0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIHRoZSBPbmUgRGFyayB0aGVtZSAoYm90aCB0aGUgZWRpdG9yIHRoZW1lIGFuZFxudGhlIGhpZ2hsaWdodCBzdHlsZSkuXG4qL1xuY29uc3Qgb25lRGFyayA9IFtvbmVEYXJrVGhlbWUsIC8qQF9fUFVSRV9fKi9zeW50YXhIaWdobGlnaHRpbmcob25lRGFya0hpZ2hsaWdodFN0eWxlKV07XG5cbmV4cG9ydCB7IGNvbG9yLCBvbmVEYXJrLCBvbmVEYXJrSGlnaGxpZ2h0U3R5bGUsIG9uZURhcmtUaGVtZSB9O1xuIl0sIm5hbWVzIjpbIkVkaXRvclZpZXciLCJIaWdobGlnaHRTdHlsZSIsInN5bnRheEhpZ2hsaWdodGluZyIsInRhZ3MiLCJjaGFsa3kiLCJjb3JhbCIsImN5YW4iLCJpbnZhbGlkIiwiaXZvcnkiLCJzdG9uZSIsIm1hbGlidSIsInNhZ2UiLCJ3aGlza2V5IiwidmlvbGV0IiwiZGFya0JhY2tncm91bmQiLCJoaWdobGlnaHRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsInRvb2x0aXBCYWNrZ3JvdW5kIiwic2VsZWN0aW9uIiwiY3Vyc29yIiwiY29sb3IiLCJvbmVEYXJrVGhlbWUiLCJ0aGVtZSIsImJhY2tncm91bmRDb2xvciIsImNhcmV0Q29sb3IiLCJib3JkZXJMZWZ0Q29sb3IiLCJib3JkZXJCb3R0b20iLCJib3JkZXJUb3AiLCJvdXRsaW5lIiwiYm9yZGVyIiwiYm9yZGVyVG9wQ29sb3IiLCJib3JkZXJCb3R0b21Db2xvciIsImRhcmsiLCJvbmVEYXJrSGlnaGxpZ2h0U3R5bGUiLCJkZWZpbmUiLCJ0YWciLCJrZXl3b3JkIiwibmFtZSIsImRlbGV0ZWQiLCJjaGFyYWN0ZXIiLCJwcm9wZXJ0eU5hbWUiLCJtYWNyb05hbWUiLCJmdW5jdGlvbiIsInZhcmlhYmxlTmFtZSIsImxhYmVsTmFtZSIsImNvbnN0YW50Iiwic3RhbmRhcmQiLCJkZWZpbml0aW9uIiwic2VwYXJhdG9yIiwidHlwZU5hbWUiLCJjbGFzc05hbWUiLCJudW1iZXIiLCJjaGFuZ2VkIiwiYW5ub3RhdGlvbiIsIm1vZGlmaWVyIiwic2VsZiIsIm5hbWVzcGFjZSIsIm9wZXJhdG9yIiwib3BlcmF0b3JLZXl3b3JkIiwidXJsIiwiZXNjYXBlIiwicmVnZXhwIiwibGluayIsInNwZWNpYWwiLCJzdHJpbmciLCJtZXRhIiwiY29tbWVudCIsInN0cm9uZyIsImZvbnRXZWlnaHQiLCJlbXBoYXNpcyIsImZvbnRTdHlsZSIsInN0cmlrZXRocm91Z2giLCJ0ZXh0RGVjb3JhdGlvbiIsImhlYWRpbmciLCJhdG9tIiwiYm9vbCIsInByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsImluc2VydGVkIiwib25lRGFyayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),\n/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),\n/* harmony export */   BlockType: () => (/* binding */ BlockType),\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   Direction: () => (/* binding */ Direction),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),\n/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),\n/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),\n/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),\n/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),\n/* harmony export */   WidgetType: () => (/* binding */ WidgetType),\n/* harmony export */   __test: () => (/* binding */ __test),\n/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),\n/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),\n/* harmony export */   drawSelection: () => (/* binding */ drawSelection),\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor),\n/* harmony export */   getDialog: () => (/* binding */ getDialog),\n/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),\n/* harmony export */   getPanel: () => (/* binding */ getPanel),\n/* harmony export */   getTooltip: () => (/* binding */ getTooltip),\n/* harmony export */   gutter: () => (/* binding */ gutter),\n/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),\n/* harmony export */   gutterWidgetClass: () => (/* binding */ gutterWidgetClass),\n/* harmony export */   gutters: () => (/* binding */ gutters),\n/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),\n/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),\n/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),\n/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),\n/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),\n/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),\n/* harmony export */   keymap: () => (/* binding */ keymap),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),\n/* harmony export */   lineNumberWidgetMarker: () => (/* binding */ lineNumberWidgetMarker),\n/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),\n/* harmony export */   logException: () => (/* binding */ logException),\n/* harmony export */   panels: () => (/* binding */ panels),\n/* harmony export */   placeholder: () => (/* binding */ placeholder),\n/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),\n/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),\n/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),\n/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),\n/* harmony export */   showDialog: () => (/* binding */ showDialog),\n/* harmony export */   showPanel: () => (/* binding */ showPanel),\n/* harmony export */   showTooltip: () => (/* binding */ showTooltip),\n/* harmony export */   tooltips: () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"(ssr)/./node_modules/w3c-keyname/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\n\nlet nav = typeof navigator != \"undefined\" ? navigator : {\n    userAgent: \"\",\n    vendor: \"\",\n    platform: \"\"\n};\nlet doc = typeof document != \"undefined\" ? document : {\n    documentElement: {\n        style: {}\n    }\n};\nconst ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nconst ios = safari && /*@__PURE__*/ (/Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n    mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n    windows: /*@__PURE__*/ /Win/.test(nav.platform),\n    linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +/*@__PURE__*/ (/Firefox\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios,\n    android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n    webkit,\n    webkit_version: webkit ? +/*@__PURE__*/ (/\\bAppleWebKit\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    safari,\n    safari_version: safari ? +/*@__PURE__*/ (/\\bVersion\\/(\\d+(\\.\\d+)?)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nfunction getSelection(root) {\n    let target;\n    // Browsers differ on whether shadow roots have a getSelection\n    // method. If it exists, use that, otherwise, call it on the\n    // document.\n    if (root.nodeType == 11) {\n        target = root.getSelection ? root : root.ownerDocument;\n    } else {\n        target = root;\n    }\n    return target.getSelection();\n}\nfunction contains(dom, node) {\n    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return contains(dom, selection.anchorNode);\n    } catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();\n    else if (dom.nodeType == 1) return dom.getClientRects();\n    else return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\") return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1) return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n            off = dir < 0 ? maxOffset(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return {\n        left: x,\n        right: x,\n        top: rect.top,\n        bottom: rect.bottom\n    };\n}\nfunction windowRect(win) {\n    let vp = win.visualViewport;\n    if (vp) return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n    };\n    return {\n        left: 0,\n        right: win.innerWidth,\n        top: 0,\n        bottom: win.innerHeight\n    };\n}\nfunction getScale(elt, rect) {\n    let scaleX = rect.width / elt.offsetWidth;\n    let scaleY = rect.height / elt.offsetHeight;\n    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;\n    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;\n    return {\n        scaleX,\n        scaleY\n    };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    for(let cur = dom, stop = false; cur && !stop;){\n        if (cur.nodeType == 1) {\n            let bounding, top = cur == doc.body;\n            let scaleX = 1, scaleY = 1;\n            if (top) {\n                bounding = windowRect(win);\n            } else {\n                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.assignedSlot || cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                ({ scaleX, scaleY } = getScale(cur, rect));\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = {\n                    left: rect.left,\n                    right: rect.left + cur.clientWidth * scaleX,\n                    top: rect.top,\n                    bottom: rect.top + cur.clientHeight * scaleY\n                };\n            }\n            let moveX = 0, moveY = 0;\n            if (y == \"nearest\") {\n                if (rect.top < bounding.top) {\n                    moveY = rect.top - (bounding.top + yMargin);\n                    if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + yMargin;\n                } else if (rect.bottom > bounding.bottom) {\n                    moveY = rect.bottom - bounding.bottom + yMargin;\n                    if (side < 0 && rect.top - moveY < bounding.top) moveY = rect.top - (bounding.top + yMargin);\n                }\n            } else {\n                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;\n                let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n                moveY = targetTop - bounding.top;\n            }\n            if (x == \"nearest\") {\n                if (rect.left < bounding.left) {\n                    moveX = rect.left - (bounding.left + xMargin);\n                    if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + xMargin;\n                } else if (rect.right > bounding.right) {\n                    moveX = rect.right - bounding.right + xMargin;\n                    if (side < 0 && rect.left < bounding.left + moveX) moveX = rect.left - (bounding.left + xMargin);\n                }\n            } else {\n                let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n                moveX = targetLeft - bounding.left;\n            }\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                } else {\n                    let movedX = 0, movedY = 0;\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY / scaleY;\n                        movedY = (cur.scrollTop - start) * scaleY;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX / scaleX;\n                        movedX = (cur.scrollLeft - start) * scaleX;\n                    }\n                    rect = {\n                        left: rect.left - movedX,\n                        top: rect.top - movedY,\n                        right: rect.right - movedX,\n                        bottom: rect.bottom - movedY\n                    };\n                    if (movedX && Math.abs(movedX - moveX) < 1) x = \"nearest\";\n                    if (movedY && Math.abs(movedY - moveY) < 1) y = \"nearest\";\n                }\n            }\n            if (top) break;\n            if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right) rect = {\n                left: Math.max(rect.left, bounding.left),\n                right: Math.min(rect.right, bounding.right),\n                top: Math.max(rect.top, bounding.top),\n                bottom: Math.min(rect.bottom, bounding.bottom)\n            };\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n}\nfunction scrollableParents(dom) {\n    let doc = dom.ownerDocument, x, y;\n    for(let cur = dom.parentNode; cur;){\n        if (cur == doc.body || x && y) {\n            break;\n        } else if (cur.nodeType == 1) {\n            if (!y && cur.scrollHeight > cur.clientHeight) y = cur;\n            if (!x && cur.scrollWidth > cur.clientWidth) x = cur;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        x,\n        y\n    };\n}\nclass DOMSelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    setRange(range) {\n        let { anchorNode, focusNode } = range;\n        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)\n        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));\n    }\n    set(anchorNode, anchorOffset, focusNode, focusOffset) {\n        this.anchorNode = anchorNode;\n        this.anchorOffset = anchorOffset;\n        this.focusNode = focusNode;\n        this.focusOffset = focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Safari 26 breaks preventScroll support\nif (browser.safari && browser.safari_version >= 26) preventScrollSupported = false;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stack = [];\n    for(let cur = dom; cur; cur = cur.parentNode){\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument) break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for(let i = 0; i < stack.length;){\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top) elt.scrollTop = top;\n            if (elt.scrollLeft != left) elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n    let range = scratchRange || (scratchRange = document.createRange());\n    range.setEnd(node, to);\n    range.setStart(node, from);\n    return range;\n}\nfunction dispatchKey(elt, name, code, mods) {\n    let options = {\n        key: name,\n        code: name,\n        keyCode: code,\n        which: code,\n        cancelable: true\n    };\n    if (mods) ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);\n    let down = new KeyboardEvent(\"keydown\", options);\n    down.synthetic = true;\n    elt.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    up.synthetic = true;\n    elt.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n    while(node){\n        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n        node = node.assignedSlot || node.parentNode;\n    }\n    return null;\n}\nfunction clearAttributes(node) {\n    while(node.attributes.length)node.removeAttributeNode(node.attributes[0]);\n}\nfunction atElementStart(doc, selection) {\n    let node = selection.focusNode, offset = selection.focusOffset;\n    if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;\n    // Safari can report bogus offsets (#1152)\n    offset = Math.min(offset, maxOffset(node));\n    for(;;){\n        if (offset) {\n            if (node.nodeType != 1) return false;\n            let prev = node.childNodes[offset - 1];\n            if (prev.contentEditable == \"false\") offset--;\n            else {\n                node = prev;\n                offset = maxOffset(node);\n            }\n        } else if (node == doc) {\n            return true;\n        } else {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n    }\n}\nfunction isScrolledToBottom(elt) {\n    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);\n}\nfunction textNodeBefore(startNode, startOffset) {\n    for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3 && offset > 0) {\n            return {\n                node: node,\n                offset: offset\n            };\n        } else if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        } else if (node.parentNode && !isBlockElement(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter(startNode, startOffset) {\n    for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3 && offset < node.nodeValue.length) {\n            return {\n                node: node,\n                offset: offset\n            };\n        } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        } else if (node.parentNode && !isBlockElement(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nclass DOMPos {\n    constructor(node, offset, precise = true){\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom), precise);\n    }\n    static after(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n    }\n}\nconst noChildren = [];\nclass ContentView {\n    constructor(){\n        this.parent = null;\n        this.dom = null;\n        this.flags = 2 /* ViewFlag.NodeDirty */ ;\n    }\n    get overrideDOMText() {\n        return null;\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children){\n            if (child == view) return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    sync(view, track) {\n        if (this.flags & 2 /* ViewFlag.NodeDirty */ ) {\n            let parent = this.dom;\n            let prev = null, next;\n            for (let child of this.children){\n                if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\n                        let contentView = ContentView.get(next);\n                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);\n                    }\n                    child.sync(view, track);\n                    child.flags &= ~7 /* ViewFlag.Dirty */ ;\n                }\n                next = prev ? prev.nextSibling : parent.firstChild;\n                if (track && !track.written && track.node == parent && next != child.dom) track.written = true;\n                if (child.dom.parentNode == parent) {\n                    while(next && next != child.dom)next = rm$1(next);\n                } else {\n                    parent.insertBefore(child.dom, next);\n                }\n                prev = child.dom;\n            }\n            next = prev ? prev.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent) track.written = true;\n            while(next)next = rm$1(next);\n        } else if (this.flags & 1 /* ViewFlag.ChildDirty */ ) {\n            for (let child of this.children)if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                child.sync(view, track);\n                child.flags &= ~7 /* ViewFlag.Dirty */ ;\n            }\n        }\n    }\n    reuseDOM(_dom) {}\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        } else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for(;;){\n                let parent = node.parentNode;\n                if (parent == this.dom) break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild) bias = -1;\n                    else bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0) after = node;\n            else after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild) return 0;\n        while(after && !ContentView.get(after))after = after.nextSibling;\n        if (!after) return this.length;\n        for(let i = 0, pos = 0;; i++){\n            let child = this.children[i];\n            if (child.dom == after) return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for(let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (pos > to && child.dom.parentNode == this.dom) {\n                toI = i;\n                toEnd = prevEnd;\n                break;\n            }\n            prevEnd = end;\n            pos = end + child.breakAfter;\n        }\n        return {\n            from: fromStart,\n            to: toEnd < 0 ? offset + this.length : toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null\n        };\n    }\n    markDirty(andParent = false) {\n        this.flags |= 2 /* ViewFlag.NodeDirty */ ;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for(let parent = this.parent; parent; parent = parent.parent){\n            if (childList) parent.flags |= 2 /* ViewFlag.NodeDirty */ ;\n            if (parent.flags & 1 /* ViewFlag.ChildDirty */ ) return;\n            parent.flags |= 1 /* ViewFlag.ChildDirty */ ;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.flags & 7 /* ViewFlag.Dirty */ ) this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        if (this.dom == dom) return;\n        if (this.dom) this.dom.cmView = null;\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for(let v = this;;){\n            let parent = v.parent;\n            if (!parent) return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = noChildren) {\n        this.markDirty();\n        for(let i = from; i < to; i++){\n            let child = this.children[i];\n            if (child.parent == this && children.indexOf(child) < 0) child.destroy();\n        }\n        if (children.length < 250) this.children.splice(from, to - from, ...children);\n        else this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));\n        for(let i = 0; i < children.length; i++)children[i].setParent(this);\n    }\n    ignoreMutation(_rec) {\n        return false;\n    }\n    ignoreEvent(_event) {\n        return false;\n    }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) {\n        return node.cmView;\n    }\n    get isEditable() {\n        return true;\n    }\n    get isWidget() {\n        return false;\n    }\n    get isHidden() {\n        return false;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        return false;\n    }\n    become(other) {\n        return false;\n    }\n    canReuseDOM(other) {\n        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    // When this is a zero-length view with a side, this should return a\n    // number <= 0 to indicate it is before its position, or a\n    // number > 0 when after its position.\n    getSide() {\n        return 0;\n    }\n    destroy() {\n        for (let child of this.children)if (child.parent == this) child.destroy();\n        this.parent = null;\n    }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nclass ChildCursor {\n    constructor(children, pos, i){\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for(;;){\n            if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n    let { children } = parent;\n    let before = children.length ? children[fromI] : null;\n    let last = insert.length ? insert[insert.length - 1] : null;\n    let breakAtEnd = last ? last.breakAfter : breakAtStart;\n    // Change within a single child\n    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n    if (toI < children.length) {\n        let after = children[toI];\n        // Make sure the end of the child after the update is preserved in `after`\n        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {\n            // If we're splitting a child, separate part of it to avoid that\n            // being mangled when updating the child before the update.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                insert[insert.length - 1] = after;\n            } else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);\n                insert.push(after);\n            }\n        } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last) last.breakAfter = 1;\n            else breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n    }\n    if (before) {\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n                before.breakAfter = insert.shift().breakAfter;\n            } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n    }\n    // Try to merge widgets on the boundaries of the replacement\n    while(fromI < toI && insert.length){\n        if (children[toI - 1].become(insert[insert.length - 1])) {\n            toI--;\n            insert.pop();\n            openEnd = insert.length ? 0 : openStart;\n        } else if (children[fromI].become(insert[0])) {\n            fromI++;\n            insert.shift();\n            openStart = insert.length ? 0 : openEnd;\n        } else {\n            break;\n        }\n    }\n    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;\n    if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);\n}\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of insert)dLen += view.length;\n    parent.length += dLen;\n    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\nconst MaxJoinLen = 256;\nclass TextView extends ContentView {\n    constructor(text){\n        super();\n        this.text = text;\n    }\n    get length() {\n        return this.text.length;\n    }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(view, track) {\n        if (!this.dom) this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom) track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType == 3) this.createDOM(dom);\n    }\n    merge(from, to, source) {\n        if (this.flags & 8 /* ViewFlag.Composition */  || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8 /* ViewFlag.Composition */ )) return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = new TextView(this.text.slice(from));\n        this.text = this.text.slice(0, from);\n        this.markDirty();\n        result.flags |= this.flags & 8 /* ViewFlag.Composition */ ;\n        return result;\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) {\n        return new DOMPos(this.dom, pos);\n    }\n    domBoundsAround(_from, _to, offset) {\n        return {\n            from: offset,\n            to: offset + this.length,\n            startDOM: this.dom,\n            endDOM: this.dom.nextSibling\n        };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side);\n    }\n}\nclass MarkView extends ContentView {\n    constructor(mark, children = [], length = 0){\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)ch.setParent(this);\n    }\n    setAttrs(dom) {\n        clearAttributes(dom);\n        if (this.mark.class) dom.className = this.mark.class;\n        if (this.mark.attrs) for(let name in this.mark.attrs)dom.setAttribute(name, this.mark.attrs[name]);\n        return dom;\n    }\n    canReuseDOM(other) {\n        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    reuseDOM(node) {\n        if (node.nodeName == this.mark.tagName.toUpperCase()) {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));\n        else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) this.setAttrs(this.dom);\n        super.sync(view, track);\n    }\n    merge(from, to, source, _hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = [], off = 0, detachFrom = -1, i = 0;\n        for (let elt of this.children){\n            let end = off + elt.length;\n            if (end > from) result.push(off < from ? elt.split(from - off) : elt);\n            if (detachFrom < 0 && off >= from) detachFrom = i;\n            off = end;\n            i++;\n        }\n        let length = this.length - from;\n        this.length = from;\n        if (detachFrom > -1) {\n            this.children.length = detachFrom;\n            this.markDirty();\n        }\n        return new MarkView(this.mark, result, length);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side) {\n    let length = text.nodeValue.length;\n    if (pos > length) pos = length;\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) {\n            if (pos) {\n                from--;\n                flatten = 1;\n            } else if (to < length) {\n                to++;\n                flatten = -1;\n            }\n        }\n    } else {\n        if (side < 0) from--;\n        else if (to < length) to++;\n    }\n    let rects = textRange(text, from, to).getClientRects();\n    if (!rects.length) return null;\n    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, (r)=>r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends ContentView {\n    static create(widget, length, side) {\n        return new WidgetView(widget, length, side);\n    }\n    constructor(widget, length, side){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.prevWidget = null;\n    }\n    split(from) {\n        let result = WidgetView.create(this.widget, this.length - from, this.side);\n        this.length -= from;\n        return result;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            if (!this.widget.editable) this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {\n            if (!this.widget.compare(other.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get overrideDOMText() {\n        if (this.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n        let top = this;\n        while(top.parent)top = top.parent;\n        let { view } = top, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    }\n    domAtPos(pos) {\n        return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos, side) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom) return custom;\n        let rects = this.dom.getClientRects(), rect = null;\n        if (!rects.length) return null;\n        let fromBack = this.side ? this.side < 0 : pos > 0;\n        for(let i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1){\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n        }\n        return flattenRect(rect, !fromBack);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    get isHidden() {\n        return this.widget.isHidden;\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferView extends ContentView {\n    constructor(side){\n        super();\n        this.side = side;\n    }\n    get length() {\n        return 0;\n    }\n    merge() {\n        return false;\n    }\n    become(other) {\n        return other instanceof WidgetBufferView && other.side == this.side;\n    }\n    split() {\n        return new WidgetBufferView(this.side);\n    }\n    sync() {\n        if (!this.dom) {\n            let dom = document.createElement(\"img\");\n            dom.className = \"cm-widgetBuffer\";\n            dom.setAttribute(\"aria-hidden\", \"true\");\n            this.setDOM(dom);\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    domAtPos(pos) {\n        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);\n    }\n    localPosFromDOM() {\n        return 0;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos) {\n        return this.dom.getBoundingClientRect();\n    }\n    get overrideDOMText() {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\nfunction inlineDOMAtPos(parent, pos) {\n    let dom = parent.dom, { children } = parent, i = 0;\n    for(let off = 0; i < children.length; i++){\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0) continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n        if (pos <= off) break;\n        off = end;\n    }\n    for(let j = i; j > 0; j--){\n        let prev = children[j - 1];\n        if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);\n    }\n    for(let j = i; j < children.length; j++){\n        let next = children[j];\n        if (next.dom.parentNode == dom) return next.domAtPos(0);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    } else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    let before = null, beforePos = -1, after = null, afterPos = -1;\n    function scan(view, pos) {\n        for(let i = 0, off = 0; i < view.children.length && off <= pos; i++){\n            let child = view.children[i], end = off + child.length;\n            if (end >= pos) {\n                if (child.children.length) {\n                    scan(child, pos - off);\n                } else if ((!after || after.isHidden && (side > 0 || onSameLine(after, child))) && (end > pos || off == end && child.getSide() > 0)) {\n                    after = child;\n                    afterPos = pos - off;\n                } else if (off < pos || off == end && child.getSide() < 0 && !child.isHidden) {\n                    before = child;\n                    beforePos = pos - off;\n                }\n            }\n            off = end;\n        }\n    }\n    scan(view, pos);\n    let target = (side < 0 ? before : after) || before || after;\n    if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\n    return fallbackRect(view);\n}\nfunction fallbackRect(view) {\n    let last = view.dom.lastChild;\n    if (!last) return view.dom.getBoundingClientRect();\n    let rects = clientRectsFor(last);\n    return rects[rects.length - 1] || null;\n}\nfunction onSameLine(a, b) {\n    let posA = a.coordsAt(0, 1), posB = b.coordsAt(0, 1);\n    return posA && posB && posB.top < posA.bottom;\n}\nfunction combineAttrs(source, target) {\n    for(let name in source){\n        if (name == \"class\" && target.class) target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style) target.style += \";\" + source.style;\n        else target[name] = source[name];\n    }\n    return target;\n}\nconst noAttrs = /*@__PURE__*/ Object.create(null);\nfunction attrsEq(a, b, ignore) {\n    if (a == b) return true;\n    if (!a) a = noAttrs;\n    if (!b) b = noAttrs;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;\n    for (let key of keysA){\n        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    let changed = false;\n    if (prev) {\n        for(let name in prev)if (!(attrs && name in attrs)) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = \"\";\n            else dom.removeAttribute(name);\n        }\n    }\n    if (attrs) {\n        for(let name in attrs)if (!(prev && prev[name] == attrs[name])) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = attrs[name];\n            else dom.setAttribute(name, attrs[name]);\n        }\n    }\n    return changed;\n}\nfunction getAttrs(dom) {\n    let attrs = Object.create(null);\n    for(let i = 0; i < dom.attributes.length; i++){\n        let attr = dom.attributes[i];\n        attrs[attr.name] = attr.value;\n    }\n    return attrs;\n}\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/ class WidgetType {\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */ eq(widget) {\n        return false;\n    }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */ updateDOM(dom, view) {\n        return false;\n    }\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */ get estimatedHeight() {\n        return -1;\n    }\n    /**\n    For inline widgets that are displayed inline (as opposed to\n    `inline-block`) and introduce line breaks (through `<br>` tags\n    or textual newlines), this must indicate the amount of line\n    breaks they introduce. Defaults to 0.\n    */ get lineBreaks() {\n        return 0;\n    }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */ ignoreEvent(event) {\n        return true;\n    }\n    /**\n    Override the way screen coordinates for positions at/in the\n    widget are found. `pos` will be the offset into the widget, and\n    `side` the side of the position that is being queriedâ€”less than\n    zero for before, greater than zero for after, and zero for\n    directly at that position.\n    */ coordsAt(dom, pos, side) {\n        return null;\n    }\n    /**\n    @internal\n    */ get isHidden() {\n        return false;\n    }\n    /**\n    @internal\n    */ get editable() {\n        return false;\n    }\n    /**\n    This is called when the an instance of the widget is removed\n    from the editor view.\n    */ destroy(dom) {}\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/ var BlockType = /*@__PURE__*/ function(BlockType) {\n    /**\n    A line of text.\n    */ BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /**\n    A block widget associated with the position after it.\n    */ BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /**\n    A block widget associated with the position before it.\n    */ BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /**\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n    */ BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n    return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/ class Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeValue {\n    constructor(/**\n    @internal\n    */ startSide, /**\n    @internal\n    */ endSide, /**\n    @internal\n    */ widget, /**\n    The config object used to create this decoration. You can\n    include additional properties in there to store metadata about\n    your decoration.\n    */ spec){\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /**\n    @internal\n    */ get heightRelevant() {\n        return false;\n    }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n    the higher-precedence decorations creating the inner DOM nodes.\n    Such elements are split on line boundaries and on the boundaries\n    of lower-precedence decorations.\n    */ static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which displays a DOM element at the\n    given position.\n    */ static widget(spec) {\n        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;\n        side += block && !spec.inlineOrder ? side > 0 ? 300000000 /* Side.BlockAfter */  : -400000000 /* Side.BlockBefore */  : side > 0 ? 100000000 /* Side.InlineAfter */  : -100000000 /* Side.InlineBefore */ ;\n        return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */ static replace(spec) {\n        let block = !!spec.block, startSide, endSide;\n        if (spec.isBlockGap) {\n            startSide = -500000000 /* Side.GapStart */ ;\n            endSide = 400000000 /* Side.GapEnd */ ;\n        } else {\n            let { start, end } = getInclusive(spec, block);\n            startSide = (start ? block ? -300000000 /* Side.BlockIncStart */  : -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ ) - 1;\n            endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */  : 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ ) + 1;\n        }\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */ static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */ static set(of, sort = false) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.of(of, sort);\n    }\n    /**\n    @internal\n    */ hasHeight() {\n        return this.widget ? this.widget.estimatedHeight > -1 : false;\n    }\n}\n/**\nThe empty set of decorations.\n*/ Decoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec){\n        let { start, end } = getInclusive(spec);\n        super(start ? -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ , end ? 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ , null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        var _a, _b;\n        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, \"class\");\n    }\n    range(from, to = from) {\n        if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec){\n        super(-200000000 /* Side.Line */ , -200000000 /* Side.Line */ , null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace){\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() {\n        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n    }\n    eq(other) {\n        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null) start = spec.inclusive;\n    if (end == null) end = spec.inclusive;\n    return {\n        start: start !== null && start !== void 0 ? start : block,\n        end: end !== null && end !== void 0 ? end : block\n    };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);\n    else ranges.push(from, to);\n}\nclass LineView extends ContentView {\n    constructor(){\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView)) return false;\n            if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (hasStart) this.setDeco(source ? source.attrs : null);\n        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0) return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].split(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n            i++;\n        }\n        for(let j = i; j < this.children.length; j++)end.append(this.children[j], 0);\n        while(i > 0 && this.children[i - 1].length == 0)this.children[--i].destroy();\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom) return;\n        this.markDirty();\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes, cls = deco.spec.class;\n        if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});\n        if (cls) this.attrs = combineAttrs({\n            class: cls\n        }, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    reuseDOM(node) {\n        if (node.nodeName == \"DIV\") {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        var _a;\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        } else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) {\n            clearAttributes(this.dom);\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(\"cm-line\");\n            this.prevAttrs = undefined;\n        }\n        super.sync(view, track);\n        let last = this.dom.lastChild;\n        while(last && ContentView.get(last) instanceof MarkView)last = last.lastChild;\n        if (!last || !this.length || last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some((ch)=>ch instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20) return null;\n        let totalWidth = 0, textHeight;\n        for (let child of this.children){\n            if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1) return null;\n            totalWidth += rects[0].width;\n            textHeight = rects[0].height;\n        }\n        return !totalWidth ? null : {\n            lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length,\n            textHeight\n        };\n    }\n    coordsAt(pos, side) {\n        let rect = coordsInChildren(this, pos, side);\n        // Correct rectangle height for empty lines when the returned\n        // height is larger than the text height.\n        if (!this.children.length && rect && this.parent) {\n            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;\n            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {\n                let dist = (height - heightOracle.textHeight) / 2;\n                return {\n                    top: rect.top + dist,\n                    bottom: rect.bottom - dist,\n                    left: rect.left,\n                    right: rect.left\n                };\n            }\n        }\n        return rect;\n    }\n    become(other) {\n        return other instanceof LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;\n    }\n    covers() {\n        return true;\n    }\n    static find(docView, pos) {\n        for(let i = 0, off = 0; i < docView.children.length; i++){\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView) return block;\n                if (end > pos) break;\n            }\n            off = end + block.breakAfter;\n        }\n        return null;\n    }\n}\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, deco){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.deco = deco;\n        this.breakAfter = 0;\n        this.prevWidget = null;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        let end = new BlockWidgetView(this.widget, len, this.deco);\n        end.breakAfter = this.breakAfter;\n        return end;\n    }\n    get children() {\n        return noChildren;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            if (!this.widget.editable) this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    become(other) {\n        if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.compare(this.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            this.deco = other.deco;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    coordsAt(pos, side) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom) return custom;\n        if (this.widget instanceof BlockGapWidget) return null;\n        return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n    covers(side) {\n        let { startSide, endSide } = this.deco;\n        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;\n    }\n}\nclass BlockGapWidget extends WidgetType {\n    constructor(height){\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-gap\";\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) {\n        return other.height == this.height;\n    }\n    updateDOM(elt) {\n        elt.style.height = this.height + \"px\";\n        return true;\n    }\n    get editable() {\n        return true;\n    }\n    get estimatedHeight() {\n        return this.height;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nclass ContentBuilder {\n    constructor(doc, pos, end, disallowBlockEffectsFor){\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.pendingBuffer = 0 /* Buf.No */ ;\n        this.bufferMarks = [];\n        // Set to false directly after a widget that covers the position after it\n        this.atCursorPos = true;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);\n    }\n    getLine() {\n        if (!this.curLine) {\n            this.content.push(this.curLine = new LineView);\n            this.atCursorPos = true;\n        }\n        return this.curLine;\n    }\n    flushBuffer(active = this.bufferMarks) {\n        if (this.pendingBuffer) {\n            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n            this.pendingBuffer = 0 /* Buf.No */ ;\n        }\n    }\n    addBlockWidget(view) {\n        this.flushBuffer();\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish(openEnd) {\n        if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();\n        else this.pendingBuffer = 0 /* Buf.No */ ;\n        if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();\n    }\n    buildText(length, active, openStart) {\n        while(length > 0){\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered()) this.getLine();\n                    if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;\n                    else this.breakAtStart = 1;\n                    this.flushBuffer();\n                    this.curLine = null;\n                    this.atCursorPos = true;\n                    length--;\n                    continue;\n                } else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let remaining = Math.min(this.text.length - this.textOff, length);\n            let take = Math.min(remaining, 512 /* T.Chunk */ );\n            this.flushBuffer(active.slice(active.length - openStart));\n            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            this.atCursorPos = true;\n            this.textOff += take;\n            length -= take;\n            openStart = remaining <= take ? 0 : active.length;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart, index) {\n        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\n            if (deco.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n            if (to > this.doc.lineAt(this.pos).to) throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n        }\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                if (deco.startSide > 0 && !this.posCovered()) this.getLine();\n                this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));\n            } else {\n                let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);\n                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\n                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\n                let line = this.getLine();\n                if (this.pendingBuffer == 2 /* Buf.IfCursor */  && !cursorBefore && !view.isEditable) this.pendingBuffer = 0 /* Buf.No */ ;\n                this.flushBuffer(active);\n                if (cursorBefore) {\n                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n                    openStart = active.length + Math.max(0, openStart - active.length);\n                }\n                line.append(wrapMarks(view, active), openStart);\n                this.atCursorPos = cursorAfter;\n                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */  : from < to || openStart > active.length ? 1 /* Buf.Yes */  : 2 /* Buf.IfCursor */ ;\n                if (this.pendingBuffer) this.bufferMarks = active.slice();\n            }\n        } else if (this.doc.lineAt(this.pos).from == this.pos) {\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            } else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    static build(text, from, to, decorations, dynamicDecorationMap) {\n        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\n        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0) builder.openStart = builder.openEnd;\n        builder.finish(builder.openEnd);\n        return builder;\n    }\n}\nfunction wrapMarks(view, active) {\n    for (let mark of active)view = new MarkView(mark, [\n        view\n    ], view.length);\n    return view;\n}\nclass NullWidget extends WidgetType {\n    constructor(tag){\n        super();\n        this.tag = tag;\n    }\n    eq(other) {\n        return other.tag == this.tag;\n    }\n    toDOM() {\n        return document.createElement(this.tag);\n    }\n    updateDOM(elt) {\n        return elt.nodeName.toLowerCase() == this.tag;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nNullWidget.inline = /*@__PURE__*/ new NullWidget(\"span\");\nNullWidget.block = /*@__PURE__*/ new NullWidget(\"div\");\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/ var Direction = /*@__PURE__*/ function(Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /**\n    Left-to-right.\n    */ Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /**\n    Right-to-left.\n    */ Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n    return Direction;\n}(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for(let i = 0; i < str.length; i++)result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/ dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/ dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/ Object.create(null), BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\n    \"()\",\n    \"[]\",\n    \"{}\"\n]){\n    let l = /*@__PURE__*/ p.charCodeAt(0), r = /*@__PURE__*/ p.charCodeAt(1);\n    Brackets[l] = r;\n    Brackets[r] = -l;\n}\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */  : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */  : 0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */  : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */  : 1 /* T.L */ ;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/ class BidiSpan {\n    /**\n    The direction of this span.\n    */ get dir() {\n        return this.level % 2 ? RTL : LTR;\n    }\n    /**\n    @internal\n    */ constructor(/**\n    The start of the span (relative to the start of the line).\n    */ from, /**\n    The end of the span.\n    */ to, /**\n    The [\"bidi\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    of the span (in this context, 0 means\n    left-to-right, 1 means right-to-left, 2 means left-to-right\n    number inside right-to-left text).\n    */ level){\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /**\n    @internal\n    */ side(end, dir) {\n        return this.dir == dir == end ? this.to : this.from;\n    }\n    /**\n    @internal\n    */ forward(forward, dir) {\n        return forward == (this.dir == dir);\n    }\n    /**\n    @internal\n    */ static find(order, index, level, assoc) {\n        let maybe = -1;\n        for(let i = 0; i < order.length; i++){\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level) return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n            }\n        }\n        if (maybe < 0) throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\nfunction isolatesEq(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        let iA = a[i], iB = b[i];\n        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;\n    }\n    return true;\n}\n// Reused array of character types\nconst types = [];\n// Fill in the character types (in `types`) from `from` to `to` and\n// apply W normalization rules.\nfunction computeCharTypes(line, rFrom, rTo, isolates, outerType) {\n    for(let iI = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        let prevType = iI ? 256 /* T.NI */  : outerType;\n        // W1. Examine each non-spacing mark (NSM) in the level run, and\n        // change the type of the NSM to the type of the previous\n        // character. If the NSM is at the start of the level run, it will\n        // get the type of sor.\n        // W2. Search backwards from each instance of a European number\n        // until the first strong type (R, L, AL, or sor) is found. If an\n        // AL is found, change the type of the European number to Arabic\n        // number.\n        // W3. Change all ALs to R.\n        // (Left after this: L, R, EN, AN, ET, CS, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = charType(line.charCodeAt(i));\n            if (type == 512 /* T.NSM */ ) type = prev;\n            else if (type == 8 /* T.EN */  && prevStrong == 4 /* T.AL */ ) type = 16 /* T.AN */ ;\n            types[i] = type == 4 /* T.AL */  ? 2 /* T.R */  : type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n            prev = type;\n        }\n        // W5. A sequence of European terminators adjacent to European\n        // numbers changes to all European numbers.\n        // W6. Otherwise, separators and terminators change to Other\n        // Neutral.\n        // W7. Search backwards from each instance of a European number\n        // until the first strong type (R, L, or sor) is found. If an L is\n        // found, then change the type of the European number to L.\n        // (Left after this: L, R, EN+AN, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = types[i];\n            if (type == 128 /* T.CS */ ) {\n                if (i < to - 1 && prev == types[i + 1] && prev & 24 /* T.Num */ ) type = types[i] = prev;\n                else types[i] = 256 /* T.NI */ ;\n            } else if (type == 64 /* T.ET */ ) {\n                let end = i + 1;\n                while(end < to && types[end] == 64 /* T.ET */ )end++;\n                let replace = i && prev == 8 /* T.EN */  || end < rTo && types[end] == 8 /* T.EN */  ? prevStrong == 1 /* T.L */  ? 1 /* T.L */  : 8 /* T.EN */  : 256 /* T.NI */ ;\n                for(let j = i; j < end; j++)types[j] = replace;\n                i = end - 1;\n            } else if (type == 8 /* T.EN */  && prevStrong == 1 /* T.L */ ) {\n                types[i] = 1 /* T.L */ ;\n            }\n            prev = type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n        }\n    }\n}\n// Process brackets throughout a run sequence.\nfunction processBracketPairs(line, rFrom, rTo, isolates, outerType) {\n    let oppositeType = outerType == 1 /* T.L */  ? 2 /* T.R */  : 1 /* T.L */ ;\n    for(let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N0. Process bracket pairs in an isolating run sequence\n        // sequentially in the logical order of the text positions of the\n        // opening paired brackets using the logic given below. Within this\n        // scope, bidirectional types EN and AN are treated as R.\n        for(let i = from, ch, br, type; i < to; i++){\n            // Keeps [startIndex, type, strongSeen] triples for each open\n            // bracket on BracketStack.\n            if (br = Brackets[ch = line.charCodeAt(i)]) {\n                if (br < 0) {\n                    for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                        if (BracketStack[sJ + 1] == -br) {\n                            let flags = BracketStack[sJ + 2];\n                            let type = flags & 2 /* Bracketed.EmbedInside */  ? outerType : !(flags & 4 /* Bracketed.OppositeInside */ ) ? 0 : flags & 1 /* Bracketed.OppositeBefore */  ? oppositeType : outerType;\n                            if (type) types[i] = types[BracketStack[sJ]] = type;\n                            sI = sJ;\n                            break;\n                        }\n                    }\n                } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */ ) {\n                    break;\n                } else {\n                    BracketStack[sI++] = i;\n                    BracketStack[sI++] = ch;\n                    BracketStack[sI++] = context;\n                }\n            } else if ((type = types[i]) == 2 /* T.R */  || type == 1 /* T.L */ ) {\n                let embed = type == outerType;\n                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */ ;\n                for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                    let cur = BracketStack[sJ + 2];\n                    if (cur & 2 /* Bracketed.EmbedInside */ ) break;\n                    if (embed) {\n                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */ ;\n                    } else {\n                        if (cur & 4 /* Bracketed.OppositeInside */ ) break;\n                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */ ;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction processNeutrals(rFrom, rTo, isolates, outerType) {\n    for(let iI = 0, prev = outerType; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N1. A sequence of neutrals takes the direction of the\n        // surrounding strong text if the text on both sides has the same\n        // direction. European and Arabic numbers act as if they were R in\n        // terms of their influence on neutrals. Start-of-level-run (sor)\n        // and end-of-level-run (eor) are used at level run boundaries.\n        // N2. Any remaining neutrals take the embedding direction.\n        // (Left after this: L, R, EN+AN)\n        for(let i = from; i < to;){\n            let type = types[i];\n            if (type == 256 /* T.NI */ ) {\n                let end = i + 1;\n                for(;;){\n                    if (end == to) {\n                        if (iI == isolates.length) break;\n                        end = isolates[iI++].to;\n                        to = iI < isolates.length ? isolates[iI].from : rTo;\n                    } else if (types[end] == 256 /* T.NI */ ) {\n                        end++;\n                    } else {\n                        break;\n                    }\n                }\n                let beforeL = prev == 1 /* T.L */ ;\n                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */ ;\n                let replace = beforeL == afterL ? beforeL ? 1 /* T.L */  : 2 /* T.R */  : outerType;\n                for(let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;){\n                    if (j == fromJ) {\n                        j = isolates[--jI].from;\n                        fromJ = jI ? isolates[jI - 1].to : rFrom;\n                    }\n                    types[--j] = replace;\n                }\n                i = end;\n            } else {\n                prev = type;\n                i++;\n            }\n        }\n    }\n}\n// Find the contiguous ranges of character types in a given range, and\n// emit spans for them. Flip the order of the spans as appropriate\n// based on the level, and call through to compute the spans for\n// isolates at the proper point.\nfunction emitSpans(line, from, to, level, baseLevel, isolates, order) {\n    let ourType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    if (level % 2 == baseLevel % 2) {\n        for(let iCh = from, iI = 0; iCh < to;){\n            // Scan a section of characters in direction ourType, unless\n            // there's another type of char right after iCh, in which case\n            // we scan a section of other characters (which, if ourType ==\n            // T.L, may contain both T.R and T.AN chars).\n            let sameDir = true, isNum = false;\n            if (iI == isolates.length || iCh < isolates[iI].from) {\n                let next = types[iCh];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            // Holds an array of isolates to pass to a recursive call if we\n            // must recurse (to distinguish T.AN inside an RTL section in\n            // LTR text), null if we can emit directly\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI < isolates.length && iScan == isolates[iI].from) {\n                    if (isNum) break run;\n                    let iso = isolates[iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.to, jI = iI + 1;;){\n                        if (upto == to) break run;\n                        if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;\n                        else if (types[upto] == ourType) break run;\n                        else break;\n                    }\n                    iI++;\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.to;\n                    }\n                    iScan = iso.to;\n                } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {\n                    break;\n                } else {\n                    iScan++;\n                }\n            }\n            if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);\n            else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));\n            iCh = iScan;\n        }\n    } else {\n        // Iterate in reverse to flip the span order. Same code again, but\n        // going from the back of the section to the front\n        for(let iCh = to, iI = isolates.length; iCh > from;){\n            let sameDir = true, isNum = false;\n            if (!iI || iCh > isolates[iI - 1].to) {\n                let next = types[iCh - 1];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI && iScan == isolates[iI - 1].to) {\n                    if (isNum) break run;\n                    let iso = isolates[--iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.from, jI = iI;;){\n                        if (upto == from) break run;\n                        if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;\n                        else if (types[upto - 1] == ourType) break run;\n                        else break;\n                    }\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.from;\n                    }\n                    iScan = iso.from;\n                } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {\n                    break;\n                } else {\n                    iScan--;\n                }\n            }\n            if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);\n            else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));\n            iCh = iScan;\n        }\n    }\n}\nfunction computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {\n    let outerType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    computeCharTypes(line, from, to, isolates, outerType);\n    processBracketPairs(line, from, to, isolates, outerType);\n    processNeutrals(from, to, isolates, outerType);\n    emitSpans(line, from, to, level, baseLevel, isolates, order);\n}\nfunction computeOrder(line, direction, isolates) {\n    if (!line) return [\n        new BidiSpan(0, 0, direction == RTL ? 1 : 0)\n    ];\n    if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);\n    if (isolates.length) while(line.length > types.length)types[types.length] = 256 /* T.NI */ ; // Make sure types array has no gaps\n    let order = [], level = direction == LTR ? 0 : 1;\n    computeSectionOrder(line, level, level, isolates, 0, line.length, order);\n    return order;\n}\nfunction trivialOrder(length) {\n    return [\n        new BidiSpan(0, length, 0)\n    ];\n}\nlet movedOver = \"\";\n// This implementation moves strictly visually, without concern for a\n// traversal visiting every logical position in the string. It will\n// still do so for simple input, but situations like multiple isolates\n// with the same level next to each other, or text going against the\n// main dir at the end of the line, will make some positions\n// unreachable with this motion. Each visible cursor position will\n// correspond to the lower-level bidi span that touches it.\n//\n// The alternative would be to solve an order globally for a given\n// line, making sure that it includes every position, but that would\n// require associating non-canonical (higher bidi span level)\n// positions with a given visual position, which is likely to confuse\n// people. (And would generally be a lot more complicated.)\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from;\n    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI], spanEnd = span.side(forward, dir);\n    // End of span\n    if (startIndex == spanEnd) {\n        let nextI = spanI += forward ? 1 : -1;\n        if (nextI < 0 || nextI >= order.length) return null;\n        span = order[spanI = nextI];\n        startIndex = span.side(!forward, dir);\n        spanEnd = span.side(forward, dir);\n    }\n    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, startIndex, span.forward(forward, dir));\n    if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);\n}\nfunction autoDirection(text, from, to) {\n    for(let i = from; i < to; i++){\n        let type = charType(text.charCodeAt(i));\n        if (type == 1 /* T.L */ ) return LTR;\n        if (type == 2 /* T.R */  || type == 4 /* T.AL */ ) return RTL;\n    }\n    return LTR;\n}\nconst clickAddsSelectionRange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst exceptionSink = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst updateListener = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst inputHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst focusChangeEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst clipboardInputFilter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst clipboardOutputFilter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst scrollHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nclass ScrollTarget {\n    constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5, // This data structure is abused to also store precise scroll\n    // snapshots, instead of a `scrollIntoView` request. When this\n    // flag is `true`, `range` points at a position in the reference\n    // line, `yMargin` holds the difference between the top of that\n    // line and the top of the editor, and `xMargin` holds the\n    // editor's `scrollLeft`.\n    isSnapshot = false){\n        this.range = range;\n        this.y = y;\n        this.x = x;\n        this.yMargin = yMargin;\n        this.xMargin = xMargin;\n        this.isSnapshot = isSnapshot;\n    }\n    map(changes) {\n        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n    clip(state) {\n        return this.range.to <= state.doc.length ? this : new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n}\nconst scrollIntoView = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: (t, ch)=>t.map(ch)\n});\nconst setEditContextFormatting = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/ function logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length) handler[0](exception);\n    else if (window.onerror && window.onerror(String(exception), context, undefined, undefined, exception)) ;\n    else if (context) console.error(context + \":\", exception);\n    else console.error(exception);\n}\nconst editable = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.length ? values[0] : true\n});\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (plugins) {\n        return plugins.filter((p, i)=>{\n            for(let j = 0; j < i; j++)if (plugins[j].plugin == p.plugin) return false;\n            return true;\n        });\n    }\n});\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view. They optionally take an argument, in\nwhich case you need to call [`of`](https://codemirror.net/6/docs/ref/#view.ViewPlugin.of) to create\nan extension for the plugin. When the argument type is undefined,\nyou can use the plugin instance as an extension directly.\n*/ class ViewPlugin {\n    constructor(/**\n    @internal\n    */ id, /**\n    @internal\n    */ create, /**\n    @internal\n    */ domEventHandlers, /**\n    @internal\n    */ domEventObservers, buildExtensions){\n        this.id = id;\n        this.create = create;\n        this.domEventHandlers = domEventHandlers;\n        this.domEventObservers = domEventObservers;\n        this.baseExtensions = buildExtensions(this);\n        this.extension = this.baseExtensions.concat(viewPlugin.of({\n            plugin: this,\n            arg: undefined\n        }));\n    }\n    /**\n    Create an extension for this plugin with the given argument.\n    */ of(arg) {\n        return this.baseExtensions.concat(viewPlugin.of({\n            plugin: this,\n            arg\n        }));\n    }\n    /**\n    Define a plugin from a constructor function that creates the\n    plugin's value, given an editor view.\n    */ static define(create, spec) {\n        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};\n        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin)=>{\n            let ext = [];\n            if (deco) ext.push(decorations.of((view)=>{\n                let pluginInst = view.plugin(plugin);\n                return pluginInst ? deco(pluginInst) : Decoration.none;\n            }));\n            if (provide) ext.push(provide(plugin));\n            return ext;\n        });\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */ static fromClass(cls, spec) {\n        return ViewPlugin.define((view, arg)=>new cls(view, arg), spec);\n    }\n}\nclass PluginInstance {\n    constructor(spec){\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `null`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    get plugin() {\n        return this.spec && this.spec.plugin;\n    }\n    update(view) {\n        if (!this.value) {\n            if (this.spec) {\n                try {\n                    this.value = this.spec.plugin.create(view, this.spec.arg);\n                } catch (e) {\n                    logException(view.state, e, \"CodeMirror plugin crashed\");\n                    this.deactivate();\n                }\n            }\n        } else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (this.value.update) {\n                try {\n                    this.value.update(update);\n                } catch (e) {\n                    logException(update.state, e, \"CodeMirror plugin crashed\");\n                    if (this.value.destroy) try {\n                        this.value.destroy();\n                    } catch (_) {}\n                    this.deactivate();\n                }\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            } catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n    deactivate() {\n        this.spec = this.value = null;\n    }\n}\nconst editorAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst contentAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst outerDecorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst atomicRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst bidiIsolatedRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nfunction getIsolatedRanges(view, line) {\n    let isolates = view.state.facet(bidiIsolatedRanges);\n    if (!isolates.length) return isolates;\n    let sets = isolates.map((i)=>i instanceof Function ? i(view) : i);\n    let result = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(sets, line.from, line.to, {\n        point () {},\n        span (fromDoc, toDoc, active, open) {\n            let from = fromDoc - line.from, to = toDoc - line.from;\n            let level = result;\n            for(let i = active.length - 1; i >= 0; i--, open--){\n                let direction = active[i].spec.bidiIsolate, update;\n                if (direction == null) direction = autoDirection(line.text, from, to);\n                if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {\n                    update.to = to;\n                    level = update.inner;\n                } else {\n                    let add = {\n                        from,\n                        to,\n                        direction,\n                        inner: []\n                    };\n                    level.push(add);\n                    level = add.inner;\n                }\n            }\n        }\n    });\n    return result;\n}\nconst scrollMargins = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nfunction getScrollMargins(view) {\n    let left = 0, right = 0, top = 0, bottom = 0;\n    for (let source of view.state.facet(scrollMargins)){\n        let m = source(view);\n        if (m) {\n            if (m.left != null) left = Math.max(left, m.left);\n            if (m.right != null) right = Math.max(right, m.right);\n            if (m.top != null) top = Math.max(top, m.top);\n            if (m.bottom != null) bottom = Math.max(bottom, m.bottom);\n        }\n    }\n    return {\n        left,\n        right,\n        top,\n        bottom\n    };\n}\nconst styleModule = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB){\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for(; i > 0; i--){\n            let range = set[i - 1];\n            if (range.fromA > me.toA) continue;\n            if (range.toA < me.fromA) break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0) return diff;\n        let result = [];\n        for(let dI = 0, rI = 0, posA = 0, posB = 0;; dI++){\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while(rI < ranges.length && ranges[rI] < end){\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end) break;\n                else rI += 2;\n            }\n            if (!next) return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/ class ViewUpdate {\n    constructor(/**\n    The editor view that the update is associated with.\n    */ view, /**\n    The new editor state.\n    */ state, /**\n    The transactions involved in the update. May be empty.\n    */ transactions){\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /**\n        @internal\n        */ this.flags = 0;\n        this.startState = view.state;\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB)=>changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n    }\n    /**\n    @internal\n    */ static create(view, state, transactions) {\n        return new ViewUpdate(view, state, transactions);\n    }\n    /**\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n    update.\n    */ get viewportChanged() {\n        return (this.flags & 4 /* UpdateFlag.Viewport */ ) > 0;\n    }\n    /**\n    Returns true when\n    [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true\n    and the viewport change is not just the result of mapping it in\n    response to document changes.\n    */ get viewportMoved() {\n        return (this.flags & 8 /* UpdateFlag.ViewportMoved */ ) > 0;\n    }\n    /**\n    Indicates whether the height of a block element in the editor\n    changed in this update.\n    */ get heightChanged() {\n        return (this.flags & 2 /* UpdateFlag.Height */ ) > 0;\n    }\n    /**\n    Returns true when the document was modified or the size of the\n    editor, or elements within the editor, changed.\n    */ get geometryChanged() {\n        return this.docChanged || (this.flags & (16 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ )) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */ get focusChanged() {\n        return (this.flags & 1 /* UpdateFlag.Focus */ ) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */ get selectionSet() {\n        return this.transactions.some((tr)=>tr.selection);\n    }\n    /**\n    @internal\n    */ get empty() {\n        return this.flags == 0 && this.transactions.length == 0;\n    }\n}\nclass DocView extends ContentView {\n    get length() {\n        return this.view.state.doc.length;\n    }\n    constructor(view){\n        super();\n        this.view = view;\n        this.decorations = [];\n        this.dynamicDecorationMap = [\n            false\n        ];\n        this.domChanged = null;\n        this.hasComposition = null;\n        this.markedForComposition = new Set;\n        this.editContextFormatting = Decoration.none;\n        this.lastCompositionAfterCursor = false;\n        // Track a minimum width for the editor. When measuring sizes in\n        // measureVisibleLineHeights, this is updated to point at the width\n        // of a given element and its extent in the document. When a change\n        // happens in that range, these are reset. That way, once we've seen\n        // a line/element of a given length, we keep the editor wide enough\n        // to fit at least that element, until it is changed, at which point\n        // we forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.forceSelection = false;\n        // Used by the resize observer to ignore resizes that we caused\n        // ourselves\n        this.lastUpdate = Date.now();\n        this.setDOM(view.contentDOM);\n        this.children = [\n            new LineView\n        ];\n        this.children[0].setParent(this);\n        this.updateDeco();\n        this.updateInner([\n            new ChangedRange(0, 0, 0, view.state.doc.length)\n        ], 0, null);\n    }\n    // Update the document view to a given state.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA })=>toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n            } else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        this.updateEditContextFormatting(update);\n        let readCompositionAt = -1;\n        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {\n            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;\n            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;\n        }\n        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;\n        this.domChanged = null;\n        if (this.hasComposition) {\n            this.markedForComposition.clear();\n            let { from, to } = this.hasComposition;\n            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());\n        }\n        this.hasComposition = composition ? {\n            from: composition.range.fromB,\n            to: composition.range.toB\n        } : null;\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        if (!(this.flags & 7 /* ViewFlag.Dirty */ ) && changedRanges.length == 0) {\n            return false;\n        } else {\n            this.updateInner(changedRanges, update.startState.doc.length, composition);\n            if (update.transactions.length) this.lastUpdate = Date.now();\n            return true;\n        }\n    }\n    // Used by update and the constructor do perform the actual DOM\n    // update\n    updateInner(changes, oldLength, composition) {\n        this.view.viewState.mustMeasureContent = true;\n        this.updateChildren(changes, oldLength, composition);\n        let { observer } = this.view;\n        observer.ignore(()=>{\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\";\n            this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome || browser.ios ? {\n                node: observer.selectionRange.focusNode,\n                written: false\n            } : undefined;\n            this.sync(this.view, track);\n            this.flags &= ~7 /* ViewFlag.Dirty */ ;\n            if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;\n            this.dom.style.height = \"\";\n        });\n        this.markedForComposition.forEach((cView)=>cView.flags &= ~8 /* ViewFlag.Composition */ );\n        let gaps = [];\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {\n            for (let child of this.children)if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n        }\n        observer.updateGaps(gaps);\n    }\n    updateChildren(changes, oldLength, composition) {\n        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;\n        let cursor = this.childCursor(oldLength);\n        for(let i = ranges.length - 1;; i--){\n            let next = i >= 0 ? ranges[i] : null;\n            if (!next) break;\n            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;\n            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {\n                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);\n                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);\n                breakAtStart = before.breakAtStart;\n                openStart = before.openStart;\n                openEnd = after.openEnd;\n                let compLine = this.compositionView(composition);\n                if (after.breakAtStart) {\n                    compLine.breakAfter = 1;\n                } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {\n                    compLine.breakAfter = after.content[0].breakAfter;\n                    after.content.shift();\n                }\n                if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {\n                    before.content.pop();\n                }\n                content = before.content.concat(compLine).concat(after.content);\n            } else {\n                ({ content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));\n            }\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n        if (composition) this.fixCompositionDOM(composition);\n    }\n    updateEditContextFormatting(update) {\n        this.editContextFormatting = this.editContextFormatting.map(update.changes);\n        for (let tr of update.transactions)for (let effect of tr.effects)if (effect.is(setEditContextFormatting)) {\n            this.editContextFormatting = effect.value;\n        }\n    }\n    compositionView(composition) {\n        let cur = new TextView(composition.text.nodeValue);\n        cur.flags |= 8 /* ViewFlag.Composition */ ;\n        for (let { deco } of composition.marks)cur = new MarkView(deco, [\n            cur\n        ], cur.length);\n        let line = new LineView;\n        line.append(cur, 0);\n        return line;\n    }\n    fixCompositionDOM(composition) {\n        let fix = (dom, cView)=>{\n            cView.flags |= 8 /* ViewFlag.Composition */  | (cView.children.some((c)=>c.flags & 7 /* ViewFlag.Dirty */ ) ? 1 /* ViewFlag.ChildDirty */  : 0);\n            this.markedForComposition.add(cView);\n            let prev = ContentView.get(dom);\n            if (prev && prev != cView) prev.dom = null;\n            cView.setDOM(dom);\n        };\n        let pos = this.childPos(composition.range.fromB, 1);\n        let cView = this.children[pos.i];\n        fix(composition.line, cView);\n        for(let i = composition.marks.length - 1; i >= -1; i--){\n            pos = cView.childPos(pos.off, 1);\n            cView = cView.children[pos.i];\n            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);\n        }\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(mustRead = false, fromPointer = false) {\n        if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();\n        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;\n        let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));\n        if (!(focused || fromPointer || selectionNotFocus)) return;\n        let force = this.forceSelection;\n        this.forceSelection = false;\n        let main = this.view.state.selection.main;\n        let anchor = this.moveToLine(this.domAtPos(main.anchor));\n        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));\n        // Always reset on Firefox when next to an uneditable node to\n        // avoid invisible cursor bugs (#111)\n        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {\n            let dummy = document.createTextNode(\"\");\n            this.view.observer.ignore(()=>anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n            anchor = head = new DOMPos(dummy, 0);\n            force = true;\n        }\n        let domSel = this.view.observer.selectionRange;\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {\n            this.view.observer.ignore(()=>{\n                // Chrome Android will hide the virtual keyboard when tapping\n                // inside an uneditable node, and not bring it back when we\n                // move the cursor to its proper position. This tries to\n                // restore the keyboard by cycling focus.\n                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {\n                    this.dom.blur();\n                    this.dom.focus({\n                        preventScroll: true\n                    });\n                }\n                let rawSel = getSelection(this.view.root);\n                if (!rawSel) ;\n                else if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* NextTo.Before */  | 2 /* NextTo.After */ )) {\n                            let text = (nextTo == 1 /* NextTo.Before */  ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);\n                            if (text) anchor = new DOMPos(text.node, text.offset);\n                        }\n                    }\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;\n                } else if (rawSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    // Safari will ignore the call above when the editor is\n                    // hidden, and then raise an error on the call to extend\n                    // (#940).\n                    try {\n                        rawSel.extend(head.node, head.offset);\n                    } catch (_) {}\n                } else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head) [anchor, head] = [\n                        head,\n                        anchor\n                    ];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    rawSel.removeAllRanges();\n                    rawSel.addRange(range);\n                }\n                if (selectionNotFocus && this.view.root.activeElement == this.dom) {\n                    this.dom.blur();\n                    if (activeElt) activeElt.focus();\n                }\n            });\n            this.view.observer.setSelectionRange(anchor, head);\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    // If a zero-length widget is inserted next to the cursor during\n    // composition, avoid moving it across it and disrupting the\n    // composition.\n    suppressWidgetCursorChange(sel, cursor) {\n        return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;\n    }\n    enforceCursorAssoc() {\n        if (this.hasComposition) return;\n        let { view } = this, cursor = view.state.selection.main;\n        let sel = getSelection(view.root);\n        let { anchorNode, anchorOffset } = view.observer.selectionRange;\n        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;\n        let line = LineView.find(this, cursor.head);\n        if (!line) return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top) return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n        // This can go wrong in corner cases like single-character lines,\n        // so check and reset if necessary.\n        view.observer.readSelectionRange();\n        let newRange = view.observer.selectionRange;\n        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);\n    }\n    // If a position is in/near a block widget, move it to a nearby text\n    // line, since we don't want the cursor inside a block widget.\n    moveToLine(pos) {\n        // Block widgets will return positions before/after them, which\n        // are thus directly in the document DOM element.\n        let dom = this.dom, newPos;\n        if (pos.node != dom) return pos;\n        for(let i = pos.offset; !newPos && i < dom.childNodes.length; i++){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(0);\n        }\n        for(let i = pos.offset - 1; !newPos && i >= 0; i--){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(view.length);\n        }\n        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;\n    }\n    nearest(dom) {\n        for(let cur = dom; cur;){\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this) return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for(; i < this.children.length - 1;){\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView) break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        let best = null, bestPos = 0;\n        for(let off = this.length, i = this.children.length - 1; i >= 0; i--){\n            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;\n            if (end < pos) break;\n            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {\n                best = child;\n                bestPos = start;\n            } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {\n                if (child.deco.startSide < 0) break;\n                else if (i) best = null;\n            }\n            off = start;\n        }\n        return best ? best.coordsAt(pos - bestPos, side) : null;\n    }\n    coordsForChar(pos) {\n        let { i, off } = this.childPos(pos, 1), child = this.children[i];\n        if (!(child instanceof LineView)) return null;\n        while(child.children.length){\n            let { i, off: childOff } = child.childPos(off, 1);\n            for(;; i++){\n                if (i == child.children.length) return null;\n                if ((child = child.children[i]).length) break;\n            }\n            off = childOff;\n        }\n        if (!(child instanceof TextView)) return null;\n        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(child.text, off);\n        if (end == off) return null;\n        let rects = textRange(child.dom, off, end).getClientRects();\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;\n        }\n        return null;\n    }\n    measureVisibleLineHeights(viewport) {\n        let result = [], { from, to } = viewport;\n        let contentWidth = this.view.contentDOM.clientWidth;\n        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        let widest = -1, ltr = this.view.textDirection == Direction.LTR;\n        for(let pos = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (end > to) break;\n            if (pos >= from) {\n                let childRect = child.dom.getBoundingClientRect();\n                result.push(childRect.height);\n                if (isWider) {\n                    let last = child.dom.lastChild;\n                    let rects = last ? clientRectsFor(last) : [];\n                    if (rects.length) {\n                        let rect = rects[rects.length - 1];\n                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n                        if (width > widest) {\n                            widest = width;\n                            this.minWidth = contentWidth;\n                            this.minWidthFrom = pos;\n                            this.minWidthTo = end;\n                        }\n                    }\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    textDirectionAt(pos) {\n        let { i } = this.childPos(pos, 1);\n        return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    }\n    measureTextSize() {\n        for (let child of this.children){\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure) return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth, textHeight;\n        dummy.className = \"cm-line\";\n        dummy.style.width = \"99999px\";\n        dummy.style.position = \"absolute\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(()=>{\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            textHeight = rect ? rect.height : lineHeight;\n            dummy.remove();\n        });\n        return {\n            lineHeight,\n            charWidth,\n            textHeight\n        };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i) pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let deco = [], vs = this.view.viewState;\n        for(let pos = 0, i = 0;; i++){\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;\n                deco.push(Decoration.replace({\n                    widget: new BlockGapWidget(height),\n                    block: true,\n                    inclusive: true,\n                    isBlockGap: true\n                }).range(pos, end));\n            }\n            if (!next) break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        let i = 1;\n        let allDeco = this.view.state.facet(decorations).map((d)=>{\n            let dynamic = this.dynamicDecorationMap[i++] = typeof d == \"function\";\n            return dynamic ? d(this.view) : d;\n        });\n        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i)=>{\n            let dynamic = typeof d == \"function\";\n            if (dynamic) dynamicOuter = true;\n            return dynamic ? d(this.view) : d;\n        });\n        if (outerDeco.length) {\n            this.dynamicDecorationMap[i++] = dynamicOuter;\n            allDeco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.join(outerDeco));\n        }\n        this.decorations = [\n            this.editContextFormatting,\n            ...allDeco,\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco\n        ];\n        while(i < this.decorations.length)this.dynamicDecorationMap[i++] = false;\n        return this.decorations;\n    }\n    scrollIntoView(target) {\n        if (target.isSnapshot) {\n            let ref = this.view.viewState.lineBlockAt(target.range.head);\n            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;\n            this.view.scrollDOM.scrollLeft = target.xMargin;\n            return;\n        }\n        for (let handler of this.view.state.facet(scrollHandler)){\n            try {\n                if (handler(this.view, target.range, target)) return true;\n            } catch (e) {\n                logException(this.view.state, e, \"scroll handler\");\n            }\n        }\n        let { range } = target;\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\n        if (!rect) return;\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n            left: Math.min(rect.left, other.left),\n            top: Math.min(rect.top, other.top),\n            right: Math.max(rect.right, other.right),\n            bottom: Math.max(rect.bottom, other.bottom)\n        };\n        let margins = getScrollMargins(this.view);\n        let targetRect = {\n            left: rect.left - margins.left,\n            top: rect.top - margins.top,\n            right: rect.right + margins.right,\n            bottom: rect.bottom + margins.bottom\n        };\n        let { offsetWidth, offsetHeight } = this.view.scrollDOM;\n        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);\n    }\n    lineHasWidget(pos) {\n        let { i } = this.childCursor().findPos(pos);\n        if (i == this.children.length) return false;\n        let scan = (child)=>child instanceof WidgetView || child.children.some(scan);\n        return scan(this.children[i]);\n    }\n}\nfunction betweenUneditable(pos) {\n    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nfunction findCompositionNode(view, headPos) {\n    let sel = view.observer.selectionRange;\n    if (!sel.focusNode) return null;\n    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);\n    let textNode = textBefore || textAfter;\n    if (textAfter && textBefore && textAfter.node != textBefore.node) {\n        let descAfter = ContentView.get(textAfter.node);\n        if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {\n            textNode = textAfter;\n        } else if (view.docView.lastCompositionAfterCursor) {\n            let descBefore = ContentView.get(textBefore.node);\n            if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue)) textNode = textAfter;\n        }\n    }\n    view.docView.lastCompositionAfterCursor = textNode != textBefore;\n    if (!textNode) return null;\n    let from = headPos - textNode.offset;\n    return {\n        from,\n        to: from + textNode.node.nodeValue.length,\n        node: textNode.node\n    };\n}\nfunction findCompositionRange(view, changes, headPos) {\n    let found = findCompositionNode(view, headPos);\n    if (!found) return null;\n    let { node: textNode, from, to } = found, text = textNode.nodeValue;\n    // Don't try to preserve multi-line compositions\n    if (/[\\n\\r]/.test(text)) return null;\n    if (view.state.doc.sliceString(found.from, found.to) != text) return null;\n    let inv = changes.invertedDesc;\n    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);\n    let marks = [];\n    for(let parent = textNode.parentNode;; parent = parent.parentNode){\n        let parentView = ContentView.get(parent);\n        if (parentView instanceof MarkView) marks.push({\n            node: parent,\n            deco: parentView.mark\n        });\n        else if (parentView instanceof LineView || parent.nodeName == \"DIV\" && parent.parentNode == view.contentDOM) return {\n            range,\n            text: textNode,\n            marks,\n            line: parent\n        };\n        else if (parent != view.contentDOM) marks.push({\n            node: parent,\n            deco: new MarkDecoration({\n                inclusive: true,\n                attributes: getAttrs(parent),\n                tagName: parent.tagName.toLowerCase()\n            })\n        });\n        else return null;\n    }\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1) return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */  : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */  : 0);\n}\nlet DecorationComparator$1 = class DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange(from, to) {\n        addRange(from, to, this.changes);\n    }\n    comparePoint(from, to) {\n        addRange(from, to, this.changes);\n    }\n    boundChange(pos) {\n        addRange(pos, pos, this.changes);\n    }\n};\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nfunction inUneditable(node, inside) {\n    for(let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode){\n        if (cur.nodeType == 1 && cur.contentEditable == \"false\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction touchesComposition(changes, composition) {\n    let touched = false;\n    if (composition) changes.iterChangedRanges((from, to)=>{\n        if (from < composition.to && to > composition.from) touched = true;\n    });\n    return touched;\n}\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos);\n    if (linePos == 0) bias = 1;\n    else if (linePos == line.length) bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0) from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos, false);\n    else to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while(from > 0){\n        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat) break;\n        from = prev;\n    }\n    while(to < line.length){\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat) break;\n        to = next;\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? {\n        top,\n        left: rect.left,\n        right: rect.right,\n        bottom: rect.bottom\n    } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? {\n        top: rect.top,\n        left: rect.left,\n        right: rect.right,\n        bottom\n    } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY, closestOverlap = false;\n    let above, below, aboveRect, belowRect;\n    for(let child = parent.firstChild; child; child = child.nextSibling){\n        let rects = clientRectsFor(child);\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n                closestOverlap = !dx ? true : x < rect.left ? i > 0 : i < rects.length - 1;\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            } else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            } else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    } else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest) return {\n        node: parent,\n        offset: 0\n    };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n    if (closestOverlap && closest.contentEditable != \"false\") return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return {\n        node: parent,\n        offset\n    };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length;\n    let closestOffset = -1, closestDY = 1e9, generalSide = 0;\n    for(let i = 0; i < len; i++){\n        let rects = textRange(node, i, i + 1).getClientRects();\n        for(let j = 0; j < rects.length; j++){\n            let rect = rects[j];\n            if (rect.top == rect.bottom) continue;\n            if (!generalSide) generalSide = x - rect.left;\n            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    let rectBefore = textRange(node, i).getBoundingClientRect();\n                    if (rectBefore.left == rect.right) after = !right;\n                }\n                if (dy <= 0) return {\n                    node,\n                    offset: i + (after ? 1 : 0)\n                };\n                closestOffset = i + (after ? 1 : 0);\n                closestDY = dy;\n            }\n        }\n    }\n    return {\n        node,\n        offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0\n    };\n}\nfunction posAtCoords(view, coords, precise, bias = -1) {\n    var _a, _b;\n    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;\n    let block, { docHeight } = view.viewState;\n    let { x, y } = coords, yOffset = y - docTop;\n    if (yOffset < 0) return 0;\n    if (yOffset > docHeight) return view.state.doc.length;\n    // Scan for a text block near the queried y position\n    for(let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;){\n        block = view.elementAtHeight(yOffset);\n        if (block.type == BlockType.Text) break;\n        for(;;){\n            // Move the y position out of this block\n            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n            if (yOffset >= 0 && yOffset <= docHeight) break;\n            // If the document consists entirely of replaced widgets, we\n            // won't find a text block, so return 0\n            if (bounced) return precise ? null : 0;\n            bounced = true;\n            bias = -bias;\n        }\n    }\n    y = docTop + yOffset;\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n    let doc = view.dom.ownerDocument;\n    let root = view.root.elementFromPoint ? view.root : doc;\n    let element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element)) element = null;\n    // If the element is unexpected, clip x at the sides of the content area and try again\n    if (!element) {\n        x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n        element = root.elementFromPoint(x, y);\n        if (element && !view.contentDOM.contains(element)) element = null;\n    }\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n        if (doc.caretPositionFromPoint) {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos) ({ offsetNode: node, offset } = pos);\n        } else if (doc.caretRangeFromPoint) {\n            let range = doc.caretRangeFromPoint(x, y);\n            if (range) ({ startContainer: node, startOffset: offset } = range);\n        }\n        if (node && (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))) node = undefined;\n        // Chrome will return offsets into <input> elements without child\n        // nodes, which will lead to a null deref below, so clip the\n        // offset to the node size.\n        if (node) offset = Math.min(maxOffset(node), offset);\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    let nearest = view.docView.nearest(node);\n    if (!nearest) return null;\n    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {\n        let rect = nearest.dom.getBoundingClientRect();\n        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;\n    } else {\n        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;\n    }\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n        let textHeight = view.viewState.heightOracle.textHeight;\n        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);\n        into += line * view.viewState.heightOracle.lineLength;\n    }\n    let content = view.state.sliceDoc(block.from, block.to);\n    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(content, into, view.state.tabSize);\n}\nfunction isEndOfLineBefore(node, offset, x) {\n    let len, scan = node;\n    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;\n    for(;;){\n        let next = scan.nextSibling;\n        if (next) {\n            if (next.nodeName == \"BR\") break;\n            return false;\n        } else {\n            let parent = scan.parentNode;\n            if (!parent || parent.nodeName == \"DIV\") break;\n            scan = parent;\n        }\n    }\n    return textRange(node, len - 1, len).getBoundingClientRect().right > x;\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\n    return isEndOfLineBefore(node, offset, x);\n}\n// Chrome will move positions between lines to the start of the next line\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\n    if (offset != 0) return isEndOfLineBefore(node, offset, x);\n    for(let cur = node;;){\n        let parent = cur.parentNode;\n        if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;\n        if (parent.classList.contains(\"cm-line\")) break;\n        cur = parent;\n    }\n    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\n    return x - rect.left > 5;\n}\nfunction blockAt(view, pos, side) {\n    let line = view.lineBlockAt(pos);\n    if (Array.isArray(line.type)) {\n        let best;\n        for (let l of line.type){\n            if (l.from > pos) break;\n            if (l.to < pos) continue;\n            if (l.from < pos && l.to > pos) return l;\n            if (!best || l.type == BlockType.Text && (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos))) best = l;\n        }\n        return best || line;\n    }\n    return line;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = blockAt(view, start.head, start.assoc || -1);\n    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let direction = view.textDirectionAt(line.from);\n        let pos = view.posAtCoords({\n            x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2\n        });\n        if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    let direction = view.textDirectionAt(line.from);\n    for(let cur = start, check = null;;){\n        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = view.visualLineSide(line, !forward);\n        }\n        if (!check) {\n            if (!by) return next;\n            check = by(char);\n        } else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.CharCategory.Space) cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(startPos, start.assoc);\n    let goal = start.goalColumn, startY;\n    let rect = view.contentDOM.getBoundingClientRect();\n    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;\n    if (startCoords) {\n        if (goal == null) goal = startCoords.left - rect.left;\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\n    } else {\n        let line = view.viewState.lineBlockAt(startPos);\n        if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n        startY = (dir < 0 ? line.top : line.bottom) + docTop;\n    }\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;\n    for(let extra = 0;; extra += 10){\n        let curY = startY + (dist + extra) * dir;\n        let pos = posAtCoords(view, {\n            x: resolvedGoal,\n            y: curY\n        }, false, dir);\n        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {\n            let charRect = view.docView.coordsForChar(pos);\n            let assoc = !charRect || curY < charRect.top ? -1 : 1;\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, assoc, undefined, goal);\n        }\n    }\n}\nfunction skipAtomicRanges(atoms, pos, bias) {\n    for(;;){\n        let moved = 0;\n        for (let set of atoms){\n            set.between(pos - 1, pos + 1, (from, to, value)=>{\n                if (pos > from && pos < to) {\n                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);\n                    pos = side < 0 ? from : to;\n                    moved = side;\n                }\n            });\n        }\n        if (!moved) return pos;\n    }\n}\nfunction skipAtomsForSelection(atoms, sel) {\n    let ranges = null;\n    for(let i = 0; i < sel.ranges.length; i++){\n        let range = sel.ranges[i], updated = null;\n        if (range.empty) {\n            let pos = skipAtomicRanges(atoms, range.from, 0);\n            if (pos != range.from) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, -1);\n        } else {\n            let from = skipAtomicRanges(atoms, range.from, -1);\n            let to = skipAtomicRanges(atoms, range.to, 1);\n            if (from != range.from || to != range.to) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);\n        }\n        if (updated) {\n            if (!ranges) ranges = sel.ranges.slice();\n            ranges[i] = updated;\n        }\n    }\n    return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges, sel.mainIndex) : sel;\n}\nfunction skipAtoms(view, oldPos, pos) {\n    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f)=>f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);\n    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);\n}\nconst LineBreakPlaceholder = \"ï¿¿\";\nclass DOMReader {\n    constructor(points, state){\n        this.points = points;\n        this.text = \"\";\n        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.lineSeparator);\n    }\n    append(text) {\n        this.text += text;\n    }\n    lineBreak() {\n        this.text += LineBreakPlaceholder;\n    }\n    readRange(start, end) {\n        if (!start) return this;\n        let parent = start.parentNode;\n        for(let cur = start;;){\n            this.findPointBefore(parent, cur);\n            let oldLen = this.text.length;\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end) break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if ((view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore) && this.text.length > oldLen) && !isEmptyToEnd(next, end)) this.lineBreak();\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n        return this;\n    }\n    readTextNode(node) {\n        let text = node.nodeValue;\n        for (let point of this.points)if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);\n        for(let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;){\n            let nextBreak = -1, breakSize = 1, m;\n            if (this.lineSeparator) {\n                nextBreak = text.indexOf(this.lineSeparator, off);\n                breakSize = this.lineSeparator.length;\n            } else if (m = re.exec(text)) {\n                nextBreak = m.index;\n                breakSize = m[0].length;\n            }\n            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n            if (nextBreak < 0) break;\n            this.lineBreak();\n            if (breakSize > 1) {\n                for (let point of this.points)if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;\n            }\n            off = nextBreak + breakSize;\n        }\n    }\n    readNode(node) {\n        if (node.cmIgnore) return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        if (fromView != null) {\n            this.findPointInside(node, fromView.length);\n            for(let i = fromView.iter(); !i.next().done;){\n                if (i.lineBreak) this.lineBreak();\n                else this.append(i.value);\n            }\n        } else if (node.nodeType == 3) {\n            this.readTextNode(node);\n        } else if (node.nodeName == \"BR\") {\n            if (node.nextSibling) this.lineBreak();\n        } else if (node.nodeType == 1) {\n            this.readRange(node.firstChild, null);\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n    }\n    findPointInside(node, length) {\n        for (let point of this.points)if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);\n    }\n}\nfunction isAtEnd(parent, node, offset) {\n    for(;;){\n        if (!node || offset < maxOffset(node)) return false;\n        if (node == parent) return true;\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n}\nfunction isEmptyToEnd(node, end) {\n    let widgets;\n    for(;; node = node.nextSibling){\n        if (node == end || !node) break;\n        let view = ContentView.get(node);\n        if (!((view === null || view === void 0 ? void 0 : view.isWidget) || node.cmIgnore)) return false;\n        if (view) (widgets || (widgets = [])).push(view);\n    }\n    if (widgets) for (let w of widgets){\n        let override = w.overrideDOMText;\n        if (override === null || override === void 0 ? void 0 : override.length) return false;\n    }\n    return true;\n}\nclass DOMPoint {\n    constructor(node, offset){\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nclass DOMChange {\n    constructor(view, start, end, typeOver){\n        this.typeOver = typeOver;\n        this.bounds = null;\n        this.text = \"\";\n        this.domChanged = start > -1;\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        if (view.state.readOnly && start > -1) {\n            // Ignore changes when the editor is read-only\n            this.newSel = null;\n        } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\n            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n            let reader = new DOMReader(selPoints, view.state);\n            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n            this.text = reader.text;\n            this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n        } else {\n            let domSel = view.observer.selectionRange;\n            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n            // iOS will refuse to select the block gaps when doing\n            // select-all.\n            // Chrome will put the selection *inside* them, confusing\n            // posFromDOM\n            let vp = view.viewport;\n            if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {\n                let from = Math.min(head, anchor), to = Math.max(head, anchor);\n                let offFrom = vp.from - from, offTo = vp.to - to;\n                if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {\n                    head = 0;\n                    anchor = view.state.doc.length;\n                }\n            }\n            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(anchor, head);\n        }\n    }\n}\nfunction applyDOMChange(view, domChange) {\n    let change;\n    let { newSel } = domChange, sel = view.state.selection.main;\n    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;\n    if (domChange.bounds) {\n        let { from, to } = domChange.bounds;\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed (or, on\n        // Android, when something was deleted)\n        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n        if (diff) {\n            // Chrome inserts two newlines when pressing shift-enter at the\n            // end of a line. DomChange drops one of those.\n            if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;\n            change = {\n                from: from + diff.from,\n                to: from + diff.toA,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))\n            };\n        }\n    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\n        newSel = null;\n    }\n    if (!change && !newSel) return false;\n    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n        // Heuristic to notice typing over a selected character\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, sel.to)\n        };\n    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") {\n        // Detect insert-period-on-double-space Mac and Android behavior,\n        // and transform it into a regular space insert.\n        if (newSel && change.insert.length == 2) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: change.from,\n            to: change.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([\n                change.insert.toString().replace(\".\", \" \")\n            ])\n        };\n    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {\n        // If the change is inside the selection and covers most of it,\n        // assume it is a selection replace (with identical characters at\n        // the start/end not included in the diff)\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n        };\n    } else if (view.state.doc.lineAt(sel.from).to < sel.to && view.docView.lineHasWidget(sel.to) && view.inputState.insertingTextAt > Date.now() - 50) {\n        // For a cross-line insertion, Chrome and Safari will crudely take\n        // the text of the line after the selection, flattening any\n        // widgets, and move it into the joined line. This tries to detect\n        // such a situation, and replaces the change with a selection\n        // replace of the text provided by the beforeinput event.\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.toText(view.inputState.insertingText)\n        };\n    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == \"\\n \" && view.lineWrapping) {\n        // In Chrome, if you insert a space at the start of a wrapped\n        // line, it will actually insert a newline and a space, causing a\n        // bogus new line to be created in CodeMirror (#968)\n        if (newSel) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([\n                \" \"\n            ])\n        };\n    }\n    if (change) {\n        return applyDOMChangeInner(view, change, newSel, lastKey);\n    } else if (newSel && !newSel.main.eq(sel)) {\n        let scrollIntoView = false, userEvent = \"select\";\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"select\") scrollIntoView = true;\n            userEvent = view.inputState.lastSelectionOrigin;\n            if (userEvent == \"select.pointer\") newSel = skipAtomsForSelection(view.state.facet(atomicRanges).map((f)=>f(view)), newSel);\n        }\n        view.dispatch({\n            selection: newSel,\n            scrollIntoView,\n            userEvent\n        });\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction applyDOMChangeInner(view, change, newSel, lastKey = -1) {\n    if (browser.ios && view.inputState.flushIOSKey(change)) return true;\n    let sel = view.state.selection.main;\n    // Android browsers don't fire reasonable key events for enter,\n    // backspace, or delete. So this detects changes that look like\n    // they're caused by those keys, and reinterprets them as key\n    // events. (Some of these keys are also handled by beforeinput\n    // events and the pendingAndroidKey mechanism, but that's not\n    // reliable in all situations.)\n    if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted\n    // after a completion when you press enter\n    (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == \" \") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return true;\n    let text = change.insert.toString();\n    if (view.inputState.composing >= 0) view.inputState.composing++;\n    let defaultTr;\n    let defaultInsert = ()=>defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));\n    if (!view.state.facet(inputHandler).some((h)=>h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());\n    return true;\n}\nfunction applyDefaultInsert(view, change, newSel) {\n    let tr, startState = view.state, sel = startState.selection.main, inAtomic = -1;\n    if (change.from == change.to && change.from < sel.from || change.from > sel.to) {\n        let side = change.from < sel.from ? -1 : 1, pos = side < 0 ? sel.from : sel.to;\n        let moved = skipAtomicRanges(startState.facet(atomicRanges).map((f)=>f(view)), pos, side);\n        if (change.from == moved) inAtomic = moved;\n    }\n    if (inAtomic > -1) {\n        tr = {\n            changes: change,\n            selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(change.from + change.insert.length, -1)\n        };\n    } else if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n        let changes = startState.changes(change);\n        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n        // Try to apply a composition change to all cursors\n        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to + 10 && change.to >= sel.to - 10) {\n            let replaced = view.state.sliceDoc(change.from, change.to);\n            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);\n            if (composition) {\n                let dLen = change.insert.length - (change.to - change.from);\n                compositionRange = {\n                    from: composition.from,\n                    to: composition.to - dLen\n                };\n            } else {\n                compositionRange = view.state.doc.lineAt(sel.head);\n            }\n            let offset = sel.to - change.to, size = sel.to - sel.from;\n            tr = startState.changeByRange((range)=>{\n                if (range.from == sel.from && range.to == sel.to) return {\n                    changes,\n                    range: mainSel || range.map(changes)\n                };\n                let to = range.to - offset, from = to - replaced.length;\n                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple\n                // changes in the same node work without aborting\n                // composition, so cursors in the composition range are\n                // ignored.\n                range.to >= compositionRange.from && range.from <= compositionRange.to) return {\n                    range\n                };\n                let rangeChanges = startState.changes({\n                    from,\n                    to,\n                    insert: change.insert\n                }), selOff = range.to - sel.to;\n                return {\n                    changes: rangeChanges,\n                    range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n                };\n            });\n        } else {\n            tr = {\n                changes,\n                selection: mainSel && startState.selection.replaceRange(mainSel)\n            };\n        }\n    }\n    let userEvent = \"input.type\";\n    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {\n        view.inputState.compositionPendingChange = false;\n        userEvent += \".compose\";\n        if (view.inputState.compositionFirstChange) {\n            userEvent += \".start\";\n            view.inputState.compositionFirstChange = false;\n        }\n    }\n    return startState.update(tr, {\n        userEvent,\n        scrollIntoView: true\n    });\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while(from < minLen && a.charCodeAt(from) == b.charCodeAt(from))from++;\n    if (from == minLen && a.length == b.length) return null;\n    let toA = a.length, toB = b.length;\n    while(toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)){\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    } else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return {\n        from,\n        toA,\n        toB\n    };\n}\nfunction selectionPoints(view) {\n    let result = [];\n    if (view.root.activeElement != view.contentDOM) return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0) return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(anchor + base, head + base) : null;\n}\nclass InputState {\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    constructor(view){\n        this.view = view;\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastTouchTime = 0;\n        this.lastFocusTime = 0;\n        this.lastScrollTop = 0;\n        this.lastScrollLeft = 0;\n        // On iOS, some keys need to have their default behavior happen\n        // (after which we retroactively handle them and reset the DOM) to\n        // avoid messing up the virtual keyboard state.\n        this.pendingIOSKey = undefined;\n        /**\n        When enabled (>-1), tab presses are not given to key handlers,\n        leaving the browser's default behavior. If >0, the mode expires\n        at that timestamp, and any other keypress clears it.\n        Esc enables temporary tab focus mode for two seconds when not\n        otherwise handled.\n        */ this.tabFocusMode = -1;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastContextMenu = 0;\n        this.scrollHandlers = [];\n        this.handlers = Object.create(null);\n        // -1 means not in a composition. Otherwise, this counts the number\n        // of changes made during the composition. The count is used to\n        // avoid treating the start state of the composition, before any\n        // changes have been made, as part of the composition.\n        this.composing = -1;\n        // Tracks whether the next change should be marked as starting the\n        // composition (null means no composition, true means next is the\n        // first, false means first has already been marked for this\n        // composition)\n        this.compositionFirstChange = null;\n        // End time of the previous composition\n        this.compositionEndedAt = 0;\n        // Used in a kludge to detect when an Enter keypress should be\n        // considered part of the composition on Safari, which fires events\n        // in the wrong order\n        this.compositionPendingKey = false;\n        // Used to categorize changes as part of a composition, even when\n        // the mutation events fire shortly after the compositionend event\n        this.compositionPendingChange = false;\n        // Set by beforeinput, used in DOM change reader\n        this.insertingText = \"\";\n        this.insertingTextAt = 0;\n        this.mouseSelection = null;\n        // When a drag from the editor is active, this points at the range\n        // being dragged.\n        this.draggedContent = null;\n        this.handleEvent = this.handleEvent.bind(this);\n        this.notifiedFocused = view.hasFocus;\n        // On Safari adding an input event handler somehow prevents an\n        // issue where the composition vanishes when you press enter.\n        if (browser.safari) view.contentDOM.addEventListener(\"input\", ()=>null);\n        if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);\n    }\n    handleEvent(event) {\n        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;\n        if (event.type == \"keydown\" && this.keydown(event)) return;\n        if (this.view.updateState != 0 /* UpdateState.Idle */ ) Promise.resolve().then(()=>this.runHandlers(event.type, event));\n        else this.runHandlers(event.type, event);\n    }\n    runHandlers(type, event) {\n        let handlers = this.handlers[type];\n        if (handlers) {\n            for (let observer of handlers.observers)observer(this.view, event);\n            for (let handler of handlers.handlers){\n                if (event.defaultPrevented) break;\n                if (handler(this.view, event)) {\n                    event.preventDefault();\n                    break;\n                }\n            }\n        }\n    }\n    ensureHandlers(plugins) {\n        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;\n        for(let type in handlers)if (type != \"scroll\") {\n            let passive = !handlers[type].handlers.length;\n            let exists = prev[type];\n            if (exists && passive != !exists.handlers.length) {\n                dom.removeEventListener(type, this.handleEvent);\n                exists = null;\n            }\n            if (!exists) dom.addEventListener(type, this.handleEvent, {\n                passive\n            });\n        }\n        for(let type in prev)if (type != \"scroll\" && !handlers[type]) dom.removeEventListener(type, this.handleEvent);\n        this.handlers = handlers;\n    }\n    keydown(event) {\n        // Must always run, even if a custom handler handled the event\n        this.lastKeyCode = event.keyCode;\n        this.lastKeyTime = Date.now();\n        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) return true;\n        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.tabFocusMode = -1;\n        // Chrome for Android usually doesn't fire proper key events, but\n        // occasionally does, usually surrounded by a bunch of complicated\n        // composition changes. When an enter or backspace key event is\n        // seen, hold off on handling DOM events for a bit, and then\n        // dispatch it.\n        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n            this.view.observer.delayAndroidKey(event.key, event.keyCode);\n            return true;\n        }\n        // Preventing the default behavior of Enter on iOS makes the\n        // virtual keyboard get stuck in the wrong (lowercase)\n        // state. So we let it go through, and then, in\n        // applyDOMChange, notify key handlers of it and reset to\n        // the state they produce.\n        let pending;\n        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key)=>key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n            this.pendingIOSKey = pending || event;\n            setTimeout(()=>this.flushIOSKey(), 250);\n            return true;\n        }\n        if (event.keyCode != 229) this.view.observer.forceFlush();\n        return false;\n    }\n    flushIOSKey(change) {\n        let key = this.pendingIOSKey;\n        if (!key) return false;\n        // This looks like an autocorrection before Enter\n        if (key.key == \"Enter\" && change && change.from < change.to && /^\\S+$/.test(change.insert.toString())) return false;\n        this.pendingIOSKey = undefined;\n        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type) || event.synthetic) return false;\n        if (this.composing > 0) return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {\n            this.compositionPendingKey = false;\n            return true;\n        }\n        return false;\n    }\n    startMouseSelection(mouseSelection) {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n        this.mouseSelection = mouseSelection;\n    }\n    update(update) {\n        this.view.observer.update(update);\n        if (this.mouseSelection) this.mouseSelection.update(update);\n        if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);\n        if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n    }\n}\nfunction bindHandler(plugin, handler) {\n    return (view, event)=>{\n        try {\n            return handler.call(plugin, event, view);\n        } catch (e) {\n            logException(view.state, e);\n        }\n    };\n}\nfunction computeHandlers(plugins) {\n    let result = Object.create(null);\n    function record(type) {\n        return result[type] || (result[type] = {\n            observers: [],\n            handlers: []\n        });\n    }\n    for (let plugin of plugins){\n        let spec = plugin.spec, handlers = spec && spec.plugin.domEventHandlers, observers = spec && spec.plugin.domEventObservers;\n        if (handlers) for(let type in handlers){\n            let f = handlers[type];\n            if (f) record(type).handlers.push(bindHandler(plugin.value, f));\n        }\n        if (observers) for(let type in observers){\n            let f = observers[type];\n            if (f) record(type).observers.push(bindHandler(plugin.value, f));\n        }\n    }\n    for(let type in handlers)record(type).handlers.push(handlers[type]);\n    for(let type in observers)record(type).observers.push(observers[type]);\n    return result;\n}\nconst PendingKeys = [\n    {\n        key: \"Backspace\",\n        keyCode: 8,\n        inputType: \"deleteContentBackward\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertParagraph\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertLineBreak\"\n    },\n    {\n        key: \"Delete\",\n        keyCode: 46,\n        inputType: \"deleteContentForward\"\n    }\n];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [\n    16,\n    17,\n    18,\n    20,\n    91,\n    92,\n    224,\n    225\n];\nconst dragScrollMargin = 6;\nfunction dragScrollSpeed(dist) {\n    return Math.max(0, dist) * 0.7 + 8;\n}\nfunction dist(a, b) {\n    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));\n}\nclass MouseSelection {\n    constructor(view, startEvent, style, mustSelect){\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        this.mustSelect = mustSelect;\n        this.scrollSpeed = {\n            x: 0,\n            y: 0\n        };\n        this.scrolling = -1;\n        this.lastEvent = startEvent;\n        this.scrollParents = scrollableParents(view.contentDOM);\n        this.atoms = view.state.facet(atomicRanges).map((f)=>f(view));\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n    }\n    start(event) {\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) this.select(event);\n    }\n    move(event) {\n        if (event.buttons == 0) return this.destroy();\n        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;\n        this.select(this.lastEvent = event);\n        let sx = 0, sy = 0;\n        let left = 0, top = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;\n        if (this.scrollParents.x) ({ left, right } = this.scrollParents.x.getBoundingClientRect());\n        if (this.scrollParents.y) ({ top, bottom } = this.scrollParents.y.getBoundingClientRect());\n        let margins = getScrollMargins(this.view);\n        if (event.clientX - margins.left <= left + dragScrollMargin) sx = -dragScrollSpeed(left - event.clientX);\n        else if (event.clientX + margins.right >= right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - right);\n        if (event.clientY - margins.top <= top + dragScrollMargin) sy = -dragScrollSpeed(top - event.clientY);\n        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - bottom);\n        this.setScrollSpeed(sx, sy);\n    }\n    up(event) {\n        if (this.dragging == null) this.select(this.lastEvent);\n        if (!this.dragging) event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        this.setScrollSpeed(0, 0);\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;\n    }\n    setScrollSpeed(sx, sy) {\n        this.scrollSpeed = {\n            x: sx,\n            y: sy\n        };\n        if (sx || sy) {\n            if (this.scrolling < 0) this.scrolling = setInterval(()=>this.scroll(), 50);\n        } else if (this.scrolling > -1) {\n            clearInterval(this.scrolling);\n            this.scrolling = -1;\n        }\n    }\n    scroll() {\n        let { x, y } = this.scrollSpeed;\n        if (x && this.scrollParents.x) {\n            this.scrollParents.x.scrollLeft += x;\n            x = 0;\n        }\n        if (y && this.scrollParents.y) {\n            this.scrollParents.y.scrollTop += y;\n            y = 0;\n        }\n        if (x || y) this.view.win.scrollBy(x, y);\n        if (this.dragging === false) this.select(this.lastEvent);\n    }\n    select(event) {\n        let { view } = this, selection = skipAtomsForSelection(this.atoms, this.style.get(event, this.extend, this.multiple));\n        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false)) this.view.dispatch({\n            selection,\n            userEvent: \"select.pointer\"\n        });\n        this.mustSelect = false;\n    }\n    update(update) {\n        if (update.transactions.some((tr)=>tr.isUserEvent(\"input.type\"))) this.destroy();\n        else if (this.style.update(update)) setTimeout(()=>this.select(this.lastEvent), 20);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n    let facet = view.state.facet(dragMovesSelection$1);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty) return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (!sel || sel.rangeCount == 0) return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for(let i = 0; i < rects.length; i++){\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target, cView; node != view.contentDOM; node = node.parentNode)if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n    return true;\n}\nconst handlers = /*@__PURE__*/ Object.create(null);\nconst observers = /*@__PURE__*/ Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIâ€”all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(()=>{\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction textFilter(state, facet, text) {\n    for (let filter of state.facet(facet))text = filter(text, state);\n    return text;\n}\nfunction doPaste(view, input) {\n    input = textFilter(view.state, clipboardInputFilter, input);\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r)=>r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        let lastLine = -1;\n        changes = state.changeByRange((range)=>{\n            let line = state.doc.lineAt(range.from);\n            if (line.from == lastLine) return {\n                range\n            };\n            lastLine = line.from;\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n            return {\n                changes: {\n                    from: line.from,\n                    insert\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(range.from + insert.length)\n            };\n        });\n    } else if (byLine) {\n        changes = state.changeByRange((range)=>{\n            let line = text.line(i++);\n            return {\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: line.text\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(range.from + line.length)\n            };\n        });\n    } else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        userEvent: \"input.paste\",\n        scrollIntoView: true\n    });\n}\nobservers.scroll = (view)=>{\n    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;\n    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;\n};\nhandlers.keydown = (view, event)=>{\n    view.inputState.setSelectionOrigin(\"select\");\n    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0) view.inputState.tabFocusMode = Date.now() + 2000;\n    return false;\n};\nobservers.touchstart = (view, e)=>{\n    view.inputState.lastTouchTime = Date.now();\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nobservers.touchmove = (view)=>{\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.mousedown = (view, event)=>{\n    view.observer.flush();\n    if (view.inputState.lastTouchTime > Date.now() - 2000) return false; // Ignore touch interaction\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)){\n        style = makeStyle(view, event);\n        if (style) break;\n    }\n    if (!style && event.button == 0) style = basicMouseSelection(view, event);\n    if (style) {\n        let mustFocus = !view.hasFocus;\n        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n        if (mustFocus) view.observer.ignore(()=>{\n            focusPreventScroll(view.contentDOM);\n            let active = view.root.activeElement;\n            if (active && !active.contains(view.contentDOM)) active.blur();\n        });\n        let mouseSel = view.inputState.mouseSelection;\n        if (mouseSel) {\n            mouseSel.start(event);\n            return mouseSel.dragging === false;\n        }\n    } else {\n        view.inputState.setSelectionOrigin(\"select.pointer\");\n    }\n    return false;\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, bias);\n    } else if (type == 2) {\n        return groupAt(view.state, pos, bias);\n    } else {\n        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\n        if (to < view.state.doc.length && to == line.to) to++;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to);\n    }\n}\nlet inside = (x, y, rect)=>y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line) return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0) return 1;\n    if (off == line.length) return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before)) return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after)) return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // above its bottom.\n    return before && before.bottom >= y ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    return {\n        pos,\n        bias: findPositionSide(view, pos, event.clientX, event.clientY)\n    };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail) return event.detail;\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\n    lastMouseDown = event;\n    lastMouseDownTime = Date.now();\n    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, extend, multiple) {\n            let cur = queryPos(view, event), removed;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(to, from);\n            }\n            if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;\n            else if (multiple) return startSel.addRange(range);\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create([\n                range\n            ]);\n        }\n    };\n}\nfunction removeRangeAround(sel, pos) {\n    for(let i = 0; i < sel.ranges.length; i++){\n        let { from, to } = sel.ranges[i];\n        if (from <= pos && to >= pos) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n    }\n    return null;\n}\nhandlers.dragstart = (view, event)=>{\n    let { selection: { main: range } } = view.state;\n    if (event.target.draggable) {\n        let cView = view.docView.nearest(event.target);\n        if (cView && cView.isWidget) {\n            let from = cView.posAtStart, to = from + cView.length;\n            if (from >= range.to || to <= range.from) range = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to);\n        }\n    }\n    let { inputState } = view;\n    if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;\n    inputState.draggedContent = range;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n    return false;\n};\nhandlers.dragend = (view)=>{\n    view.inputState.draggedContent = null;\n    return false;\n};\nfunction dropText(view, event, text, direct) {\n    text = textFilter(view.state, clipboardInputFilter, text);\n    if (!text) return;\n    let dropPos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let { draggedContent } = view.inputState;\n    let del = direct && draggedContent && dragMovesSelection(view, event) ? {\n        from: draggedContent.from,\n        to: draggedContent.to\n    } : null;\n    let ins = {\n        from: dropPos,\n        insert: text\n    };\n    let changes = view.state.changes(del ? [\n        del,\n        ins\n    ] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: {\n            anchor: changes.mapPos(dropPos, -1),\n            head: changes.mapPos(dropPos, 1)\n        },\n        userEvent: del ? \"move.drop\" : \"input.drop\"\n    });\n    view.inputState.draggedContent = null;\n}\nhandlers.drop = (view, event)=>{\n    if (!event.dataTransfer) return false;\n    if (view.state.readOnly) return true;\n    let files = event.dataTransfer.files;\n    if (files && files.length) {\n        let text = Array(files.length), read = 0;\n        let finishFile = ()=>{\n            if (++read == files.length) dropText(view, event, text.filter((s)=>s != null).join(view.state.lineBreak), false);\n        };\n        for(let i = 0; i < files.length; i++){\n            let reader = new FileReader;\n            reader.onerror = finishFile;\n            reader.onload = ()=>{\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n                finishFile();\n            };\n            reader.readAsText(files[i]);\n        }\n        return true;\n    } else {\n        let text = event.dataTransfer.getData(\"Text\");\n        if (text) {\n            dropText(view, event, text, true);\n            return true;\n        }\n    }\n    return false;\n};\nhandlers.paste = (view, event)=>{\n    if (view.state.readOnly) return true;\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        doPaste(view, data.getData(\"text/plain\") || data.getData(\"text/uri-list\"));\n        return true;\n    } else {\n        capturePaste(view);\n        return false;\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(()=>{\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)if (!range.empty) {\n        content.push(state.sliceDoc(range.from, range.to));\n        ranges.push(range);\n    }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges){\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({\n                    from: line.from,\n                    to: Math.min(state.doc.length, line.to + 1)\n                });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return {\n        text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)),\n        ranges,\n        linewise\n    };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event)=>{\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text && !linewise) return false;\n    lastLinewiseCopy = linewise ? text : null;\n    if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n        changes: ranges,\n        scrollIntoView: true,\n        userEvent: \"delete.cut\"\n    });\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        data.clearData();\n        data.setData(\"text/plain\", text);\n        return true;\n    } else {\n        captureCopy(view, text);\n        return false;\n    }\n};\nconst isFocusChange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Annotation.define();\nfunction focusChangeTransaction(state, focus) {\n    let effects = [];\n    for (let getEffect of state.facet(focusChangeEffect)){\n        let effect = getEffect(state, focus);\n        if (effect) effects.push(effect);\n    }\n    return effects.length ? state.update({\n        effects,\n        annotations: isFocusChange.of(true)\n    }) : null;\n}\nfunction updateForFocusChange(view) {\n    setTimeout(()=>{\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            let tr = focusChangeTransaction(view.state, focus);\n            if (tr) view.dispatch(tr);\n            else view.update([]);\n        }\n    }, 10);\n}\nobservers.focus = (view)=>{\n    view.inputState.lastFocusTime = Date.now();\n    // When focusing reset the scroll position, move it back to where it was\n    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n    }\n    updateForFocusChange(view);\n};\nobservers.blur = (view)=>{\n    view.observer.clearSelectionRange();\n    updateForFocusChange(view);\n};\nobservers.compositionstart = observers.compositionupdate = (view)=>{\n    if (view.observer.editContext) return; // Composition handled by edit context\n    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n    if (view.inputState.composing < 0) {\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = 0;\n    }\n};\nobservers.compositionend = (view)=>{\n    if (view.observer.editContext) return; // Composition handled by edit context\n    view.inputState.composing = -1;\n    view.inputState.compositionEndedAt = Date.now();\n    view.inputState.compositionPendingKey = true;\n    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;\n    view.inputState.compositionFirstChange = null;\n    if (browser.chrome && browser.android) {\n        // Delay flushing for a bit on Android because it'll often fire a\n        // bunch of contradictory changes in a row at end of compositon\n        view.observer.flushSoon();\n    } else if (view.inputState.compositionPendingChange) {\n        // If we found pending records, schedule a flush.\n        Promise.resolve().then(()=>view.observer.flush());\n    } else {\n        // Otherwise, make sure that, if no changes come in soon, the\n        // composition view is cleared.\n        setTimeout(()=>{\n            if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);\n        }, 50);\n    }\n};\nobservers.contextmenu = (view)=>{\n    view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event)=>{\n    var _a, _b;\n    if (event.inputType == \"insertText\" || event.inputType == \"insertCompositionText\") {\n        view.inputState.insertingText = event.data;\n        view.inputState.insertingTextAt = Date.now();\n    }\n    // In EditContext mode, we must handle insertReplacementText events\n    // directly, to make spell checking corrections work\n    if (event.inputType == \"insertReplacementText\" && view.observer.editContext) {\n        let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData(\"text/plain\"), ranges = event.getTargetRanges();\n        if (text && ranges.length) {\n            let r = ranges[0];\n            let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);\n            applyDOMChangeInner(view, {\n                from,\n                to,\n                insert: view.state.toText(text)\n            }, null);\n            return true;\n        }\n    }\n    // Because Chrome Android doesn't fire useful key events, use\n    // beforeinput to detect backspace (and possibly enter and delete,\n    // but those usually don't even seem to fire beforeinput events at\n    // the moment) and fake a key event for it.\n    //\n    // (preventDefault on beforeinput, though supported in the spec,\n    // seems to do nothing at all on Chrome).\n    let pending;\n    if (browser.chrome && browser.android && (pending = PendingKeys.find((key)=>key.inputType == event.inputType))) {\n        view.observer.delayAndroidKey(pending.key, pending.keyCode);\n        if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n            let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;\n            setTimeout(()=>{\n                var _a;\n                // Backspacing near uneditable nodes on Chrome Android sometimes\n                // closes the virtual keyboard. This tries to crudely detect\n                // that and refocus to get it back.\n                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n                    view.contentDOM.blur();\n                    view.focus();\n                }\n            }, 100);\n        }\n    }\n    if (browser.ios && event.inputType == \"deleteContentForward\") {\n        // For some reason, DOM changes (and beforeinput) happen _before_\n        // the key event for ctrl-d on iOS when using an external\n        // keyboard.\n        view.observer.flushSoon();\n    }\n    // Safari will occasionally forget to fire compositionend at the end of a dead-key composition\n    if (browser.safari && event.inputType == \"insertText\" && view.inputState.composing >= 0) {\n        setTimeout(()=>observers.compositionend(view, event), 20);\n    }\n    return false;\n};\nconst appliedFirefoxHack = /*@__PURE__*/ new Set;\n// In Firefox, when cut/copy handlers are added to the document, that\n// somehow avoids a bug where those events aren't fired when the\n// selection is empty. See https://github.com/codemirror/dev/issues/1082\n// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961\nfunction firefoxCopyCutHack(doc) {\n    if (!appliedFirefoxHack.has(doc)) {\n        appliedFirefoxHack.add(doc);\n        doc.addEventListener(\"copy\", ()=>{});\n        doc.addEventListener(\"cut\", ()=>{});\n    }\n}\nconst wrappingWhiteSpace = [\n    \"pre-wrap\",\n    \"normal\",\n    \"pre-line\",\n    \"break-spaces\"\n];\n// Used to track, during updateHeight, if any actual heights changed\nlet heightChangeFlag = false;\nfunction clearHeightChangeFlag() {\n    heightChangeFlag = false;\n}\nclass HeightOracle {\n    constructor(lineWrapping){\n        this.lineWrapping = lineWrapping;\n        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n        this.heightSamples = {};\n        this.lineHeight = 14; // The height of an entire line (line-height)\n        this.charWidth = 7;\n        this.textHeight = 14; // The height of the actual font (font-size)\n        this.lineLength = 30;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping) return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) {\n        this.doc = doc;\n        return this;\n    }\n    mustRefreshForWrapping(whiteSpace) {\n        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;\n    }\n    mustRefreshForHeights(lineHeights) {\n        let newHeight = false;\n        for(let i = 0; i < lineHeights.length; i++){\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            } else if (!this.heightSamples[Math.floor(h * 10)]) {\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight;\n    }\n    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n        this.lineWrapping = lineWrapping;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.textHeight = textHeight;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for(let i = 0; i < knownHeights.length; i++){\n                let h = knownHeights[i];\n                if (h < 0) i++;\n                else this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights){\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() {\n        return this.index < this.heights.length;\n    }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/ class BlockInfo {\n    /**\n    @internal\n    */ constructor(/**\n    The start of the element in the document.\n    */ from, /**\n    The length of the element.\n    */ length, /**\n    The top position of the element (relative to the top of the\n    document).\n    */ top, /**\n    Its height.\n    */ height, /**\n    @internal Weird packed field that holds an array of children\n    for composite blocks, a decoration for block widgets, and a\n    number indicating the amount of widget-create line breaks for\n    text blocks.\n    */ _content){\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this._content = _content;\n    }\n    /**\n    The type of element this is. When querying lines, this may be\n    an array of all the blocks that make up the line.\n    */ get type() {\n        return typeof this._content == \"number\" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;\n    }\n    /**\n    The end of the element as a document position.\n    */ get to() {\n        return this.from + this.length;\n    }\n    /**\n    The bottom position of the element.\n    */ get bottom() {\n        return this.top + this.height;\n    }\n    /**\n    If this is a widget block, this will return the widget\n    associated with it.\n    */ get widget() {\n        return this._content instanceof PointDecoration ? this._content.widget : null;\n    }\n    /**\n    If this is a textblock, this holds the number of line breaks\n    that appear in widgets inside the block.\n    */ get widgetLineBreaks() {\n        return typeof this._content == \"number\" ? this._content : 0;\n    }\n    /**\n    @internal\n    */ join(other) {\n        let content = (Array.isArray(this._content) ? this._content : [\n            this\n        ]).concat(Array.isArray(other._content) ? other._content : [\n            other\n        ]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);\n    }\n}\nvar QueryType = /*@__PURE__*/ function(QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n    return QueryType;\n}(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n    constructor(length, height, flags = 2 /* Flag.Outdated */ ){\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() {\n        return (this.flags & 2 /* Flag.Outdated */ ) > 0;\n    }\n    set outdated(value) {\n        this.flags = (value ? 2 /* Flag.Outdated */  : 0) | this.flags & ~2 /* Flag.Outdated */ ;\n    }\n    setHeight(height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon) heightChangeFlag = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) {\n        result.push(this);\n    }\n    decomposeRight(_from, result) {\n        result.push(this);\n    }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this, doc = oracle.doc;\n        for(let i = changes.length - 1; i >= 0; i--){\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while(i > 0 && start.from <= changes[i - 1].toA){\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);\n            me = replace(me, me.replace(fromA, toA, nodes));\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() {\n        return new HeightMapText(0, 0);\n    }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1) return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for(;;){\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break) nodes.splice(--i, 1, split.left, null, split.right);\n                    else nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                } else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break) nodes.splice(j, 1, split.left, null, split.right);\n                    else nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                } else {\n                    break;\n                }\n            } else if (before < after) {\n                let next = nodes[i++];\n                if (next) before += next.size;\n            } else {\n                let next = nodes[--j];\n                if (next) after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        } else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nfunction replace(old, val) {\n    if (old == val) return old;\n    if (old.constructor != val.constructor) heightChangeFlag = true;\n    return val;\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, deco){\n        super(length, height);\n        this.deco = deco;\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);\n    }\n    lineAt(_value, _type, oracle, top, offset) {\n        return this.blockAt(0, oracle, top, offset);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `block(${this.length})`;\n    }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height){\n        super(length, height, null);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n        this.breaks = 0; // Number of widget-introduced line breaks on the line\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.breaks);\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */ ) && Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);\n            else node.height = this.height;\n            if (!this.outdated) node.outdated = false;\n            return node;\n        } else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);\n        else if (force || this.outdated) this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length){\n        super(length, 0);\n    }\n    heightMetrics(oracle, offset) {\n        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;\n        let lines = lastLine - firstLine + 1;\n        let perLine, perChar = 0;\n        if (oracle.lineWrapping) {\n            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);\n            perLine = totalPerLine / lines;\n            if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);\n        } else {\n            perLine = this.height / lines;\n        }\n        return {\n            firstLine,\n            lastLine,\n            perLine,\n            perChar\n        };\n    }\n    blockAt(height, oracle, top, offset) {\n        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        if (oracle.lineWrapping) {\n            let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));\n            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;\n            let lineTop = Math.max(top, height - lineHeight / 2);\n            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);\n        } else {\n            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));\n            let { from, length } = oracle.doc.line(firstLine + line);\n            return new BlockInfo(from, length, top + perLine * line, perLine, 0);\n        }\n    }\n    lineAt(value, type, oracle, top, offset) {\n        if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = oracle.doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, 0);\n        }\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;\n        let linesAbove = line.number - firstLine;\n        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);\n        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        from = Math.max(from, offset);\n        to = Math.min(to, offset + this.length);\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        for(let pos = from, lineTop = top; pos <= to;){\n            let line = oracle.doc.lineAt(pos);\n            if (pos == from) {\n                let linesAbove = line.number - firstLine;\n                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);\n            }\n            let lineHeight = perLine + perChar * line.length;\n            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));\n            lineTop += lineHeight;\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);\n            else nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;\n            if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while(pos <= end && measured.more){\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length) nodes.push(null);\n                let height = measured.heights[measured.index++];\n                if (singleHeight == -1) singleHeight = height;\n                else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n                let line = new HeightMapText(len, height);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            let result = HeightMap.of(nodes);\n            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) heightChangeFlag = true;\n            return replace(this, result);\n        } else if (force || this.outdated) {\n            this.setHeight(oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() {\n        return `gap(${this.length})`;\n    }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right){\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */  : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() {\n        return this.flags & 1 /* Flag.Break */ ;\n    }\n    blockAt(height, oracle, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, oracle, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));\n        else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);\n            if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);\n        } else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);\n            if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);\n            if (mid.to >= from && mid.from <= to) f(mid);\n            if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0) this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)result.push(node);\n        if (from > 0) mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left) return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left) result.push(null);\n        }\n        if (to > left) this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right) return this.right.decomposeRight(from - right, result);\n        if (from < left) this.left.decomposeRight(from, result);\n        if (this.break && from < right) result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [\n            left,\n            null,\n            right\n        ] : [\n            left,\n            right\n        ]);\n        this.left = replace(this.left, left);\n        this.right = replace(this.right, right);\n        this.setHeight(left.height + right.height);\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else right.updateHeight(oracle, rightStart, force);\n        if (rebalance) return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return this.left + (this.break ? \" \" : \"-\") + this.right;\n    }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle){\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText) last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? deco.widget.estimatedHeight : 0;\n            let breaks = deco.widget ? deco.widget.lineBreaks : 0;\n            if (height < 0) height = this.oracle.lineHeight;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco));\n            } else if (len || breaks || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, breaks, len);\n            }\n        } else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1) return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */ ;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText) return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        let deco = block.deco;\n        if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (deco && deco.endSide > 0) this.covering = block;\n    }\n    addLineDeco(height, breaks, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        line.breaks += breaks;\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes){\n            if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange() {}\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n    }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);\n    for(let parent = dom.parentNode; parent && parent != doc.body;){\n        if (parent.nodeType == 1) {\n            let elt = parent;\n            let style = window.getComputedStyle(elt);\n            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n                let parentRect = elt.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);\n            }\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n        } else if (parent.nodeType == 11) {\n            parent = parent.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        left: left - rect.left,\n        right: Math.max(left, right) - rect.left,\n        top: top - (rect.top + paddingTop),\n        bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n    };\n}\nfunction inWindow(elt) {\n    let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;\n    return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;\n}\nfunction fullPixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    return {\n        left: 0,\n        right: rect.right - rect.left,\n        top: paddingTop,\n        bottom: rect.bottom - (rect.top + paddingTop)\n    };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size, displaySize){\n        this.from = from;\n        this.to = to;\n        this.size = size;\n        this.displaySize = displaySize;\n    }\n    static same(a, b) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++){\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n        }\n        return true;\n    }\n    draw(viewState, wrapping) {\n        return Decoration.replace({\n            widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)\n        }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical){\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) {\n        return other.size == this.size && other.vertical == this.vertical;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        } else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() {\n        return this.vertical ? this.size : -1;\n    }\n}\nclass ViewState {\n    constructor(state){\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = {\n            left: 0,\n            right: window.innerWidth,\n            top: 0,\n            bottom: 0\n        };\n        this.inView = true;\n        this.paddingTop = 0; // Padding above the document, scaled\n        this.paddingBottom = 0; // Padding below the document, scaled\n        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width\n        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height\n        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled\n        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled\n        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled\n        this.scrolledToBottom = false;\n        // The CSS-transformation scale of the editor (transformed size /\n        // concrete size)\n        this.scaleX = 1;\n        this.scaleY = 1;\n        // The vertical position (document-relative) to which to anchor the\n        // scroll position. -1 means anchor to the end of the document.\n        this.scrollAnchorPos = 0;\n        // The height at the anchor position. Set by the DOM update phase.\n        // -1 means no height available.\n        this.scrollAnchorHeight = -1;\n        // See VP.MaxDOMHeight\n        this.scaler = IdScaler;\n        this.scrollTarget = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        // Flag set when editor content was redrawn, so that the next\n        // measure stage knows it must read DOM layout\n        this.mustMeasureContent = true;\n        this.defaultTextDirection = Direction.LTR;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be significant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        let guessWrapping = state.facet(contentAttributes).some((v)=>typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n        this.heightOracle = new HeightOracle(guessWrapping);\n        this.stateDeco = state.facet(decorations).filter((d)=>typeof d != \"function\");\n        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty, this.heightOracle.setDoc(state.doc), [\n            new ChangedRange(0, 0, 0, state.doc.length)\n        ]);\n        for(let i = 0; i < 2; i++){\n            this.viewport = this.getViewport(0, null);\n            if (!this.updateForViewport()) break;\n        }\n        this.updateViewportLines();\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap)=>gap.draw(this, false)));\n        this.computeVisibleRanges();\n    }\n    updateForViewport() {\n        let viewports = [\n            this.viewport\n        ], { main } = this.state.selection;\n        for(let i = 0; i <= 1; i++){\n            let pos = i ? main.head : main.anchor;\n            if (!viewports.some(({ from, to })=>pos >= from && pos <= to)) {\n                let { from, to } = this.lineBlockAt(pos);\n                viewports.push(new Viewport(from, to));\n            }\n        }\n        this.viewports = viewports.sort((a, b)=>a.from - b.from);\n        return this.updateScaler();\n    }\n    updateScaler() {\n        let scaler = this.scaler;\n        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */  ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);\n        return scaler.eq(this.scaler) ? 0 : 2 /* UpdateFlag.Height */ ;\n    }\n    updateViewportLines() {\n        this.viewportLines = [];\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block)=>{\n            this.viewportLines.push(scaleBlock(block, this.scaler));\n        });\n    }\n    update(update, scrollTarget = null) {\n        this.state = update.state;\n        let prevDeco = this.stateDeco;\n        this.stateDeco = this.state.facet(decorations).filter((d)=>typeof d != \"function\");\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n        clearHeightChangeFlag();\n        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight || heightChangeFlag) update.flags |= 2 /* UpdateFlag.Height */ ;\n        if (scrollAnchor) {\n            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);\n            this.scrollAnchorHeight = scrollAnchor.top;\n        } else {\n            this.scrollAnchorPos = -1;\n            this.scrollAnchorHeight = prevHeight;\n        }\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n        this.viewport = viewport;\n        update.flags |= this.updateForViewport();\n        if (viewportChange || !update.changes.empty || update.flags & 2 /* UpdateFlag.Height */ ) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        update.flags |= this.computeVisibleRanges(update.changes);\n        if (scrollTarget) this.scrollTarget = scrollTarget;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;\n    }\n    measure(view) {\n        let dom = view.contentDOM, style = window.getComputedStyle(dom);\n        let oracle = this.heightOracle;\n        let whiteSpace = style.whiteSpace;\n        this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\n        let domRect = dom.getBoundingClientRect();\n        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;\n        this.contentDOMHeight = domRect.height;\n        this.mustMeasureContent = false;\n        let result = 0, bias = 0;\n        if (domRect.width && domRect.height) {\n            let { scaleX, scaleY } = getScale(dom, domRect);\n            if (scaleX > .005 && Math.abs(this.scaleX - scaleX) > .005 || scaleY > .005 && Math.abs(this.scaleY - scaleY) > .005) {\n                this.scaleX = scaleX;\n                this.scaleY = scaleY;\n                result |= 16 /* UpdateFlag.Geometry */ ;\n                refresh = measureContent = true;\n            }\n        }\n        // Vertical padding\n        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;\n        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n            this.paddingTop = paddingTop;\n            this.paddingBottom = paddingBottom;\n            result |= 16 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ ;\n        }\n        if (this.editorWidth != view.scrollDOM.clientWidth) {\n            if (oracle.lineWrapping) measureContent = true;\n            this.editorWidth = view.scrollDOM.clientWidth;\n            result |= 16 /* UpdateFlag.Geometry */ ;\n        }\n        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;\n        if (this.scrollTop != scrollTop) {\n            this.scrollAnchorHeight = -1;\n            this.scrollTop = scrollTop;\n        }\n        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);\n        // Pixel viewport\n        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (inView != this.inView) {\n            this.inView = inView;\n            if (inView) measureContent = true;\n        }\n        if (!this.inView && !this.scrollTarget && !inWindow(view.dom)) return 0;\n        let contentWidth = domRect.width;\n        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n            this.contentDOMWidth = domRect.width;\n            this.editorHeight = view.scrollDOM.clientHeight;\n            result |= 16 /* UpdateFlag.Geometry */ ;\n        }\n        if (measureContent) {\n            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n            if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();\n                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);\n                if (refresh) {\n                    view.docView.minWidth = 0;\n                    result |= 16 /* UpdateFlag.Geometry */ ;\n                }\n            }\n            if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n            clearHeightChangeFlag();\n            for (let vp of this.viewports){\n                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty, this.heightOracle, [\n                    new ChangedRange(0, 0, 0, view.state.doc.length)\n                ]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n            }\n            if (heightChangeFlag) result |= 2 /* UpdateFlag.Height */ ;\n        }\n        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n        if (viewportChange) {\n            if (result & 2 /* UpdateFlag.Height */ ) result |= this.updateScaler();\n            this.viewport = this.getViewport(bias, this.scrollTarget);\n            result |= this.updateForViewport();\n        }\n        if (result & 2 /* UpdateFlag.Height */  || viewportChange) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n        result |= this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            view.docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    get visibleTop() {\n        return this.scaler.fromDOM(this.pixelViewport.top);\n    }\n    get visibleBottom() {\n        return this.scaler.fromDOM(this.pixelViewport.bottom);\n    }\n    getViewport(bias, scrollTarget) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */  / 2));\n        let map = this.heightMap, oracle = this.heightOracle;\n        let { visibleTop, visibleBottom } = this;\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).to);\n        // If scrollTarget is given, make sure the viewport includes that position\n        if (scrollTarget) {\n            let { head } = scrollTarget.range;\n            if (head < viewport.from || head > viewport.to) {\n                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;\n                if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;\n                else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;\n                else topPos = block.bottom - viewHeight;\n                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        if (!this.inView) return true;\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { visibleTop, visibleBottom } = this;\n        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */ , Math.min(-bias, 250 /* VP.MaxCoverMargin */ ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */ , Math.min(bias, 250 /* VP.MaxCoverMargin */ ))) && top > visibleTop - 2 * 1000 /* VP.Margin */  && bottom < visibleBottom + 2 * 1000 /* VP.Margin */ ;\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty) return gaps;\n        let mapped = [];\n        for (let gap of gaps)if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current, mayMeasure) {\n        let wrapping = this.heightOracle.lineWrapping;\n        let margin = wrapping ? 10000 /* LG.MarginWrap */  : 2000 /* LG.Margin */ , halfMargin = margin >> 1, doubleMargin = margin << 1;\n        // The non-wrapping logic won't work at all in predominantly right-to-left text.\n        if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];\n        let gaps = [];\n        let addGap = (from, to, line, structure)=>{\n            if (to - from < halfMargin) return;\n            let sel = this.state.selection.main, avoid = [\n                sel.from\n            ];\n            if (!sel.empty) avoid.push(sel.to);\n            for (let pos of avoid){\n                if (pos > from && pos < to) {\n                    addGap(from, pos - 10 /* LG.SelectionMargin */ , line, structure);\n                    addGap(pos + 10 /* LG.SelectionMargin */ , to, line, structure);\n                    return;\n                }\n            }\n            let gap = find(current, (gap)=>gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some((pos)=>gap.from < pos && gap.to > pos));\n            if (!gap) {\n                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n                if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r)=>r.from <= to && r.to >= to)) {\n                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(to), false, true).head;\n                    if (lineStart > from) to = lineStart;\n                }\n                let size = this.gapSize(line, from, to, structure);\n                let displaySize = wrapping || size < 2000000 /* VP.MaxHorizGap */  ? size : 2000000 /* VP.MaxHorizGap */ ;\n                gap = new LineGap(from, to, size, displaySize);\n            }\n            gaps.push(gap);\n        };\n        let checkLine = (line)=>{\n            if (line.length < doubleMargin || line.type != BlockType.Text) return;\n            let structure = lineStructure(line.from, line.to, this.stateDeco);\n            if (structure.total < doubleMargin) return;\n            let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n            let viewFrom, viewTo;\n            if (wrapping) {\n                let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;\n                let top, bot;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n                    top = targetFrac - spaceFrac;\n                    bot = targetFrac + spaceFrac;\n                } else {\n                    top = (this.visibleTop - line.top - marginHeight) / line.height;\n                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n                }\n                viewFrom = findPosition(structure, top);\n                viewTo = findPosition(structure, bot);\n            } else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                let marginWidth = margin * this.heightOracle.charWidth;\n                let horizOffset = 0;\n                if (totalWidth > 2000000 /* VP.MaxHorizGap */ ) for (let old of current){\n                    if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left) horizOffset = old.size - old.displaySize;\n                }\n                let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;\n                let left, right;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;\n                    left = targetFrac - spaceFrac;\n                    right = targetFrac + spaceFrac;\n                } else {\n                    left = (pxLeft - marginWidth) / totalWidth;\n                    right = (pxRight + marginWidth) / totalWidth;\n                }\n                viewFrom = findPosition(structure, left);\n                viewTo = findPosition(structure, right);\n            }\n            if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);\n            if (viewTo < line.to) addGap(viewTo, line.to, line, structure);\n        };\n        for (let line of this.viewportLines){\n            if (Array.isArray(line.type)) line.type.forEach(checkLine);\n            else checkLine(line);\n        }\n        return gaps;\n    }\n    gapSize(line, from, to, structure) {\n        let fraction = findFraction(structure, to) - findFraction(structure, from);\n        if (this.heightOracle.lineWrapping) {\n            return line.height * fraction;\n        } else {\n            return structure.total * this.heightOracle.charWidth * fraction;\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map((gap)=>gap.draw(this, this.heightOracle.lineWrapping)));\n        }\n    }\n    computeVisibleRanges(changes) {\n        let deco = this.stateDeco;\n        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span (from, to) {\n                ranges.push({\n                    from,\n                    to\n                });\n            },\n            point () {}\n        }, 20);\n        let changed = 0;\n        if (ranges.length != this.visibleRanges.length) {\n            changed = 8 /* UpdateFlag.ViewportMoved */  | 4 /* UpdateFlag.Viewport */ ;\n        } else {\n            for(let i = 0; i < ranges.length && !(changed & 8 /* UpdateFlag.ViewportMoved */ ); i++){\n                let old = this.visibleRanges[i], nw = ranges[i];\n                if (old.from != nw.from || old.to != nw.to) {\n                    changed |= 4 /* UpdateFlag.Viewport */ ;\n                    if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to)) changed |= 8 /* UpdateFlag.ViewportMoved */ ;\n                }\n            }\n        }\n        this.visibleRanges = ranges;\n        return changed;\n    }\n    lineBlockAt(pos) {\n        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b)=>b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);\n    }\n    lineBlockAtHeight(height) {\n        return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l)=>l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);\n    }\n    scrollAnchorAt(scrollTop) {\n        let block = this.lineBlockAtHeight(scrollTop + 8);\n        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];\n    }\n    elementAtHeight(height) {\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);\n    }\n    get docHeight() {\n        return this.scaler.toDOM(this.heightMap.height);\n    }\n    get contentHeight() {\n        return this.docHeight + this.paddingTop + this.paddingBottom;\n    }\n}\nclass Viewport {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\nfunction lineStructure(from, to, stateDeco) {\n    let ranges = [], pos = from, total = 0;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(stateDeco, from, to, {\n        span () {},\n        point (from, to) {\n            if (from > pos) {\n                ranges.push({\n                    from: pos,\n                    to: from\n                });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({\n            from: pos,\n            to\n        });\n        total += to - pos;\n    }\n    return {\n        total,\n        ranges\n    };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0) return ranges[0].from;\n    if (ratio >= 1) return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for(let i = 0;; i++){\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size) return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges){\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)if (f(val)) return val;\n    return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n    toDOM (n) {\n        return n;\n    },\n    fromDOM (n) {\n        return n;\n    },\n    scale: 1,\n    eq (other) {\n        return other == this;\n    }\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n    constructor(oracle, heightMap, viewports){\n        let vpHeight = 0, base = 0, domBase = 0;\n        this.viewports = viewports.map(({ from, to })=>{\n            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;\n            vpHeight += bottom - top;\n            return {\n                from,\n                to,\n                top,\n                bottom,\n                domTop: 0,\n                domBottom: 0\n            };\n        });\n        this.scale = (7000000 /* VP.MaxDOMHeight */  - vpHeight) / (heightMap.height - vpHeight);\n        for (let obj of this.viewports){\n            obj.domTop = domBase + (obj.top - base) * this.scale;\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n            base = obj.bottom;\n        }\n    }\n    toDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.top) return domBase + (n - base) * this.scale;\n            if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    fromDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;\n            if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    eq(other) {\n        if (!(other instanceof BigScaler)) return false;\n        return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i)=>vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);\n    }\n}\nfunction scaleBlock(block, scaler) {\n    if (scaler.scale == 1) return block;\n    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b)=>scaleBlock(b, scaler)) : block._content);\n}\nconst theme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (strs)=>strs.join(\" \")\n});\nconst darkTheme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.indexOf(true) > -1\n});\nconst baseThemeID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = {\n    \"&light\": \".\" + baseLightID,\n    \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n        finish (sel) {\n            return /&/.test(sel) ? sel.replace(/&\\w*/, (m)=>{\n                if (m == \"&\") return main;\n                if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n                return scopes[m];\n            }) : main + \" \" + sel;\n        }\n    });\n}\nconst baseTheme$1 = /*@__PURE__*/ buildTheme(\".\" + baseThemeID, {\n    \"&\": {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // Provide a simple default outline to make sure a focused\n            // editor is visually distinct. Can't leave the default behavior\n            // because that will apply to the content element, which is\n            // inside the scrollable container and doesn't include the\n            // gutters. We also can't use an 'auto' outline, since those\n            // are, for some reason, drawn behind the element content, which\n            // will cause things like the active line background to cover\n            // the outline (#297).\n            outline: \"1px dotted #212121\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    \".cm-scroller\": {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0,\n        overflowAnchor: \"none\"\n    },\n    \".cm-content\": {\n        margin: 0,\n        flexGrow: 2,\n        flexShrink: 0,\n        display: \"block\",\n        whiteSpace: \"pre\",\n        wordWrap: \"normal\",\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        \"&[contenteditable=true]\": {\n            WebkitUserModify: \"read-write-plaintext-only\"\n        }\n    },\n    \".cm-lineWrapping\": {\n        whiteSpace_fallback: \"pre-wrap\",\n        whiteSpace: \"break-spaces\",\n        wordBreak: \"break-word\",\n        overflowWrap: \"anywhere\",\n        flexShrink: 1\n    },\n    \"&light .cm-content\": {\n        caretColor: \"black\"\n    },\n    \"&dark .cm-content\": {\n        caretColor: \"white\"\n    },\n    \".cm-line\": {\n        display: \"block\",\n        padding: \"0 2px 0 6px\"\n    },\n    \".cm-layer\": {\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        contain: \"size style\",\n        \"& > *\": {\n            position: \"absolute\"\n        }\n    },\n    \"&light .cm-selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"&dark .cm-selectionBackground\": {\n        background: \"#222\"\n    },\n    \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#233\"\n    },\n    \".cm-cursorLayer\": {\n        pointerEvents: \"none\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \"@keyframes cm-blink2\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\"\n    },\n    \".cm-cursor\": {\n        display: \"none\"\n    },\n    \"&dark .cm-cursor\": {\n        borderLeftColor: \"#ddd\"\n    },\n    \".cm-dropCursor\": {\n        position: \"absolute\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n        display: \"block\"\n    },\n    \".cm-iso\": {\n        unicodeBidi: \"isolate\"\n    },\n    \".cm-announced\": {\n        position: \"fixed\",\n        top: \"-10000px\"\n    },\n    \"@media print\": {\n        \".cm-announced\": {\n            display: \"none\"\n        }\n    },\n    \"&light .cm-activeLine\": {\n        backgroundColor: \"#cceeff44\"\n    },\n    \"&dark .cm-activeLine\": {\n        backgroundColor: \"#99eeff33\"\n    },\n    \"&light .cm-specialChar\": {\n        color: \"red\"\n    },\n    \"&dark .cm-specialChar\": {\n        color: \"#f78\"\n    },\n    \".cm-gutters\": {\n        flexShrink: 0,\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        zIndex: 200\n    },\n    \".cm-gutters-before\": {\n        insetInlineStart: 0\n    },\n    \".cm-gutters-after\": {\n        insetInlineEnd: 0\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#6c6c6c\",\n        border: \"0px solid #ddd\",\n        \"&.cm-gutters-before\": {\n            borderRightWidth: \"1px\"\n        },\n        \"&.cm-gutters-after\": {\n            borderLeftWidth: \"1px\"\n        }\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    },\n    \".cm-panels\": {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0,\n        zIndex: 300\n    },\n    \"&light .cm-panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"&light .cm-panels-top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"&light .cm-panels-bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"&dark .cm-panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-dialog\": {\n        padding: \"2px 19px 4px 6px\",\n        position: \"relative\",\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    },\n    \".cm-dialog-close\": {\n        position: \"absolute\",\n        top: \"3px\",\n        right: \"4px\",\n        backgroundColor: \"inherit\",\n        border: \"none\",\n        font: \"inherit\",\n        fontSize: \"14px\",\n        padding: \"0\"\n    },\n    \".cm-tab\": {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    },\n    \".cm-widgetBuffer\": {\n        verticalAlign: \"text-top\",\n        height: \"1em\",\n        width: 0,\n        display: \"inline\"\n    },\n    \".cm-placeholder\": {\n        color: \"#888\",\n        display: \"inline-block\",\n        verticalAlign: \"top\",\n        userSelect: \"none\"\n    },\n    \".cm-highlightSpace\": {\n        backgroundImage: \"radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)\",\n        backgroundPosition: \"center\"\n    },\n    \".cm-highlightTab\": {\n        backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n        backgroundSize: \"auto 100%\",\n        backgroundPosition: \"right 90%\",\n        backgroundRepeat: \"no-repeat\"\n    },\n    \".cm-trailingSpace\": {\n        backgroundColor: \"#ff332255\"\n    },\n    \".cm-button\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"1px\"\n    },\n    \"&light .cm-button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"&dark .cm-button\": {\n        backgroundImage: \"linear-gradient(#393939, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    \".cm-textfield\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"&light .cm-textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"&dark .cm-textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n}, lightDarkIDs);\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    attributes: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view){\n        this.view = view;\n        this.active = false;\n        this.editContext = null;\n        // The known selection. Kept in our own object, as opposed to just\n        // directly accessing the selection because:\n        //  - Safari doesn't report the right selection in shadow DOM\n        //  - Reading from the selection forces a DOM layout\n        //  - This way, we can ignore selectionchange events if we have\n        //    already seen the 'new' selection\n        this.selectionRange = new DOMSelectionState;\n        // Set when a selection change is detected, cleared on flush\n        this.selectionChanged = false;\n        this.delayedFlush = -1;\n        this.resizeTimeout = -1;\n        this.queue = [];\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n        this.lastChange = 0;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.resizeScroll = null;\n        this.intersecting = false;\n        this.gapIntersection = null;\n        this.gaps = [];\n        this.printQuery = null;\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver((mutations)=>{\n            for (let mut of mutations)this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM.\n            //\n            // Unrelatedly, iOS Safari will, when ending a composition,\n            // sometimes first clear it, deliver the mutations, and then\n            // reinsert the finished text. CodeMirror's handling of the\n            // deletion will prevent the reinsertion from happening,\n            // breaking composition.\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (window.EditContext && browser.android && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)\n        !(browser.chrome && browser.chrome_version < 126)) {\n            this.editContext = new EditContextManager(view);\n            if (view.state.facet(editable)) view.contentDOM.editContext = this.editContext.editContext;\n        }\n        if (useCharData) this.onCharData = (event)=>{\n            this.queue.push({\n                target: event.target,\n                type: \"characterData\",\n                oldValue: event.prevValue\n            });\n            this.flushSoon();\n        };\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        this.onResize = this.onResize.bind(this);\n        this.onPrint = this.onPrint.bind(this);\n        this.onScroll = this.onScroll.bind(this);\n        if (window.matchMedia) this.printQuery = window.matchMedia(\"print\");\n        if (typeof ResizeObserver == \"function\") {\n            this.resizeScroll = new ResizeObserver(()=>{\n                var _a;\n                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();\n            });\n            this.resizeScroll.observe(view.scrollDOM);\n        }\n        this.addWindowListeners(this.win = view.win);\n        this.start();\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver((entries)=>{\n                if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {\n                threshold: [\n                    0,\n                    .001\n                ]\n            });\n            this.intersection.observe(this.dom);\n            this.gapIntersection = new IntersectionObserver((entries)=>{\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent(\"Event\"));\n            }, {});\n        }\n        this.listenForScroll();\n        this.readSelectionRange();\n    }\n    onScrollChanged(e) {\n        this.view.inputState.runHandlers(\"scroll\", e);\n        if (this.intersecting) this.view.measure();\n    }\n    onScroll(e) {\n        if (this.intersecting) this.flush(false);\n        if (this.editContext) this.view.requestMeasure(this.editContext.measureReq);\n        this.onScrollChanged(e);\n    }\n    onResize() {\n        if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(()=>{\n            this.resizeTimeout = -1;\n            this.view.requestMeasure();\n        }, 50);\n    }\n    onPrint(event) {\n        if ((event.type == \"change\" || !event.type) && !event.matches) return;\n        this.view.viewState.printing = true;\n        this.view.measure();\n        setTimeout(()=>{\n            this.view.viewState.printing = false;\n            this.view.requestMeasure();\n        }, 500);\n    }\n    updateGaps(gaps) {\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i)=>g != gaps[i]))) {\n            this.gapIntersection.disconnect();\n            for (let gap of gaps)this.gapIntersection.observe(gap);\n            this.gaps = gaps;\n        }\n    }\n    onSelectionChange(event) {\n        let wasChanged = this.selectionChanged;\n        if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n        let { view } = this, sel = this.selectionRange;\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel)) return;\n        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n        if (context && context.ignoreEvent(event)) {\n            if (!wasChanged) this.selectionChanged = false;\n            return;\n        }\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        // Chrome Android has a similar issue when backspacing out a\n        // selection (#645).\n        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)\n        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();\n        else this.flush(false);\n    }\n    readSelectionRange() {\n        let { view } = this;\n        // The Selection object is broken in shadow roots in Safari. See\n        // https://github.com/codemirror/dev/issues/414\n        let selection = getSelection(view.root);\n        if (!selection) return false;\n        let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;\n        if (!range || this.selectionRange.eq(range)) return false;\n        let local = hasSelection(this.dom, range);\n        // Detect the situation where the browser has, on focus, moved the\n        // selection to the start of the content element. Reset it to the\n        // position from the editor state.\n        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {\n            this.view.inputState.lastFocusTime = 0;\n            view.docView.updateSelection();\n            return false;\n        }\n        this.selectionRange.setRange(range);\n        if (local) this.selectionChanged = true;\n        return true;\n    }\n    setSelectionRange(anchor, head) {\n        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n        this.selectionChanged = false;\n    }\n    clearSelectionRange() {\n        this.selectionRange.set(null, 0, null, 0);\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for(let dom = this.dom; dom;){\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;\n                else if (!changed) changed = this.scrollTargets.slice(0, i);\n                if (changed) changed.push(dom);\n                dom = dom.assignedSlot || dom.parentNode;\n            } else if (dom.nodeType == 11) {\n                dom = dom.host;\n            } else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active) return f();\n        try {\n            this.stop();\n            return f();\n        } finally{\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active) return;\n        this.observer.observe(this.dom, observeOptions);\n        if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active) return;\n        this.active = false;\n        this.observer.disconnect();\n        if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    // Throw away any pending changes\n    clear() {\n        this.processRecords();\n        this.queue.length = 0;\n        this.selectionChanged = false;\n    }\n    // Chrome Android, especially in combination with GBoard, not only\n    // doesn't reliably fire regular key events, but also often\n    // surrounds the effect of enter or backspace with a bunch of\n    // composition events that, when interrupted, cause text duplication\n    // or other kinds of corruption. This hack makes the editor back off\n    // from handling DOM changes for a moment when such a key is\n    // detected (via beforeinput or keydown), and then tries to flush\n    // them or, if that has no effect, dispatches the given key.\n    delayAndroidKey(key, keyCode) {\n        var _a;\n        if (!this.delayedAndroidKey) {\n            let flush = ()=>{\n                let key = this.delayedAndroidKey;\n                if (key) {\n                    this.clearDelayedAndroidKey();\n                    this.view.inputState.lastKeyCode = key.keyCode;\n                    this.view.inputState.lastKeyTime = Date.now();\n                    let flushed = this.flush();\n                    if (!flushed && key.force) dispatchKey(this.dom, key.key, key.keyCode);\n                }\n            };\n            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n        }\n        // Since backspace beforeinput is sometimes signalled spuriously,\n        // Enter always takes precedence.\n        if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n            key,\n            keyCode,\n            // Only run the key handler when no changes are detected if\n            // this isn't coming right after another change, in which case\n            // it is probably part of a weird chain of updates, and should\n            // be ignored if it returns the DOM to its previous state.\n            force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n        };\n    }\n    clearDelayedAndroidKey() {\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(()=>{\n            this.delayedFlush = -1;\n            this.flush();\n        });\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            this.view.win.cancelAnimationFrame(this.delayedFlush);\n            this.delayedFlush = -1;\n        }\n        this.flush();\n    }\n    pendingRecords() {\n        for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    processRecords() {\n        let records = this.pendingRecords();\n        if (records.length) this.queue = [];\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records){\n            let range = this.readMutation(record);\n            if (!range) continue;\n            if (range.typeOver) typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            } else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        return {\n            from,\n            to,\n            typeOver\n        };\n    }\n    readChange() {\n        let { from, to, typeOver } = this.processRecords();\n        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n        if (from < 0 && !newSel) return null;\n        if (from > -1) this.lastChange = Date.now();\n        this.view.inputState.lastFocusTime = 0;\n        this.selectionChanged = false;\n        let change = new DOMChange(this.view, from, to, typeOver);\n        this.view.docView.domChanged = {\n            newSel: change.newSel ? change.newSel.main : null\n        };\n        return change;\n    }\n    // Apply pending changes, if any\n    flush(readSelection = true) {\n        // Completely hold off flushing when pending keys are setâ€”the code\n        // managing those will make sure processRecords is called and the\n        // view is resynchronized after\n        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;\n        if (readSelection) this.readSelectionRange();\n        let domChange = this.readChange();\n        if (!domChange) {\n            this.view.requestMeasure();\n            return false;\n        }\n        let startState = this.view.state;\n        let handled = applyDOMChange(this.view, domChange);\n        // The view wasn't updated but DOM/selection changes were seen. Reset the view.\n        if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main))) this.view.update([]);\n        return handled;\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec)) return null;\n        cView.markDirty(rec.type == \"attributes\");\n        if (rec.type == \"attributes\") cView.flags |= 4 /* ViewFlag.AttrsDirty */ ;\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return {\n                from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n                typeOver: false\n            };\n        } else if (rec.type == \"characterData\") {\n            return {\n                from: cView.posAtStart,\n                to: cView.posAtEnd,\n                typeOver: rec.target.nodeValue == rec.oldValue\n            };\n        } else {\n            return null;\n        }\n    }\n    setWindow(win) {\n        if (win != this.win) {\n            this.removeWindowListeners(this.win);\n            this.win = win;\n            this.addWindowListeners(this.win);\n        }\n    }\n    addWindowListeners(win) {\n        win.addEventListener(\"resize\", this.onResize);\n        if (this.printQuery) {\n            if (this.printQuery.addEventListener) this.printQuery.addEventListener(\"change\", this.onPrint);\n            else this.printQuery.addListener(this.onPrint);\n        } else win.addEventListener(\"beforeprint\", this.onPrint);\n        win.addEventListener(\"scroll\", this.onScroll);\n        win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    removeWindowListeners(win) {\n        win.removeEventListener(\"scroll\", this.onScroll);\n        win.removeEventListener(\"resize\", this.onResize);\n        if (this.printQuery) {\n            if (this.printQuery.removeEventListener) this.printQuery.removeEventListener(\"change\", this.onPrint);\n            else this.printQuery.removeListener(this.onPrint);\n        } else win.removeEventListener(\"beforeprint\", this.onPrint);\n        win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    update(update) {\n        if (this.editContext) {\n            this.editContext.update(update);\n            if (update.startState.facet(editable) != update.state.facet(editable)) update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;\n        }\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.stop();\n        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n        for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n        this.removeWindowListeners(this.win);\n        clearTimeout(this.parentCheck);\n        clearTimeout(this.resizeTimeout);\n        this.win.cancelAnimationFrame(this.delayedFlush);\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        if (this.editContext) {\n            this.view.contentDOM.editContext = null;\n            this.editContext.destroy();\n        }\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while(dom){\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView) return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\nfunction buildSelectionRangeFromRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range) return buildSelectionRangeFromRange(view, range);\n    }\n    let found = null;\n    // Because Safari (at least in 2018-2021) doesn't provide regular\n    // access to the selection inside a shadowroot, we have to perform a\n    // ridiculous hack to get at itâ€”using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\n    view.dom.ownerDocument.execCommand(\"indent\");\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n    return found ? buildSelectionRangeFromRange(view, found) : null;\n}\nclass EditContextManager {\n    constructor(view){\n        // The document window for which the text in the context is\n        // maintained. For large documents, this may be smaller than the\n        // editor document. This window always includes the selection head.\n        this.from = 0;\n        this.to = 0;\n        // When applying a transaction, this is used to compare the change\n        // made to the context content to the change in the transaction in\n        // order to make the minimal changes to the context (since touching\n        // that sometimes breaks series of multiple edits made for a single\n        // user action on some Android keyboards)\n        this.pendingContextChange = null;\n        this.handlers = Object.create(null);\n        // Kludge to work around the fact that EditContext does not respond\n        // well to having its content updated during a composition (see #1472)\n        this.composing = null;\n        this.resetRange(view.state);\n        let context = this.editContext = new window.EditContext({\n            text: view.state.doc.sliceString(this.from, this.to),\n            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),\n            selectionEnd: this.toContextPos(view.state.selection.main.head)\n        });\n        this.handlers.textupdate = (e)=>{\n            let main = view.state.selection.main, { anchor, head } = main;\n            let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);\n            if (view.inputState.composing >= 0 && !this.composing) this.composing = {\n                contextBase: e.updateRangeStart,\n                editorBase: from,\n                drifted: false\n            };\n            let deletes = to - from > e.text.length;\n            // If the window doesn't include the anchor, assume changes\n            // adjacent to a side go up to the anchor.\n            if (from == this.from && anchor < this.from) from = anchor;\n            else if (to == this.to && anchor > this.to) to = anchor;\n            let diff = findDiff(view.state.sliceDoc(from, to), e.text, (deletes ? main.from : main.to) - from, deletes ? \"end\" : null);\n            // Edit contexts sometimes fire empty changes\n            if (!diff) {\n                let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));\n                if (!newSel.main.eq(main)) view.dispatch({\n                    selection: newSel,\n                    userEvent: \"select\"\n                });\n                return;\n            }\n            let change = {\n                from: diff.from + from,\n                to: diff.toA + from,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of(e.text.slice(diff.from, diff.toB).split(\"\\n\"))\n            };\n            if ((browser.mac || browser.android) && change.from == head - 1 && /^\\. ?$/.test(e.text) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") change = {\n                from,\n                to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([\n                    e.text.replace(\".\", \" \")\n                ])\n            };\n            this.pendingContextChange = change;\n            if (!view.state.readOnly) {\n                let newLen = this.to - this.from + (change.to - change.from + change.insert.length);\n                applyDOMChangeInner(view, change, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));\n            }\n            // If the transaction didn't flush our change, revert it so\n            // that the context is in sync with the editor state again.\n            if (this.pendingContextChange) {\n                this.revertPending(view.state);\n                this.setSelection(view.state);\n            }\n            // Work around missed compositionend events. See https://discuss.codemirror.net/t/a/9514\n            if (change.from < change.to && !change.insert.length && view.inputState.composing >= 0 && !/[\\\\p{Alphabetic}\\\\p{Number}_]/.test(context.text.slice(Math.max(0, e.updateRangeStart - 1), Math.min(context.text.length, e.updateRangeStart + 1)))) this.handlers.compositionend(e);\n        };\n        this.handlers.characterboundsupdate = (e)=>{\n            let rects = [], prev = null;\n            for(let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++){\n                let rect = view.coordsForChar(i);\n                prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect;\n                rects.push(prev);\n            }\n            context.updateCharacterBounds(e.rangeStart, rects);\n        };\n        this.handlers.textformatupdate = (e)=>{\n            let deco = [];\n            for (let format of e.getTextFormats()){\n                let lineStyle = format.underlineStyle, thickness = format.underlineThickness;\n                if (!/none/i.test(lineStyle) && !/none/i.test(thickness)) {\n                    let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);\n                    if (from < to) {\n                        // These values changed from capitalized custom strings to lower-case CSS keywords in 2025\n                        let style = `text-decoration: underline ${/^[a-z]/.test(lineStyle) ? lineStyle + \" \" : lineStyle == \"Dashed\" ? \"dashed \" : lineStyle == \"Squiggle\" ? \"wavy \" : \"\"}${/thin/i.test(thickness) ? 1 : 2}px`;\n                        deco.push(Decoration.mark({\n                            attributes: {\n                                style\n                            }\n                        }).range(from, to));\n                    }\n                }\n            }\n            view.dispatch({\n                effects: setEditContextFormatting.of(Decoration.set(deco))\n            });\n        };\n        this.handlers.compositionstart = ()=>{\n            if (view.inputState.composing < 0) {\n                view.inputState.composing = 0;\n                view.inputState.compositionFirstChange = true;\n            }\n        };\n        this.handlers.compositionend = ()=>{\n            view.inputState.composing = -1;\n            view.inputState.compositionFirstChange = null;\n            if (this.composing) {\n                let { drifted } = this.composing;\n                this.composing = null;\n                if (drifted) this.reset(view.state);\n            }\n        };\n        for(let event in this.handlers)context.addEventListener(event, this.handlers[event]);\n        this.measureReq = {\n            read: (view)=>{\n                this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());\n                let sel = getSelection(view.root);\n                if (sel && sel.rangeCount) this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());\n            }\n        };\n    }\n    applyEdits(update) {\n        let off = 0, abort = false, pending = this.pendingContextChange;\n        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert)=>{\n            if (abort) return;\n            let dLen = insert.length - (toA - fromA);\n            if (pending && toA >= pending.to) {\n                if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert)) {\n                    pending = this.pendingContextChange = null; // Match\n                    off += dLen;\n                    this.to += dLen;\n                    return;\n                } else {\n                    pending = null;\n                    this.revertPending(update.state);\n                }\n            }\n            fromA += off;\n            toA += off;\n            if (toA <= this.from) {\n                this.from += dLen;\n                this.to += dLen;\n            } else if (fromA < this.to) {\n                if (fromA < this.from || toA > this.to || this.to - this.from + insert.length > 30000 /* CxVp.MaxSize */ ) {\n                    abort = true;\n                    return;\n                }\n                this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());\n                this.to += dLen;\n            }\n            off += dLen;\n        });\n        if (pending && !abort) this.revertPending(update.state);\n        return !abort;\n    }\n    update(update) {\n        let reverted = this.pendingContextChange, startSel = update.startState.selection.main;\n        if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr)=>!tr.isUserEvent(\"input.type\") && tr.changes.touchesRange(this.from, this.to)))) {\n            this.composing.drifted = true;\n            this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);\n        } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {\n            this.pendingContextChange = null;\n            this.reset(update.state);\n        } else if (update.docChanged || update.selectionSet || reverted) {\n            this.setSelection(update.state);\n        }\n        if (update.geometryChanged || update.docChanged || update.selectionSet) update.view.requestMeasure(this.measureReq);\n    }\n    resetRange(state) {\n        let { head } = state.selection.main;\n        this.from = Math.max(0, head - 10000 /* CxVp.Margin */ );\n        this.to = Math.min(state.doc.length, head + 10000 /* CxVp.Margin */ );\n    }\n    reset(state) {\n        this.resetRange(state);\n        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));\n        this.setSelection(state);\n    }\n    revertPending(state) {\n        let pending = this.pendingContextChange;\n        this.pendingContextChange = null;\n        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));\n    }\n    setSelection(state) {\n        let { main } = state.selection;\n        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));\n        let end = this.toContextPos(main.head);\n        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end) this.editContext.updateSelection(start, end);\n    }\n    rangeIsValid(state) {\n        let { head } = state.selection.main;\n        return !(this.from > 0 && head - this.from < 500 /* CxVp.MinMargin */  || this.to < state.doc.length && this.to - head < 500 /* CxVp.MinMargin */  || this.to - this.from > 10000 /* CxVp.Margin */  * 3);\n    }\n    toEditorPos(contextPos, clipLen = this.to - this.from) {\n        contextPos = Math.min(contextPos, clipLen);\n        let c = this.composing;\n        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;\n    }\n    toContextPos(editorPos) {\n        let c = this.composing;\n        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;\n    }\n    destroy() {\n        for(let event in this.handlers)this.editContext.removeEventListener(event, this.handlers[event]);\n    }\n}\n// The editor's update state machine looks something like this:\n//\n//     Idle â†’ Updating â‡† Idle (unchecked) â†’ Measuring â†’ Idle\n//                                         â†‘      â†“\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/ class EditorView {\n    /**\n    The current editor state.\n    */ get state() {\n        return this.viewState.state;\n    }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */ get viewport() {\n        return this.viewState.viewport;\n    }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */ get visibleRanges() {\n        return this.viewState.visibleRanges;\n    }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */ get inView() {\n        return this.viewState.inView;\n    }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n    one change has been made in the current composition.\n    */ get composing() {\n        return !!this.inputState && this.inputState.composing > 0;\n    }\n    /**\n    Indicates whether the user is currently in composing state. Note\n    that on some platforms, like Android, this will be the case a\n    lot, since just putting the cursor on a word starts a\n    composition there.\n    */ get compositionStarted() {\n        return !!this.inputState && this.inputState.composing >= 0;\n    }\n    /**\n    The document or shadow root that the view lives in.\n    */ get root() {\n        return this._root;\n    }\n    /**\n    @internal\n    */ get win() {\n        return this.dom.ownerDocument.defaultView || window;\n    }\n    /**\n    Construct a new view. You'll want to either provide a `parent`\n    option, or put `view.dom` into your document after creating a\n    view, so that the user can see the editor.\n    */ constructor(config = {}){\n        var _a;\n        this.plugins = [];\n        this.pluginMap = new Map;\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        this.destroyed = false;\n        /**\n        @internal\n        */ this.updateState = 2 /* UpdateState.Updating */ ;\n        /**\n        @internal\n        */ this.measureScheduled = -1;\n        /**\n        @internal\n        */ this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.tabIndex = -1;\n        this.scrollDOM.className = \"cm-scroller\";\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.announceDOM = document.createElement(\"div\");\n        this.announceDOM.className = \"cm-announced\";\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.announceDOM);\n        this.dom.appendChild(this.scrollDOM);\n        if (config.parent) config.parent.appendChild(this.dom);\n        let { dispatch } = config;\n        this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs)=>trs.forEach((tr)=>dispatch(tr, this))) || ((trs)=>this.update(trs));\n        this.dispatch = this.dispatch.bind(this);\n        this._root = config.root || getRoot(config.parent) || document;\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.create(config));\n        if (config.scrollTo && config.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);\n        this.plugins = this.state.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n        for (let plugin of this.plugins)plugin.update(this);\n        this.observer = new DOMObserver(this);\n        this.inputState = new InputState(this);\n        this.inputState.ensureHandlers(this.plugins);\n        this.docView = new DocView(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* UpdateState.Idle */ ;\n        this.requestMeasure();\n        if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready) document.fonts.ready.then(()=>this.requestMeasure());\n    }\n    dispatch(...input) {\n        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [\n            this.state.update(...input)\n        ];\n        this.dispatchTransactions(trs, this);\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */ update(transactions) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, attrsChanged = false, update;\n        let state = this.state;\n        for (let tr of transactions){\n            if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n            state = tr.state;\n        }\n        if (this.destroyed) {\n            this.viewState.state = state;\n            return;\n        }\n        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;\n        if (transactions.some((tr)=>tr.annotation(isFocusChange))) {\n            this.inputState.notifiedFocused = focus;\n            // If a focus-change transaction is being dispatched, set this update flag.\n            focusFlag = 1 /* UpdateFlag.Focus */ ;\n        } else if (focus != this.inputState.notifiedFocused) {\n            this.inputState.notifiedFocused = focus;\n            // Schedule a separate focus transaction if necessary, otherwise\n            // add a flag to this update\n            dispatchFocus = focusChangeTransaction(state, focus);\n            if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */ ;\n        }\n        // If there was a pending DOM change, eagerly read it and try to\n        // apply it after the given transactions.\n        let pendingKey = this.observer.delayedAndroidKey, domChange = null;\n        if (pendingKey) {\n            this.observer.clearDelayedAndroidKey();\n            domChange = this.observer.readChange();\n            // Only try to apply DOM changes if the transactions didn't\n            // change the doc or selection.\n            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;\n        } else {\n            this.observer.clear();\n        }\n        // When the phrases change, redraw the editor\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.phrases)) return this.setState(state);\n        update = ViewUpdate.create(this, state, transactions);\n        update.flags |= focusFlag;\n        let scrollTarget = this.viewState.scrollTarget;\n        try {\n            this.updateState = 2 /* UpdateState.Updating */ ;\n            for (let tr of transactions){\n                if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n                if (tr.scrollIntoView) {\n                    let { main } = tr.state.selection;\n                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n                }\n                for (let e of tr.effects)if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state);\n            }\n            this.viewState.update(update, scrollTarget);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty) {\n                this.updatePlugins(update);\n                this.inputState.update(update);\n            }\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n            attrsChanged = this.updateAttrs();\n            this.showAnnouncements(transactions);\n            this.docView.updateSelection(redrawn, transactions.some((tr)=>tr.isUserEvent(\"select.pointer\")));\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;\n        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();\n        if (redrawn) this.docViewUpdate();\n        if (!update.empty) for (let listener of this.state.facet(updateListener)){\n            try {\n                listener(update);\n            } catch (e) {\n                logException(this.state, e, \"update listener\");\n            }\n        }\n        if (dispatchFocus || domChange) Promise.resolve().then(()=>{\n            if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);\n            if (domChange) {\n                if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n            }\n        });\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */ setState(newState) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        if (this.destroyed) {\n            this.viewState.state = newState;\n            return;\n        }\n        this.updateState = 2 /* UpdateState.Updating */ ;\n        let hadFocus = this.hasFocus;\n        try {\n            for (let plugin of this.plugins)plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n            this.pluginMap.clear();\n            for (let plugin of this.plugins)plugin.update(this);\n            this.docView.destroy();\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this.plugins);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (hadFocus) this.focus();\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs){\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                } else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)if (plugin.mustUpdate != update) plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.pluginMap.clear();\n        } else {\n            for (let p of this.plugins)p.mustUpdate = update;\n        }\n        for(let i = 0; i < this.plugins.length; i++)this.plugins[i].update(this);\n        if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);\n    }\n    docViewUpdate() {\n        for (let plugin of this.plugins){\n            let val = plugin.value;\n            if (val && val.docViewUpdate) {\n                try {\n                    val.docViewUpdate(this);\n                } catch (e) {\n                    logException(this.state, e, \"doc view update listener\");\n                }\n            }\n        }\n    }\n    /**\n    @internal\n    */ measure(flush = true) {\n        if (this.destroyed) return;\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        if (this.observer.delayedAndroidKey) {\n            this.measureScheduled = -1;\n            this.requestMeasure();\n            return;\n        }\n        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n        if (flush) this.observer.forceFlush();\n        let updated = null;\n        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;\n        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;\n        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;\n        this.viewState.scrollAnchorHeight = -1;\n        try {\n            for(let i = 0;; i++){\n                if (scrollAnchorHeight < 0) {\n                    if (isScrolledToBottom(sDOM)) {\n                        scrollAnchorPos = -1;\n                        scrollAnchorHeight = this.viewState.heightMap.height;\n                    } else {\n                        let block = this.viewState.scrollAnchorAt(scrollTop);\n                        scrollAnchorPos = block.from;\n                        scrollAnchorHeight = block.top;\n                    }\n                }\n                this.updateState = 1 /* UpdateState.Measuring */ ;\n                let changed = this.viewState.measure(this);\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n                if (i > 5) {\n                    console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n                    break;\n                }\n                let measuring = [];\n                // Only run measure requests in this cycle when the viewport didn't change\n                if (!(changed & 4 /* UpdateFlag.Viewport */ )) [this.measureRequests, measuring] = [\n                    measuring,\n                    this.measureRequests\n                ];\n                let measured = measuring.map((m)=>{\n                    try {\n                        return m.read(this);\n                    } catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = ViewUpdate.create(this, this.state, []), redrawn = false;\n                update.flags |= changed;\n                if (!updated) updated = update;\n                else updated.flags |= changed;\n                this.updateState = 2 /* UpdateState.Updating */ ;\n                if (!update.empty) {\n                    this.updatePlugins(update);\n                    this.inputState.update(update);\n                    this.updateAttrs();\n                    redrawn = this.docView.update(update);\n                    if (redrawn) this.docViewUpdate();\n                }\n                for(let i = 0; i < measuring.length; i++)if (measured[i] != BadMeasure) {\n                    try {\n                        let m = measuring[i];\n                        if (m.write) m.write(measured[i], this);\n                    } catch (e) {\n                        logException(this.state, e);\n                    }\n                }\n                if (redrawn) this.docView.updateSelection(true);\n                if (!update.viewportChanged && this.measureRequests.length == 0) {\n                    if (this.viewState.editorHeight) {\n                        if (this.viewState.scrollTarget) {\n                            this.docView.scrollIntoView(this.viewState.scrollTarget);\n                            this.viewState.scrollTarget = null;\n                            scrollAnchorHeight = -1;\n                            continue;\n                        } else {\n                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;\n                            let diff = newAnchorHeight - scrollAnchorHeight;\n                            if (diff > 1 || diff < -1) {\n                                scrollTop = scrollTop + diff;\n                                sDOM.scrollTop = scrollTop / this.scaleY;\n                                scrollAnchorHeight = -1;\n                                continue;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n            this.measureScheduled = -1;\n        }\n        if (updated && !updated.empty) for (let listener of this.state.facet(updateListener))listener(updated);\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */ get themeClasses() {\n        return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = attrsFromFacet(this, editorAttributes, {\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        let contentAttrs = {\n            spellcheck: \"false\",\n            autocorrect: \"off\",\n            autocapitalize: \"off\",\n            writingsuggestions: \"false\",\n            translate: \"no\",\n            contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n            class: \"cm-content\",\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        };\n        if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n        attrsFromFacet(this, contentAttributes, contentAttrs);\n        let changed = this.observer.ignore(()=>{\n            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n            return changedContent || changedEditor;\n        });\n        this.editorAttrs = editorAttrs;\n        this.contentAttrs = contentAttrs;\n        return changed;\n    }\n    showAnnouncements(trs) {\n        let first = true;\n        for (let tr of trs)for (let effect of tr.effects)if (effect.is(EditorView.announce)) {\n            if (first) this.announceDOM.textContent = \"\";\n            first = false;\n            let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n            div.textContent = effect.value;\n        }\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        let nonce = this.state.facet(EditorView.cspNonce);\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {\n            nonce\n        } : undefined);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* UpdateState.Updating */ ) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* UpdateState.Idle */  && this.measureScheduled > -1) this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */ requestMeasure(request) {\n        if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(()=>this.measure());\n        if (request) {\n            if (this.measureRequests.indexOf(request) > -1) return;\n            if (request.key != null) for(let i = 0; i < this.measureRequests.length; i++){\n                if (this.measureRequests[i].key === request.key) {\n                    this.measureRequests[i] = request;\n                    return;\n                }\n            }\n            this.measureRequests.push(request);\n        }\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */ plugin(plugin) {\n        let known = this.pluginMap.get(plugin);\n        if (known === undefined || known && known.plugin != plugin) this.pluginMap.set(plugin, known = this.plugins.find((p)=>p.plugin == plugin) || null);\n        return known && known.update(this).value;\n    }\n    /**\n    The top position of the document, in screen coordinates. This\n    may be negative when the editor is scrolled down. Points\n    directly to the top of the first line, not above the padding.\n    */ get documentTop() {\n        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n    }\n    /**\n    Reports the padding above and below the document.\n    */ get documentPadding() {\n        return {\n            top: this.viewState.paddingTop,\n            bottom: this.viewState.paddingBottom\n        };\n    }\n    /**\n    If the editor is transformed with CSS, this provides the scale\n    along the X axis. Otherwise, it will just be 1. Note that\n    transforms other than translation and scaling are not supported.\n    */ get scaleX() {\n        return this.viewState.scaleX;\n    }\n    /**\n    Provide the CSS transformed scale along the Y axis.\n    */ get scaleY() {\n        return this.viewState.scaleY;\n    }\n    /**\n    Find the text line or block widget at the given vertical\n    position (which is interpreted as relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n    */ elementAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.elementAtHeight(height);\n    }\n    /**\n    Find the line block (see\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given\n    height, again interpreted relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n    */ lineBlockAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.lineBlockAtHeight(height);\n    }\n    /**\n    Get the extent and vertical position of all [line\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n    are relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n    */ get viewportLineBlocks() {\n        return this.viewState.viewportLines;\n    }\n    /**\n    Find the line block around the given document position. A line\n    block is a range delimited on both sides by either a\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the\n    start/end of the document. It will usually just hold a line of\n    text, but may be broken into multiple textblocks by block\n    widgets.\n    */ lineBlockAt(pos) {\n        return this.viewState.lineBlockAt(pos);\n    }\n    /**\n    The editor's total content height.\n    */ get contentHeight() {\n        return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. In\n    bidirectional text, the line is traversed in visual order, using\n    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n    When the start position was the last one on the line, the\n    returned position will be across the line break. If there is no\n    further line, the original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */ moveByChar(start, forward, by) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */ moveByGroup(start, forward) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, (initial)=>byGroup(this, start.head, initial)));\n    }\n    /**\n    Get the cursor position visually at the start or end of a line.\n    Note that this may differ from the _logical_ position at its\n    start or end (which is simply at `line.from`/`line.to`) if text\n    at the start or end goes against the line's base text direction.\n    */ visualLineSide(line, end) {\n        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);\n        let span = order[end ? order.length - 1 : 0];\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */ moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */ moveVertically(start, forward, distance) {\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    \n    Note that for positions that aren't currently in\n    `visibleRanges`, the resulting DOM position isn't necessarily\n    meaningful (it may just point before or after a placeholder\n    element).\n    */ domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */ posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    posAtCoords(coords, precise = true) {\n        this.readMeasured();\n        return posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */ coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right) return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n    }\n    /**\n    Return the rectangle around a given character. If `pos` does not\n    point in front of a character that is in the viewport and\n    rendered (i.e. not replaced, not a line break), this will return\n    null. For space characters that are a line wrap point, this will\n    return the position before the line break.\n    */ coordsForChar(pos) {\n        this.readMeasured();\n        return this.docView.coordsForChar(pos);\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */ get defaultCharacterWidth() {\n        return this.viewState.heightOracle.charWidth;\n    }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */ get defaultLineHeight() {\n        return this.viewState.heightOracle.lineHeight;\n    }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor's content element.\n    */ get textDirection() {\n        return this.viewState.defaultTextDirection;\n    }\n    /**\n    Find the text direction of the block at the given position, as\n    assigned by CSS. If\n    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n    isn't enabled, or the given position is outside of the viewport,\n    this will always return the same as\n    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n    this may trigger a DOM layout.\n    */ textDirectionAt(pos) {\n        let perLine = this.state.facet(perLineTextDirection);\n        if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;\n        this.readMeasured();\n        return this.docView.textDirectionAt(pos);\n    }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */ get lineWrapping() {\n        return this.viewState.heightOracle.lineWrapping;\n    }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */ bidiSpans(line) {\n        if (line.length > MaxBidiLine) return trivialOrder(line.length);\n        let dir = this.textDirectionAt(line.from), isolates;\n        for (let entry of this.bidiCache){\n            if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;\n        }\n        if (!isolates) isolates = getIsolatedRanges(this, line);\n        let order = computeOrder(line.text, dir, isolates);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));\n        return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */ get hasFocus() {\n        var _a;\n        // Safari return false for hasFocus when the context menu is open\n        // or closing, which leads us to ignore selection changes from the\n        // context menu because it looks like the editor isn't focused.\n        // This kludges around that.\n        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */ focus() {\n        this.observer.ignore(()=>{\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /**\n    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n    necessary when moving the editor's existing DOM to a new window or shadow root.\n    */ setRoot(root) {\n        if (this._root != root) {\n            this._root = root;\n            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n            this.mountStyles();\n        }\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */ destroy() {\n        if (this.root.activeElement == this.contentDOM) this.contentDOM.blur();\n        for (let plugin of this.plugins)plugin.destroy(this);\n        this.plugins = [];\n        this.inputState.destroy();\n        this.docView.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        this.destroyed = true;\n    }\n    /**\n    Returns an effect that can be\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n    cause it to scroll the given position or range into view.\n    */ static scrollIntoView(pos, options = {}) {\n        return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n    }\n    /**\n    Return an effect that resets the editor to its current (at the\n    time this method was called) scroll position. Note that this\n    only affects the editor's own scrollable element, not parents.\n    See also\n    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).\n    \n    The effect should be used with a document identical to the one\n    it was created for. Failing to do so is not an error, but may\n    not scroll to the expected position. You can\n    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.\n    */ scrollSnapshot() {\n        let { scrollTop, scrollLeft } = this.scrollDOM;\n        let ref = this.viewState.scrollAnchorAt(scrollTop);\n        return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(ref.from), \"start\", \"start\", ref.top - scrollTop, scrollLeft, true));\n    }\n    /**\n    Enable or disable tab-focus mode, which disables key bindings\n    for Tab and Shift-Tab, letting the browser's default\n    focus-changing behavior go through instead. This is useful to\n    prevent trapping keyboard users in your editor.\n    \n    Without argument, this toggles the mode. With a boolean, it\n    enables (true) or disables it (false). Given a number, it\n    temporarily enables the mode until that number of milliseconds\n    have passed or another non-Tab key is pressed.\n    */ setTabFocusMode(to) {\n        if (to == null) this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;\n        else if (typeof to == \"boolean\") this.inputState.tabFocusMode = to ? 0 : -1;\n        else if (this.inputState.tabFocusMode != 0) this.inputState.tabFocusMode = Date.now() + to;\n    }\n    /**\n    Returns an extension that can be used to add DOM event handlers.\n    The value should be an object mapping event names to handler\n    functions. For any given event, such functions are ordered by\n    extension precedence, and the first handler to return true will\n    be assumed to have handled that event, and no other handlers or\n    built-in behavior will be activated for it. These are registered\n    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n    for `scroll` handlers, which will be called any time the\n    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n    its parent nodes is scrolled.\n    */ static domEventHandlers(handlers) {\n        return ViewPlugin.define(()=>({}), {\n            eventHandlers: handlers\n        });\n    }\n    /**\n    Create an extension that registers DOM event observers. Contrary\n    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),\n    observers can't be prevented from running by a higher-precedence\n    handler returning true. They also don't prevent other handlers\n    and observers from running when they return true, and should not\n    call `preventDefault`.\n    */ static domEventObservers(observers) {\n        return ViewPlugin.define(()=>({}), {\n            eventObservers: observers\n        });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be\n    addedâ€”need to be explicitly differentiated by adding an `&` to\n    the selector for that elementâ€”for example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */ static theme(spec, options) {\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n        let result = [\n            theme.of(prefix),\n            styleModule.of(buildTheme(`.${prefix}`, spec))\n        ];\n        if (options && options.dark) result.push(darkTheme.of(true));\n        return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */ static baseTheme(spec) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n    /**\n    Retrieve an editor view instance from the view's DOM\n    representation.\n    */ static findFromDOM(dom) {\n        var _a;\n        let content = dom.querySelector(\".cm-content\");\n        let cView = content && ContentView.get(content) || ContentView.get(dom);\n        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\n    }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/ EditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n\nThe `insert` argument can be used to get the default transaction\nthat would be applied for this input. This can be useful when\ndispatching the custom behavior as a separate transaction.\n*/ EditorView.inputHandler = inputHandler;\n/**\nFunctions provided in this facet will be used to transform text\npasted or dropped into the editor.\n*/ EditorView.clipboardInputFilter = clipboardInputFilter;\n/**\nTransform text copied or dragged from the editor.\n*/ EditorView.clipboardOutputFilter = clipboardOutputFilter;\n/**\nScroll handlers can override how things are scrolled into view.\nIf they return `true`, no further handling happens for the\nscrolling. If they return false, the default scroll behavior is\napplied. Scroll handlers should never initiate editor updates.\n*/ EditorView.scrollHandler = scrollHandler;\n/**\nThis facet can be used to provide functions that create effects\nto be dispatched when the editor's focus state changes.\n*/ EditorView.focusChangeEffect = focusChangeEffect;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/ EditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/ EditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/ EditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/ EditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/ EditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/ EditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/ EditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nwaysâ€”directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/ EditorView.decorations = decorations;\n/**\nFacet that works much like\n[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its\ninputs at the very bottom of the precedence stack, meaning mark\ndecorations provided here will only be split by other, partially\noverlapping `outerDecorations` ranges, and wrap around all\nregular decorations. Use this for mark elements that should, as\nmuch as possible, remain in one piece.\n*/ EditorView.outerDecorations = outerDecorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/ EditorView.atomicRanges = atomicRanges;\n/**\nWhen range decorations add a `unicode-bidi: isolate` style, they\nshould also include a\n[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property\nin their decoration spec, and be exposed through this facet, so\nthat the editor can compute the proper text order. (Other values\nfor `unicode-bidi`, except of course `normal`, are not\nsupported.)\n*/ EditorView.bidiIsolatedRanges = bidiIsolatedRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/ EditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/ EditorView.darkTheme = darkTheme;\n/**\nProvides a Content Security Policy nonce to use when creating\nthe style sheets for the editor. Holds the empty string when no\nnonce has been provided.\n*/ EditorView.cspNonce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.length ? values[0] : \"\"\n});\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/ EditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/ EditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/ EditorView.lineWrapping = /*@__PURE__*/ EditorView.contentAttributes.of({\n    \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/ EditorView.announce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, isolates, fresh, order){\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.isolates = isolates;\n        this.fresh = fresh;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty && !cache.some((c)=>c.fresh)) return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for(let i = Math.max(0, cache.length - 10); i < cache.length; i++){\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));\n        }\n        return result;\n    }\n}\nfunction attrsFromFacet(view, facet, base) {\n    for(let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--){\n        let source = sources[i], value = typeof source == \"function\" ? source(view) : source;\n        if (value) combineAttrs(value, base);\n    }\n    return base;\n}\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\") result = \" \";\n    let alt, ctrl, shift, meta;\n    for(let i = 0; i < parts.length - 1; ++i){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) meta = true;\n        else if (/^a(lt)?$/i.test(mod)) alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n        else if (/^s(hift)?$/i.test(mod)) shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\") meta = true;\n            else ctrl = true;\n        } else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) result = \"Alt-\" + result;\n    if (ctrl) result = \"Ctrl-\" + result;\n    if (meta) result = \"Meta-\" + result;\n    if (shift) result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey) name = \"Alt-\" + name;\n    if (event.ctrlKey) name = \"Ctrl-\" + name;\n    if (event.metaKey) name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.default(/*@__PURE__*/ EditorView.domEventHandlers({\n    keydown (event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/ const keymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    enables: handleKeyEvents\n});\nconst Keymaps = /*@__PURE__*/ new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b)=>a.concat(b), [])));\n    return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/ function runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is)=>{\n        let current = isPrefix[name];\n        if (current == null) isPrefix[name] = is;\n        else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault, stopPropagation)=>{\n        var _a, _b;\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map((k)=>normalizeKeyName(k, platform));\n        for(let i = 1; i < parts.length; i++){\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix]) scopeObj[prefix] = {\n                preventDefault: true,\n                stopPropagation: false,\n                run: [\n                    (view)=>{\n                        let ourObj = storedPrefix = {\n                            view,\n                            prefix,\n                            scope\n                        };\n                        setTimeout(()=>{\n                            if (storedPrefix == ourObj) storedPrefix = null;\n                        }, PrefixTimeout);\n                        return true;\n                    }\n                ]\n            };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = {\n            preventDefault: false,\n            stopPropagation: false,\n            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n        });\n        if (command) binding.run.push(command);\n        if (preventDefault) binding.preventDefault = true;\n        if (stopPropagation) binding.stopPropagation = true;\n    };\n    for (let b of bindings){\n        let scopes = b.scope ? b.scope.split(\" \") : [\n            \"editor\"\n        ];\n        if (b.any) for (let scope of scopes){\n            let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n            if (!scopeObj._any) scopeObj._any = {\n                preventDefault: false,\n                stopPropagation: false,\n                run: []\n            };\n            let { any } = b;\n            for(let key in scopeObj)scopeObj[key].run.push((view)=>any(view, currentKeyEvent));\n        }\n        let name = b[platform] || b.key;\n        if (!name) continue;\n        for (let scope of scopes){\n            add(scope, name, b.run, b.preventDefault, b.stopPropagation);\n            if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault, b.stopPropagation);\n        }\n    }\n    return bound;\n}\nlet currentKeyEvent = null;\nfunction runHandlers(map, event, view, scope) {\n    currentKeyEvent = event;\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointSize)(charCode) == name.length && name != \" \";\n    let prefix = \"\", handled = false, prevented = false, stopPropagation = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (modifierCodes.indexOf(event.keyCode) < 0) {\n            prevented = true;\n            storedPrefix = null;\n        }\n    }\n    let ran = new Set;\n    let runFor = (binding)=>{\n        if (binding) {\n            for (let cmd of binding.run)if (!ran.has(cmd)) {\n                ran.add(cmd);\n                if (cmd(view)) {\n                    if (binding.stopPropagation) stopPropagation = true;\n                    return true;\n                }\n            }\n            if (binding.preventDefault) {\n                if (binding.stopPropagation) stopPropagation = true;\n                prevented = true;\n            }\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName, shiftName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {\n            handled = true;\n        } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n        !(browser.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters\n        !(browser.mac && event.altKey && !(event.ctrlKey || event.metaKey)) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {\n                handled = true;\n            } else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {\n                handled = true;\n            }\n        } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {\n            handled = true;\n        }\n        if (!handled && runFor(scopeObj._any)) handled = true;\n    }\n    if (prevented) handled = true;\n    if (handled && stopPropagation) event.stopPropagation();\n    currentKeyEvent = null;\n    return handled;\n}\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/ class RectangleMarker {\n    /**\n    Create a marker with the given class and dimensions. If `width`\n    is null, the DOM element will get no width style.\n    */ constructor(className, /**\n    The left position of the marker (in pixels, document-relative).\n    */ left, /**\n    The top position of the marker.\n    */ top, /**\n    The width of the marker, or null if it shouldn't get a width assigned.\n    */ width, /**\n    The height of the marker.\n    */ height){\n        this.className = className;\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    update(elt, prev) {\n        if (prev.className != this.className) return false;\n        this.adjust(elt);\n        return true;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width != null) elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n    }\n    /**\n    Create a set of rectangles for the given selection range,\n    assigning them theclass`className`. Will create a single\n    rectangle for empty ranges, and a set of selection-style\n    rectangles covering the range's content (in a bidi-aware\n    way) for non-empty ones.\n    */ static forRange(view, className, range) {\n        if (range.empty) {\n            let pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (!pos) return [];\n            let base = getBase(view);\n            return [\n                new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)\n            ];\n        } else {\n            return rectanglesForRange(view, className, range);\n        }\n    }\n}\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;\n    return {\n        left: left - view.scrollDOM.scrollLeft * view.scaleX,\n        top: rect.top - view.scrollDOM.scrollTop * view.scaleY\n    };\n}\nfunction wrappedLine(view, pos, side, inside) {\n    let coords = view.coordsAtPos(pos, side * 2);\n    if (!coords) return inside;\n    let editorRect = view.dom.getBoundingClientRect();\n    let y = (coords.top + coords.bottom) / 2;\n    let left = view.posAtCoords({\n        x: editorRect.left + 1,\n        y\n    });\n    let right = view.posAtCoords({\n        x: editorRect.right - 1,\n        y\n    });\n    if (left == null || right == null) return inside;\n    return {\n        from: Math.max(inside.from, Math.min(left, right)),\n        to: Math.min(inside.to, Math.max(left, right))\n    };\n}\nfunction rectanglesForRange(view, className, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineElt = content.querySelector(\".cm-line\"), lineStyle = lineElt && window.getComputedStyle(lineElt);\n    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);\n    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);\n    let startBlock = blockAt(view, from, 1), endBlock = blockAt(view, to, -1);\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, 1, visualStart);\n    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, -1, visualEnd);\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {\n        return pieces(drawForLine(range.from, range.to, visualStart));\n    } else {\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n        let between = [];\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new RectangleMarker(className, left - base.left, top - base.top, right - left, bottom - top);\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for(let i = 0; i < horizontal.length; i += 2)pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to, line) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            // Passing 2/-2 is a kludge to force the view to return\n            // coordinates on the proper side of block widgets, since\n            // normalizing the side there, though appropriate for most\n            // coordsAtPos queries, would break selection drawing.\n            let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n            let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n            if (!fromCoords || !toCoords) return;\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)if (r.to > start && r.from < end) {\n            for(let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;){\n                let docLine = view.state.doc.lineAt(pos);\n                for (let span of view.bidiSpans(docLine)){\n                    let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                    if (spanFrom >= endPos) break;\n                    if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                }\n                pos = docLine.to + 1;\n                if (pos >= endPos) break;\n            }\n        }\n        if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n        return {\n            top,\n            bottom,\n            horizontal\n        };\n    }\n    function drawForWidget(block, top) {\n        let y = contentRect.top + (top ? block.top : block.bottom);\n        return {\n            top: y,\n            bottom: y,\n            horizontal: []\n        };\n    }\n}\nfunction sameMarker(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n    constructor(view, layer){\n        this.view = view;\n        this.layer = layer;\n        this.drawn = [];\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.measureReq = {\n            read: this.measure.bind(this),\n            write: this.draw.bind(this)\n        };\n        this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.dom.classList.add(\"cm-layer\");\n        if (layer.above) this.dom.classList.add(\"cm-layer-above\");\n        if (layer.class) this.dom.classList.add(layer.class);\n        this.scale();\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.setOrder(view.state);\n        view.requestMeasure(this.measureReq);\n        if (layer.mount) layer.mount(this.dom, view);\n    }\n    update(update) {\n        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);\n        if (this.layer.update(update, this.dom) || update.geometryChanged) {\n            this.scale();\n            update.view.requestMeasure(this.measureReq);\n        }\n    }\n    docViewUpdate(view) {\n        if (this.layer.updateOnDocViewUpdate !== false) view.requestMeasure(this.measureReq);\n    }\n    setOrder(state) {\n        let pos = 0, order = state.facet(layerOrder);\n        while(pos < order.length && order[pos] != this.layer)pos++;\n        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n    }\n    measure() {\n        return this.layer.markers(this.view);\n    }\n    scale() {\n        let { scaleX, scaleY } = this.view;\n        if (scaleX != this.scaleX || scaleY != this.scaleY) {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;\n        }\n    }\n    draw(markers) {\n        if (markers.length != this.drawn.length || markers.some((p, i)=>!sameMarker(p, this.drawn[i]))) {\n            let old = this.dom.firstChild, oldI = 0;\n            for (let marker of markers){\n                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {\n                    old = old.nextSibling;\n                    oldI++;\n                } else {\n                    this.dom.insertBefore(marker.draw(), old);\n                }\n            }\n            while(old){\n                let next = old.nextSibling;\n                old.remove();\n                old = next;\n            }\n            this.drawn = markers;\n            if (browser.safari && browser.safari_version >= 26) this.dom.style.display = this.dom.firstChild ? \"\" : \"none\";\n        }\n    }\n    destroy() {\n        if (this.layer.destroy) this.layer.destroy(this.dom, this.view);\n        this.dom.remove();\n    }\n}\nconst layerOrder = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nDefine a layer.\n*/ function layer(config) {\n    return [\n        ViewPlugin.define((v)=>new LayerView(v, config)),\n        layerOrder.of(config)\n    ];\n}\nconst selectionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b)=>Math.min(a, b),\n            drawRangeCursor: (a, b)=>a || b\n        });\n    }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/ function drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        cursorLayer,\n        selectionLayer,\n        hideNativeSelection,\n        nativeSelectionHidden.of(true)\n    ];\n}\n/**\nRetrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration\nfor this state. (Note that this will return a set of defaults even\nif `drawSelection` isn't enabled.)\n*/ function getDrawSelectionConfig(state) {\n    return state.facet(selectionConfig);\n}\nfunction configChanged(update) {\n    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/ layer({\n    above: true,\n    markers (view) {\n        let { state } = view, conf = state.facet(selectionConfig);\n        let cursors = [];\n        for (let r of state.selection.ranges){\n            let prim = r == state.selection.main;\n            if (r.empty || conf.drawRangeCursor) {\n                let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n                for (let piece of RectangleMarker.forRange(view, className, cursor))cursors.push(piece);\n            }\n        }\n        return cursors;\n    },\n    update (update, dom) {\n        if (update.transactions.some((tr)=>tr.selection)) dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        let confChange = configChanged(update);\n        if (confChange) setBlinkRate(update.state, dom);\n        return update.docChanged || update.selectionSet || confChange;\n    },\n    mount (dom, view) {\n        setBlinkRate(view.state, dom);\n    },\n    class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/ layer({\n    above: false,\n    markers (view) {\n        return view.state.selection.ranges.map((r)=>r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r)).reduce((a, b)=>a.concat(b));\n    },\n    update (update, dom) {\n        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n    },\n    class: \"cm-selectionLayer\"\n});\nconst hideNativeSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.highest(/*@__PURE__*/ EditorView.theme({\n    \".cm-line\": {\n        \"& ::selection, &::selection\": {\n            backgroundColor: \"transparent !important\"\n        },\n        caretColor: \"transparent !important\"\n    },\n    \".cm-content\": {\n        caretColor: \"transparent !important\",\n        \"& :focus\": {\n            caretColor: \"initial !important\",\n            \"&::selection, & ::selection\": {\n                backgroundColor: \"Highlight !important\"\n            }\n        }\n    }\n}));\nconst setDropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map (pos, mapping) {\n        return pos == null ? null : mapping.mapPos(pos);\n    }\n});\nconst dropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return null;\n    },\n    update (pos, tr) {\n        if (pos != null) pos = tr.changes.mapPos(pos);\n        return tr.effects.reduce((pos, e)=>e.is(setDropCursorPos) ? e.value : pos, pos);\n    }\n});\nconst drawDropCursor = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.cursor = null;\n        this.measureReq = {\n            read: this.readPos.bind(this),\n            write: this.drawCursor.bind(this)\n        };\n    }\n    update(update) {\n        var _a;\n        let cursorPos = update.state.field(dropCursorPos);\n        if (cursorPos == null) {\n            if (this.cursor != null) {\n                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n                this.cursor = null;\n            }\n        } else {\n            if (!this.cursor) {\n                this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n                this.cursor.className = \"cm-dropCursor\";\n            }\n            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);\n        }\n    }\n    readPos() {\n        let { view } = this;\n        let pos = view.state.field(dropCursorPos);\n        let rect = pos != null && view.coordsAtPos(pos);\n        if (!rect) return null;\n        let outer = view.scrollDOM.getBoundingClientRect();\n        return {\n            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,\n            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,\n            height: rect.bottom - rect.top\n        };\n    }\n    drawCursor(pos) {\n        if (this.cursor) {\n            let { scaleX, scaleY } = this.view;\n            if (pos) {\n                this.cursor.style.left = pos.left / scaleX + \"px\";\n                this.cursor.style.top = pos.top / scaleY + \"px\";\n                this.cursor.style.height = pos.height / scaleY + \"px\";\n            } else {\n                this.cursor.style.left = \"-100000px\";\n            }\n        }\n    }\n    destroy() {\n        if (this.cursor) this.cursor.remove();\n    }\n    setDropPos(pos) {\n        if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n            effects: setDropCursorPos.of(pos)\n        });\n    }\n}, {\n    eventObservers: {\n        dragover (event) {\n            this.setDropPos(this.view.posAtCoords({\n                x: event.clientX,\n                y: event.clientY\n            }));\n        },\n        dragleave (event) {\n            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n        },\n        dragend () {\n            this.setDropPos(null);\n        },\n        drop () {\n            this.setDropPos(null);\n        }\n    }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/ function dropCursor() {\n    return [\n        dropCursorPos,\n        drawDropCursor\n    ];\n}\nfunction iterMatches(doc, re, from, to, f) {\n    re.lastIndex = 0;\n    for(let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length){\n        if (!cursor.lineBreak) while(m = re.exec(cursor.value))f(pos + m.index, m);\n    }\n}\nfunction matchRanges(view, maxLength) {\n    let visible = view.visibleRanges;\n    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n    let result = [];\n    for (let { from, to } of visible){\n        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n        if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;\n        else result.push({\n            from,\n            to\n        });\n    }\n    return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/ class MatchDecorator {\n    /**\n    Create a decorator.\n    */ constructor(config){\n        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;\n        if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n        this.regexp = regexp;\n        if (decorate) {\n            this.addMatch = (match, view, from, add)=>decorate(add, from, from + match[0].length, match, view);\n        } else if (typeof decoration == \"function\") {\n            this.addMatch = (match, view, from, add)=>{\n                let deco = decoration(match, view, from);\n                if (deco) add(from, from + match[0].length, deco);\n            };\n        } else if (decoration) {\n            this.addMatch = (match, _view, from, add)=>add(from, from + match[0].length, decoration);\n        } else {\n            throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n        }\n        this.boundary = boundary;\n        this.maxLength = maxLength;\n    }\n    /**\n    Compute the full set of decorations for matches in the given\n    view's viewport. You'll want to call this when initializing your\n    plugin.\n    */ createDeco(view) {\n        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder(), add = build.add.bind(build);\n        for (let { from, to } of matchRanges(view, this.maxLength))iterMatches(view.state.doc, this.regexp, from, to, (from, m)=>this.addMatch(m, view, from, add));\n        return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */ updateDeco(update, deco) {\n        let changeFrom = 1e9, changeTo = -1;\n        if (update.docChanged) update.changes.iterChanges((_f, _t, from, to)=>{\n            if (to >= update.view.viewport.from && from <= update.view.viewport.to) {\n                changeFrom = Math.min(from, changeFrom);\n                changeTo = Math.max(to, changeTo);\n            }\n        });\n        if (update.viewportMoved || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n        if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n        return deco;\n    }\n    updateRange(view, deco, updateFrom, updateTo) {\n        for (let r of view.visibleRanges){\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n            if (to >= from) {\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n                if (this.boundary) {\n                    for(; from > fromLine.from; from--)if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                        start = from;\n                        break;\n                    }\n                    for(; to < toLine.to; to++)if (this.boundary.test(toLine.text[to - toLine.from])) {\n                        end = to;\n                        break;\n                    }\n                }\n                let ranges = [], m;\n                let add = (from, to, deco)=>ranges.push(deco.range(from, to));\n                if (fromLine == toLine) {\n                    this.regexp.lastIndex = start - fromLine.from;\n                    while((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)this.addMatch(m, view, m.index + fromLine.from, add);\n                } else {\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, m)=>this.addMatch(m, view, from, add));\n                }\n                deco = deco.update({\n                    filterFrom: start,\n                    filterTo: end,\n                    filter: (from, to)=>from < start || to > end,\n                    add: ranges\n                });\n            }\n        }\n        return deco;\n    }\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/ new RegExp(\"[\\x00-\\b\\n-\\x1f\\x7f-\\x9f\\xadØœâ€‹â€Žâ€\\u2028\\u2029â€­â€®â¦â§â©\\uFEFFï¿¹-ï¿¼]\", UnicodeRegexpSupport);\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8237: \"left-to-right override\",\n    8238: \"right-to-left override\",\n    8294: \"left-to-right isolate\",\n    8295: \"right-to-left isolate\",\n    8297: \"pop directional isolate\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    var _a;\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/ function highlightSpecialChars(/**\nConfiguration options.\n*/ config = {}) {\n    return [\n        specialCharConfig.of(config),\n        specialCharPlugin()\n    ];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.decorations = Decoration.none;\n            this.decorationCache = Object.create(null);\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n            this.decorations = this.decorator.createDeco(view);\n        }\n        makeDecorator(conf) {\n            return new MatchDecorator({\n                regexp: conf.specialChars,\n                decoration: (m, view, pos)=>{\n                    let { doc } = view.state;\n                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(m[0], 0);\n                    if (code == 9) {\n                        let line = doc.lineAt(pos);\n                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, size, pos - line.from);\n                        return Decoration.replace({\n                            widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)\n                        });\n                    }\n                    return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n                        widget: new SpecialCharWidget(conf, code)\n                    }));\n                },\n                boundary: conf.replaceTabs ? undefined : /[^]/\n            });\n        }\n        update(update) {\n            let conf = update.state.facet(specialCharConfig);\n            if (update.startState.facet(specialCharConfig) != conf) {\n                this.decorator = this.makeDecorator(conf);\n                this.decorations = this.decorator.createDeco(update.view);\n            } else {\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\n            }\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    }));\n}\nconst DefaultPlaceholder = \"â€¢\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n    if (code >= 32) return DefaultPlaceholder;\n    if (code == 10) return \"â¤\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code){\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) {\n        return other.code == this.code;\n    }\n    toDOM(view) {\n        let ph = placeholder$1(this.code);\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom) return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.className = \"cm-specialChar\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nclass TabWidget extends WidgetType {\n    constructor(width){\n        super();\n        this.width = width;\n    }\n    eq(other) {\n        return other.width == this.width;\n    }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\t\";\n        span.className = \"cm-tab\";\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nconst plugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(){\n        this.height = 1000;\n        this.attrs = {\n            style: \"padding-bottom: 1000px\"\n        };\n    }\n    update(update) {\n        let { view } = update;\n        let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;\n        if (height >= 0 && height != this.height) {\n            this.height = height;\n            this.attrs = {\n                style: `padding-bottom: ${height}px`\n            };\n        }\n    }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/ function scrollPastEnd() {\n    return [\n        plugin,\n        contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n        })\n    ];\n}\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/ function highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/ Decoration.line({\n    class: \"cm-activeLine\"\n});\nconst activeLineHighlighter = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges){\n            let line = view.lineBlockAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nclass Placeholder extends WidgetType {\n    constructor(content){\n        super();\n        this.content = content;\n    }\n    toDOM(view) {\n        let wrap = document.createElement(\"span\");\n        wrap.className = \"cm-placeholder\";\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : typeof this.content == \"function\" ? this.content(view) : this.content.cloneNode(true));\n        wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    coordsAt(dom) {\n        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];\n        if (!rects.length) return null;\n        let style = window.getComputedStyle(dom.parentNode);\n        let rect = flattenRect(rects[0], style.direction != \"rtl\");\n        let lineHeight = parseInt(style.lineHeight);\n        if (rect.bottom - rect.top > lineHeight * 1.5) return {\n            left: rect.left,\n            right: rect.right,\n            top: rect.top,\n            bottom: rect.top + lineHeight\n        };\n        return rect;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\n/**\nExtension that enables a placeholderâ€”a piece of example content\nto show when the editor is empty.\n*/ function placeholder(content) {\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.placeholder = content ? Decoration.set([\n                Decoration.widget({\n                    widget: new Placeholder(content),\n                    side: 1\n                }).range(0)\n            ]) : Decoration.none;\n        }\n        get decorations() {\n            return this.view.state.doc.length ? Decoration.none : this.placeholder;\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    });\n    return typeof content == \"string\" ? [\n        plugin,\n        EditorView.contentAttributes.of({\n            \"aria-placeholder\": content\n        })\n    ] : plugin;\n}\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    } else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(line.text, startCol, state.tabSize, true);\n            if (start < 0) {\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(line.to));\n            } else {\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(line.text, endCol, state.tabSize);\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n    return {\n        line: line.number,\n        col,\n        off\n    };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start) return null;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = {\n                    line: newLine.number,\n                    col: start.col,\n                    off: Math.min(start.off, newLine.length)\n                };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur) return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length) return startSel;\n            if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges.concat(startSel.ranges));\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/ function rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e)=>e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event)=>filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n    Alt: [\n        18,\n        (e)=>!!e.altKey\n    ],\n    Control: [\n        17,\n        (e)=>!!e.ctrlKey\n    ],\n    Shift: [\n        16,\n        (e)=>!!e.shiftKey\n    ],\n    Meta: [\n        91,\n        (e)=>!!e.metaKey\n    ]\n};\nconst showCrosshair = {\n    style: \"cursor: crosshair\"\n};\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/ function crosshairCursor(options = {}) {\n    let [code, getter] = keys[options.key || \"Alt\"];\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.isDown = false;\n        }\n        set(isDown) {\n            if (this.isDown != isDown) {\n                this.isDown = isDown;\n                this.view.update([]);\n            }\n        }\n    }, {\n        eventObservers: {\n            keydown (e) {\n                this.set(e.keyCode == code || getter(e));\n            },\n            keyup (e) {\n                if (e.keyCode == code || !getter(e)) this.set(false);\n            },\n            mousemove (e) {\n                this.set(getter(e));\n            }\n        }\n    });\n    return [\n        plugin,\n        EditorView.contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;\n        })\n    ];\n}\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n    constructor(view, facet, createTooltipView, removeTooltipView){\n        this.facet = facet;\n        this.createTooltipView = createTooltipView;\n        this.removeTooltipView = removeTooltipView;\n        this.input = view.state.facet(facet);\n        this.tooltips = this.input.filter((t)=>t);\n        let prev = null;\n        this.tooltipViews = this.tooltips.map((t)=>prev = createTooltipView(t, prev));\n    }\n    update(update, above) {\n        var _a;\n        let input = update.state.facet(this.facet);\n        let tooltips = input.filter((x)=>x);\n        if (input === this.input) {\n            for (let t of this.tooltipViews)if (t.update) t.update(update);\n            return false;\n        }\n        let tooltipViews = [], newAbove = above ? [] : null;\n        for(let i = 0; i < tooltips.length; i++){\n            let tip = tooltips[i], known = -1;\n            if (!tip) continue;\n            for(let i = 0; i < this.tooltips.length; i++){\n                let other = this.tooltips[i];\n                if (other && other.create == tip.create) known = i;\n            }\n            if (known < 0) {\n                tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);\n                if (newAbove) newAbove[i] = !!tip.above;\n            } else {\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n                if (newAbove) newAbove[i] = above[known];\n                if (tooltipView.update) tooltipView.update(update);\n            }\n        }\n        for (let t of this.tooltipViews)if (tooltipViews.indexOf(t) < 0) {\n            this.removeTooltipView(t);\n            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n        }\n        if (above) {\n            newAbove.forEach((val, i)=>above[i] = val);\n            above.length = newAbove.length;\n        }\n        this.input = input;\n        this.tooltips = tooltips;\n        this.tooltipViews = tooltipViews;\n        return true;\n    }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/ function tooltips(config = {}) {\n    return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n    let docElt = view.dom.ownerDocument.documentElement;\n    return {\n        top: 0,\n        left: 0,\n        bottom: docElt.clientHeight,\n        right: docElt.clientWidth\n    };\n}\nconst tooltipConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>{\n        var _a, _b, _c;\n        return {\n            position: browser.ios ? \"absolute\" : ((_a = values.find((conf)=>conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n            parent: ((_b = values.find((conf)=>conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n            tooltipSpace: ((_c = values.find((conf)=>conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n        };\n    }\n});\nconst knownHeight = /*@__PURE__*/ new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.above = [];\n        this.inView = true;\n        this.madeAbsolute = false;\n        this.lastTransaction = 0;\n        this.measureTimeout = -1;\n        let config = view.state.facet(tooltipConfig);\n        this.position = config.position;\n        this.parent = config.parent;\n        this.classes = view.themeClasses;\n        this.createContainer();\n        this.measureReq = {\n            read: this.readMeasure.bind(this),\n            write: this.writeMeasure.bind(this),\n            key: this\n        };\n        this.resizeObserver = typeof ResizeObserver == \"function\" ? new ResizeObserver(()=>this.measureSoon()) : null;\n        this.manager = new TooltipViewManager(view, showTooltip, (t, p)=>this.createTooltip(t, p), (t)=>{\n            if (this.resizeObserver) this.resizeObserver.unobserve(t.dom);\n            t.dom.remove();\n        });\n        this.above = this.manager.tooltips.map((t)=>!!t.above);\n        this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver((entries)=>{\n            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();\n        }, {\n            threshold: [\n                1\n            ]\n        }) : null;\n        this.observeIntersection();\n        view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n        this.maybeMeasure();\n    }\n    createContainer() {\n        if (this.parent) {\n            this.container = document.createElement(\"div\");\n            this.container.style.position = \"relative\";\n            this.container.className = this.view.themeClasses;\n            this.parent.appendChild(this.container);\n        } else {\n            this.container = this.view.dom;\n        }\n    }\n    observeIntersection() {\n        if (this.intersectionObserver) {\n            this.intersectionObserver.disconnect();\n            for (let tooltip of this.manager.tooltipViews)this.intersectionObserver.observe(tooltip.dom);\n        }\n    }\n    measureSoon() {\n        if (this.measureTimeout < 0) this.measureTimeout = setTimeout(()=>{\n            this.measureTimeout = -1;\n            this.maybeMeasure();\n        }, 50);\n    }\n    update(update) {\n        if (update.transactions.length) this.lastTransaction = Date.now();\n        let updated = this.manager.update(update, this.above);\n        if (updated) this.observeIntersection();\n        let shouldMeasure = updated || update.geometryChanged;\n        let newConfig = update.state.facet(tooltipConfig);\n        if (newConfig.position != this.position && !this.madeAbsolute) {\n            this.position = newConfig.position;\n            for (let t of this.manager.tooltipViews)t.dom.style.position = this.position;\n            shouldMeasure = true;\n        }\n        if (newConfig.parent != this.parent) {\n            if (this.parent) this.container.remove();\n            this.parent = newConfig.parent;\n            this.createContainer();\n            for (let t of this.manager.tooltipViews)this.container.appendChild(t.dom);\n            shouldMeasure = true;\n        } else if (this.parent && this.view.themeClasses != this.classes) {\n            this.classes = this.container.className = this.view.themeClasses;\n        }\n        if (shouldMeasure) this.maybeMeasure();\n    }\n    createTooltip(tooltip, prev) {\n        let tooltipView = tooltip.create(this.view);\n        let before = prev ? prev.dom : null;\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n            let arrow = document.createElement(\"div\");\n            arrow.className = \"cm-tooltip-arrow\";\n            tooltipView.dom.appendChild(arrow);\n        }\n        tooltipView.dom.style.position = this.position;\n        tooltipView.dom.style.top = Outside;\n        tooltipView.dom.style.left = \"0px\";\n        this.container.insertBefore(tooltipView.dom, before);\n        if (tooltipView.mount) tooltipView.mount(this.view);\n        if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);\n        return tooltipView;\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.view.win.removeEventListener(\"resize\", this.measureSoon);\n        for (let tooltipView of this.manager.tooltipViews){\n            tooltipView.dom.remove();\n            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n        }\n        if (this.parent) this.container.remove();\n        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();\n        clearTimeout(this.measureTimeout);\n    }\n    readMeasure() {\n        let scaleX = 1, scaleY = 1, makeAbsolute = false;\n        if (this.position == \"fixed\" && this.manager.tooltipViews.length) {\n            let { dom } = this.manager.tooltipViews[0];\n            if (browser.safari) {\n                // Safari always sets offsetParent to null, even if a fixed\n                // element is positioned relative to a transformed parent. So\n                // we use this kludge to try and detect this.\n                let rect = dom.getBoundingClientRect();\n                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;\n            } else {\n                // More conforming browsers will set offsetParent to the\n                // transformed element.\n                makeAbsolute = !!dom.offsetParent && dom.offsetParent != this.container.ownerDocument.body;\n            }\n        }\n        if (makeAbsolute || this.position == \"absolute\") {\n            if (this.parent) {\n                let rect = this.parent.getBoundingClientRect();\n                if (rect.width && rect.height) {\n                    scaleX = rect.width / this.parent.offsetWidth;\n                    scaleY = rect.height / this.parent.offsetHeight;\n                }\n            } else {\n                ({ scaleX, scaleY } = this.view.viewState);\n            }\n        }\n        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);\n        return {\n            visible: {\n                left: visible.left + margins.left,\n                top: visible.top + margins.top,\n                right: visible.right - margins.right,\n                bottom: visible.bottom - margins.bottom\n            },\n            parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),\n            pos: this.manager.tooltips.map((t, i)=>{\n                let tv = this.manager.tooltipViews[i];\n                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n            }),\n            size: this.manager.tooltipViews.map(({ dom })=>dom.getBoundingClientRect()),\n            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\n            scaleX,\n            scaleY,\n            makeAbsolute\n        };\n    }\n    writeMeasure(measured) {\n        var _a;\n        if (measured.makeAbsolute) {\n            this.madeAbsolute = true;\n            this.position = \"absolute\";\n            for (let t of this.manager.tooltipViews)t.dom.style.position = \"absolute\";\n        }\n        let { visible, space, scaleX, scaleY } = measured;\n        let others = [];\n        for(let i = 0; i < this.manager.tooltips.length; i++){\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) || pos.top >= Math.min(visible.bottom, space.bottom) || pos.right < Math.max(visible.left, space.left) - .1 || pos.left > Math.min(visible.right, space.right) + .1)) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n            let arrowHeight = arrow ? 7 /* Arrow.Size */  : 0;\n            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;\n            let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */  : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */  : 0) - offset.x), space.right - width);\n            let above = this.above[i];\n            if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space.top : pos.bottom + height + arrowHeight + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i] = !above;\n            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n            if (spaceVert < height && tView.resize !== false) {\n                if (spaceVert < this.view.defaultLineHeight) {\n                    dom.style.top = Outside;\n                    continue;\n                }\n                knownHeight.set(tView, height);\n                dom.style.height = (height = spaceVert) / scaleY + \"px\";\n            } else if (dom.style.height) {\n                dom.style.height = \"\";\n            }\n            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n            let right = left + width;\n            if (tView.overlap !== true) {\n                for (let r of others)if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n            }\n            if (this.position == \"absolute\") {\n                dom.style.top = (top - measured.parent.top) / scaleY + \"px\";\n                setLeftStyle(dom, (left - measured.parent.left) / scaleX);\n            } else {\n                dom.style.top = top / scaleY + \"px\";\n                setLeftStyle(dom, left / scaleX);\n            }\n            if (arrow) {\n                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */  - 7 /* Arrow.Size */ );\n                arrow.style.left = arrowLeft / scaleX + \"px\";\n            }\n            if (tView.overlap !== true) others.push({\n                left,\n                top,\n                right,\n                bottom: top + height\n            });\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned) tView.positioned(measured.space);\n        }\n    }\n    maybeMeasure() {\n        if (this.manager.tooltips.length) {\n            if (this.view.inView) this.view.requestMeasure(this.measureReq);\n            if (this.inView != this.view.inView) {\n                this.inView = this.view.inView;\n                if (!this.inView) for (let tv of this.manager.tooltipViews)tv.dom.style.top = Outside;\n            }\n        }\n    }\n}, {\n    eventObservers: {\n        scroll () {\n            this.maybeMeasure();\n        }\n    }\n});\nfunction setLeftStyle(elt, value) {\n    let current = parseInt(elt.style.left, 10);\n    if (isNaN(current) || Math.abs(value - current) > 1) elt.style.left = value + \"px\";\n}\nconst baseTheme = /*@__PURE__*/ EditorView.baseTheme({\n    \".cm-tooltip\": {\n        zIndex: 500,\n        boxSizing: \"border-box\"\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #bbb\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&light .cm-tooltip-section:not(:first-child)\": {\n        borderTop: \"1px solid #bbb\"\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tooltip-arrow\": {\n        height: `${7 /* Arrow.Size */ }px`,\n        width: `${7 /* Arrow.Size */  * 2}px`,\n        position: \"absolute\",\n        zIndex: -1,\n        overflow: \"hidden\",\n        \"&:before, &:after\": {\n            content: \"''\",\n            position: \"absolute\",\n            width: 0,\n            height: 0,\n            borderLeft: `${7 /* Arrow.Size */ }px solid transparent`,\n            borderRight: `${7 /* Arrow.Size */ }px solid transparent`\n        },\n        \".cm-tooltip-above &\": {\n            bottom: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                bottom: \"1px\"\n            }\n        },\n        \".cm-tooltip-below &\": {\n            top: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                top: \"1px\"\n            }\n        }\n    },\n    \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n        \"&:before\": {\n            borderTopColor: \"#333338\",\n            borderBottomColor: \"#333338\"\n        },\n        \"&:after\": {\n            borderTopColor: \"transparent\",\n            borderBottomColor: \"transparent\"\n        }\n    }\n});\nconst noOffset = {\n    x: 0,\n    y: 0\n};\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/ const showTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    enables: [\n        tooltipPlugin,\n        baseTheme\n    ]\n});\nconst showHoverTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (inputs)=>inputs.reduce((a, i)=>a.concat(i), [])\n});\nclass HoverTooltipHost {\n    // Needs to be static so that host tooltip instances always match\n    static create(view) {\n        return new HoverTooltipHost(view);\n    }\n    constructor(view){\n        this.view = view;\n        this.mounted = false;\n        this.dom = document.createElement(\"div\");\n        this.dom.classList.add(\"cm-tooltip-hover\");\n        this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p)=>this.createHostedView(t, p), (t)=>t.dom.remove());\n    }\n    createHostedView(tooltip, prev) {\n        let hostedView = tooltip.create(this.view);\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\n        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);\n        if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n        return hostedView;\n    }\n    mount(view) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.mount) hostedView.mount(view);\n        }\n        this.mounted = true;\n    }\n    positioned(space) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.positioned) hostedView.positioned(space);\n        }\n    }\n    update(update) {\n        this.manager.update(update);\n    }\n    destroy() {\n        var _a;\n        for (let t of this.manager.tooltipViews)(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n    passProp(name) {\n        let value = undefined;\n        for (let view of this.manager.tooltipViews){\n            let given = view[name];\n            if (given !== undefined) {\n                if (value === undefined) value = given;\n                else if (value !== given) return undefined;\n            }\n        }\n        return value;\n    }\n    get offset() {\n        return this.passProp(\"offset\");\n    }\n    get getCoords() {\n        return this.passProp(\"getCoords\");\n    }\n    get overlap() {\n        return this.passProp(\"overlap\");\n    }\n    get resize() {\n        return this.passProp(\"resize\");\n    }\n}\nconst showHoverTooltipHost = /*@__PURE__*/ showTooltip.compute([\n    showHoverTooltip\n], (state)=>{\n    let tooltips = state.facet(showHoverTooltip);\n    if (tooltips.length === 0) return null;\n    return {\n        pos: Math.min(...tooltips.map((t)=>t.pos)),\n        end: Math.max(...tooltips.map((t)=>{\n            var _a;\n            return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos;\n        })),\n        create: HoverTooltipHost.create,\n        above: tooltips[0].above,\n        arrow: tooltips.some((t)=>t.arrow)\n    };\n});\nclass HoverPlugin {\n    constructor(view, source, field, setHover, hoverTime){\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.hoverTime = hoverTime;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.lastMove = {\n            x: 0,\n            y: 0,\n            target: view.dom,\n            time: 0\n        };\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(()=>this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active.length) return;\n        let hovered = Date.now() - this.lastMove.time;\n        if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\n        else this.startHover();\n    }\n    startHover() {\n        clearTimeout(this.restartTimeout);\n        let { view, lastMove } = this;\n        let desc = view.docView.nearest(lastMove.target);\n        if (!desc) return;\n        let pos, side = 1;\n        if (desc instanceof WidgetView) {\n            pos = desc.posAtStart;\n        } else {\n            pos = view.posAtCoords(lastMove);\n            if (pos == null) return;\n            let posCoords = view.coordsAtPos(pos);\n            if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;\n            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s)=>s.from <= pos && s.to >= pos);\n            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n            side = lastMove.x < posCoords.left ? -rtl : rtl;\n        }\n        let open = this.source(view, pos, side);\n        if (open === null || open === void 0 ? void 0 : open.then) {\n            let pending = this.pending = {\n                pos\n            };\n            open.then((result)=>{\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result && !(Array.isArray(result) && !result.length)) view.dispatch({\n                        effects: this.setHover.of(Array.isArray(result) ? result : [\n                            result\n                        ])\n                    });\n                }\n            }, (e)=>logException(view.state, e, \"hover tooltip\"));\n        } else if (open && !(Array.isArray(open) && !open.length)) {\n            view.dispatch({\n                effects: this.setHover.of(Array.isArray(open) ? open : [\n                    open\n                ])\n            });\n        }\n    }\n    get tooltip() {\n        let plugin = this.view.plugin(tooltipPlugin);\n        let index = plugin ? plugin.manager.tooltips.findIndex((t)=>t.create == HoverTooltipHost.create) : -1;\n        return index > -1 ? plugin.manager.tooltipViews[index] : null;\n    }\n    mousemove(event) {\n        var _a, _b;\n        this.lastMove = {\n            x: event.clientX,\n            y: event.clientY,\n            target: event.target,\n            time: Date.now()\n        };\n        if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n        let { active, tooltip } = this;\n        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {\n            let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;\n            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {\n                this.view.dispatch({\n                    effects: this.setHover.of([])\n                });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave(event) {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        let { active } = this;\n        if (active.length) {\n            let { tooltip } = this;\n            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);\n            if (!inTooltip) this.view.dispatch({\n                effects: this.setHover.of([])\n            });\n            else this.watchTooltipLeave(tooltip.dom);\n        }\n    }\n    watchTooltipLeave(tooltip) {\n        let watch = (event)=>{\n            tooltip.removeEventListener(\"mouseleave\", watch);\n            if (this.active.length && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({\n                effects: this.setHover.of([])\n            });\n        };\n        tooltip.addEventListener(\"mouseleave\", watch);\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nconst tooltipMargin = 4;\nfunction isInTooltip(tooltip, event) {\n    let { left, right, top, bottom } = tooltip.getBoundingClientRect(), arrow;\n    if (arrow = tooltip.querySelector(\".cm-tooltip-arrow\")) {\n        let arrowRect = arrow.getBoundingClientRect();\n        top = Math.min(arrowRect.top, top);\n        bottom = Math.max(arrowRect.bottom, bottom);\n    }\n    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top - tooltipMargin && event.clientY <= bottom + tooltipMargin;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;\n    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;\n    let pos = view.posAtCoords({\n        x,\n        y\n    }, false);\n    return pos >= from && pos <= to;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer isâ€”it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n\nThe return value is a valid [editor extension](https://codemirror.net/6/docs/ref/#state.Extension)\nbut also provides an `active` property holding a state field that\ncan be used to read the currently active tooltips produced by this\nextension.\n*/ function hoverTooltip(source, options = {}) {\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n        create () {\n            return [];\n        },\n        update (value, tr) {\n            if (value.length) {\n                if (options.hideOnChange && (tr.docChanged || tr.selection)) value = [];\n                else if (options.hideOn) value = value.filter((v)=>!options.hideOn(tr, v));\n                if (tr.docChanged) {\n                    let mapped = [];\n                    for (let tooltip of value){\n                        let newPos = tr.changes.mapPos(tooltip.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackDel);\n                        if (newPos != null) {\n                            let copy = Object.assign(Object.create(null), tooltip);\n                            copy.pos = newPos;\n                            if (copy.end != null) copy.end = tr.changes.mapPos(copy.end);\n                            mapped.push(copy);\n                        }\n                    }\n                    value = mapped;\n                }\n            }\n            for (let effect of tr.effects){\n                if (effect.is(setHover)) value = effect.value;\n                if (effect.is(closeHoverTooltipEffect)) value = [];\n            }\n            return value;\n        },\n        provide: (f)=>showHoverTooltip.from(f)\n    });\n    return {\n        active: hoverState,\n        extension: [\n            hoverState,\n            ViewPlugin.define((view)=>new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */ )),\n            showHoverTooltipHost\n        ]\n    };\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/ function getTooltip(view, tooltip) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (!plugin) return null;\n    let found = plugin.manager.tooltips.indexOf(tooltip);\n    return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/ function hasHoverTooltips(state) {\n    return state.facet(showHoverTooltip).some((x)=>x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/ const closeHoverTooltips = /*@__PURE__*/ closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/ function repositionTooltips(view) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (plugin) plugin.maybeMeasure();\n}\nconst panelConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs){\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return {\n            topContainer,\n            bottomContainer\n        };\n    }\n});\n/**\nConfigures the panel-managing extension.\n*/ function panels(config) {\n    return config ? [\n        panelConfig.of(config)\n    ] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/ function getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\n    return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.input = view.state.facet(showPanel);\n        this.specs = this.input.filter((s)=>s);\n        this.panels = this.specs.map((spec)=>spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter((p)=>p.top));\n        this.bottom.sync(this.panels.filter((p)=>!p.top));\n        for (let p of this.panels){\n            p.dom.classList.add(\"cm-panel\");\n            if (p.mount) p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let input = update.state.facet(showPanel);\n        if (input != this.input) {\n            let specs = input.filter((x)=>x);\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs){\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                } else {\n                    panel = this.panels[known];\n                    if (panel.update) panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount){\n                p.dom.classList.add(\"cm-panel\");\n                if (p.mount) p.mount();\n            }\n        } else {\n            for (let p of this.panels)if (p.update) p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            return value && {\n                top: value.top.scrollMargin(),\n                bottom: value.bottom.scrollMargin()\n            };\n        })\n});\nclass PanelGroup {\n    constructor(view, top, container){\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        for (let p of this.panels)if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels){\n            if (panel.dom.parentNode == this.dom) {\n                while(curDOM != panel.dom)curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            } else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while(curDOM)curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses) return;\n        for (let cls of this.classes.split(\" \"))if (cls) this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))if (cls) this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/ const showPanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    enables: panelPlugin\n});\n/**\nShow a panel above or below the editor to show the user a message\nor prompt them for input. Returns an effect that can be dispatched\nto close the dialog, and a promise that resolves when the dialog\nis closed or a form inside of it is submitted.\n\nYou are encouraged, if your handling of the result of the promise\ndispatches a transaction, to include the `close` effect in it. If\nyou don't, this function will automatically dispatch a separate\ntransaction right after.\n*/ function showDialog(view, config) {\n    let resolve;\n    let promise = new Promise((r)=>resolve = r);\n    let panelCtor = (view)=>createDialog(view, config, resolve);\n    if (view.state.field(dialogField, false)) {\n        view.dispatch({\n            effects: openDialogEffect.of(panelCtor)\n        });\n    } else {\n        view.dispatch({\n            effects: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(dialogField.init(()=>[\n                    panelCtor\n                ]))\n        });\n    }\n    let close = closeDialogEffect.of(panelCtor);\n    return {\n        close,\n        result: promise.then((form)=>{\n            let queue = view.win.queueMicrotask || ((f)=>view.win.setTimeout(f, 10));\n            queue(()=>{\n                if (view.state.field(dialogField).indexOf(panelCtor) > -1) view.dispatch({\n                    effects: close\n                });\n            });\n            return form;\n        })\n    };\n}\n/**\nFind the [`Panel`](https://codemirror.net/6/docs/ref/#view.Panel) for an open dialog, using a class\nname as identifier.\n*/ function getDialog(view, className) {\n    let dialogs = view.state.field(dialogField, false) || [];\n    for (let open of dialogs){\n        let panel = getPanel(view, open);\n        if (panel && panel.dom.classList.contains(className)) return panel;\n    }\n    return null;\n}\nconst dialogField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return [];\n    },\n    update (dialogs, tr) {\n        for (let e of tr.effects){\n            if (e.is(openDialogEffect)) dialogs = [\n                e.value\n            ].concat(dialogs);\n            else if (e.is(closeDialogEffect)) dialogs = dialogs.filter((d)=>d != e.value);\n        }\n        return dialogs;\n    },\n    provide: (f)=>showPanel.computeN([\n            f\n        ], (state)=>state.field(f))\n});\nconst openDialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nconst closeDialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction createDialog(view, config, result) {\n    let content = config.content ? config.content(view, ()=>done(null)) : null;\n    if (!content) {\n        content = (0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"form\");\n        if (config.input) {\n            let input = (0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"input\", config.input);\n            if (/^(text|password|number|email|tel|url)$/.test(input.type)) input.classList.add(\"cm-textfield\");\n            if (!input.name) input.name = \"input\";\n            content.appendChild((0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"label\", (config.label || \"\") + \": \", input));\n        } else {\n            content.appendChild(document.createTextNode(config.label || \"\"));\n        }\n        content.appendChild(document.createTextNode(\" \"));\n        content.appendChild((0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"button\", {\n            class: \"cm-button\",\n            type: \"submit\"\n        }, config.submitLabel || \"OK\"));\n    }\n    let forms = content.nodeName == \"FORM\" ? [\n        content\n    ] : content.querySelectorAll(\"form\");\n    for(let i = 0; i < forms.length; i++){\n        let form = forms[i];\n        form.addEventListener(\"keydown\", (event)=>{\n            if (event.keyCode == 27) {\n                event.preventDefault();\n                done(null);\n            } else if (event.keyCode == 13) {\n                event.preventDefault();\n                done(form);\n            }\n        });\n        form.addEventListener(\"submit\", (event)=>{\n            event.preventDefault();\n            done(form);\n        });\n    }\n    let panel = (0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"div\", content, (0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"button\", {\n        onclick: ()=>done(null),\n        \"aria-label\": view.state.phrase(\"close\"),\n        class: \"cm-dialog-close\",\n        type: \"button\"\n    }, [\n        \"\\xd7\"\n    ]));\n    if (config.class) panel.className = config.class;\n    panel.classList.add(\"cm-dialog\");\n    function done(form) {\n        if (panel.contains(panel.ownerDocument.activeElement)) view.focus();\n        result(form);\n    }\n    return {\n        dom: panel,\n        top: config.top,\n        mount: ()=>{\n            if (config.focus) {\n                let focus;\n                if (typeof config.focus == \"string\") focus = content.querySelector(config.focus);\n                else focus = content.querySelector(\"input\") || content.querySelector(\"button\");\n                if (focus && \"select\" in focus) focus.select();\n                else if (focus && \"focus\" in focus) focus.focus();\n            }\n        }\n    };\n}\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/ class GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeValue {\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */ eq(other) {\n        return false;\n    }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */ destroy(dom) {}\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/ const gutterLineClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet used to add a class to all gutter elements next to a widget.\nShould not provide widgets with a `toDOM` method.\n*/ const gutterWidgetClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: ()=>_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty,\n    lineMarker: ()=>null,\n    widgetMarker: ()=>null,\n    lineMarkerChange: null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {},\n    side: \"before\"\n};\nconst activeGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/ function gutter(config) {\n    return [\n        gutters(),\n        activeGutters.of({\n            ...defaults,\n            ...config\n        })\n    ];\n}\nconst unfixGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/ function gutters(config) {\n    let result = [\n        gutterView\n    ];\n    if (config && config.fixed === false) result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.domAfter = null;\n        this.prevViewport = view.viewport;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters cm-gutters-before\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n        this.gutters = view.state.facet(activeGutters).map((conf)=>new SingleGutterView(view, conf));\n        this.fixed = !view.state.facet(unfixGutters);\n        for (let gutter of this.gutters){\n            if (gutter.config.side == \"after\") this.getDOMAfter().appendChild(gutter.dom);\n            else this.dom.appendChild(gutter.dom);\n        }\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        this.syncGutters(false);\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    getDOMAfter() {\n        if (!this.domAfter) {\n            this.domAfter = document.createElement(\"div\");\n            this.domAfter.className = \"cm-gutters cm-gutters-after\";\n            this.domAfter.setAttribute(\"aria-hidden\", \"true\");\n            this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n            this.domAfter.style.position = this.fixed ? \"sticky\" : \"\";\n            this.view.scrollDOM.appendChild(this.domAfter);\n        }\n        return this.domAfter;\n    }\n    update(update) {\n        if (this.updateGutters(update)) {\n            // Detach during sync when the viewport changed significantly\n            // (such as during scrolling), since for large updates that is\n            // faster.\n            let vpA = this.prevViewport, vpB = update.view.viewport;\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n        }\n        if (update.geometryChanged) {\n            let min = this.view.contentHeight / this.view.scaleY + \"px\";\n            this.dom.style.minHeight = min;\n            if (this.domAfter) this.domAfter.style.minHeight = min;\n        }\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n            if (this.domAfter) this.domAfter.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n        this.prevViewport = update.view.viewport;\n    }\n    syncGutters(detach) {\n        let after = this.dom.nextSibling;\n        if (detach) {\n            this.dom.remove();\n            if (this.domAfter) this.domAfter.remove();\n        }\n        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map((gutter)=>new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n        for (let line of this.view.viewportLineBlocks){\n            if (classSet.length) classSet = [];\n            if (Array.isArray(line.type)) {\n                let first = true;\n                for (let b of line.type){\n                    if (b.type == BlockType.Text && first) {\n                        advanceCursor(lineClasses, classSet, b.from);\n                        for (let cx of contexts)cx.line(this.view, b, classSet);\n                        first = false;\n                    } else if (b.widget) {\n                        for (let cx of contexts)cx.widget(this.view, b);\n                    }\n                }\n            } else if (line.type == BlockType.Text) {\n                advanceCursor(lineClasses, classSet, line.from);\n                for (let cx of contexts)cx.line(this.view, line, classSet);\n            } else if (line.widget) {\n                for (let cx of contexts)cx.widget(this.view, line);\n            }\n        }\n        for (let cx of contexts)cx.finish();\n        if (detach) {\n            this.view.scrollDOM.insertBefore(this.dom, after);\n            if (this.domAfter) this.view.scrollDOM.appendChild(this.domAfter);\n        }\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)if (gutter.update(update)) change = true;\n        } else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur){\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                } else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters){\n                g.dom.remove();\n                if (gutters.indexOf(g) < 0) g.destroy();\n            }\n            for (let g of gutters){\n                if (g.config.side == \"after\") this.getDOMAfter().appendChild(g.dom);\n                else this.dom.appendChild(g.dom);\n            }\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        for (let view of this.gutters)view.destroy();\n        this.dom.remove();\n        if (this.domAfter) this.domAfter.remove();\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            if (!value || value.gutters.length == 0 || !value.fixed) return null;\n            let before = value.dom.offsetWidth * view.scaleX, after = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;\n            return view.textDirection == Direction.LTR ? {\n                left: before,\n                right: after\n            } : {\n                right: before,\n                left: after\n            };\n        })\n});\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\nfunction advanceCursor(cursor, collect, pos) {\n    while(cursor.value && cursor.from <= pos){\n        if (cursor.from == pos) collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport, height){\n        this.gutter = gutter;\n        this.height = height;\n        this.i = 0;\n        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.iter(gutter.markers, viewport.from);\n    }\n    addElement(view, block, markers) {\n        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, height, above, markers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        } else {\n            gutter.elements[this.i].update(view, height, above, markers);\n        }\n        this.height = block.bottom;\n        this.i++;\n    }\n    line(view, line, extraMarkers) {\n        let localMarkers = [];\n        advanceCursor(this.cursor, localMarkers, line.from);\n        if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine) localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n        this.addElement(view, line, localMarkers);\n    }\n    widget(view, block) {\n        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [\n            marker\n        ] : null;\n        for (let cls of view.state.facet(gutterWidgetClass)){\n            let marker = cls(view, block.widget, block);\n            if (marker) (markers || (markers = [])).push(marker);\n        }\n        if (markers) this.addElement(view, block, markers);\n    }\n    finish() {\n        let gutter = this.gutter;\n        while(gutter.elements.length > this.i){\n            let last = gutter.elements.pop();\n            gutter.dom.removeChild(last.dom);\n            last.destroy();\n        }\n    }\n}\nclass SingleGutterView {\n    constructor(view, config){\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for(let prop in config.domEventHandlers){\n            this.dom.addEventListener(prop, (event)=>{\n                let target = event.target, y;\n                if (target != this.dom && this.dom.contains(target)) {\n                    while(target.parentNode != this.dom)target = target.parentNode;\n                    let rect = target.getBoundingClientRect();\n                    y = (rect.top + rect.bottom) / 2;\n                } else {\n                    y = event.clientY;\n                }\n                let line = view.lineBlockAtHeight(y - view.documentTop);\n                if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [\n                config.initialSpacer(view)\n            ]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [\n                updated\n            ]);\n        }\n        let vp = update.view.viewport;\n        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n    }\n    destroy() {\n        for (let elt of this.elements)elt.destroy();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers){\n        this.height = -1;\n        this.above = 0;\n        this.markers = [];\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutterElement\";\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height) {\n            this.height = height;\n            this.dom.style.height = height + \"px\";\n        }\n        if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n    }\n    setMarkers(view, markers) {\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\n        for(let iNew = 0, iOld = 0;;){\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\n            if (marker) {\n                let c = marker.elementClass;\n                if (c) cls += \" \" + c;\n                for(let i = iOld; i < this.markers.length; i++)if (this.markers[i].compare(marker)) {\n                    skipTo = i;\n                    matched = true;\n                    break;\n                }\n            } else {\n                skipTo = this.markers.length;\n            }\n            while(iOld < skipTo){\n                let next = this.markers[iOld++];\n                if (next.toDOM) {\n                    next.destroy(domPos);\n                    let after = domPos.nextSibling;\n                    domPos.remove();\n                    domPos = after;\n                }\n            }\n            if (!marker) break;\n            if (marker.toDOM) {\n                if (matched) domPos = domPos.nextSibling;\n                else this.dom.insertBefore(marker.toDOM(view), domPos);\n            }\n            if (matched) iOld++;\n        }\n        this.dom.className = cls;\n        this.markers = markers;\n    }\n    destroy() {\n        this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].compare(b[i])) return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/ const lineNumberMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet used to create markers in the line number gutter next to widgets.\n*/ const lineNumberWidgetMarker = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, {\n            formatNumber: String,\n            domEventHandlers: {}\n        }, {\n            domEventHandlers (a, b) {\n                let result = Object.assign({}, a);\n                for(let event in b){\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event)=>exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number){\n        super();\n        this.number = number;\n    }\n    eq(other) {\n        return this.number == other.number;\n    }\n    toDOM() {\n        return document.createTextNode(this.number);\n    }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/ activeGutters.compute([\n    lineNumberConfig\n], (state)=>({\n        class: \"cm-lineNumbers\",\n        renderEmptyElements: false,\n        markers (view) {\n            return view.state.facet(lineNumberMarkers);\n        },\n        lineMarker (view, line, others) {\n            if (others.some((m)=>m.toDOM)) return null;\n            return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n        },\n        widgetMarker: (view, widget, block)=>{\n            for (let m of view.state.facet(lineNumberWidgetMarker)){\n                let result = m(view, widget, block);\n                if (result) return result;\n            }\n            return null;\n        },\n        lineMarkerChange: (update)=>update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n        initialSpacer (view) {\n            return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n        },\n        updateSpacer (spacer, update) {\n            let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n            return max == spacer.number ? spacer : new NumberMarker(max);\n        },\n        domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,\n        side: \"before\"\n    }));\n/**\nCreate a line number gutter extension.\n*/ function lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while(last < lines)last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/ new class extends GutterMarker {\n    constructor(){\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/ gutterLineClass.compute([\n    \"selection\"\n], (state)=>{\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges){\n        let linePos = state.doc.lineAt(range.head).from;\n        if (linePos > last) {\n            last = linePos;\n            marks.push(activeLineGutterMarker.range(linePos));\n        }\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/ function highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\nfunction matcher(decorator) {\n    return ViewPlugin.define((view)=>({\n            decorations: decorator.createDeco(view),\n            update (u) {\n                this.decorations = decorator.updateDeco(u, this.decorations);\n            }\n        }), {\n        decorations: (v)=>v.decorations\n    });\n}\nconst tabDeco = /*@__PURE__*/ Decoration.mark({\n    class: \"cm-highlightTab\"\n});\nconst spaceDeco = /*@__PURE__*/ Decoration.mark({\n    class: \"cm-highlightSpace\"\n});\nconst whitespaceHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\t| /g,\n    decoration: (match)=>match[0] == \"\t\" ? tabDeco : spaceDeco,\n    boundary: /\\S/\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/ function highlightWhitespace() {\n    return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\s+$/g,\n    decoration: /*@__PURE__*/ Decoration.mark({\n        class: \"cm-trailingSpace\"\n    })\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/ function highlightTrailingWhitespace() {\n    return trailingHighlighter;\n}\n/**\n@internal\n*/ const __test = {\n    HeightMap,\n    HeightOracle,\n    MeasuredHeights,\n    QueryType,\n    ChangedRange,\n    computeOrder,\n    moveVisually,\n    clearHeightChangeFlag,\n    getHeightChangeFlag: ()=>heightChangeFlag\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcVM7QUFDN1A7QUFDVztBQUMzQjtBQUV4QixJQUFJMEIsTUFBTSxPQUFPQyxhQUFhLGNBQWNBLFlBQVk7SUFBRUMsV0FBVztJQUFJQyxRQUFRO0lBQUlDLFVBQVU7QUFBRztBQUNsRyxJQUFJQyxNQUFNLE9BQU9DLFlBQVksY0FBY0EsV0FBVztJQUFFQyxpQkFBaUI7UUFBRUMsT0FBTyxDQUFDO0lBQUU7QUFBRTtBQUN2RixNQUFNQyxVQUFVLFdBQVcsR0FBRSxjQUFjQyxJQUFJLENBQUNWLElBQUlFLFNBQVM7QUFDN0QsTUFBTVMsWUFBWSxXQUFXLEdBQUUsVUFBVUMsSUFBSSxDQUFDWixJQUFJRSxTQUFTO0FBQzNELE1BQU1XLFVBQVUsV0FBVyxHQUFFLHdDQUF3Q0gsSUFBSSxDQUFDVixJQUFJRSxTQUFTO0FBQ3ZGLE1BQU1ZLEtBQUssQ0FBQyxDQUFFSCxDQUFBQSxhQUFhRSxXQUFXSixPQUFNO0FBQzVDLE1BQU1NLFFBQVEsQ0FBQ0QsTUFBTSxXQUFXLEdBQUUsZ0JBQWdCRixJQUFJLENBQUNaLElBQUlFLFNBQVM7QUFDcEUsTUFBTWMsU0FBUyxDQUFDRixNQUFNLFdBQVcsR0FBRSxnQkFBZ0JKLElBQUksQ0FBQ1YsSUFBSUUsU0FBUztBQUNyRSxNQUFNZSxTQUFTLHlCQUF5QlosSUFBSUUsZUFBZSxDQUFDQyxLQUFLO0FBQ2pFLE1BQU1VLFNBQVMsQ0FBQ0osTUFBTSxXQUFXLEdBQUUsaUJBQWlCRixJQUFJLENBQUNaLElBQUlHLE1BQU07QUFDbkUsTUFBTWdCLE1BQU1ELFVBQVcsV0FBVyxHQUFFLGVBQWNOLElBQUksQ0FBQ1osSUFBSUUsU0FBUyxLQUFLRixJQUFJb0IsY0FBYyxHQUFHO0FBQzlGLElBQUlDLFVBQVU7SUFDVkMsS0FB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QUFBLElBQUtBLEVBQUV5TixXQUFXO0lBQ25DO0FBQ0o7QUFDQSxNQUFNKzlDLFVBQVUsV0FBVyxHQUFFaGtELFdBQVdqRSxJQUFJLENBQUM7SUFBRUcsT0FBTztBQUFrQjtBQUN4RSxNQUFNK25ELFlBQVksV0FBVyxHQUFFamtELFdBQVdqRSxJQUFJLENBQUM7SUFBRUcsT0FBTztBQUFvQjtBQUM1RSxNQUFNZ29ELHdCQUF3QixXQUFXLEdBQUVKLFFBQVEsV0FBVyxHQUFFLElBQUk1UixlQUFlO0lBQy9FQyxRQUFRO0lBQ1JDLFlBQVlLLENBQUFBLFFBQVNBLEtBQUssQ0FBQyxFQUFFLElBQUksTUFBT3VSLFVBQVVDO0lBQ2xEM1IsVUFBVTtBQUNkO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTNlI7SUFDTCxPQUFPRDtBQUNYO0FBQ0EsTUFBTUUsc0JBQXNCLFdBQVcsR0FBRU4sUUFBUSxXQUFXLEdBQUUsSUFBSTVSLGVBQWU7SUFDN0VDLFFBQVE7SUFDUkMsWUFBWSxXQUFXLEdBQUVweUMsV0FBV2pFLElBQUksQ0FBQztRQUFFRyxPQUFPO0lBQW1CO0FBQ3pFO0FBQ0E7OztBQUdBLEdBQ0EsU0FBU21vRDtJQUNMLE9BQU9EO0FBQ1g7QUFFQTs7QUFFQSxHQUNBLE1BQU1FLFNBQVM7SUFBRTcwQjtJQUFXcEI7SUFBY2E7SUFBaUJLO0lBQVdqZ0I7SUFBY25GO0lBQ2hGRztJQUFjOGpCO0lBQXVCbTJCLHFCQUFxQixJQUFNcDJCO0FBQWlCO0FBRTZuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYXJuY29kZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci92aWV3L2Rpc3QvaW5kZXguanM/ODdjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0LCBSYW5nZVNldCwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgZmluZENsdXN0ZXJCcmVhaywgRWRpdG9yU2VsZWN0aW9uLCBGYWNldCwgU3RhdGVFZmZlY3QsIENoYW5nZVNldCwgZmluZENvbHVtbiwgQ2hhckNhdGVnb3J5LCBFZGl0b3JTdGF0ZSwgQW5ub3RhdGlvbiwgVHJhbnNhY3Rpb24sIFByZWMsIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBSYW5nZVNldEJ1aWxkZXIsIGNvdW50Q29sdW1uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuaW1wb3J0IHsga2V5TmFtZSwgYmFzZSwgc2hpZnQgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxubGV0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IHsgdXNlckFnZW50OiBcIlwiLCB2ZW5kb3I6IFwiXCIsIHBsYXRmb3JtOiBcIlwiIH07XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH07XG5jb25zdCBpZV9lZGdlID0gLypAX19QVVJFX18qLy9FZGdlXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gLypAX19QVVJFX18qLy9NU0lFIFxcZC8udGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvKkBfX1BVUkVfXyovL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGdlY2tvID0gIWllICYmIC8qQF9fUFVSRV9fKi8vZ2Vja29cXC8oXFxkKykvaS50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgY2hyb21lID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuY29uc3QgaW9zID0gc2FmYXJpICYmICgvKkBfX1BVUkVfXyovL01vYmlsZVxcL1xcdysvLnRlc3QobmF2LnVzZXJBZ2VudCkgfHwgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG52YXIgYnJvd3NlciA9IHtcbiAgICBtYWM6IGlvcyB8fCAvKkBfX1BVUkVfXyovL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIHdpbmRvd3M6IC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgbGludXg6IC8qQF9fUFVSRV9fKi8vTGludXh8WDExLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgaWUsXG4gICAgaWVfdmVyc2lvbjogaWVfdXB0bzEwID8gZG9jLmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMCxcbiAgICBnZWNrbyxcbiAgICBnZWNrb192ZXJzaW9uOiBnZWNrbyA/ICsoLypAX19QVVJFX18qLy9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvcyxcbiAgICBhbmRyb2lkOiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2LnVzZXJBZ2VudCksXG4gICAgd2Via2l0LFxuICAgIHdlYmtpdF92ZXJzaW9uOiB3ZWJraXQgPyArKC8qQF9fUFVSRV9fKi8vXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgc2FmYXJpLFxuICAgIHNhZmFyaV92ZXJzaW9uOiBzYWZhcmkgPyArKC8qQF9fUFVSRV9fKi8vXFxiVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLmV4ZWMobmF2LnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgdGFiU2l6ZTogZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS50YWJTaXplICE9IG51bGwgPyBcInRhYi1zaXplXCIgOiBcIi1tb3otdGFiLXNpemVcIlxufTtcblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHJvb3QpIHtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIC8vIEJyb3dzZXJzIGRpZmZlciBvbiB3aGV0aGVyIHNoYWRvdyByb290cyBoYXZlIGEgZ2V0U2VsZWN0aW9uXG4gICAgLy8gbWV0aG9kLiBJZiBpdCBleGlzdHMsIHVzZSB0aGF0LCBvdGhlcndpc2UsIGNhbGwgaXQgb24gdGhlXG4gICAgLy8gZG9jdW1lbnQuXG4gICAgaWYgKHJvb3Qubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgdGFyZ2V0ID0gcm9vdC5nZXRTZWxlY3Rpb24gPyByb290IDogcm9vdC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKGRvbSwgbm9kZSkge1xuICAgIHJldHVybiBub2RlID8gZG9tID09IG5vZGUgfHwgZG9tLmNvbnRhaW5zKG5vZGUubm9kZVR5cGUgIT0gMSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24oZG9tLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIXNlbGVjdGlvbi5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBjb250YWlucyhkb20sIHNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3RzRm9yKGRvbSkge1xuICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIHRleHRSYW5nZShkb20sIDAsIGRvbS5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICByZXR1cm4gZG9tLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gW107XG59XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRQb3NpdGlvbihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlID8gKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRvbUluZGV4KG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSB0YXJnZXROb2RlICYmIG9mZiA9PSB0YXJnZXRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9mZiA9PSAoZGlyIDwgMCA/IDAgOiBtYXhPZmZzZXQobm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBtYXhPZmZzZXQobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWF4T2Zmc2V0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5SZWN0KHJlY3QsIGxlZnQpIHtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tIH07XG59XG5mdW5jdGlvbiB3aW5kb3dSZWN0KHdpbikge1xuICAgIGxldCB2cCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgICBpZiAodnApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAwLCByaWdodDogdnAud2lkdGgsXG4gICAgICAgICAgICB0b3A6IDAsIGJvdHRvbTogdnAuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0IH07XG59XG5mdW5jdGlvbiBnZXRTY2FsZShlbHQsIHJlY3QpIHtcbiAgICBsZXQgc2NhbGVYID0gcmVjdC53aWR0aCAvIGVsdC5vZmZzZXRXaWR0aDtcbiAgICBsZXQgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyBlbHQub2Zmc2V0SGVpZ2h0O1xuICAgIGlmIChzY2FsZVggPiAwLjk5NSAmJiBzY2FsZVggPCAxLjAwNSB8fCAhaXNGaW5pdGUoc2NhbGVYKSB8fCBNYXRoLmFicyhyZWN0LndpZHRoIC0gZWx0Lm9mZnNldFdpZHRoKSA8IDEpXG4gICAgICAgIHNjYWxlWCA9IDE7XG4gICAgaWYgKHNjYWxlWSA+IDAuOTk1ICYmIHNjYWxlWSA8IDEuMDA1IHx8ICFpc0Zpbml0ZShzY2FsZVkpIHx8IE1hdGguYWJzKHJlY3QuaGVpZ2h0IC0gZWx0Lm9mZnNldEhlaWdodCkgPCAxKVxuICAgICAgICBzY2FsZVkgPSAxO1xuICAgIHJldHVybiB7IHNjYWxlWCwgc2NhbGVZIH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcoZG9tLCByZWN0LCBzaWRlLCB4LCB5LCB4TWFyZ2luLCB5TWFyZ2luLCBsdHIpIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tLCBzdG9wID0gZmFsc2U7IGN1ciAmJiAhc3RvcDspIHtcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7IC8vIEVsZW1lbnRcbiAgICAgICAgICAgIGxldCBib3VuZGluZywgdG9wID0gY3VyID09IGRvYy5ib2R5O1xuICAgICAgICAgICAgbGV0IHNjYWxlWCA9IDEsIHNjYWxlWSA9IDE7XG4gICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB3aW5kb3dSZWN0KHdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oZml4ZWR8c3RpY2t5KSQvLnRlc3QoZ2V0Q29tcHV0ZWRTdHlsZShjdXIpLnBvc2l0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5zY3JvbGxIZWlnaHQgPD0gY3VyLmNsaWVudEhlaWdodCAmJiBjdXIuc2Nyb2xsV2lkdGggPD0gY3VyLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IGN1ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAoeyBzY2FsZVgsIHNjYWxlWSB9ID0gZ2V0U2NhbGUoY3VyLCByZWN0KSk7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIGN1ci5jbGllbnRXaWR0aCAqIHNjYWxlWCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGN1ci5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgICAgIGlmICh5ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC50b3AgLSAoYm91bmRpbmcudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSArIG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgKHJlY3QudG9wIC0gbW92ZVkpIDwgYm91bmRpbmcudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LnRvcCAtIChib3VuZGluZy50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AsIGJvdW5kaW5nSGVpZ2h0ID0gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRUb3AgPSB5ID09IFwiY2VudGVyXCIgJiYgcmVjdEhlaWdodCA8PSBib3VuZGluZ0hlaWdodCA/IHJlY3QudG9wICsgcmVjdEhlaWdodCAvIDIgLSBib3VuZGluZ0hlaWdodCAvIDIgOlxuICAgICAgICAgICAgICAgICAgICB5ID09IFwic3RhcnRcIiB8fCB5ID09IFwiY2VudGVyXCIgJiYgc2lkZSA8IDAgPyByZWN0LnRvcCAtIHlNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5ib3R0b20gLSBib3VuZGluZ0hlaWdodCArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVkgPSB0YXJnZXRUb3AgLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5sZWZ0IC0gKGJvdW5kaW5nLmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgcmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LmxlZnQgLSAoYm91bmRpbmcubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRMZWZ0ID0geCA9PSBcImNlbnRlclwiID8gcmVjdC5sZWZ0ICsgKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMiAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpIC8gMiA6XG4gICAgICAgICAgICAgICAgICAgICh4ID09IFwic3RhcnRcIikgPT0gbHRyID8gcmVjdC5sZWZ0IC0geE1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnJpZ2h0IC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVYID0gdGFyZ2V0TGVmdCAtIGJvdW5kaW5nLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVkWCA9IDAsIG1vdmVkWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxUb3AgKz0gbW92ZVkgLyBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFkgPSAoY3VyLnNjcm9sbFRvcCAtIHN0YXJ0KSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbExlZnQgKz0gbW92ZVggLyBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFggPSAoY3VyLnNjcm9sbExlZnQgLSBzdGFydCkgKiBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gbW92ZWRYLCB0b3A6IHJlY3QudG9wIC0gbW92ZWRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgLSBtb3ZlZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBtb3ZlZFkgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWCAmJiBNYXRoLmFicyhtb3ZlZFggLSBtb3ZlWCkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRZICYmIE1hdGguYWJzKG1vdmVkWSAtIG1vdmVZKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCB8fCByZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSB8fFxuICAgICAgICAgICAgICAgIHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgfHwgcmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0KVxuICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IE1hdGgubWF4KHJlY3QubGVmdCwgYm91bmRpbmcubGVmdCksIHJpZ2h0OiBNYXRoLm1pbihyZWN0LnJpZ2h0LCBib3VuZGluZy5yaWdodCksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogTWF0aC5tYXgocmVjdC50b3AsIGJvdW5kaW5nLnRvcCksIGJvdHRvbTogTWF0aC5taW4ocmVjdC5ib3R0b20sIGJvdW5kaW5nLmJvdHRvbSkgfTtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7IC8vIEEgc2hhZG93IHJvb3RcbiAgICAgICAgICAgIGN1ciA9IGN1ci5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzY3JvbGxhYmxlUGFyZW50cyhkb20pIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHgsIHk7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tLnBhcmVudE5vZGU7IGN1cjspIHtcbiAgICAgICAgaWYgKGN1ciA9PSBkb2MuYm9keSB8fCAoeCAmJiB5KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmICgheSAmJiBjdXIuc2Nyb2xsSGVpZ2h0ID4gY3VyLmNsaWVudEhlaWdodClcbiAgICAgICAgICAgICAgICB5ID0gY3VyO1xuICAgICAgICAgICAgaWYgKCF4ICYmIGN1ci5zY3JvbGxXaWR0aCA+IGN1ci5jbGllbnRXaWR0aClcbiAgICAgICAgICAgICAgICB4ID0gY3VyO1xuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xufVxuY2xhc3MgRE9NU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGVxKGRvbVNlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JOb2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIHRoaXMuYW5jaG9yT2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMuZm9jdXNOb2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgdGhpcy5mb2N1c09mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIHNldFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGZvY3VzTm9kZSB9ID0gcmFuZ2U7XG4gICAgICAgIC8vIENsaXAgb2Zmc2V0cyB0byBub2RlIHNpemUgdG8gYXZvaWQgY3Jhc2hlcyB3aGVuIFNhZmFyaSByZXBvcnRzIGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgICAgICB0aGlzLnNldChhbmNob3JOb2RlLCBNYXRoLm1pbihyYW5nZS5hbmNob3JPZmZzZXQsIGFuY2hvck5vZGUgPyBtYXhPZmZzZXQoYW5jaG9yTm9kZSkgOiAwKSwgZm9jdXNOb2RlLCBNYXRoLm1pbihyYW5nZS5mb2N1c09mZnNldCwgZm9jdXNOb2RlID8gbWF4T2Zmc2V0KGZvY3VzTm9kZSkgOiAwKSk7XG4gICAgfVxuICAgIHNldChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gU2FmYXJpIDI2IGJyZWFrcyBwcmV2ZW50U2Nyb2xsIHN1cHBvcnRcbmlmIChicm93c2VyLnNhZmFyaSAmJiBicm93c2VyLnNhZmFyaV92ZXJzaW9uID49IDI2KVxuICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXIsIGN1ci5zY3JvbGxUb3AsIGN1ci5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKGN1ciA9PSBjdXIub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gc3RhY2tbaSsrXSwgdG9wID0gc3RhY2tbaSsrXSwgbGVmdCA9IHN0YWNrW2krK107XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbFRvcCAhPSB0b3ApXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzY3JhdGNoUmFuZ2U7XG5mdW5jdGlvbiB0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgbGV0IHJhbmdlID0gc2NyYXRjaFJhbmdlIHx8IChzY3JhdGNoUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20pO1xuICAgIHJldHVybiByYW5nZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoS2V5KGVsdCwgbmFtZSwgY29kZSwgbW9kcykge1xuICAgIGxldCBvcHRpb25zID0geyBrZXk6IG5hbWUsIGNvZGU6IG5hbWUsIGtleUNvZGU6IGNvZGUsIHdoaWNoOiBjb2RlLCBjYW5jZWxhYmxlOiB0cnVlIH07XG4gICAgaWYgKG1vZHMpXG4gICAgICAgICh7IGFsdEtleTogb3B0aW9ucy5hbHRLZXksIGN0cmxLZXk6IG9wdGlvbnMuY3RybEtleSwgc2hpZnRLZXk6IG9wdGlvbnMuc2hpZnRLZXksIG1ldGFLZXk6IG9wdGlvbnMubWV0YUtleSB9ID0gbW9kcyk7XG4gICAgbGV0IGRvd24gPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwgb3B0aW9ucyk7XG4gICAgZG93bi5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KGRvd24pO1xuICAgIGxldCB1cCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIiwgb3B0aW9ucyk7XG4gICAgdXAuc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudCh1cCk7XG4gICAgcmV0dXJuIGRvd24uZGVmYXVsdFByZXZlbnRlZCB8fCB1cC5kZWZhdWx0UHJldmVudGVkO1xufVxuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT0gOSB8fCBub2RlLm5vZGVUeXBlID09IDExICYmIG5vZGUuaG9zdCkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbGVhckF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHdoaWxlIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZU5vZGUobm9kZS5hdHRyaWJ1dGVzWzBdKTtcbn1cbmZ1bmN0aW9uIGF0RWxlbWVudFN0YXJ0KGRvYywgc2VsZWN0aW9uKSB7XG4gICAgbGV0IG5vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JOb2RlICE9IG5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBTYWZhcmkgY2FuIHJlcG9ydCBib2d1cyBvZmZzZXRzICgjMTE1MilcbiAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG1heE9mZnNldChub2RlKSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlID09IGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1Njcm9sbGVkVG9Cb3R0b20oZWx0KSB7XG4gICAgcmV0dXJuIGVsdC5zY3JvbGxUb3AgPiBNYXRoLm1heCgxLCBlbHQuc2Nyb2xsSGVpZ2h0IC0gZWx0LmNsaWVudEhlaWdodCAtIDQpO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUoc3RhcnROb2RlLCBzdGFydE9mZnNldCkge1xuICAgIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGUsIG9mZnNldCA9IHN0YXJ0T2Zmc2V0OzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWlzQmxvY2tFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIoc3RhcnROb2RlLCBzdGFydE9mZnNldCkge1xuICAgIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGUsIG9mZnNldCA9IHN0YXJ0T2Zmc2V0OzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaXNCbG9ja0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRE9NUG9zIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xuICAgIH1cbiAgICBzdGF0aWMgYmVmb3JlKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSwgcHJlY2lzZSk7IH1cbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cbn1cbmNvbnN0IG5vQ2hpbGRyZW4gPSBbXTtcbmNsYXNzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlKHRoaXMpIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc0JlZm9yZSh2aWV3KSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PSB2aWV3KVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY2hpbGQgaW4gcG9zQmVmb3JlXCIpO1xuICAgIH1cbiAgICBwb3NBZnRlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSh2aWV3KSArIHZpZXcubGVuZ3RoO1xuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYgMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi8pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbCwgbmV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQuZG9tICYmIChuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudFZpZXcgfHwgIWNvbnRlbnRWaWV3LnBhcmVudCAmJiBjb250ZW50Vmlldy5jYW5SZXVzZURPTShjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucmV1c2VET00obmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgIXRyYWNrLndyaXR0ZW4gJiYgdHJhY2subm9kZSA9PSBwYXJlbnQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQuZG9tLCBuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKG5leHQgJiYgdHJhY2sgJiYgdHJhY2subm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAobmV4dClcbiAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZsYWdzICYgMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShfZG9tKSB7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5kb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBtYXhPZmZzZXQobm9kZSkgPT0gMCA/IDAgOiBvZmZzZXQgPT0gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChiaWFzID09IDAgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT0gcGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXIgPT0gdGhpcy5kb20uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIgJiYgIUNvbnRlbnRWaWV3LmdldChhZnRlcikpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kb20gPT0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZnJvbUkgPSAtMSwgZnJvbVN0YXJ0ID0gLTEsIHRvSSA9IC0xLCB0b0VuZCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gb2Zmc2V0LCBwcmV2RW5kID0gb2Zmc2V0OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgcG9zKTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gZnJvbSAmJiBmcm9tSSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZyb21JID0gaTtcbiAgICAgICAgICAgICAgICBmcm9tU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID4gdG8gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0b0kgPSBpO1xuICAgICAgICAgICAgICAgIHRvRW5kID0gcHJldkVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZFbmQgPSBlbmQ7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb21TdGFydCwgdG86IHRvRW5kIDwgMCA/IG9mZnNldCArIHRoaXMubGVuZ3RoIDogdG9FbmQsXG4gICAgICAgICAgICBzdGFydERPTTogKGZyb21JID8gdGhpcy5jaGlsZHJlbltmcm9tSSAtIDFdLmRvbS5uZXh0U2libGluZyA6IG51bGwpIHx8IHRoaXMuZG9tLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBlbmRET006IHRvSSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHRvSSA+PSAwID8gdGhpcy5jaGlsZHJlblt0b0ldLmRvbSA6IG51bGwgfTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGFuZFBhcmVudCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgfD0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eShhbmRQYXJlbnQpO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KGNoaWxkTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRMaXN0KVxuICAgICAgICAgICAgICAgIHBhcmVudC5mbGFncyB8PSAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZmxhZ3MgJiAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGFyZW50LmZsYWdzIHw9IDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLztcbiAgICAgICAgICAgIGNoaWxkTGlzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9IHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldERPTShkb20pIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5kb20uY21WaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIGRvbS5jbVZpZXcgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgcm9vdFZpZXcoKSB7XG4gICAgICAgIGZvciAobGV0IHYgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB2LnBhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgdiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlQ2hpbGRyZW4oZnJvbSwgdG8sIGNoaWxkcmVuID0gbm9DaGlsZHJlbikge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09IHRoaXMgJiYgY2hpbGRyZW4uaW5kZXhPZihjaGlsZCkgPCAwKVxuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoIDwgMjUwKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tLCAuLi5jaGlsZHJlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXS5jb25jYXQodGhpcy5jaGlsZHJlbi5zbGljZSgwLCBmcm9tKSwgY2hpbGRyZW4sIHRoaXMuY2hpbGRyZW4uc2xpY2UodG8pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oX3JlYykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZ25vcmVFdmVudChfZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG4gICAgY2hpbGRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoXCJWaWV3XCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gbmFtZSArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgdGhpcy5jaGlsZHJlbi5qb2luKCkgKyBcIilcIiA6XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA/IFwiW1wiICsgKG5hbWUgPT0gXCJUZXh0XCIgPyB0aGlzLnRleHQgOiB0aGlzLmxlbmd0aCkgKyBcIl1cIiA6IFwiXCIpICtcbiAgICAgICAgICAgICh0aGlzLmJyZWFrQWZ0ZXIgPyBcIiNcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KG5vZGUpIHsgcmV0dXJuIG5vZGUuY21WaWV3OyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLmNvbnN0cnVjdG9yID09IHRoaXMuY29uc3RydWN0b3IgJiYgISgodGhpcy5mbGFncyB8IG90aGVyLmZsYWdzKSAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoaXMgaXMgYSB6ZXJvLWxlbmd0aCB2aWV3IHdpdGggYSBzaWRlLCB0aGlzIHNob3VsZCByZXR1cm4gYVxuICAgIC8vIG51bWJlciA8PSAwIHRvIGluZGljYXRlIGl0IGlzIGJlZm9yZSBpdHMgcG9zaXRpb24sIG9yIGFcbiAgICAvLyBudW1iZXIgPiAwIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICAgIGdldFNpZGUoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT0gdGhpcylcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG59XG5Db250ZW50Vmlldy5wcm90b3R5cGUuYnJlYWtBZnRlciA9IDA7XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybSQxKGRvbSkge1xuICAgIGxldCBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5jbGFzcyBDaGlsZEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHBvcywgaSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGZpbmRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAocG9zID4gdGhpcy5wb3MgfHwgcG9zID09IHRoaXMucG9zICYmXG4gICAgICAgICAgICAgICAgKGJpYXMgPiAwIHx8IHRoaXMuaSA9PSAwIHx8IHRoaXMuY2hpbGRyZW5bdGhpcy5pIC0gMV0uYnJlYWtBZnRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiA9IHBvcyAtIHRoaXMucG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuWy0tdGhpcy5pXTtcbiAgICAgICAgICAgIHRoaXMucG9zIC09IG5leHQubGVuZ3RoICsgbmV4dC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGxldCBiZWZvcmUgPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbltmcm9tSV0gOiBudWxsO1xuICAgIGxldCBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCA/IGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIGxldCBicmVha0F0RW5kID0gbGFzdCA/IGxhc3QuYnJlYWtBZnRlciA6IGJyZWFrQXRTdGFydDtcbiAgICAvLyBDaGFuZ2Ugd2l0aGluIGEgc2luZ2xlIGNoaWxkXG4gICAgaWYgKGZyb21JID09IHRvSSAmJiBiZWZvcmUgJiYgIWJyZWFrQXRTdGFydCAmJiAhYnJlYWtBdEVuZCAmJiBpbnNlcnQubGVuZ3RoIDwgMiAmJlxuICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgdG9PZmYsIGluc2VydC5sZW5ndGggPyBsYXN0IDogbnVsbCwgZnJvbU9mZiA9PSAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHRvSSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBjaGlsZHJlblt0b0ldO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVuZCBvZiB0aGUgY2hpbGQgYWZ0ZXIgdGhlIHVwZGF0ZSBpcyBwcmVzZXJ2ZWQgaW4gYGFmdGVyYFxuICAgICAgICBpZiAoYWZ0ZXIgJiYgKHRvT2ZmIDwgYWZ0ZXIubGVuZ3RoIHx8IGFmdGVyLmJyZWFrQWZ0ZXIgJiYgKGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5icmVha0FmdGVyKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHNwbGl0dGluZyBhIGNoaWxkLCBzZXBhcmF0ZSBwYXJ0IG9mIGl0IHRvIGF2b2lkIHRoYXRcbiAgICAgICAgICAgIC8vIGJlaW5nIG1hbmdsZWQgd2hlbiB1cGRhdGluZyB0aGUgY2hpbGQgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgICAgICAgICBpZiAoZnJvbUkgPT0gdG9JKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zcGxpdCh0b09mZik7XG4gICAgICAgICAgICAgICAgdG9PZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHJlcGxhY2VtZW50IHNob3VsZCBiZSBtZXJnZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcmVwbGFjaW5nIGVsZW1lbnQsIHVwZGF0ZSBgY29udGVudGBcbiAgICAgICAgICAgIGlmICghYnJlYWtBdEVuZCAmJiBsYXN0ICYmIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBsYXN0LCB0cnVlLCAwLCBvcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgIGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gPSBhZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGFmdGVyIGVsZW1lbnQsIGlmIG5lY2Vzc2FyeSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0IHRvIGBjb250ZW50YC5cbiAgICAgICAgICAgICAgICBpZiAodG9PZmYgfHwgYWZ0ZXIuY2hpbGRyZW4ubGVuZ3RoICYmICFhZnRlci5jaGlsZHJlblswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBudWxsLCBmYWxzZSwgMCwgb3BlbkVuZCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFmdGVyID09PSBudWxsIHx8IGFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZnRlci5icmVha0FmdGVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBhdCBgdG9JYCBpcyBlbnRpcmVseSBjb3ZlcmVkIGJ5IHRoaXMgcmFuZ2UuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBpdHMgbGluZSBicmVhaywgaWYgYW55LlxuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgbGFzdC5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGhhbmRsZWQgdGhlIG5leHQgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRzXG4gICAgICAgIC8vIG5vdywgbWFrZSBzdXJlIGB0b0lgIHBvaW50cyBhZnRlciB0aGF0LlxuICAgICAgICB0b0krKztcbiAgICB9XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGJyZWFrQXRTdGFydDtcbiAgICAgICAgaWYgKGZyb21PZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRTdGFydCAmJiBpbnNlcnQubGVuZ3RoICYmIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBpbnNlcnRbMF0sIGZhbHNlLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBpbnNlcnQuc2hpZnQoKS5icmVha0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbU9mZiA8IGJlZm9yZS5sZW5ndGggfHwgYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAmJiBiZWZvcmUuY2hpbGRyZW5bYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIG51bGwsIGZhbHNlLCBvcGVuU3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gbWVyZ2Ugd2lkZ2V0cyBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICB3aGlsZSAoZnJvbUkgPCB0b0kgJiYgaW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoY2hpbGRyZW5bdG9JIC0gMV0uYmVjb21lKGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICB0b0ktLTtcbiAgICAgICAgICAgIGluc2VydC5wb3AoKTtcbiAgICAgICAgICAgIG9wZW5FbmQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5TdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltmcm9tSV0uYmVjb21lKGluc2VydFswXSkpIHtcbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgICAgICBpbnNlcnQuc2hpZnQoKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlbkVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zZXJ0Lmxlbmd0aCAmJiBmcm9tSSAmJiB0b0kgPCBjaGlsZHJlbi5sZW5ndGggJiYgIWNoaWxkcmVuW2Zyb21JIC0gMV0uYnJlYWtBZnRlciAmJlxuICAgICAgICBjaGlsZHJlblt0b0ldLm1lcmdlKDAsIDAsIGNoaWxkcmVuW2Zyb21JIC0gMV0sIGZhbHNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICBmcm9tSS0tO1xuICAgIGlmIChmcm9tSSA8IHRvSSB8fCBpbnNlcnQubGVuZ3RoKVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkcmVuKGZyb21JLCB0b0ksIGluc2VydCk7XG59XG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuSW50byhwYXJlbnQsIGZyb20sIHRvLCBpbnNlcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCBjdXIgPSBwYXJlbnQuY2hpbGRDdXJzb3IoKTtcbiAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1ci5maW5kUG9zKHRvLCAxKTtcbiAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXIuZmluZFBvcyhmcm9tLCAtMSk7XG4gICAgbGV0IGRMZW4gPSBmcm9tIC0gdG87XG4gICAgZm9yIChsZXQgdmlldyBvZiBpbnNlcnQpXG4gICAgICAgIGRMZW4gKz0gdmlldy5sZW5ndGg7XG4gICAgcGFyZW50Lmxlbmd0aCArPSBkTGVuO1xuICAgIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIDAsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbmNvbnN0IE1heEpvaW5MZW4gPSAyNTY7XG5jbGFzcyBUZXh0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgY3JlYXRlRE9NKHRleHRET00pIHtcbiAgICAgICAgdGhpcy5zZXRET00odGV4dERPTSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tLm5vZGVWYWx1ZSAhPSB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20ubm9kZVZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTShkb20pO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlKSB7XG4gICAgICAgIGlmICgodGhpcy5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pIHx8XG4gICAgICAgICAgICBzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHNvdXJjZS5sZW5ndGggPiBNYXhKb2luTGVuIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZS5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pICsgKHNvdXJjZSA/IHNvdXJjZS50ZXh0IDogXCJcIikgKyB0aGlzLnRleHQuc2xpY2UodG8pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZShmcm9tKSk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmVzdWx0LmZsYWdzIHw9IHRoaXMuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBub2RlID09IHRoaXMuZG9tID8gb2Zmc2V0IDogb2Zmc2V0ID8gdGhpcy50ZXh0Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gbmV3IERPTVBvcyh0aGlzLmRvbSwgcG9zKTsgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChfZnJvbSwgX3RvLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2Zmc2V0LCB0bzogb2Zmc2V0ICsgdGhpcy5sZW5ndGgsIHN0YXJ0RE9NOiB0aGlzLmRvbSwgZW5kRE9NOiB0aGlzLmRvbS5uZXh0U2libGluZyB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb29yZHModGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgfVxufVxuY2xhc3MgTWFya1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IobWFyaywgY2hpbGRyZW4gPSBbXSwgbGVuZ3RoID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGNoLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgc2V0QXR0cnMoZG9tKSB7XG4gICAgICAgIGNsZWFyQXR0cmlidXRlcyhkb20pO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmNsYXNzKVxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IHRoaXMubWFyay5jbGFzcztcbiAgICAgICAgaWYgKHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdGhpcy5tYXJrLmF0dHJzW25hbWVdKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhblJldXNlRE9NKG90aGVyKSAmJiAhKCh0aGlzLmZsYWdzIHwgb3RoZXIuZmxhZ3MpICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyk7XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gdGhpcy5tYXJrLnRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLyB8IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMuc2V0QXR0cnMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1hcmsudGFnTmFtZSkpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLylcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnModGhpcy5kb20pO1xuICAgICAgICBzdXBlci5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX2hhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBzb3VyY2UubWFyay5lcSh0aGlzLm1hcmspKSB8fFxuICAgICAgICAgICAgKGZyb20gJiYgb3BlblN0YXJ0IDw9IDApIHx8ICh0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuLnNsaWNlKCkgOiBbXSwgb3BlblN0YXJ0IC0gMSwgb3BlbkVuZCAtIDEpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIG9mZiA9IDAsIGRldGFjaEZyb20gPSAtMSwgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gb2ZmICsgZWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9mZiA8IGZyb20gPyBlbHQuc3BsaXQoZnJvbSAtIG9mZikgOiBlbHQpO1xuICAgICAgICAgICAgaWYgKGRldGFjaEZyb20gPCAwICYmIG9mZiA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIGRldGFjaEZyb20gPSBpO1xuICAgICAgICAgICAgb2ZmID0gZW5kO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aCAtIGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbTtcbiAgICAgICAgaWYgKGRldGFjaEZyb20gPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBkZXRhY2hGcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3KHRoaXMubWFyaywgcmVzdWx0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gY29vcmRzSW5DaGlsZHJlbih0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGxlbmd0aCA9IHRleHQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBpZiAocG9zID4gbGVuZ3RoKVxuICAgICAgICBwb3MgPSBsZW5ndGg7XG4gICAgbGV0IGZyb20gPSBwb3MsIHRvID0gcG9zLCBmbGF0dGVuID0gMDtcbiAgICBpZiAocG9zID09IDAgJiYgc2lkZSA8IDAgfHwgcG9zID09IGxlbmd0aCAmJiBzaWRlID49IDApIHtcbiAgICAgICAgaWYgKCEoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykpIHsgLy8gVGhlc2UgYnJvd3NlcnMgcmVsaWFibHkgcmV0dXJuIHZhbGlkIHJlY3RhbmdsZXMgZm9yIGVtcHR5IHJhbmdlc1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gMTtcbiAgICAgICAgICAgIH0gLy8gRklYTUUgdGhpcyBpcyB3cm9uZyBpbiBSVEwgdGV4dFxuICAgICAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNpZGUgPCAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgfVxuICAgIGxldCByZWN0cyA9IHRleHRSYW5nZSh0ZXh0LCBmcm9tLCB0bykuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlY3QgPSByZWN0c1soZmxhdHRlbiA/IGZsYXR0ZW4gPCAwIDogc2lkZSA+PSAwKSA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWZsYXR0ZW4gJiYgcmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZWN0ID0gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgciA9PiByLndpZHRoKSB8fCByZWN0O1xuICAgIHJldHVybiBmbGF0dGVuID8gZmxhdHRlblJlY3QocmVjdCwgZmxhdHRlbiA8IDApIDogcmVjdCB8fCBudWxsO1xufVxuLy8gQWxzbyB1c2VkIGZvciBjb2xsYXBzZWQgcmFuZ2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHBsYWNlaG9sZGVyIHdpZGdldCFcbmNsYXNzIFdpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgc3RhdGljIGNyZWF0ZSh3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdpZGdldFZpZXcod2lkZ2V0LCBsZW5ndGgsIHNpZGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFdpZGdldFZpZXcuY3JlYXRlKHRoaXMud2lkZ2V0LCB0aGlzLmxlbmd0aCAtIGZyb20sIHRoaXMuc2lkZSk7XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IGZyb207XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZSAmJlxuICAgICAgICAgICAgdGhpcy53aWRnZXQuY29uc3RydWN0b3IgPT0gb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmNvbXBhcmUob3RoZXIud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodG9wLnBhcmVudClcbiAgICAgICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRvcCwgdGV4dCA9IHZpZXcgJiYgdmlldy5zdGF0ZS5kb2MsIHN0YXJ0ID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4gdGV4dCA/IHRleHQuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5sZW5ndGgpIDogVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sZW5ndGggPyBwb3MgPT0gMCA6IHRoaXMuc2lkZSA+IDApXG4gICAgICAgICAgICA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pXG4gICAgICAgICAgICA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgcmVjdHMgPSB0aGlzLmRvbS5nZXRDbGllbnRSZWN0cygpLCByZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGZyb21CYWNrID0gdGhpcy5zaWRlID8gdGhpcy5zaWRlIDwgMCA6IHBvcyA+IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tQmFjayA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwOzsgaSArPSAoZnJvbUJhY2sgPyAtMSA6IDEpKSB7XG4gICAgICAgICAgICByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocG9zID4gMCA/IGkgPT0gMCA6IGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAhZnJvbUJhY2spO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LmlzSGlkZGVuOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG59XG4vLyBUaGVzZSBhcmUgZHJhd24gYXJvdW5kIHVuZWRpdGFibGUgd2lkZ2V0cyB0byBhdm9pZCBhIG51bWJlciBvZlxuLy8gYnJvd3NlciBidWdzIHRoYXQgc2hvdyB1cCB3aGVuIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgbmV4dCB0b1xuLy8gdW5lZGl0YWJsZSBpbmxpbmUgY29udGVudC5cbmNsYXNzIFdpZGdldEJ1ZmZlclZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuICAgIG1lcmdlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0QnVmZmVyVmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZTtcbiAgICB9XG4gICAgc3BsaXQoKSB7IHJldHVybiBuZXcgV2lkZ2V0QnVmZmVyVmlldyh0aGlzLnNpZGUpOyB9XG4gICAgc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJjbS13aWRnZXRCdWZmZXJcIjtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNpZGUoKSB7IHJldHVybiB0aGlzLnNpZGU7IH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIHRoaXMuc2lkZSA+IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSk7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oKSB7IHJldHVybiAwOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0cnVlOyB9XG59XG5UZXh0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldEJ1ZmZlclZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gbm9DaGlsZHJlbjtcbmZ1bmN0aW9uIGlubGluZURPTUF0UG9zKHBhcmVudCwgcG9zKSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudC5kb20sIHsgY2hpbGRyZW4gfSA9IHBhcmVudCwgaSA9IDA7XG4gICAgZm9yIChsZXQgb2ZmID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPT0gb2ZmICYmIGNoaWxkLmdldFNpZGUoKSA8PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChwb3MgPiBvZmYgJiYgcG9zIDwgZW5kICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21BdFBvcyhwb3MgLSBvZmYpO1xuICAgICAgICBpZiAocG9zIDw9IG9mZilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvZmYgPSBlbmQ7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgIGxldCBwcmV2ID0gY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICBpZiAocHJldi5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gcHJldi5kb21BdFBvcyhwcmV2Lmxlbmd0aCk7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKG5leHQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tQXRQb3MoMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRE9NUG9zKGRvbSwgMCk7XG59XG4vLyBBc3N1bWVzIGB2aWV3YCwgaWYgYSBtYXJrIHZpZXcsIGhhcyBwcmVjaXNlbHkgMSBjaGlsZC5cbmZ1bmN0aW9uIGpvaW5JbmxpbmVJbnRvKHBhcmVudCwgdmlldywgb3Blbikge1xuICAgIGxldCBsYXN0LCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgaWYgKG9wZW4gPiAwICYmIHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBjaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKGxhc3QgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBsYXN0Lm1hcmsuZXEodmlldy5tYXJrKSkge1xuICAgICAgICBqb2luSW5saW5lSW50byhsYXN0LCB2aWV3LmNoaWxkcmVuWzBdLCBvcGVuIC0gMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHZpZXcpO1xuICAgICAgICB2aWV3LnNldFBhcmVudChwYXJlbnQpO1xuICAgIH1cbiAgICBwYXJlbnQubGVuZ3RoICs9IHZpZXcubGVuZ3RoO1xufVxuZnVuY3Rpb24gY29vcmRzSW5DaGlsZHJlbih2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgYmVmb3JlID0gbnVsbCwgYmVmb3JlUG9zID0gLTEsIGFmdGVyID0gbnVsbCwgYWZ0ZXJQb3MgPSAtMTtcbiAgICBmdW5jdGlvbiBzY2FuKHZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IHZpZXcuY2hpbGRyZW4ubGVuZ3RoICYmIG9mZiA8PSBwb3M7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW4oY2hpbGQsIHBvcyAtIG9mZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuaXNIaWRkZW4gJiYgKHNpZGUgPiAwIHx8IG9uU2FtZUxpbmUoYWZ0ZXIsIGNoaWxkKSkpICYmXG4gICAgICAgICAgICAgICAgICAgIChlbmQgPiBwb3MgfHwgb2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhZnRlclBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmIDwgcG9zIHx8IChvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA8IDApICYmICFjaGlsZC5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuKHZpZXcsIHBvcyk7XG4gICAgbGV0IHRhcmdldCA9IChzaWRlIDwgMCA/IGJlZm9yZSA6IGFmdGVyKSB8fCBiZWZvcmUgfHwgYWZ0ZXI7XG4gICAgaWYgKHRhcmdldClcbiAgICAgICAgcmV0dXJuIHRhcmdldC5jb29yZHNBdChNYXRoLm1heCgwLCB0YXJnZXQgPT0gYmVmb3JlID8gYmVmb3JlUG9zIDogYWZ0ZXJQb3MpLCBzaWRlKTtcbiAgICByZXR1cm4gZmFsbGJhY2tSZWN0KHZpZXcpO1xufVxuZnVuY3Rpb24gZmFsbGJhY2tSZWN0KHZpZXcpIHtcbiAgICBsZXQgbGFzdCA9IHZpZXcuZG9tLmxhc3RDaGlsZDtcbiAgICBpZiAoIWxhc3QpXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihsYXN0KTtcbiAgICByZXR1cm4gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIG9uU2FtZUxpbmUoYSwgYikge1xuICAgIGxldCBwb3NBID0gYS5jb29yZHNBdCgwLCAxKSwgcG9zQiA9IGIuY29vcmRzQXQoMCwgMSk7XG4gICAgcmV0dXJuIHBvc0EgJiYgcG9zQiAmJiBwb3NCLnRvcCA8IHBvc0EuYm90dG9tO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQXR0cnMoc291cmNlLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIgJiYgdGFyZ2V0LmNsYXNzKVxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzICs9IFwiIFwiICsgc291cmNlLmNsYXNzO1xuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiB0YXJnZXQuc3R5bGUpXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUgKz0gXCI7XCIgKyBzb3VyY2Uuc3R5bGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNvbnN0IG5vQXR0cnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGF0dHJzRXEoYSwgYiwgaWdub3JlKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhKVxuICAgICAgICBhID0gbm9BdHRycztcbiAgICBpZiAoIWIpXG4gICAgICAgIGIgPSBub0F0dHJzO1xuICAgIGxldCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpLCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChrZXlzQS5sZW5ndGggLSAoaWdub3JlICYmIGtleXNBLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApICE9XG4gICAgICAgIGtleXNCLmxlbmd0aCAtIChpZ25vcmUgJiYga2V5c0IuaW5kZXhPZihpZ25vcmUpID4gLTEgPyAxIDogMCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKGtleSAhPSBpZ25vcmUgJiYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQXR0cnMoZG9tLCBwcmV2LCBhdHRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKHByZXYpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgIGlmICghKGF0dHJzICYmIG5hbWUgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgIGlmIChhdHRycylcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgIGlmICghKHByZXYgJiYgcHJldltuYW1lXSA9PSBhdHRyc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEF0dHJzKGRvbSkge1xuICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0ciA9IGRvbS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICBhdHRyc1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuXG4vKipcbldpZGdldHMgYWRkZWQgdG8gdGhlIGNvbnRlbnQgYXJlIGRlc2NyaWJlZCBieSBzdWJjbGFzc2VzIG9mIHRoaXNcbmNsYXNzLiBVc2luZyBhIGRlc2NyaXB0aW9uIG9iamVjdCBsaWtlIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG9cbmRlbGF5IGNyZWF0aW5nIG9mIHRoZSBET00gc3RydWN0dXJlIGZvciBhIHdpZGdldCB1bnRpbCBpdCBpc1xubmVlZGVkLCBhbmQgdG8gYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgZXZlbiBpZiB0aGUgZGVjb3JhdGlvbnNcbnRoYXQgZGVmaW5lIHRoZW0gYXJlIHJlY3JlYXRlZC5cbiovXG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgaW5zdGFuY2UgdG8gYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgIChUeXBlU2NyaXB0IGNhbid0IGV4cHJlc3MgdGhpcywgYnV0IG9ubHkgaW5zdGFuY2VzIG9mIHRoZSBzYW1lXG4gICAgc3BlY2lmaWMgY2xhc3Mgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuKSBUaGlzIGlzIHVzZWQgdG9cbiAgICBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyB3aGVuIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgbmV3XG4gICAgZGVjb3JhdGlvbiBvZiB0aGUgc2FtZSB0eXBlLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0XG4gICAgcmV0dXJucyBgZmFsc2VgLCB3aGljaCB3aWxsIGNhdXNlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHdpZGdldCB0b1xuICAgIGFsd2F5cyBiZSByZWRyYXduLlxuICAgICovXG4gICAgZXEod2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgYSB3aWRnZXQgb2YgdGhlIHNhbWUgdHlwZSAoYnV0XG4gICAgZGlmZmVyZW50LCBub24tYGVxYCBjb250ZW50KSB0byByZWZsZWN0IHRoaXMgd2lkZ2V0LiBNYXkgcmV0dXJuXG4gICAgdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvdWxkIHVwZGF0ZSwgZmFsc2UgdG8gaW5kaWNhdGUgaXRcbiAgICBjb3VsZG4ndCAoaW4gd2hpY2ggY2FzZSB0aGUgd2lkZ2V0IHdpbGwgYmUgcmVkcmF3bikuIFRoZSBkZWZhdWx0XG4gICAgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGZhbHNlLlxuICAgICovXG4gICAgdXBkYXRlRE9NKGRvbSwgdmlldykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVzdGltYXRlZCBoZWlnaHQgdGhpcyB3aWRnZXQgd2lsbCBoYXZlLCB0byBiZSB1c2VkIHdoZW5cbiAgICBlc3RpbWF0aW5nIHRoZSBoZWlnaHQgb2YgY29udGVudCB0aGF0IGhhc24ndCBiZWVuIGRyYXduLiBNYXlcbiAgICByZXR1cm4gLTEgdG8gaW5kaWNhdGUgeW91IGRvbid0IGtub3cuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJucyAtMS5cbiAgICAqL1xuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiAtMTsgfVxuICAgIC8qKlxuICAgIEZvciBpbmxpbmUgd2lkZ2V0cyB0aGF0IGFyZSBkaXNwbGF5ZWQgaW5saW5lIChhcyBvcHBvc2VkIHRvXG4gICAgYGlubGluZS1ibG9ja2ApIGFuZCBpbnRyb2R1Y2UgbGluZSBicmVha3MgKHRocm91Z2ggYDxicj5gIHRhZ3NcbiAgICBvciB0ZXh0dWFsIG5ld2xpbmVzKSwgdGhpcyBtdXN0IGluZGljYXRlIHRoZSBhbW91bnQgb2YgbGluZVxuICAgIGJyZWFrcyB0aGV5IGludHJvZHVjZS4gRGVmYXVsdHMgdG8gMC5cbiAgICAqL1xuICAgIGdldCBsaW5lQnJlYWtzKCkgeyByZXR1cm4gMDsgfVxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB3aGljaCBraW5kcyBvZiBldmVudHMgaW5zaWRlIHRoZSB3aWRnZXRcbiAgICBzaG91bGQgYmUgaWdub3JlZCBieSB0aGUgZWRpdG9yLiBUaGUgZGVmYXVsdCBpcyB0byBpZ25vcmUgYWxsXG4gICAgZXZlbnRzLlxuICAgICovXG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAvKipcbiAgICBPdmVycmlkZSB0aGUgd2F5IHNjcmVlbiBjb29yZGluYXRlcyBmb3IgcG9zaXRpb25zIGF0L2luIHRoZVxuICAgIHdpZGdldCBhcmUgZm91bmQuIGBwb3NgIHdpbGwgYmUgdGhlIG9mZnNldCBpbnRvIHRoZSB3aWRnZXQsIGFuZFxuICAgIGBzaWRlYCB0aGUgc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhhdCBpcyBiZWluZyBxdWVyaWVk4oCUbGVzcyB0aGFuXG4gICAgemVybyBmb3IgYmVmb3JlLCBncmVhdGVyIHRoYW4gemVybyBmb3IgYWZ0ZXIsIGFuZCB6ZXJvIGZvclxuICAgIGRpcmVjdGx5IGF0IHRoYXQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBjb29yZHNBdChkb20sIHBvcywgc2lkZSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIHdpZGdldCBpcyByZW1vdmVkXG4gICAgZnJvbSB0aGUgZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG4vKipcblRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgYmxvY2tzIHRoYXQgY2FuIG9jY3VyIGluIGFuIGVkaXRvciB2aWV3LlxuKi9cbnZhciBCbG9ja1R5cGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCbG9ja1R5cGUpIHtcbiAgICAvKipcbiAgICBBIGxpbmUgb2YgdGV4dC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGFmdGVyIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEJlZm9yZVwiXSA9IDFdID0gXCJXaWRnZXRCZWZvcmVcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uIGJlZm9yZSBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRBZnRlclwiXSA9IDJdID0gXCJXaWRnZXRBZnRlclwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IFtyZXBsYWNpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJlcGxhY2UpIGEgcmFuZ2Ugb2YgY29udGVudC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRSYW5nZVwiXSA9IDNdID0gXCJXaWRnZXRSYW5nZVwiO1xucmV0dXJuIEJsb2NrVHlwZX0pKEJsb2NrVHlwZSB8fCAoQmxvY2tUeXBlID0ge30pKTtcbi8qKlxuQSBkZWNvcmF0aW9uIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBkcmF3IG9yIHN0eWxlIGEgcGllY2Vcbm9mIGNvbnRlbnQuIFlvdSdsbCB1c3VhbGx5IHVzZSBpdCB3cmFwcGVkIGluIGFcbltgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSwgd2hpY2ggYWRkcyBhIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXG5Abm9uYWJzdHJhY3RcbiovXG5jbGFzcyBEZWNvcmF0aW9uIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFydFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZW5kU2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3aWRnZXQsIFxuICAgIC8qKlxuICAgIFRoZSBjb25maWcgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoaXMgZGVjb3JhdGlvbi4gWW91IGNhblxuICAgIGluY2x1ZGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGluIHRoZXJlIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0XG4gICAgeW91ciBkZWNvcmF0aW9uLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9IHN0YXJ0U2lkZTtcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gZW5kU2lkZTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIGRlY29yYXRpb24sIHdoaWNoIGluZmx1ZW5jZXMgdGhlIHN0eWxpbmcgb2YgdGhlXG4gICAgY29udGVudCBpbiBpdHMgcmFuZ2UuIE5lc3RlZCBtYXJrIGRlY29yYXRpb25zIHdpbGwgY2F1c2UgbmVzdGVkXG4gICAgRE9NIGVsZW1lbnRzIHRvIGJlIGNyZWF0ZWQuIE5lc3Rpbmcgb3JkZXIgaXMgZGV0ZXJtaW5lZCBieVxuICAgIHByZWNlZGVuY2Ugb2YgdGhlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZGVjb3JhdGlvbnMpLCB3aXRoXG4gICAgdGhlIGhpZ2hlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zIGNyZWF0aW5nIHRoZSBpbm5lciBET00gbm9kZXMuXG4gICAgU3VjaCBlbGVtZW50cyBhcmUgc3BsaXQgb24gbGluZSBib3VuZGFyaWVzIGFuZCBvbiB0aGUgYm91bmRhcmllc1xuICAgIG9mIGxvd2VyLXByZWNlZGVuY2UgZGVjb3JhdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFyayhzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFya0RlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBkaXNwbGF5cyBhIERPTSBlbGVtZW50IGF0IHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHdpZGdldChzcGVjKSB7XG4gICAgICAgIGxldCBzaWRlID0gTWF0aC5tYXgoLTEwMDAwLCBNYXRoLm1pbigxMDAwMCwgc3BlYy5zaWRlIHx8IDApKSwgYmxvY2sgPSAhIXNwZWMuYmxvY2s7XG4gICAgICAgIHNpZGUgKz0gKGJsb2NrICYmICFzcGVjLmlubGluZU9yZGVyKVxuICAgICAgICAgICAgPyAoc2lkZSA+IDAgPyAzMDAwMDAwMDAgLyogU2lkZS5CbG9ja0FmdGVyICovIDogLTQwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQmVmb3JlICovKVxuICAgICAgICAgICAgOiAoc2lkZSA+IDAgPyAxMDAwMDAwMDAgLyogU2lkZS5JbmxpbmVBZnRlciAqLyA6IC0xMDAwMDAwMDAgLyogU2lkZS5JbmxpbmVCZWZvcmUgKi8pO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50RGVjb3JhdGlvbihzcGVjLCBzaWRlLCBzaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlIGRlY29yYXRpb24gd2hpY2ggcmVwbGFjZXMgdGhlIGdpdmVuIHJhbmdlIHdpdGhcbiAgICBhIHdpZGdldCwgb3Igc2ltcGx5IGhpZGVzIGl0LlxuICAgICovXG4gICAgc3RhdGljIHJlcGxhY2Uoc3BlYykge1xuICAgICAgICBsZXQgYmxvY2sgPSAhIXNwZWMuYmxvY2ssIHN0YXJ0U2lkZSwgZW5kU2lkZTtcbiAgICAgICAgaWYgKHNwZWMuaXNCbG9ja0dhcCkge1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gLTUwMDAwMDAwMCAvKiBTaWRlLkdhcFN0YXJ0ICovO1xuICAgICAgICAgICAgZW5kU2lkZSA9IDQwMDAwMDAwMCAvKiBTaWRlLkdhcEVuZCAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGdldEluY2x1c2l2ZShzcGVjLCBibG9jayk7XG4gICAgICAgICAgICBzdGFydFNpZGUgPSAoc3RhcnQgPyAoYmxvY2sgPyAtMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tJbmNTdGFydCAqLyA6IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8pIDogNTAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jU3RhcnQgKi8pIC0gMTtcbiAgICAgICAgICAgIGVuZFNpZGUgPSAoZW5kID8gKGJsb2NrID8gMjAwMDAwMDAwIC8qIFNpZGUuQmxvY2tJbmNFbmQgKi8gOiAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovKSA6IC02MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNFbmQgKi8pICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvaW50RGVjb3JhdGlvbihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGluZSBkZWNvcmF0aW9uLCB3aGljaCBjYW4gYWRkIERPTSBhdHRyaWJ1dGVzIHRvIHRoZVxuICAgIGxpbmUgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGxpbmUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIFtgRGVjb3JhdGlvblNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uU2V0KSBmcm9tIHRoZSBnaXZlblxuICAgIGRlY29yYXRlZCByYW5nZSBvciByYW5nZXMuIElmIHRoZSByYW5nZXMgYXJlbid0IGFscmVhZHkgc29ydGVkLFxuICAgIHBhc3MgYHRydWVgIGZvciBgc29ydGAgdG8gbWFrZSB0aGUgbGlicmFyeSBzb3J0IHRoZW0gZm9yIHlvdS5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXQob2YsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2VTZXQub2Yob2YsIHNvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGhhc0hlaWdodCgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0ID8gdGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID4gLTEgOiBmYWxzZTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb24ubm9uZSA9IFJhbmdlU2V0LmVtcHR5O1xuY2xhc3MgTWFya0RlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGdldEluY2x1c2l2ZShzcGVjKTtcbiAgICAgICAgc3VwZXIoc3RhcnQgPyAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovIDogNTAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jU3RhcnQgKi8sIGVuZCA/IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8gOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovLCBudWxsLCBzcGVjKTtcbiAgICAgICAgdGhpcy50YWdOYW1lID0gc3BlYy50YWdOYW1lIHx8IFwic3BhblwiO1xuICAgICAgICB0aGlzLmNsYXNzID0gc3BlYy5jbGFzcyB8fCBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJzID0gc3BlYy5hdHRyaWJ1dGVzIHx8IG51bGw7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICBvdGhlciBpbnN0YW5jZW9mIE1hcmtEZWNvcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgdGhpcy50YWdOYW1lID09IG90aGVyLnRhZ05hbWUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5jbGFzcyB8fCAoKF9hID0gdGhpcy5hdHRycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzKSkgPT0gKG90aGVyLmNsYXNzIHx8ICgoX2IgPSBvdGhlci5hdHRycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsYXNzKSkgJiZcbiAgICAgICAgICAgICAgICBhdHRyc0VxKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzLCBcImNsYXNzXCIpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hcmsgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5NYXJrRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcbmNsYXNzIExpbmVEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIG51bGwsIHNwZWMpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5zcGVjLmNsYXNzID09IG90aGVyLnNwZWMuY2xhc3MgJiZcbiAgICAgICAgICAgIGF0dHJzRXEodGhpcy5zcGVjLmF0dHJpYnV0ZXMsIG90aGVyLnNwZWMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZSBkZWNvcmF0aW9uIHJhbmdlcyBtdXN0IGJlIHplcm8tbGVuZ3RoXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5jbGFzcyBQb2ludERlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCB3aWRnZXQsIGlzUmVwbGFjZSkge1xuICAgICAgICBzdXBlcihzdGFydFNpZGUsIGVuZFNpZGUsIHdpZGdldCwgc3BlYyk7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgdGhpcy5pc1JlcGxhY2UgPSBpc1JlcGxhY2U7XG4gICAgICAgIHRoaXMubWFwTW9kZSA9ICFibG9jayA/IE1hcE1vZGUuVHJhY2tEZWwgOiBzdGFydFNpZGUgPD0gMCA/IE1hcE1vZGUuVHJhY2tCZWZvcmUgOiBNYXBNb2RlLlRyYWNrQWZ0ZXI7XG4gICAgfVxuICAgIC8vIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGlzLmJsb2NrID09IHRydWVcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTaWRlICE9IHRoaXMuZW5kU2lkZSA/IEJsb2NrVHlwZS5XaWRnZXRSYW5nZVxuICAgICAgICAgICAgOiB0aGlzLnN0YXJ0U2lkZSA8PSAwID8gQmxvY2tUeXBlLldpZGdldEJlZm9yZSA6IEJsb2NrVHlwZS5XaWRnZXRBZnRlcjtcbiAgICB9XG4gICAgZ2V0IGhlaWdodFJlbGV2YW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayB8fCAhIXRoaXMud2lkZ2V0ICYmICh0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPj0gNSB8fCB0aGlzLndpZGdldC5saW5lQnJlYWtzID4gMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgd2lkZ2V0c0VxKHRoaXMud2lkZ2V0LCBvdGhlci53aWRnZXQpICYmXG4gICAgICAgICAgICB0aGlzLmJsb2NrID09IG90aGVyLmJsb2NrICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9PSBvdGhlci5zdGFydFNpZGUgJiYgdGhpcy5lbmRTaWRlID09IG90aGVyLmVuZFNpZGU7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlcGxhY2UgJiYgKGZyb20gPiB0byB8fCAoZnJvbSA9PSB0byAmJiB0aGlzLnN0YXJ0U2lkZSA+IDAgJiYgdGhpcy5lbmRTaWRlIDw9IDApKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBmb3IgcmVwbGFjZW1lbnQgZGVjb3JhdGlvblwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVwbGFjZSAmJiB0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaWRnZXQgZGVjb3JhdGlvbnMgY2FuIG9ubHkgaGF2ZSB6ZXJvLWxlbmd0aCByYW5nZXNcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuUG9pbnREZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5mdW5jdGlvbiBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2sgPSBmYWxzZSkge1xuICAgIGxldCB7IGluY2x1c2l2ZVN0YXJ0OiBzdGFydCwgaW5jbHVzaXZlRW5kOiBlbmQgfSA9IHNwZWM7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHN0YXJ0ID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogYmxvY2ssIGVuZDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogYmxvY2sgfTtcbn1cbmZ1bmN0aW9uIHdpZGdldHNFcShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCAhIShhICYmIGIgJiYgYS5jb21wYXJlKGIpKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKGZyb20sIHRvLCByYW5nZXMsIG1hcmdpbiA9IDApIHtcbiAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdICsgbWFyZ2luID49IGZyb20pXG4gICAgICAgIHJhbmdlc1tsYXN0XSA9IE1hdGgubWF4KHJhbmdlc1tsYXN0XSwgdG8pO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2VzLnB1c2goZnJvbSwgdG8pO1xufVxuXG5jbGFzcyBMaW5lVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmF0dHJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICB9XG4gICAgLy8gQ29uc3VtZXMgc291cmNlXG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICBzb3VyY2UudHJhbnNmZXJET00odGhpcyk7IC8vIFJldXNlIHNvdXJjZS5kb20gd2hlbiBhcHByb3ByaWF0ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTdGFydClcbiAgICAgICAgICAgIHRoaXMuc2V0RGVjbyhzb3VyY2UgPyBzb3VyY2UuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbi5zbGljZSgpIDogW10sIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChhdCkge1xuICAgICAgICBsZXQgZW5kID0gbmV3IExpbmVWaWV3O1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRQb3MoYXQpO1xuICAgICAgICBpZiAob2ZmKSB7XG4gICAgICAgICAgICBlbmQuYXBwZW5kKHRoaXMuY2hpbGRyZW5baV0uc3BsaXQob2ZmKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLm1lcmdlKG9mZiwgdGhpcy5jaGlsZHJlbltpXS5sZW5ndGgsIG51bGwsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBlbmQuYXBwZW5kKHRoaXMuY2hpbGRyZW5bal0sIDApO1xuICAgICAgICB3aGlsZSAoaSA+IDAgJiYgdGhpcy5jaGlsZHJlbltpIC0gMV0ubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuWy0taV0uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IGk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIHRyYW5zZmVyRE9NKG90aGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIG90aGVyLnNldERPTSh0aGlzLmRvbSk7XG4gICAgICAgIG90aGVyLnByZXZBdHRycyA9IHRoaXMucHJldkF0dHJzID09PSB1bmRlZmluZWQgPyB0aGlzLmF0dHJzIDogdGhpcy5wcmV2QXR0cnM7XG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgfVxuICAgIHNldERlY28oYXR0cnMpIHtcbiAgICAgICAgaWYgKCFhdHRyc0VxKHRoaXMuYXR0cnMsIGF0dHJzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kKGNoaWxkLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgam9pbklubGluZUludG8odGhpcywgY2hpbGQsIG9wZW5TdGFydCk7XG4gICAgfVxuICAgIC8vIE9ubHkgY2FsbGVkIHdoZW4gYnVpbGRpbmcgYSBsaW5lIHZpZXcgaW4gQ29udGVudEJ1aWxkZXJcbiAgICBhZGRMaW5lRGVjbyhkZWNvKSB7XG4gICAgICAgIGxldCBhdHRycyA9IGRlY28uc3BlYy5hdHRyaWJ1dGVzLCBjbHMgPSBkZWNvLnNwZWMuY2xhc3M7XG4gICAgICAgIGlmIChhdHRycylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoYXR0cnMsIHRoaXMuYXR0cnMgfHwge30pO1xuICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyh7IGNsYXNzOiBjbHMgfSwgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gaW5saW5lRE9NQXRQb3ModGhpcywgcG9zKTtcbiAgICB9XG4gICAgcmV1c2VET00obm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovIHwgMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxhZ3MgJiA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8pIHtcbiAgICAgICAgICAgIGNsZWFyQXR0cmlidXRlcyh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldkF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLnByZXZBdHRycywgdGhpcy5hdHRycyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGluZVwiKTtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGxhc3QgJiYgQ29udGVudFZpZXcuZ2V0KGxhc3QpIGluc3RhbmNlb2YgTWFya1ZpZXcpXG4gICAgICAgICAgICBsYXN0ID0gbGFzdC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdCB8fCAhdGhpcy5sZW5ndGggfHxcbiAgICAgICAgICAgIGxhc3Qubm9kZU5hbWUgIT0gXCJCUlwiICYmICgoX2EgPSBDb250ZW50Vmlldy5nZXQobGFzdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VkaXRhYmxlKSA9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICghYnJvd3Nlci5pb3MgfHwgIXRoaXMuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRleHRWaWV3KSkpIHtcbiAgICAgICAgICAgIGxldCBoYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkJSXCIpO1xuICAgICAgICAgICAgaGFjay5jbUlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChoYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IHRoaXMubGVuZ3RoID4gMjApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvdGFsV2lkdGggPSAwLCB0ZXh0SGVpZ2h0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fCAvW14gLX5dLy50ZXN0KGNoaWxkLnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IoY2hpbGQuZG9tKTtcbiAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGggIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gcmVjdHNbMF0ud2lkdGg7XG4gICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gcmVjdHNbMF0uaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdG90YWxXaWR0aCA/IG51bGwgOiB7XG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsXG4gICAgICAgICAgICBjaGFyV2lkdGg6IHRvdGFsV2lkdGggLyB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgIHRleHRIZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCByZWN0ID0gY29vcmRzSW5DaGlsZHJlbih0aGlzLCBwb3MsIHNpZGUpO1xuICAgICAgICAvLyBDb3JyZWN0IHJlY3RhbmdsZSBoZWlnaHQgZm9yIGVtcHR5IGxpbmVzIHdoZW4gdGhlIHJldHVybmVkXG4gICAgICAgIC8vIGhlaWdodCBpcyBsYXJnZXIgdGhhbiB0aGUgdGV4dCBoZWlnaHQuXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgcmVjdCAmJiB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgbGV0IHsgaGVpZ2h0T3JhY2xlIH0gPSB0aGlzLnBhcmVudC52aWV3LnZpZXdTdGF0ZSwgaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQgLSBoZWlnaHRPcmFjbGUubGluZUhlaWdodCkgPCAyICYmIGhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSAoaGVpZ2h0IC0gaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wICsgZGlzdCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIGRpc3QsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGluZVZpZXcgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCAmJiBvdGhlci5jaGlsZHJlbi5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgYXR0cnNFcSh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiYgdGhpcy5icmVha0FmdGVyID09IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgfVxuICAgIGNvdmVycygpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBzdGF0aWMgZmluZChkb2NWaWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCBkb2NWaWV3LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSBkb2NWaWV3LmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBibG9jay5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChibG9jayBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQgKyBibG9jay5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrV2lkZ2V0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgZGVjbykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuZGVjbyA9IGRlY287XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF90YWtlRGVjbywgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3KSB8fCAhdGhpcy53aWRnZXQuY29tcGFyZShzb3VyY2Uud2lkZ2V0KSB8fFxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb20gKyAoc291cmNlID8gc291cmNlLmxlbmd0aCA6IDApICsgKHRoaXMubGVuZ3RoIC0gdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPT0gMCA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tLCBwb3MgPT0gdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBzcGxpdChhdCkge1xuICAgICAgICBsZXQgbGVuID0gdGhpcy5sZW5ndGggLSBhdDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBCbG9ja1dpZGdldFZpZXcodGhpcy53aWRnZXQsIGxlbiwgdGhpcy5kZWNvKTtcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIG5vQ2hpbGRyZW47IH1cbiAgICBzeW5jKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tLCB2aWV3KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odmlldykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmXG4gICAgICAgICAgICBvdGhlci53aWRnZXQuY29uc3RydWN0b3IgPT0gdGhpcy53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXIud2lkZ2V0LmNvbXBhcmUodGhpcy53aWRnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmICF0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvID0gb3RoZXIuZGVjbztcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBpZiAodGhpcy53aWRnZXQgaW5zdGFuY2VvZiBCbG9ja0dhcFdpZGdldClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gZmxhdHRlblJlY3QodGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRoaXMubGVuZ3RoID8gcG9zID09IDAgOiBzaWRlIDw9IDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgIH1cbiAgICBjb3ZlcnMoc2lkZSkge1xuICAgICAgICBsZXQgeyBzdGFydFNpZGUsIGVuZFNpZGUgfSA9IHRoaXMuZGVjbztcbiAgICAgICAgcmV0dXJuIHN0YXJ0U2lkZSA9PSBlbmRTaWRlID8gZmFsc2UgOiBzaWRlIDwgMCA/IHN0YXJ0U2lkZSA8IDAgOiBlbmRTaWRlID4gMDtcbiAgICB9XG59XG5jbGFzcyBCbG9ja0dhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGhlaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gXCJjbS1nYXBcIjtcbiAgICAgICAgdGhpcy51cGRhdGVET00oZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmhlaWdodCA9PSB0aGlzLmhlaWdodDsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IGVkaXRhYmxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmhlaWdodDsgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY2xhc3MgQ29udGVudEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvYywgcG9zLCBlbmQsIGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IgPSBkaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcjtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBbXTtcbiAgICAgICAgLy8gU2V0IHRvIGZhbHNlIGRpcmVjdGx5IGFmdGVyIGEgd2lkZ2V0IHRoYXQgY292ZXJzIHRoZSBwb3NpdGlvbiBhZnRlciBpdFxuICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gLTE7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICAgICAgdGhpcy5za2lwID0gcG9zO1xuICAgIH1cbiAgICBwb3NDb3ZlcmVkKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmJyZWFrQXRTdGFydCAmJiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gIT0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuICEobGFzdC5icmVha0FmdGVyIHx8IGxhc3QgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgbGFzdC5kZWNvLmVuZFNpZGUgPCAwKTtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1ckxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKHRoaXMuY3VyTGluZSA9IG5ldyBMaW5lVmlldyk7XG4gICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJMaW5lO1xuICAgIH1cbiAgICBmbHVzaEJ1ZmZlcihhY3RpdmUgPSB0aGlzLmJ1ZmZlck1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZS5hcHBlbmQod3JhcE1hcmtzKG5ldyBXaWRnZXRCdWZmZXJWaWV3KC0xKSwgYWN0aXZlKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRCbG9ja1dpZGdldCh2aWV3KSB7XG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2godmlldyk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgJiYgb3BlbkVuZCA8PSB0aGlzLmJ1ZmZlck1hcmtzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkgJiZcbiAgICAgICAgICAgICEob3BlbkVuZCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoICYmIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpKVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgfVxuICAgIGJ1aWxkVGV4dChsZW5ndGgsIGFjdGl2ZSwgb3BlblN0YXJ0KSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmID09IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB2YWx1ZSwgbGluZUJyZWFrLCBkb25lIH0gPSB0aGlzLmN1cnNvci5uZXh0KHRoaXMuc2tpcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuIG91dCBvZiB0ZXh0IGNvbnRlbnQgd2hlbiBkcmF3aW5nIGlubGluZSB2aWV3c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSBNYXRoLm1pbih0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmLCBsZW5ndGgpO1xuICAgICAgICAgICAgbGV0IHRha2UgPSBNYXRoLm1pbihyZW1haW5pbmcsIDUxMiAvKiBULkNodW5rICovKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlLnNsaWNlKGFjdGl2ZS5sZW5ndGggLSBvcGVuU3RhcnQpKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh3cmFwTWFya3MobmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZSh0aGlzLnRleHRPZmYsIHRoaXMudGV4dE9mZiArIHRha2UpKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IHRha2U7XG4gICAgICAgICAgICBsZW5ndGggLT0gdGFrZTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IHJlbWFpbmluZyA8PSB0YWtlID8gMCA6IGFjdGl2ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Bhbihmcm9tLCB0bywgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgdGhpcy5idWlsZFRleHQodG8gLSBmcm9tLCBhY3RpdmUsIG9wZW5TdGFydCk7XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28sIGFjdGl2ZSwgb3BlblN0YXJ0LCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcltpbmRleF0gJiYgZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCbG9jayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgICAgIGlmICh0byA+IHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykudG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2tXaWRnZXQobmV3IEJsb2NrV2lkZ2V0VmlldyhkZWNvLndpZGdldCB8fCBOdWxsV2lkZ2V0LmJsb2NrLCBsZW4sIGRlY28pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gV2lkZ2V0Vmlldy5jcmVhdGUoZGVjby53aWRnZXQgfHwgTnVsbFdpZGdldC5pbmxpbmUsIGxlbiwgbGVuID8gMCA6IGRlY28uc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQmVmb3JlID0gdGhpcy5hdEN1cnNvclBvcyAmJiAhdmlldy5pc0VkaXRhYmxlICYmIG9wZW5TdGFydCA8PSBhY3RpdmUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChmcm9tIDwgdG8gfHwgZGVjby5zdGFydFNpZGUgPiAwKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQWZ0ZXIgPSAhdmlldy5pc0VkaXRhYmxlICYmIChmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCB8fCBkZWNvLnN0YXJ0U2lkZSA8PSAwKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgPT0gMiAvKiBCdWYuSWZDdXJzb3IgKi8gJiYgIWN1cnNvckJlZm9yZSAmJiAhdmlldy5pc0VkaXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvckJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoMSksIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5TdGFydCA9IGFjdGl2ZS5sZW5ndGggKyBNYXRoLm1heCgwLCBvcGVuU3RhcnQgLSBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZS5hcHBlbmQod3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IGN1cnNvckFmdGVyO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9ICFjdXJzb3JBZnRlciA/IDAgLyogQnVmLk5vICovIDogZnJvbSA8IHRvIHx8IG9wZW5TdGFydCA+IGFjdGl2ZS5sZW5ndGggPyAxIC8qIEJ1Zi5ZZXMgKi8gOiAyIC8qIEJ1Zi5JZkN1cnNvciAqLztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlck1hcmtzID0gYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tID09IHRoaXMucG9zKSB7IC8vIExpbmUgZGVjb3JhdGlvblxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYWRkTGluZURlY28oZGVjbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgaXRlcmF0b3IgcGFzdCB0aGUgcmVwbGFjZWQgY29udGVudFxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiArIGxlbiA8PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCArPSBsZW4gLSAodGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMudGV4dE9mZik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZCh0ZXh0LCBmcm9tLCB0bywgZGVjb3JhdGlvbnMsIGR5bmFtaWNEZWNvcmF0aW9uTWFwKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IENvbnRlbnRCdWlsZGVyKHRleHQsIGZyb20sIHRvLCBkeW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgIGJ1aWxkZXIub3BlbkVuZCA9IFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlcik7XG4gICAgICAgIGlmIChidWlsZGVyLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICBidWlsZGVyLm9wZW5TdGFydCA9IGJ1aWxkZXIub3BlbkVuZDtcbiAgICAgICAgYnVpbGRlci5maW5pc2goYnVpbGRlci5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSkge1xuICAgIGZvciAobGV0IG1hcmsgb2YgYWN0aXZlKVxuICAgICAgICB2aWV3ID0gbmV3IE1hcmtWaWV3KG1hcmssIFt2aWV3XSwgdmlldy5sZW5ndGgpO1xuICAgIHJldHVybiB2aWV3O1xufVxuY2xhc3MgTnVsbFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnRhZyA9PSB0aGlzLnRhZzsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZyk7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7IHJldHVybiBlbHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSB0aGlzLnRhZzsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRydWU7IH1cbn1cbk51bGxXaWRnZXQuaW5saW5lID0gLypAX19QVVJFX18qL25ldyBOdWxsV2lkZ2V0KFwic3BhblwiKTtcbk51bGxXaWRnZXQuYmxvY2sgPSAvKkBfX1BVUkVfXyovbmV3IE51bGxXaWRnZXQoXCJkaXZcIik7XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbnZhciBEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbnJldHVybiBEaXJlY3Rpb259KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBEaXJlY3Rpb24uTFRSLCBSVEwgPSBEaXJlY3Rpb24uUlRMO1xuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxuZnVuY3Rpb24gZGVjKHN0cikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMSA8PCArc3RyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmOFxuY29uc3QgTG93VHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjQ0NDQ0NDg4MjY2MjcyODg5OTk5OTk5OTk5OTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk5OTk5OTk5OTk5OTk5OTQ0NDQ0NDQ0NDQ2NDQyMjI4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5NDk5OTk5OTkyMjk5ODk5OTkyMjMzMzMzMzMzMzNcIik7XG5jb25zdCBCcmFja2V0cyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBCcmFja2V0U3RhY2sgPSBbXTtcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL0JpZGlCcmFja2V0cy50eHQsXG4vLyB3aGljaCBhcmUgbGVmdCBvdXQgdG8ga2VlcCBjb2RlIHNpemUgZG93bi5cbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XG4gICAgbGV0IGwgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDApLCByID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgxKTtcbiAgICBCcmFja2V0c1tsXSA9IHI7XG4gICAgQnJhY2tldHNbcl0gPSAtbDtcbn1cbmZ1bmN0aW9uIGNoYXJUeXBlKGNoKSB7XG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxuICAgICAgICAweDU5MCA8PSBjaCAmJiBjaCA8PSAweDVmNCA/IDIgLyogVC5SICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgMHgyMDAwIDw9IGNoICYmIGNoIDw9IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmI1MCA8PSBjaCAmJiBjaCA8PSAweGZkZmYgPyA0IC8qIFQuQUwgKi8gOiAxIC8qIFQuTCAqLztcbn1cbmNvbnN0IEJpZGlSRSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXFx1ZmI1MC1cXHVmZGZmXS87XG4vKipcblJlcHJlc2VudHMgYSBjb250aWd1b3VzIHJhbmdlIG9mIHRleHQgdGhhdCBoYXMgYSBzaW5nbGUgZGlyZWN0aW9uXG4oYXMgaW4gbGVmdC10by1yaWdodCBvciByaWdodC10by1sZWZ0KS5cbiovXG5jbGFzcyBCaWRpU3BhbiB7XG4gICAgLyoqXG4gICAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAgKi9cbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgc3BhbiAocmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIFtcImJpZGlcbiAgICBsZXZlbFwiXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNCYXNpY19EaXNwbGF5X0FsZ29yaXRobSlcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXG4gICAgbGVmdC10by1yaWdodCwgMSBtZWFucyByaWdodC10by1sZWZ0LCAyIG1lYW5zIGxlZnQtdG8tcmlnaHRcbiAgICBudW1iZXIgaW5zaWRlIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4gICAgKi9cbiAgICBsZXZlbCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaWRlKGVuZCwgZGlyKSB7IHJldHVybiAodGhpcy5kaXIgPT0gZGlyKSA9PSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3J3YXJkKGZvcndhcmQsIGRpcikgeyByZXR1cm4gZm9yd2FyZCA9PSAodGhpcy5kaXIgPT0gZGlyKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmQob3JkZXIsIGluZGV4LCBsZXZlbCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IG1heWJlID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gb3JkZXJbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGluZGV4ICYmIHNwYW4udG8gPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbi5sZXZlbCA9PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBtdWx0aXBsZSBzcGFucyBtYXRjaCwgaWYgYXNzb2MgIT0gMCwgdGFrZSB0aGUgb25lIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBjb3ZlcnMgdGhhdCBzaWRlLCBvdGhlcndpc2UgdGFrZSB0aGUgb25lIHdpdGggdGhlIG1pbmltdW1cbiAgICAgICAgICAgICAgICAvLyBsZXZlbC5cbiAgICAgICAgICAgICAgICBpZiAobWF5YmUgPCAwIHx8IChhc3NvYyAhPSAwID8gKGFzc29jIDwgMCA/IHNwYW4uZnJvbSA8IGluZGV4IDogc3Bhbi50byA+IGluZGV4KSA6IG9yZGVyW21heWJlXS5sZXZlbCA+IHNwYW4ubGV2ZWwpKVxuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gbWF5YmU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNvbGF0ZXNFcShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpQSA9IGFbaV0sIGlCID0gYltpXTtcbiAgICAgICAgaWYgKGlBLmZyb20gIT0gaUIuZnJvbSB8fCBpQS50byAhPSBpQi50byB8fCBpQS5kaXJlY3Rpb24gIT0gaUIuZGlyZWN0aW9uIHx8ICFpc29sYXRlc0VxKGlBLmlubmVyLCBpQi5pbm5lcikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmV1c2VkIGFycmF5IG9mIGNoYXJhY3RlciB0eXBlc1xuY29uc3QgdHlwZXMgPSBbXTtcbi8vIEZpbGwgaW4gdGhlIGNoYXJhY3RlciB0eXBlcyAoaW4gYHR5cGVzYCkgZnJvbSBgZnJvbWAgdG8gYHRvYCBhbmRcbi8vIGFwcGx5IFcgbm9ybWFsaXphdGlvbiBydWxlcy5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgbGV0IHByZXZUeXBlID0gaUkgPyAyNTYgLyogVC5OSSAqLyA6IG91dGVyVHlwZTtcbiAgICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhblxuICAgICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAgIC8vIG51bWJlci5cbiAgICAgICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFIuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOLCBBTiwgRVQsIENTLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZShsaW5lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gNTEyIC8qIFQuTlNNICovKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBwcmV2O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSA0IC8qIFQuQUwgKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGUgPT0gNCAvKiBULkFMICovID8gMiAvKiBULlIgKi8gOiB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cbiAgICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgICAgLy8gTmV1dHJhbC5cbiAgICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTiwgTkkpXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBwcmV2ID0gcHJldlR5cGUsIHByZXZTdHJvbmcgPSBwcmV2VHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAxMjggLyogVC5DUyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdG8gLSAxICYmIHByZXYgPT0gdHlwZXNbaSArIDFdICYmIChwcmV2ICYgMjQgLyogVC5OdW0gKi8pKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZXNbaV0gPSBwcmV2O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gNjQgLyogVC5FVCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW5kIDwgdG8gJiYgdHlwZXNbZW5kXSA9PSA2NCAvKiBULkVUICovKVxuICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZSA9IChpICYmIHByZXYgPT0gOCAvKiBULkVOICovKSB8fCAoZW5kIDwgclRvICYmIHR5cGVzW2VuZF0gPT0gOCAvKiBULkVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogVC5MICovID8gMSAvKiBULkwgKi8gOiA4IC8qIFQuRU4gKi8pIDogMjU2IC8qIFQuTkkgKi87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcbiAgICAgICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFByb2Nlc3MgYnJhY2tldHMgdGhyb3VnaG91dCBhIHJ1biBzZXF1ZW5jZS5cbmZ1bmN0aW9uIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGxldCBvcHBvc2l0ZVR5cGUgPSBvdXRlclR5cGUgPT0gMSAvKiBULkwgKi8gPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovO1xuICAgIGZvciAobGV0IGlJID0gMCwgc0kgPSAwLCBjb250ZXh0ID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXG4gICAgICAgIC8vIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXNcbiAgICAgICAgLy8gc2NvcGUsIGJpZGlyZWN0aW9uYWwgdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBjaCwgYnIsIHR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBLZWVwcyBbc3RhcnRJbmRleCwgdHlwZSwgc3Ryb25nU2Vlbl0gdHJpcGxlcyBmb3IgZWFjaCBvcGVuXG4gICAgICAgICAgICAvLyBicmFja2V0IG9uIEJyYWNrZXRTdGFjay5cbiAgICAgICAgICAgIGlmIChiciA9IEJyYWNrZXRzW2NoID0gbGluZS5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgICAgIGlmIChiciA8IDApIHsgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnJhY2tldFN0YWNrW3NKICsgMV0gPT0gLWJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAoZmxhZ3MgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLykgPyBvdXRlclR5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLykgPyBvcHBvc2l0ZVR5cGUgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZXNbQnJhY2tldFN0YWNrW3NKXV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNJID0gc0o7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnJhY2tldFN0YWNrLmxlbmd0aCA9PSAxODkgLyogQnJhY2tldGVkLk1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBULlIgKi8gfHwgdHlwZSA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbWJlZCA9IHR5cGUgPT0gb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1iZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzTmV1dHJhbHMockZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAyNTYgLyogVC5OSSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpSSA9PSBpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpc29sYXRlc1tpSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1tlbmRdID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiZWZvcmVMID0gcHJldiA9PSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IHJUbyA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gYmVmb3JlTCA9PSBhZnRlckwgPyAoYmVmb3JlTCA/IDEgLyogVC5MICovIDogMiAvKiBULlIgKi8pIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBlbmQsIGpJID0gaUksIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207IGogPiBpOykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBmcm9tSikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tSiA9IGpJID8gaXNvbGF0ZXNbakkgLSAxXS50byA6IHJGcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzWy0tal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCB0aGUgY29udGlndW91cyByYW5nZXMgb2YgY2hhcmFjdGVyIHR5cGVzIGluIGEgZ2l2ZW4gcmFuZ2UsIGFuZFxuLy8gZW1pdCBzcGFucyBmb3IgdGhlbS4gRmxpcCB0aGUgb3JkZXIgb2YgdGhlIHNwYW5zIGFzIGFwcHJvcHJpYXRlXG4vLyBiYXNlZCBvbiB0aGUgbGV2ZWwsIGFuZCBjYWxsIHRocm91Z2ggdG8gY29tcHV0ZSB0aGUgc3BhbnMgZm9yXG4vLyBpc29sYXRlcyBhdCB0aGUgcHJvcGVyIHBvaW50LlxuZnVuY3Rpb24gZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpIHtcbiAgICBsZXQgb3VyVHlwZSA9IGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgaWYgKChsZXZlbCAlIDIpID09IChiYXNlTGV2ZWwgJSAyKSkgeyAvLyBTYW1lIGRpciBhcyBiYXNlIGRpcmVjdGlvbiwgZG9uJ3QgZmxpcFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSBmcm9tLCBpSSA9IDA7IGlDaCA8IHRvOykge1xuICAgICAgICAgICAgLy8gU2NhbiBhIHNlY3Rpb24gb2YgY2hhcmFjdGVycyBpbiBkaXJlY3Rpb24gb3VyVHlwZSwgdW5sZXNzXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGFub3RoZXIgdHlwZSBvZiBjaGFyIHJpZ2h0IGFmdGVyIGlDaCwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgLy8gd2Ugc2NhbiBhIHNlY3Rpb24gb2Ygb3RoZXIgY2hhcmFjdGVycyAod2hpY2gsIGlmIG91clR5cGUgPT1cbiAgICAgICAgICAgIC8vIFQuTCwgbWF5IGNvbnRhaW4gYm90aCBULlIgYW5kIFQuQU4gY2hhcnMpLlxuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aCB8fCBpQ2ggPCBpc29sYXRlc1tpSV0uZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdHlwZXNbaUNoXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSG9sZHMgYW4gYXJyYXkgb2YgaXNvbGF0ZXMgdG8gcGFzcyB0byBhIHJlY3Vyc2l2ZSBjYWxsIGlmIHdlXG4gICAgICAgICAgICAvLyBtdXN0IHJlY3Vyc2UgKHRvIGRpc3Rpbmd1aXNoIFQuQU4gaW5zaWRlIGFuIFJUTCBzZWN0aW9uIGluXG4gICAgICAgICAgICAvLyBMVFIgdGV4dCksIG51bGwgaWYgd2UgY2FuIGVtaXQgZGlyZWN0bHlcbiAgICAgICAgICAgIGxldCByZWN1cnNlID0gIXNhbWVEaXIgJiYgb3VyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBsb2NhbExldmVsID0gc2FtZURpciA/IGxldmVsIDogbGV2ZWwgKyAxO1xuICAgICAgICAgICAgbGV0IGlTY2FuID0gaUNoO1xuICAgICAgICAgICAgcnVuOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlTY2FuID09IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzW2lJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby50bywgakkgPSBpSSArIDE7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlzb2xhdGVzW2pJXS5mcm9tID09IHVwdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8gPSBpc29sYXRlc1tqSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvXSA9PSBvdXJUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaUkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UucHVzaChpc28pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzby5mcm9tID4gaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaXNvLmZyb20sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpU2NhbiA9PSB0byB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuXSAhPSBvdXJUeXBlIDogdHlwZXNbaVNjYW5dID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaUNoLCBpU2NhbiwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlDaCA8IGlTY2FuKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaVNjYW4sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgdG8gZmxpcCB0aGUgc3BhbiBvcmRlci4gU2FtZSBjb2RlIGFnYWluLCBidXRcbiAgICAgICAgLy8gZ29pbmcgZnJvbSB0aGUgYmFjayBvZiB0aGUgc2VjdGlvbiB0byB0aGUgZnJvbnRcbiAgICAgICAgZm9yIChsZXQgaUNoID0gdG8sIGlJID0gaXNvbGF0ZXMubGVuZ3RoOyBpQ2ggPiBmcm9tOykge1xuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpSSB8fCBpQ2ggPiBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2ggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUkgLSAxXS50bykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc28gPSBpc29sYXRlc1stLWlJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby5mcm9tLCBqSSA9IGlJOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXB0byA9PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJICYmIGlzb2xhdGVzW2pJIC0gMV0udG8gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNbdXB0byAtIDFdID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLnRvIDwgaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlzby50bywgaUNoLCBsb2NhbExldmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlyU3dhcCA9IChpc28uZGlyZWN0aW9uID09IExUUikgIT0gIShsb2NhbExldmVsICUgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGRpclN3YXAgPyBsZXZlbCArIDEgOiBsZXZlbCwgYmFzZUxldmVsLCBpc28uaW5uZXIsIGlzby5mcm9tLCBpc28udG8sIG9yZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlDaCA9IGlzby5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IGZyb20gfHwgKHNhbWVEaXIgPyB0eXBlc1tpU2NhbiAtIDFdICE9IG91clR5cGUgOiB0eXBlc1tpU2NhbiAtIDFdID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaVNjYW4sIGlDaCwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuIDwgaUNoKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlTY2FuLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgZnJvbSwgdG8sIG9yZGVyKSB7XG4gICAgbGV0IG91dGVyVHlwZSA9IChsZXZlbCAlIDIgPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovKTtcbiAgICBjb21wdXRlQ2hhclR5cGVzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzQnJhY2tldFBhaXJzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzTmV1dHJhbHMoZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIGVtaXRTcGFucyhsaW5lLCBmcm9tLCB0bywgbGV2ZWwsIGJhc2VMZXZlbCwgaXNvbGF0ZXMsIG9yZGVyKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVPcmRlcihsaW5lLCBkaXJlY3Rpb24sIGlzb2xhdGVzKSB7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCAwLCBkaXJlY3Rpb24gPT0gUlRMID8gMSA6IDApXTtcbiAgICBpZiAoZGlyZWN0aW9uID09IExUUiAmJiAhaXNvbGF0ZXMubGVuZ3RoICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgaWYgKGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gdHlwZXMubGVuZ3RoKVxuICAgICAgICAgICAgdHlwZXNbdHlwZXMubGVuZ3RoXSA9IDI1NiAvKiBULk5JICovOyAvLyBNYWtlIHN1cmUgdHlwZXMgYXJyYXkgaGFzIG5vIGdhcHNcbiAgICBsZXQgb3JkZXIgPSBbXSwgbGV2ZWwgPSBkaXJlY3Rpb24gPT0gTFRSID8gMCA6IDE7XG4gICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgbGV2ZWwsIGlzb2xhdGVzLCAwLCBsaW5lLmxlbmd0aCwgb3JkZXIpO1xuICAgIHJldHVybiBvcmRlcjtcbn1cbmZ1bmN0aW9uIHRyaXZpYWxPcmRlcihsZW5ndGgpIHtcbiAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCBsZW5ndGgsIDApXTtcbn1cbmxldCBtb3ZlZE92ZXIgPSBcIlwiO1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBtb3ZlcyBzdHJpY3RseSB2aXN1YWxseSwgd2l0aG91dCBjb25jZXJuIGZvciBhXG4vLyB0cmF2ZXJzYWwgdmlzaXRpbmcgZXZlcnkgbG9naWNhbCBwb3NpdGlvbiBpbiB0aGUgc3RyaW5nLiBJdCB3aWxsXG4vLyBzdGlsbCBkbyBzbyBmb3Igc2ltcGxlIGlucHV0LCBidXQgc2l0dWF0aW9ucyBsaWtlIG11bHRpcGxlIGlzb2xhdGVzXG4vLyB3aXRoIHRoZSBzYW1lIGxldmVsIG5leHQgdG8gZWFjaCBvdGhlciwgb3IgdGV4dCBnb2luZyBhZ2FpbnN0IHRoZVxuLy8gbWFpbiBkaXIgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSwgd2lsbCBtYWtlIHNvbWUgcG9zaXRpb25zXG4vLyB1bnJlYWNoYWJsZSB3aXRoIHRoaXMgbW90aW9uLiBFYWNoIHZpc2libGUgY3Vyc29yIHBvc2l0aW9uIHdpbGxcbi8vIGNvcnJlc3BvbmQgdG8gdGhlIGxvd2VyLWxldmVsIGJpZGkgc3BhbiB0aGF0IHRvdWNoZXMgaXQuXG4vL1xuLy8gVGhlIGFsdGVybmF0aXZlIHdvdWxkIGJlIHRvIHNvbHZlIGFuIG9yZGVyIGdsb2JhbGx5IGZvciBhIGdpdmVuXG4vLyBsaW5lLCBtYWtpbmcgc3VyZSB0aGF0IGl0IGluY2x1ZGVzIGV2ZXJ5IHBvc2l0aW9uLCBidXQgdGhhdCB3b3VsZFxuLy8gcmVxdWlyZSBhc3NvY2lhdGluZyBub24tY2Fub25pY2FsIChoaWdoZXIgYmlkaSBzcGFuIGxldmVsKVxuLy8gcG9zaXRpb25zIHdpdGggYSBnaXZlbiB2aXN1YWwgcG9zaXRpb24sIHdoaWNoIGlzIGxpa2VseSB0byBjb25mdXNlXG4vLyBwZW9wbGUuIChBbmQgd291bGQgZ2VuZXJhbGx5IGJlIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQuKVxuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIG9yZGVyLCBkaXIsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaGVhZCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgc3BhbkkgPSBCaWRpU3Bhbi5maW5kKG9yZGVyLCBzdGFydEluZGV4LCAoX2EgPSBzdGFydC5iaWRpTGV2ZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IHNwYW4gPSBvcmRlcltzcGFuSV0sIHNwYW5FbmQgPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKTtcbiAgICAvLyBFbmQgb2Ygc3BhblxuICAgIGlmIChzdGFydEluZGV4ID09IHNwYW5FbmQpIHtcbiAgICAgICAgbGV0IG5leHRJID0gc3BhbkkgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgaWYgKG5leHRJIDwgMCB8fCBuZXh0SSA+PSBvcmRlci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgc3BhbiA9IG9yZGVyW3NwYW5JID0gbmV4dEldO1xuICAgICAgICBzdGFydEluZGV4ID0gc3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpO1xuICAgICAgICBzcGFuRW5kID0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcik7XG4gICAgfVxuICAgIGxldCBuZXh0SW5kZXggPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgc3RhcnRJbmRleCwgc3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikpO1xuICAgIGlmIChuZXh0SW5kZXggPCBzcGFuLmZyb20gfHwgbmV4dEluZGV4ID4gc3Bhbi50bylcbiAgICAgICAgbmV4dEluZGV4ID0gc3BhbkVuZDtcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XG4gICAgbGV0IG5leHRTcGFuID0gc3BhbkkgPT0gKGZvcndhcmQgPyBvcmRlci5sZW5ndGggLSAxIDogMCkgPyBudWxsIDogb3JkZXJbc3BhbkkgKyAoZm9yd2FyZCA/IDEgOiAtMSldO1xuICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0SW5kZXggPT0gc3BhbkVuZCAmJiBuZXh0U3Bhbi5sZXZlbCArIChmb3J3YXJkID8gMCA6IDEpIDwgc3Bhbi5sZXZlbClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dFNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKSArIGxpbmUuZnJvbSwgbmV4dFNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpID8gMSA6IC0xLCBuZXh0U3Bhbi5sZXZlbCk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XG59XG5mdW5jdGlvbiBhdXRvRGlyZWN0aW9uKHRleHQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIGxldCB0eXBlID0gY2hhclR5cGUodGV4dC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gMSAvKiBULkwgKi8pXG4gICAgICAgICAgICByZXR1cm4gTFRSO1xuICAgICAgICBpZiAodHlwZSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgIHJldHVybiBSVEw7XG4gICAgfVxuICAgIHJldHVybiBMVFI7XG59XG5cbmNvbnN0IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZHJhZ01vdmVzU2VsZWN0aW9uJDEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBtb3VzZVNlbGVjdGlvblN0eWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZXhjZXB0aW9uU2luayA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHVwZGF0ZUxpc3RlbmVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZm9jdXNDaGFuZ2VFZmZlY3QgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjbGlwYm9hcmRJbnB1dEZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNsaXBib2FyZE91dHB1dEZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHBlckxpbmVUZXh0RGlyZWN0aW9uID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3QgbmF0aXZlU2VsZWN0aW9uSGlkZGVuID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3Qgc2Nyb2xsSGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIFNjcm9sbFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIHkgPSBcIm5lYXJlc3RcIiwgeCA9IFwibmVhcmVzdFwiLCB5TWFyZ2luID0gNSwgeE1hcmdpbiA9IDUsIFxuICAgIC8vIFRoaXMgZGF0YSBzdHJ1Y3R1cmUgaXMgYWJ1c2VkIHRvIGFsc28gc3RvcmUgcHJlY2lzZSBzY3JvbGxcbiAgICAvLyBzbmFwc2hvdHMsIGluc3RlYWQgb2YgYSBgc2Nyb2xsSW50b1ZpZXdgIHJlcXVlc3QuIFdoZW4gdGhpc1xuICAgIC8vIGZsYWcgaXMgYHRydWVgLCBgcmFuZ2VgIHBvaW50cyBhdCBhIHBvc2l0aW9uIGluIHRoZSByZWZlcmVuY2VcbiAgICAvLyBsaW5lLCBgeU1hcmdpbmAgaG9sZHMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdG9wIG9mIHRoYXRcbiAgICAvLyBsaW5lIGFuZCB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIGFuZCBgeE1hcmdpbmAgaG9sZHMgdGhlXG4gICAgLy8gZWRpdG9yJ3MgYHNjcm9sbExlZnRgLlxuICAgIGlzU25hcHNob3QgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueU1hcmdpbiA9IHlNYXJnaW47XG4gICAgICAgIHRoaXMueE1hcmdpbiA9IHhNYXJnaW47XG4gICAgICAgIHRoaXMuaXNTbmFwc2hvdCA9IGlzU25hcHNob3Q7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgU2Nyb2xsVGFyZ2V0KHRoaXMucmFuZ2UubWFwKGNoYW5nZXMpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4sIHRoaXMuaXNTbmFwc2hvdCk7XG4gICAgfVxuICAgIGNsaXAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UudG8gPD0gc3RhdGUuZG9jLmxlbmd0aCA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IFNjcm9sbFRhcmdldChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXRlLmRvYy5sZW5ndGgpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4sIHRoaXMuaXNTbmFwc2hvdCk7XG4gICAgfVxufVxuY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiAodCwgY2gpID0+IHQubWFwKGNoKSB9KTtcbmNvbnN0IHNldEVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuTG9nIG9yIHJlcG9ydCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGluIGNsaWVudCBjb2RlLiBTaG91bGRcbnByb2JhYmx5IG9ubHkgYmUgdXNlZCBieSBleHRlbnNpb24gY29kZSB0aGF0IGFsbG93cyBjbGllbnQgY29kZSB0b1xucHJvdmlkZSBmdW5jdGlvbnMsIGFuZCBjYWxscyB0aG9zZSBmdW5jdGlvbnMgaW4gYSBjb250ZXh0IHdoZXJlIGFuXG5leGNlcHRpb24gY2FuJ3QgYmUgcHJvcGFnYXRlZCB0byBjYWxsaW5nIGNvZGUgaW4gYSByZWFzb25hYmxlIHdheVxuKGZvciBleGFtcGxlIHdoZW4gaW4gYW4gZXZlbnQgaGFuZGxlcikuXG5cbkVpdGhlciBjYWxscyBhIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoXG5bYEVkaXRvclZpZXcuZXhjZXB0aW9uU2lua2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmV4Y2VwdGlvblNpbmspLFxuYHdpbmRvdy5vbmVycm9yYCwgaWYgZGVmaW5lZCwgb3IgYGNvbnNvbGUuZXJyb3JgIChpbiB3aGljaCBjYXNlXG5pdCdsbCBwYXNzIGBjb250ZXh0YCwgd2hlbiBnaXZlbiwgYXMgZmlyc3QgYXJndW1lbnQpLlxuKi9cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihzdGF0ZSwgZXhjZXB0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhbmRsZXIgPSBzdGF0ZS5mYWNldChleGNlcHRpb25TaW5rKTtcbiAgICBpZiAoaGFuZGxlci5sZW5ndGgpXG4gICAgICAgIGhhbmRsZXJbMF0oZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmICh3aW5kb3cub25lcnJvciAmJiB3aW5kb3cub25lcnJvcihTdHJpbmcoZXhjZXB0aW9uKSwgY29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4Y2VwdGlvbikpIDtcbiAgICBlbHNlIGlmIChjb250ZXh0KVxuICAgICAgICBjb25zb2xlLmVycm9yKGNvbnRleHQgKyBcIjpcIiwgZXhjZXB0aW9uKTtcbiAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXhjZXB0aW9uKTtcbn1cbmNvbnN0IGVkaXRhYmxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdHJ1ZSB9KTtcbmxldCBuZXh0UGx1Z2luSUQgPSAwO1xuY29uc3Qgdmlld1BsdWdpbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUocGx1Z2lucykge1xuICAgICAgICByZXR1cm4gcGx1Z2lucy5maWx0ZXIoKHAsIGkpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5zW2pdLnBsdWdpbiA9PSBwLnBsdWdpbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5WaWV3IHBsdWdpbnMgYXNzb2NpYXRlIHN0YXRlZnVsIHZhbHVlcyB3aXRoIGEgdmlldy4gVGhleSBjYW5cbmluZmx1ZW5jZSB0aGUgd2F5IHRoZSBjb250ZW50IGlzIGRyYXduLCBhbmQgYXJlIG5vdGlmaWVkIG9mIHRoaW5nc1xudGhhdCBoYXBwZW4gaW4gdGhlIHZpZXcuIFRoZXkgb3B0aW9uYWxseSB0YWtlIGFuIGFyZ3VtZW50LCBpblxud2hpY2ggY2FzZSB5b3UgbmVlZCB0byBjYWxsIFtgb2ZgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbi5vZikgdG8gY3JlYXRlXG5hbiBleHRlbnNpb24gZm9yIHRoZSBwbHVnaW4uIFdoZW4gdGhlIGFyZ3VtZW50IHR5cGUgaXMgdW5kZWZpbmVkLFxueW91IGNhbiB1c2UgdGhlIHBsdWdpbiBpbnN0YW5jZSBhcyBhbiBleHRlbnNpb24gZGlyZWN0bHkuXG4qL1xuY2xhc3MgVmlld1BsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjcmVhdGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tRXZlbnRIYW5kbGVycywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudE9ic2VydmVycywgYnVpbGRFeHRlbnNpb25zKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRIYW5kbGVycyA9IGRvbUV2ZW50SGFuZGxlcnM7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRPYnNlcnZlcnMgPSBkb21FdmVudE9ic2VydmVycztcbiAgICAgICAgdGhpcy5iYXNlRXh0ZW5zaW9ucyA9IGJ1aWxkRXh0ZW5zaW9ucyh0aGlzKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSB0aGlzLmJhc2VFeHRlbnNpb25zLmNvbmNhdCh2aWV3UGx1Z2luLm9mKHsgcGx1Z2luOiB0aGlzLCBhcmc6IHVuZGVmaW5lZCB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIHRoaXMgcGx1Z2luIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50LlxuICAgICovXG4gICAgb2YoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VFeHRlbnNpb25zLmNvbmNhdCh2aWV3UGx1Z2luLm9mKHsgcGx1Z2luOiB0aGlzLCBhcmcgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBwbHVnaW4gZnJvbSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNyZWF0ZSwgc3BlYykge1xuICAgICAgICBjb25zdCB7IGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwcm92aWRlLCBkZWNvcmF0aW9uczogZGVjbyB9ID0gc3BlYyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UGx1Z2luKG5leHRQbHVnaW5JRCsrLCBjcmVhdGUsIGV2ZW50SGFuZGxlcnMsIGV2ZW50T2JzZXJ2ZXJzLCBwbHVnaW4gPT4ge1xuICAgICAgICAgICAgbGV0IGV4dCA9IFtdO1xuICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgZXh0LnB1c2goZGVjb3JhdGlvbnMub2YodmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW5JbnN0ID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkluc3QgPyBkZWNvKHBsdWdpbkluc3QpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKHByb3ZpZGUocGx1Z2luKSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gICAgZWRpdG9yIHZpZXcgYXMgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUNsYXNzKGNscywgc3BlYykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKHZpZXcsIGFyZykgPT4gbmV3IGNscyh2aWV3LCBhcmcpLCBzcGVjKTtcbiAgICB9XG59XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBudWxsYC4gUmV0cmlldmluZyBhIHBsdWdpbiB0aGF0IG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIHVwZGF0ZWQgd2l0aCBgdmlldy5wbHVnaW5gIGZvcmNlcyBhbiBlYWdlciB1cGRhdGUuXG4gICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgaXMgbnVsbCB3aGVuIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIGJ1dFxuICAgICAgICAvLyBpbml0aWFsaXplZCBvbiB0aGUgZmlyc3QgdXBkYXRlLlxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBsdWdpbigpIHsgcmV0dXJuIHRoaXMuc3BlYyAmJiB0aGlzLnNwZWMucGx1Z2luOyB9XG4gICAgdXBkYXRlKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGVjKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3BlYy5wbHVnaW4uY3JlYXRlKHZpZXcsIHRoaXMuc3BlYy5hcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjb250ZW50QXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcbmNvbnN0IGRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3Qgb3V0ZXJEZWNvcmF0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGF0b21pY1JhbmdlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGJpZGlJc29sYXRlZFJhbmdlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGdldElzb2xhdGVkUmFuZ2VzKHZpZXcsIGxpbmUpIHtcbiAgICBsZXQgaXNvbGF0ZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGJpZGlJc29sYXRlZFJhbmdlcyk7XG4gICAgaWYgKCFpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBpc29sYXRlcztcbiAgICBsZXQgc2V0cyA9IGlzb2xhdGVzLm1hcChpID0+IGkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGkodmlldykgOiBpKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgUmFuZ2VTZXQuc3BhbnMoc2V0cywgbGluZS5mcm9tLCBsaW5lLnRvLCB7XG4gICAgICAgIHBvaW50KCkgeyB9LFxuICAgICAgICBzcGFuKGZyb21Eb2MsIHRvRG9jLCBhY3RpdmUsIG9wZW4pIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZnJvbURvYyAtIGxpbmUuZnJvbSwgdG8gPSB0b0RvYyAtIGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHJlc3VsdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBhY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0sIG9wZW4tLSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBhY3RpdmVbaV0uc3BlYy5iaWRpSXNvbGF0ZSwgdXBkYXRlO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gYXV0b0RpcmVjdGlvbihsaW5lLnRleHQsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlbiA+IDAgJiYgbGV2ZWwubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICh1cGRhdGUgPSBsZXZlbFtsZXZlbC5sZW5ndGggLSAxXSkudG8gPT0gZnJvbSAmJiB1cGRhdGUuZGlyZWN0aW9uID09IGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudG8gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSB1cGRhdGUuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0geyBmcm9tLCB0bywgZGlyZWN0aW9uLCBpbm5lcjogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwucHVzaChhZGQpO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IGFkZC5pbm5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgc2Nyb2xsTWFyZ2lucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGdldFNjcm9sbE1hcmdpbnModmlldykge1xuICAgIGxldCBsZWZ0ID0gMCwgcmlnaHQgPSAwLCB0b3AgPSAwLCBib3R0b20gPSAwO1xuICAgIGZvciAobGV0IHNvdXJjZSBvZiB2aWV3LnN0YXRlLmZhY2V0KHNjcm9sbE1hcmdpbnMpKSB7XG4gICAgICAgIGxldCBtID0gc291cmNlKHZpZXcpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgaWYgKG0ubGVmdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBtLmxlZnQpO1xuICAgICAgICAgICAgaWYgKG0ucmlnaHQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBtLnJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChtLnRvcCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgbS50b3ApO1xuICAgICAgICAgICAgaWYgKG0uYm90dG9tICE9IG51bGwpXG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYm90dG9tLCBtLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH07XG59XG5jb25zdCBzdHlsZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIENoYW5nZWRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikge1xuICAgICAgICB0aGlzLmZyb21BID0gZnJvbUE7XG4gICAgICAgIHRoaXMudG9BID0gdG9BO1xuICAgICAgICB0aGlzLmZyb21CID0gZnJvbUI7XG4gICAgICAgIHRoaXMudG9CID0gdG9CO1xuICAgIH1cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlZFJhbmdlKE1hdGgubWluKHRoaXMuZnJvbUEsIG90aGVyLmZyb21BKSwgTWF0aC5tYXgodGhpcy50b0EsIG90aGVyLnRvQSksIE1hdGgubWluKHRoaXMuZnJvbUIsIG90aGVyLmZyb21CKSwgTWF0aC5tYXgodGhpcy50b0IsIG90aGVyLnRvQikpO1xuICAgIH1cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGkgPSBzZXQubGVuZ3RoLCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZXRbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmZyb21BID4gbWUudG9BKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnRvQSA8IG1lLmZyb21BKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbWUgPSBtZS5qb2luKHJhbmdlKTtcbiAgICAgICAgICAgIHNldC5zcGxpY2UoaSAtIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5zcGxpY2UoaSwgMCwgbWUpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBzdGF0aWMgZXh0ZW5kV2l0aFJhbmdlcyhkaWZmLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGRJID0gMCwgckkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7OyBkSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGRJID09IGRpZmYubGVuZ3RoID8gbnVsbCA6IGRpZmZbZEldLCBvZmYgPSBwb3NBIC0gcG9zQjtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tQiA6IDFlOTtcbiAgICAgICAgICAgIHdoaWxlIChySSA8IHJhbmdlcy5sZW5ndGggJiYgcmFuZ2VzW3JJXSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW3JJXSwgdG8gPSByYW5nZXNbckkgKyAxXTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUIgPSBNYXRoLm1heChwb3NCLCBmcm9tKSwgdG9CID0gTWF0aC5taW4oZW5kLCB0byk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21CIDw9IHRvQilcbiAgICAgICAgICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShmcm9tQiArIG9mZiwgdG9CICsgb2ZmLCBmcm9tQiwgdG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICh0byA+IGVuZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBySSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKG5leHQuZnJvbUEsIG5leHQudG9BLCBuZXh0LmZyb21CLCBuZXh0LnRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgIHBvc0EgPSBuZXh0LnRvQTtcbiAgICAgICAgICAgIHBvc0IgPSBuZXh0LnRvQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuVmlldyBbcGx1Z2luc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pIGFyZSBnaXZlbiBpbnN0YW5jZXMgb2YgdGhpc1xuY2xhc3MsIHdoaWNoIGRlc2NyaWJlIHdoYXQgaGFwcGVuZWQsIHdoZW5ldmVyIHRoZSB2aWV3IGlzIHVwZGF0ZWQuXG4qL1xuY2xhc3MgVmlld1VwZGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciB2aWV3IHRoYXQgdGhlIHVwZGF0ZSBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgKi9cbiAgICB2aWV3LCBcbiAgICAvKipcbiAgICBUaGUgbmV3IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb25zIGludm9sdmVkIGluIHRoZSB1cGRhdGUuIE1heSBiZSBlbXB0eS5cbiAgICAqL1xuICAgIHRyYW5zYWN0aW9ucykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkodGhpcy5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLmNoYW5nZXMuY29tcG9zZSh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiBjaGFuZ2VkUmFuZ2VzLnB1c2gobmV3IENoYW5nZWRSYW5nZShmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSkpO1xuICAgICAgICB0aGlzLmNoYW5nZWRSYW5nZXMgPSBjaGFuZ2VkUmFuZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdVcGRhdGUodmlldywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBbdmlld3BvcnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpZXdwb3J0KSBvclxuICAgIFt2aXNpYmxlIHJhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlzaWJsZVJhbmdlcykgY2hhbmdlZCBpbiB0aGlzXG4gICAgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuXG4gICAgW2B2aWV3cG9ydENoYW5nZWRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1VwZGF0ZS52aWV3cG9ydENoYW5nZWQpIGlzIHRydWVcbiAgICBhbmQgdGhlIHZpZXdwb3J0IGNoYW5nZSBpcyBub3QganVzdCB0aGUgcmVzdWx0IG9mIG1hcHBpbmcgaXQgaW5cbiAgICByZXNwb25zZSB0byBkb2N1bWVudCBjaGFuZ2VzLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TW92ZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDggLyogVXBkYXRlRmxhZy5WaWV3cG9ydE1vdmVkICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBoZWlnaHQgb2YgYSBibG9jayBlbGVtZW50IGluIHRoZSBlZGl0b3JcbiAgICBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGhlaWdodENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGRvY3VtZW50IHdhcyBtb2RpZmllZCBvciB0aGUgc2l6ZSBvZiB0aGVcbiAgICBlZGl0b3IsIG9yIGVsZW1lbnRzIHdpdGhpbiB0aGUgZWRpdG9yLCBjaGFuZ2VkLlxuICAgICovXG4gICAgZ2V0IGdlb21ldHJ5Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jQ2hhbmdlZCB8fCAodGhpcy5mbGFncyAmICgxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdXBkYXRlIGluZGljYXRlcyBhIGZvY3VzIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBmb2N1c0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBkb2N1bWVudCBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgc2V0IGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZsYWdzID09IDAgJiYgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoID09IDA7IH1cbn1cblxuY2xhc3MgRG9jVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGg7IH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCA9IFtmYWxzZV07XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzQ29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uID0gbmV3IFNldDtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIHRoaXMubGFzdENvbXBvc2l0aW9uQWZ0ZXJDdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgLy8gVHJhY2sgYSBtaW5pbXVtIHdpZHRoIGZvciB0aGUgZWRpdG9yLiBXaGVuIG1lYXN1cmluZyBzaXplcyBpblxuICAgICAgICAvLyBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzLCB0aGlzIGlzIHVwZGF0ZWQgdG8gcG9pbnQgYXQgdGhlIHdpZHRoXG4gICAgICAgIC8vIG9mIGEgZ2l2ZW4gZWxlbWVudCBhbmQgaXRzIGV4dGVudCBpbiB0aGUgZG9jdW1lbnQuIFdoZW4gYSBjaGFuZ2VcbiAgICAgICAgLy8gaGFwcGVucyBpbiB0aGF0IHJhbmdlLCB0aGVzZSBhcmUgcmVzZXQuIFRoYXQgd2F5LCBvbmNlIHdlJ3ZlIHNlZW5cbiAgICAgICAgLy8gYSBsaW5lL2VsZW1lbnQgb2YgYSBnaXZlbiBsZW5ndGgsIHdlIGtlZXAgdGhlIGVkaXRvciB3aWRlIGVub3VnaFxuICAgICAgICAvLyB0byBmaXQgYXQgbGVhc3QgdGhhdCBlbGVtZW50LCB1bnRpbCBpdCBpcyBjaGFuZ2VkLCBhdCB3aGljaCBwb2ludFxuICAgICAgICAvLyB3ZSBmb3JnZXQgaXQgYWdhaW4uXG4gICAgICAgIHRoaXMubWluV2lkdGggPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIERPTSBzZWxlY3Rpb24gd2FzIHNldCBpbiBhIGxvc3N5IHdheSwgc28gdGhhdFxuICAgICAgICAvLyB3ZSBkb24ndCBtZXNzIGl0IHVwIHdoZW4gcmVhZGluZyBpdCBiYWNrIGl0XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBVc2VkIGJ5IHRoZSByZXNpemUgb2JzZXJ2ZXIgdG8gaWdub3JlIHJlc2l6ZXMgdGhhdCB3ZSBjYXVzZWRcbiAgICAgICAgLy8gb3Vyc2VsdmVzXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc2V0RE9NKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbbmV3IExpbmVWaWV3XTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlRGVjbygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCldLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHRoZSBkb2N1bWVudCB2aWV3IHRvIGEgZ2l2ZW4gc3RhdGUuXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjaGFuZ2VkUmFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGlmICh0aGlzLm1pbldpZHRoID4gMCAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2VkUmFuZ2VzLmV2ZXJ5KCh7IGZyb21BLCB0b0EgfSkgPT4gdG9BIDwgdGhpcy5taW5XaWR0aEZyb20gfHwgZnJvbUEgPiB0aGlzLm1pbldpZHRoVG8pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9IHRoaXMubWluV2lkdGhGcm9tID0gdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhGcm9tLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aFRvLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRDb250ZXh0Rm9ybWF0dGluZyh1cGRhdGUpO1xuICAgICAgICBsZXQgcmVhZENvbXBvc2l0aW9uQXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmICF0aGlzLnZpZXcub2JzZXJ2ZXIuZWRpdENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLmRvbUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXdTZWwpXG4gICAgICAgICAgICAgICAgcmVhZENvbXBvc2l0aW9uQXQgPSB0aGlzLmRvbUNoYW5nZWQubmV3U2VsLmhlYWQ7XG4gICAgICAgICAgICBlbHNlIGlmICghdG91Y2hlc0NvbXBvc2l0aW9uKHVwZGF0ZS5jaGFuZ2VzLCB0aGlzLmhhc0NvbXBvc2l0aW9uKSAmJiAhdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgICAgICByZWFkQ29tcG9zaXRpb25BdCA9IHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHJlYWRDb21wb3NpdGlvbkF0ID4gLTEgPyBmaW5kQ29tcG9zaXRpb25SYW5nZSh0aGlzLnZpZXcsIHVwZGF0ZS5jaGFuZ2VzLCByZWFkQ29tcG9zaXRpb25BdCkgOiBudWxsO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5jbGVhcigpO1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuaGFzQ29tcG9zaXRpb247XG4gICAgICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gbmV3IENoYW5nZWRSYW5nZShmcm9tLCB0bywgdXBkYXRlLmNoYW5nZXMubWFwUG9zKGZyb20sIC0xKSwgdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRvLCAxKSlcbiAgICAgICAgICAgICAgICAuYWRkVG9TZXQoY2hhbmdlZFJhbmdlcy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0NvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gPyB7IGZyb206IGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCB0bzogY29tcG9zaXRpb24ucmFuZ2UudG9CIH0gOiBudWxsO1xuICAgICAgICAvLyBXaGVuIHRoZSBET00gbm9kZXMgYXJvdW5kIHRoZSBzZWxlY3Rpb24gYXJlIG1vdmVkIHRvIGFub3RoZXJcbiAgICAgICAgLy8gcGFyZW50LCBDaHJvbWUgc29tZXRpbWVzIHJlcG9ydHMgYSBkaWZmZXJlbnQgc2VsZWN0aW9uIHRocm91Z2hcbiAgICAgICAgLy8gZ2V0U2VsZWN0aW9uIHRoYW4gdGhlIG9uZSB0aGF0IGl0IGFjdHVhbGx5IHNob3dzIHRvIHRoZSB1c2VyLlxuICAgICAgICAvLyBUaGlzIGZvcmNlcyBhIHNlbGVjdGlvbiB1cGRhdGUgd2hlbiBsaW5lcyBhcmUgam9pbmVkIHRvIHdvcmtcbiAgICAgICAgLy8gYXJvdW5kIHRoYXQuIElzc3VlICM1NFxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgfHwgYnJvd3Nlci5jaHJvbWUpICYmICFjb21wb3NpdGlvbiAmJiB1cGRhdGUgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5kb2MubGluZXMgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmVzKVxuICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuZGVjb3JhdGlvbnMsIGRlY28gPSB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCBkZWNvLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGlmICghKHRoaXMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5sZW5ndGgsIGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCBieSB1cGRhdGUgYW5kIHRoZSBjb25zdHJ1Y3RvciBkbyBwZXJmb3JtIHRoZSBhY3R1YWwgRE9NXG4gICAgLy8gdXBkYXRlXG4gICAgdXBkYXRlSW5uZXIoY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbikge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbik7XG4gICAgICAgIGxldCB7IG9ic2VydmVyIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIG9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBMb2NrIHRoZSBoZWlnaHQgZHVyaW5nIHJlZHJhd2luZywgc2luY2UgQ2hyb21lIHNvbWV0aW1lc1xuICAgICAgICAgICAgLy8gbWVzc2VzIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgRE9NIG11dGF0aW9uICh0aG91Z2hcbiAgICAgICAgICAgIC8vIG5vIHJlbGF5b3V0IGlzIHRyaWdnZXJlZCBhbmQgSSBjYW5ub3QgaW1hZ2luZSBob3cgaXQgY2FuXG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB3aXRob3V0IGEgbGF5b3V0KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmZsZXhCYXNpcyA9IHRoaXMubWluV2lkdGggPyB0aGlzLm1pbldpZHRoICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcywgd2hlbiBET00gbXV0YXRpb25zIG9jY3VyIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBhcm91bmQgdGhlIHNlbGVjdGlvbiwgZ2V0IGNvbmZ1c2VkIGFuZCByZXBvcnQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBmcm9tIHRoZSBvbmUgaXQgZGlzcGxheXMgKGlzc3VlICMyMTgpLiBUaGlzIHRyaWVzXG4gICAgICAgICAgICAvLyB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSBicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmlvcyA/IHsgbm9kZTogb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlLCB3cml0dGVuOiBmYWxzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zeW5jKHRoaXMudmlldywgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiAodHJhY2sud3JpdHRlbiB8fCBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUgIT0gdHJhY2subm9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5mb3JFYWNoKGNWaWV3ID0+IGNWaWV3LmZsYWdzICY9IH44IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlldy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA8IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgY2hpbGQud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIGdhcHMucHVzaChjaGlsZC5kb20pO1xuICAgICAgICBvYnNlcnZlci51cGRhdGVHYXBzKGdhcHMpO1xuICAgIH1cbiAgICB1cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBjb21wb3NpdGlvbiA/IGNvbXBvc2l0aW9uLnJhbmdlLmFkZFRvU2V0KGNoYW5nZXMuc2xpY2UoKSkgOiBjaGFuZ2VzO1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jaGlsZEN1cnNvcihvbGRMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VzLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA+PSAwID8gcmFuZ2VzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IG5leHQsIGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CIDwgdG9CICYmIGNvbXBvc2l0aW9uLnJhbmdlLnRvQiA+IGZyb21CKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgY29tcG9zaXRpb24ucmFuZ2UudG9CLCB0b0IsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IGJlZm9yZS5icmVha0F0U3RhcnQ7XG4gICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYmVmb3JlLm9wZW5TdGFydDtcbiAgICAgICAgICAgICAgICBvcGVuRW5kID0gYWZ0ZXIub3BlbkVuZDtcbiAgICAgICAgICAgICAgICBsZXQgY29tcExpbmUgPSB0aGlzLmNvbXBvc2l0aW9uVmlldyhjb21wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyLmJyZWFrQXRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIuY29udGVudC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUubWVyZ2UoY29tcExpbmUubGVuZ3RoLCBjb21wTGluZS5sZW5ndGgsIGFmdGVyLmNvbnRlbnRbMF0sIGZhbHNlLCBhZnRlci5vcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLmJyZWFrQWZ0ZXIgPSBhZnRlci5jb250ZW50WzBdLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLmNvbnRlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZS5jb250ZW50Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5tZXJnZSgwLCAwLCBiZWZvcmUuY29udGVudFtiZWZvcmUuY29udGVudC5sZW5ndGggLSAxXSwgdHJ1ZSwgMCwgYmVmb3JlLm9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZS5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmNvbnRlbnQuY29uY2F0KGNvbXBMaW5lKS5jb25jYXQoYWZ0ZXIuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoeyBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID1cbiAgICAgICAgICAgICAgICAgICAgQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyh0b0EsIDEpO1xuICAgICAgICAgICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3Vyc29yLmZpbmRQb3MoZnJvbUEsIC0xKTtcbiAgICAgICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb3NpdGlvbilcbiAgICAgICAgICAgIHRoaXMuZml4Q29tcG9zaXRpb25ET00oY29tcG9zaXRpb24pO1xuICAgIH1cbiAgICB1cGRhdGVFZGl0Q29udGV4dEZvcm1hdHRpbmcodXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nID0gdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0RWRpdENvbnRleHRGb3JtYXR0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2l0aW9uVmlldyhjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgY3VyID0gbmV3IFRleHRWaWV3KGNvbXBvc2l0aW9uLnRleHQubm9kZVZhbHVlKTtcbiAgICAgICAgY3VyLmZsYWdzIHw9IDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi87XG4gICAgICAgIGZvciAobGV0IHsgZGVjbyB9IG9mIGNvbXBvc2l0aW9uLm1hcmtzKVxuICAgICAgICAgICAgY3VyID0gbmV3IE1hcmtWaWV3KGRlY28sIFtjdXJdLCBjdXIubGVuZ3RoKTtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGxpbmUuYXBwZW5kKGN1ciwgMCk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBmaXhDb21wb3NpdGlvbkRPTShjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgZml4ID0gKGRvbSwgY1ZpZXcpID0+IHtcbiAgICAgICAgICAgIGNWaWV3LmZsYWdzIHw9IDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8gfCAoY1ZpZXcuY2hpbGRyZW4uc29tZShjID0+IGMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSA/IDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLyA6IDApO1xuICAgICAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5hZGQoY1ZpZXcpO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYgIT0gY1ZpZXcpXG4gICAgICAgICAgICAgICAgcHJldi5kb20gPSBudWxsO1xuICAgICAgICAgICAgY1ZpZXcuc2V0RE9NKGRvbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmNoaWxkUG9zKGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCAxKTtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy5jaGlsZHJlbltwb3MuaV07XG4gICAgICAgIGZpeChjb21wb3NpdGlvbi5saW5lLCBjVmlldyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb21wb3NpdGlvbi5tYXJrcy5sZW5ndGggLSAxOyBpID49IC0xOyBpLS0pIHtcbiAgICAgICAgICAgIHBvcyA9IGNWaWV3LmNoaWxkUG9zKHBvcy5vZmYsIDEpO1xuICAgICAgICAgICAgY1ZpZXcgPSBjVmlldy5jaGlsZHJlbltwb3MuaV07XG4gICAgICAgICAgICBmaXgoaSA+PSAwID8gY29tcG9zaXRpb24ubWFya3NbaV0ubm9kZSA6IGNvbXBvc2l0aW9uLnRleHQsIGNWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBET00gc2VsZWN0aW9uIHRvIHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgdXBkYXRlU2VsZWN0aW9uKG11c3RSZWFkID0gZmFsc2UsIGZyb21Qb2ludGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG11c3RSZWFkIHx8ICF0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgYWN0aXZlRWx0ID0gdGhpcy52aWV3LnJvb3QuYWN0aXZlRWxlbWVudCwgZm9jdXNlZCA9IGFjdGl2ZUVsdCA9PSB0aGlzLmRvbTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbk5vdEZvY3VzID0gIWZvY3VzZWQgJiYgISh0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpIHx8IHRoaXMuZG9tLnRhYkluZGV4ID4gLTEpICYmXG4gICAgICAgICAgICBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSkgJiYgIShhY3RpdmVFbHQgJiYgdGhpcy5kb20uY29udGFpbnMoYWN0aXZlRWx0KSk7XG4gICAgICAgIGlmICghKGZvY3VzZWQgfHwgZnJvbVBvaW50ZXIgfHwgc2VsZWN0aW9uTm90Rm9jdXMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgYW5jaG9yID0gdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpKTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYWluLmVtcHR5ID8gYW5jaG9yIDogdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5oZWFkKSk7XG4gICAgICAgIC8vIEFsd2F5cyByZXNldCBvbiBGaXJlZm94IHdoZW4gbmV4dCB0byBhbiB1bmVkaXRhYmxlIG5vZGUgdG9cbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmICF0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGJldHdlZW5VbmVkaXRhYmxlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZCA9IG5ldyBET01Qb3MoZHVtbXksIDApO1xuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb21TZWwgPSB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSBoZXJlLCBvciBpbiBhbiBlcXVpdmFsZW50IHBvc2l0aW9uLCBkb24ndCB0b3VjaCBpdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHwgKCFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkgJiYgIXRoaXMuc3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2UoZG9tU2VsLCBtYWluKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gdGFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiB1bmVkaXRhYmxlIG5vZGUsIGFuZCBub3QgYnJpbmcgaXQgYmFjayB3aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBrZXlib2FyZCBieSBjeWNsaW5nIGZvY3VzLlxuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgdGhpcy5kb20uY29udGFpbnMoZG9tU2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhd1NlbCA9IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYXdTZWwpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MTIwNzZcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VG8gJiYgbmV4dFRvICE9ICgxIC8qIE5leHRUby5CZWZvcmUgKi8gfCAyIC8qIE5leHRUby5BZnRlciAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IChuZXh0VG8gPT0gMSAvKiBOZXh0VG8uQmVmb3JlICovID8gdGV4dE5vZGVCZWZvcmUgOiB0ZXh0Tm9kZUFmdGVyKShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBET01Qb3ModGV4dC5ub2RlLCB0ZXh0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYmlkaUxldmVsICE9IG51bGwgJiYgcmF3U2VsLmNhcmV0QmlkaUxldmVsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuY2FyZXRCaWRpTGV2ZWwgPSBtYWluLmJpZGlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3U2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGNhbGwgYWJvdmUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGRlbiwgYW5kIHRoZW4gcmFpc2UgYW4gZXJyb3Igb24gdGhlIGNhbGwgdG8gZXh0ZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICgjOTQwKS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5leHRlbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIChJRSkgd2F5XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmFuY2hvciA+IG1haW4uaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gW2hlYWQsIGFuY2hvcl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Ob3RGb2N1cyAmJiB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsdC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gaGVhZC5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgYSB6ZXJvLWxlbmd0aCB3aWRnZXQgaXMgaW5zZXJ0ZWQgbmV4dCB0byB0aGUgY3Vyc29yIGR1cmluZ1xuICAgIC8vIGNvbXBvc2l0aW9uLCBhdm9pZCBtb3ZpbmcgaXQgYWNyb3NzIGl0IGFuZCBkaXNydXB0aW5nIHRoZVxuICAgIC8vIGNvbXBvc2l0aW9uLlxuICAgIHN1cHByZXNzV2lkZ2V0Q3Vyc29yQ2hhbmdlKHNlbCwgY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGN1cnNvci5lbXB0eSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIHRoaXMucG9zRnJvbURPTShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpID09IGN1cnNvci5oZWFkO1xuICAgIH1cbiAgICBlbmZvcmNlQ3Vyc29yQXNzb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodGhpcywgY3Vyc29yLmhlYWQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIHNlbC5jb2xsYXBzZShkb20ubm9kZSwgZG9tLm9mZnNldCk7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICAgIC8vIFRoaXMgY2FuIGdvIHdyb25nIGluIGNvcm5lciBjYXNlcyBsaWtlIHNpbmdsZS1jaGFyYWN0ZXIgbGluZXMsXG4gICAgICAgIC8vIHNvIGNoZWNrIGFuZCByZXNldCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdSYW5nZSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShuZXdSYW5nZS5hbmNob3JOb2RlLCBuZXdSYW5nZS5hbmNob3JPZmZzZXQpICE9IGN1cnNvci5mcm9tKVxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgfVxuICAgIC8vIElmIGEgcG9zaXRpb24gaXMgaW4vbmVhciBhIGJsb2NrIHdpZGdldCwgbW92ZSBpdCB0byBhIG5lYXJieSB0ZXh0XG4gICAgLy8gbGluZSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGUgY3Vyc29yIGluc2lkZSBhIGJsb2NrIHdpZGdldC5cbiAgICBtb3ZlVG9MaW5lKHBvcykge1xuICAgICAgICAvLyBCbG9jayB3aWRnZXRzIHdpbGwgcmV0dXJuIHBvc2l0aW9ucyBiZWZvcmUvYWZ0ZXIgdGhlbSwgd2hpY2hcbiAgICAgICAgLy8gYXJlIHRodXMgZGlyZWN0bHkgaW4gdGhlIGRvY3VtZW50IERPTSBlbGVtZW50LlxuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb20sIG5ld1BvcztcbiAgICAgICAgaWYgKHBvcy5ub2RlICE9IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0OyAhbmV3UG9zICYmIGkgPCBkb20uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3Mub2Zmc2V0IC0gMTsgIW5ld1BvcyAmJiBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSB2aWV3LmRvbUF0UG9zKHZpZXcubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UG9zID8gbmV3IERPTVBvcyhuZXdQb3Mubm9kZSwgbmV3UG9zLm9mZnNldCwgdHJ1ZSkgOiBwb3M7XG4gICAgfVxuICAgIG5lYXJlc3QoZG9tKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOykge1xuICAgICAgICAgICAgbGV0IGRvbVZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKTtcbiAgICAgICAgICAgIGlmIChkb21WaWV3ICYmIGRvbVZpZXcucm9vdFZpZXcgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tVmlldztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMubmVhcmVzdChub2RlKTtcbiAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gZmluZCBwb3NpdGlvbiBmb3IgYSBET00gcG9zaXRpb24gb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgdmlldy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIC0xKTtcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG9mZiA8IGNoaWxkLmxlbmd0aCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21BdFBvcyhvZmYpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGJlc3QgPSBudWxsLCBiZXN0UG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5sZW5ndGgsIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgLSBjaGlsZC5icmVha0FmdGVyLCBzdGFydCA9IGVuZCAtIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPCBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gcG9zICYmIChzdGFydCA8IHBvcyB8fCBjaGlsZC5jb3ZlcnMoLTEpKSAmJiAoZW5kID4gcG9zIHx8IGNoaWxkLmNvdmVycygxKSkgJiZcbiAgICAgICAgICAgICAgICAoIWJlc3QgfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiAhKGJlc3QgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiBzaWRlID49IDApKSkge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBiZXN0UG9zID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZXN0ICYmIHN0YXJ0ID09IHBvcyAmJiBlbmQgPT0gcG9zICYmIGNoaWxkIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIE1hdGguYWJzKHNpZGUpIDwgMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kZWNvLnN0YXJ0U2lkZSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIGJlc3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3QgPyBiZXN0LmNvb3Jkc0F0KHBvcyAtIGJlc3RQb3MsIHNpZGUpIDogbnVsbDtcbiAgICB9XG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSksIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgaSwgb2ZmOiBjaGlsZE9mZiB9ID0gY2hpbGQuY2hpbGRQb3Mob2ZmLCAxKTtcbiAgICAgICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoKGNoaWxkID0gY2hpbGQuY2hpbGRyZW5baV0pLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBjaGlsZE9mZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZW5kID0gZmluZENsdXN0ZXJCcmVhayhjaGlsZC50ZXh0LCBvZmYpO1xuICAgICAgICBpZiAoZW5kID09IG9mZilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQuZG9tLCBvZmYsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSAmJiByZWN0LmxlZnQgPCByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZpZXdwb3J0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgeyBmcm9tLCB0byB9ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSB0aGlzLnZpZXcuY29udGVudERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IGlzV2lkZXIgPSBjb250ZW50V2lkdGggPiBNYXRoLm1heCh0aGlzLnZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB0aGlzLm1pbldpZHRoKSArIDE7XG4gICAgICAgIGxldCB3aWRlc3QgPSAtMSwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSZWN0ID0gY2hpbGQuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1dpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gY2hpbGQuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gbGFzdCA/IGNsaWVudFJlY3RzRm9yKGxhc3QpIDogW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBsdHIgPyByZWN0LnJpZ2h0IC0gY2hpbGRSZWN0LmxlZnQgOiBjaGlsZFJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiB3aWRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlc3QgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgeyBpIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSk7XG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuY2hpbGRyZW5baV0uZG9tKS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmUgPSBjaGlsZC5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gd29ya2FibGUgbGluZSBleGlzdHMsIGZvcmNlIGEgbGF5b3V0IG9mIGEgbWVhc3VyYWJsZSBlbGVtZW50XG4gICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodDtcbiAgICAgICAgZHVtbXkuY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgIGR1bW15LnN0eWxlLndpZHRoID0gXCI5OTk5OXB4XCI7XG4gICAgICAgIGR1bW15LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBkdW1teS50ZXh0Q29udGVudCA9IFwiYWJjIGRlZiBnaGkgamtsIG1ubyBwcXIgc3R1XCI7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZHVtbXkpO1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBjbGllbnRSZWN0c0ZvcihkdW1teS5maXJzdENoaWxkKVswXTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBkdW1teS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBjaGFyV2lkdGggPSByZWN0ID8gcmVjdC53aWR0aCAvIDI3IDogNztcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0ID8gcmVjdC5oZWlnaHQgOiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgZHVtbXkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfTtcbiAgICB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTW92ZSBiYWNrIHRvIHN0YXJ0IG9mIGxhc3QgZWxlbWVudCB3aGVuIHBvc3NpYmxlLCBzbyB0aGF0XG4gICAgICAgIC8vIGBDaGlsZEN1cnNvci5maW5kUG9zYCBkb2Vzbid0IGhhdmUgdG8gZGVhbCB3aXRoIHRoZSBlZGdlIGNhc2VcbiAgICAgICAgLy8gb2YgYmVpbmcgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAgbGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICBwb3MgLT0gdGhpcy5jaGlsZHJlblstLWldLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIGkpO1xuICAgIH1cbiAgICBjb21wdXRlQmxvY2tHYXBEZWNvKCkge1xuICAgICAgICBsZXQgZGVjbyA9IFtdLCB2cyA9IHRoaXMudmlldy52aWV3U3RhdGU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gdnMudmlld3BvcnRzLmxlbmd0aCA/IG51bGwgOiB2cy52aWV3cG9ydHNbaV07XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbSAtIDEgOiB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gKHZzLmxpbmVCbG9ja0F0KGVuZCkuYm90dG9tIC0gdnMubGluZUJsb2NrQXQocG9zKS50b3ApIC8gdGhpcy52aWV3LnNjYWxlWTtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2goRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgQmxvY2tHYXBXaWRnZXQoaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9ja0dhcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShwb3MsIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dC50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbiAgICB1cGRhdGVEZWNvKCkge1xuICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgIGxldCBhbGxEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5tYXAoZCA9PiB7XG4gICAgICAgICAgICBsZXQgZHluYW1pYyA9IHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkeW5hbWljT3V0ZXIgPSBmYWxzZSwgb3V0ZXJEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KG91dGVyRGVjb3JhdGlvbnMpLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgICAgICBkeW5hbWljT3V0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dGVyRGVjby5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IGR5bmFtaWNPdXRlcjtcbiAgICAgICAgICAgIGFsbERlY28ucHVzaChSYW5nZVNldC5qb2luKG91dGVyRGVjbykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyxcbiAgICAgICAgICAgIC4uLmFsbERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubGluZUdhcERlY29cbiAgICAgICAgXTtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaSsrXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9ucztcbiAgICB9XG4gICAgc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuaXNTbmFwc2hvdCkge1xuICAgICAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQodGFyZ2V0LnJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSByZWYudG9wIC0gdGFyZ2V0LnlNYXJnaW47XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB0YXJnZXQueE1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIHRoaXMudmlldy5zdGF0ZS5mYWNldChzY3JvbGxIYW5kbGVyKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcih0aGlzLnZpZXcsIHRhcmdldC5yYW5nZSwgdGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwic2Nyb2xsIGhhbmRsZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHRhcmdldDtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmhlYWQsIHJhbmdlLmVtcHR5ID8gcmFuZ2UuYXNzb2MgOiByYW5nZS5oZWFkID4gcmFuZ2UuYW5jaG9yID8gLTEgOiAxKSwgb3RoZXI7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiAob3RoZXIgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmFuY2hvciwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IC0xIDogMSkpKVxuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5taW4ocmVjdC5sZWZ0LCBvdGhlci5sZWZ0KSwgdG9wOiBNYXRoLm1pbihyZWN0LnRvcCwgb3RoZXIudG9wKSxcbiAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgocmVjdC5yaWdodCwgb3RoZXIucmlnaHQpLCBib3R0b206IE1hdGgubWF4KHJlY3QuYm90dG9tLCBvdGhlci5ib3R0b20pIH07XG4gICAgICAgIGxldCBtYXJnaW5zID0gZ2V0U2Nyb2xsTWFyZ2lucyh0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgdGFyZ2V0UmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG1hcmdpbnMubGVmdCwgdG9wOiByZWN0LnRvcCAtIG1hcmdpbnMudG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtYXJnaW5zLnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tICsgbWFyZ2lucy5ib3R0b21cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCB9ID0gdGhpcy52aWV3LnNjcm9sbERPTTtcbiAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMudmlldy5zY3JvbGxET00sIHRhcmdldFJlY3QsIHJhbmdlLmhlYWQgPCByYW5nZS5hbmNob3IgPyAtMSA6IDEsIHRhcmdldC54LCB0YXJnZXQueSwgTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0LnhNYXJnaW4sIG9mZnNldFdpZHRoKSwgLW9mZnNldFdpZHRoKSwgTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0LnlNYXJnaW4sIG9mZnNldEhlaWdodCksIC1vZmZzZXRIZWlnaHQpLCB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKTtcbiAgICB9XG4gICAgbGluZUhhc1dpZGdldChwb3MpIHtcbiAgICAgICAgbGV0IHsgaSB9ID0gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zKTtcbiAgICAgICAgaWYgKGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzY2FuID0gKGNoaWxkKSA9PiBjaGlsZCBpbnN0YW5jZW9mIFdpZGdldFZpZXcgfHwgY2hpbGQuY2hpbGRyZW4uc29tZShzY2FuKTtcbiAgICAgICAgcmV0dXJuIHNjYW4odGhpcy5jaGlsZHJlbltpXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmV0d2VlblVuZWRpdGFibGUocG9zKSB7XG4gICAgcmV0dXJuIHBvcy5ub2RlLm5vZGVUeXBlID09IDEgJiYgcG9zLm5vZGUuZmlyc3RDaGlsZCAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSAwIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IHBvcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIGhlYWRQb3MpIHtcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0ZXh0QmVmb3JlID0gdGV4dE5vZGVCZWZvcmUoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBsZXQgdGV4dEFmdGVyID0gdGV4dE5vZGVBZnRlcihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGxldCB0ZXh0Tm9kZSA9IHRleHRCZWZvcmUgfHwgdGV4dEFmdGVyO1xuICAgIGlmICh0ZXh0QWZ0ZXIgJiYgdGV4dEJlZm9yZSAmJiB0ZXh0QWZ0ZXIubm9kZSAhPSB0ZXh0QmVmb3JlLm5vZGUpIHtcbiAgICAgICAgbGV0IGRlc2NBZnRlciA9IENvbnRlbnRWaWV3LmdldCh0ZXh0QWZ0ZXIubm9kZSk7XG4gICAgICAgIGlmICghZGVzY0FmdGVyIHx8IGRlc2NBZnRlciBpbnN0YW5jZW9mIFRleHRWaWV3ICYmIGRlc2NBZnRlci50ZXh0ICE9IHRleHRBZnRlci5ub2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgdGV4dE5vZGUgPSB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldy5kb2NWaWV3Lmxhc3RDb21wb3NpdGlvbkFmdGVyQ3Vyc29yKSB7XG4gICAgICAgICAgICBsZXQgZGVzY0JlZm9yZSA9IENvbnRlbnRWaWV3LmdldCh0ZXh0QmVmb3JlLm5vZGUpO1xuICAgICAgICAgICAgaWYgKCEoIWRlc2NCZWZvcmUgfHwgZGVzY0JlZm9yZSBpbnN0YW5jZW9mIFRleHRWaWV3ICYmIGRlc2NCZWZvcmUudGV4dCAhPSB0ZXh0QmVmb3JlLm5vZGUubm9kZVZhbHVlKSlcbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZSA9IHRleHRBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvY1ZpZXcubGFzdENvbXBvc2l0aW9uQWZ0ZXJDdXJzb3IgPSB0ZXh0Tm9kZSAhPSB0ZXh0QmVmb3JlO1xuICAgIGlmICghdGV4dE5vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmcm9tID0gaGVhZFBvcyAtIHRleHROb2RlLm9mZnNldDtcbiAgICByZXR1cm4geyBmcm9tLCB0bzogZnJvbSArIHRleHROb2RlLm5vZGUubm9kZVZhbHVlLmxlbmd0aCwgbm9kZTogdGV4dE5vZGUubm9kZSB9O1xufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uUmFuZ2UodmlldywgY2hhbmdlcywgaGVhZFBvcykge1xuICAgIGxldCBmb3VuZCA9IGZpbmRDb21wb3NpdGlvbk5vZGUodmlldywgaGVhZFBvcyk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgbm9kZTogdGV4dE5vZGUsIGZyb20sIHRvIH0gPSBmb3VuZCwgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAvLyBEb24ndCB0cnkgdG8gcHJlc2VydmUgbXVsdGktbGluZSBjb21wb3NpdGlvbnNcbiAgICBpZiAoL1tcXG5cXHJdLy50ZXN0KHRleHQpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZm91bmQuZnJvbSwgZm91bmQudG8pICE9IHRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpbnYgPSBjaGFuZ2VzLmludmVydGVkRGVzYztcbiAgICBsZXQgcmFuZ2UgPSBuZXcgQ2hhbmdlZFJhbmdlKGludi5tYXBQb3MoZnJvbSksIGludi5tYXBQb3ModG8pLCBmcm9tLCB0byk7XG4gICAgbGV0IG1hcmtzID0gW107XG4gICAgZm9yIChsZXQgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTs7IHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxldCBwYXJlbnRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnRWaWV3IGluc3RhbmNlb2YgTWFya1ZpZXcpXG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbm9kZTogcGFyZW50LCBkZWNvOiBwYXJlbnRWaWV3Lm1hcmsgfSk7XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudFZpZXcgaW5zdGFuY2VvZiBMaW5lVmlldyB8fCBwYXJlbnQubm9kZU5hbWUgPT0gXCJESVZcIiAmJiBwYXJlbnQucGFyZW50Tm9kZSA9PSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSwgdGV4dDogdGV4dE5vZGUsIG1hcmtzLCBsaW5lOiBwYXJlbnQgfTtcbiAgICAgICAgZWxzZSBpZiAocGFyZW50ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBub2RlOiBwYXJlbnQsIGRlY286IG5ldyBNYXJrRGVjb3JhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogZ2V0QXR0cnMocGFyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogcGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXh0VG9VbmVkaXRhYmxlKG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAob2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMSAvKiBOZXh0VG8uQmVmb3JlICovIDogMCkgfFxuICAgICAgICAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMiAvKiBOZXh0VG8uQWZ0ZXIgKi8gOiAwKTtcbn1cbmxldCBEZWNvcmF0aW9uQ29tcGFyYXRvciQxID0gY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvKSB7IGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMpOyB9XG4gICAgYm91bmRDaGFuZ2UocG9zKSB7IGFkZFJhbmdlKHBvcywgcG9zLCB0aGlzLmNoYW5nZXMpOyB9XG59O1xuZnVuY3Rpb24gZmluZENoYW5nZWREZWNvKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvciQxO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGluVW5lZGl0YWJsZShub2RlLCBpbnNpZGUpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXIgJiYgY3VyICE9IGluc2lkZTsgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEgJiYgY3VyLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0b3VjaGVzQ29tcG9zaXRpb24oY2hhbmdlcywgY29tcG9zaXRpb24pIHtcbiAgICBsZXQgdG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmIChjb21wb3NpdGlvbilcbiAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgY29tcG9zaXRpb24udG8gJiYgdG8gPiBjb21wb3NpdGlvbi5mcm9tKVxuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hlZDtcbn1cblxuZnVuY3Rpb24gZ3JvdXBBdChzdGF0ZSwgcG9zLCBiaWFzID0gMSkge1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGxpbmVQb3MgPSBwb3MgLSBsaW5lLmZyb207XG4gICAgaWYgKGxpbmUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyk7XG4gICAgaWYgKGxpbmVQb3MgPT0gMClcbiAgICAgICAgYmlhcyA9IDE7XG4gICAgZWxzZSBpZiAobGluZVBvcyA9PSBsaW5lLmxlbmd0aClcbiAgICAgICAgYmlhcyA9IC0xO1xuICAgIGxldCBmcm9tID0gbGluZVBvcywgdG8gPSBsaW5lUG9zO1xuICAgIGlmIChiaWFzIDwgMClcbiAgICAgICAgZnJvbSA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zLCBmYWxzZSk7XG4gICAgZWxzZVxuICAgICAgICB0byA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBsaW5lUG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB3aGlsZSAoZnJvbSA+IDApIHtcbiAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UocHJldiwgZnJvbSkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmcm9tID0gcHJldjtcbiAgICB9XG4gICAgd2hpbGUgKHRvIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgdG8pO1xuICAgICAgICBpZiAoY2F0ZWdvcml6ZShsaW5lLnRleHQuc2xpY2UodG8sIG5leHQpKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgdG8gPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20gKyBsaW5lLmZyb20sIHRvICsgbGluZS5mcm9tKTtcbn1cbi8vIFNlYXJjaCB0aGUgRE9NIGZvciB0aGUge25vZGUsIG9mZnNldH0gcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW5cbi8vIGNvb3JkaW5hdGVzLiBWZXJ5IGluZWZmaWNpZW50IGFuZCBjcnVkZSwgYnV0IGNhbiB1c3VhbGx5IGJlIGF2b2lkZWRcbi8vIGJ5IGNhbGxpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGluc3RlYWQuXG5mdW5jdGlvbiBnZXRkeCh4LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QubGVmdCA+IHggPyByZWN0LmxlZnQgLSB4IDogTWF0aC5tYXgoMCwgeCAtIHJlY3QucmlnaHQpO1xufVxuZnVuY3Rpb24gZ2V0ZHkoeSwgcmVjdCkge1xuICAgIHJldHVybiByZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiBNYXRoLm1heCgwLCB5IC0gcmVjdC5ib3R0b20pO1xufVxuZnVuY3Rpb24geU92ZXJsYXAoYSwgYikge1xuICAgIHJldHVybiBhLnRvcCA8IGIuYm90dG9tIC0gMSAmJiBhLmJvdHRvbSA+IGIudG9wICsgMTtcbn1cbmZ1bmN0aW9uIHVwVG9wKHJlY3QsIHRvcCkge1xuICAgIHJldHVybiB0b3AgPCByZWN0LnRvcCA/IHsgdG9wLCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tIH0gOiByZWN0O1xufVxuZnVuY3Rpb24gdXBCb3QocmVjdCwgYm90dG9tKSB7XG4gICAgcmV0dXJuIGJvdHRvbSA+IHJlY3QuYm90dG9tID8geyB0b3A6IHJlY3QudG9wLCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCBib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiBkb21Qb3NBdENvb3JkcyhwYXJlbnQsIHgsIHkpIHtcbiAgICBsZXQgY2xvc2VzdCwgY2xvc2VzdFJlY3QsIGNsb3Nlc3RYLCBjbG9zZXN0WSwgY2xvc2VzdE92ZXJsYXAgPSBmYWxzZTtcbiAgICBsZXQgYWJvdmUsIGJlbG93LCBhYm92ZVJlY3QsIGJlbG93UmVjdDtcbiAgICBmb3IgKGxldCBjaGlsZCA9IHBhcmVudC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAoY2xvc2VzdFJlY3QgJiYgeU92ZXJsYXAoY2xvc2VzdFJlY3QsIHJlY3QpKVxuICAgICAgICAgICAgICAgIHJlY3QgPSB1cFRvcCh1cEJvdChyZWN0LCBjbG9zZXN0UmVjdC5ib3R0b20pLCBjbG9zZXN0UmVjdC50b3ApO1xuICAgICAgICAgICAgbGV0IGR4ID0gZ2V0ZHgoeCwgcmVjdCksIGR5ID0gZ2V0ZHkoeSwgcmVjdCk7XG4gICAgICAgICAgICBpZiAoZHggPT0gMCAmJiBkeSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5ub2RlVHlwZSA9PSAzID8gZG9tUG9zSW5UZXh0KGNoaWxkLCB4LCB5KSA6IGRvbVBvc0F0Q29vcmRzKGNoaWxkLCB4LCB5KTtcbiAgICAgICAgICAgIGlmICghY2xvc2VzdCB8fCBjbG9zZXN0WSA+IGR5IHx8IGNsb3Nlc3RZID09IGR5ICYmIGNsb3Nlc3RYID4gZHgpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RYID0gZHg7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFkgPSBkeTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T3ZlcmxhcCA9ICFkeCA/IHRydWUgOiB4IDwgcmVjdC5sZWZ0ID8gaSA+IDAgOiBpIDwgcmVjdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHkgPiByZWN0LmJvdHRvbSAmJiAoIWFib3ZlUmVjdCB8fCBhYm92ZVJlY3QuYm90dG9tIDwgcmVjdC5ib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkgPCByZWN0LnRvcCAmJiAoIWJlbG93UmVjdCB8fCBiZWxvd1JlY3QudG9wID4gcmVjdC50b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWJvdmVSZWN0ICYmIHlPdmVybGFwKGFib3ZlUmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSB1cEJvdChhYm92ZVJlY3QsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiB5T3ZlcmxhcChiZWxvd1JlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gdXBUb3AoYmVsb3dSZWN0LCByZWN0LnRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFib3ZlUmVjdCAmJiBhYm92ZVJlY3QuYm90dG9tID49IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGFib3ZlO1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGFib3ZlUmVjdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIGJlbG93UmVjdC50b3AgPD0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYmVsb3c7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYmVsb3dSZWN0O1xuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3QpXG4gICAgICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0OiAwIH07XG4gICAgbGV0IGNsaXBYID0gTWF0aC5tYXgoY2xvc2VzdFJlY3QubGVmdCwgTWF0aC5taW4oY2xvc2VzdFJlY3QucmlnaHQsIHgpKTtcbiAgICBpZiAoY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZG9tUG9zSW5UZXh0KGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBpZiAoY2xvc2VzdE92ZXJsYXAgJiYgY2xvc2VzdC5jb250ZW50RWRpdGFibGUgIT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gZG9tUG9zQXRDb29yZHMoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGxldCBvZmZzZXQgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHBhcmVudC5jaGlsZE5vZGVzLCBjbG9zZXN0KSArXG4gICAgICAgICh4ID49IChjbG9zZXN0UmVjdC5sZWZ0ICsgY2xvc2VzdFJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldCB9O1xufVxuZnVuY3Rpb24gZG9tUG9zSW5UZXh0KG5vZGUsIHgsIHkpIHtcbiAgICBsZXQgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGxldCBjbG9zZXN0T2Zmc2V0ID0gLTEsIGNsb3Nlc3REWSA9IDFlOSwgZ2VuZXJhbFNpZGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKG5vZGUsIGksIGkgKyAxKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFnZW5lcmFsU2lkZSlcbiAgICAgICAgICAgICAgICBnZW5lcmFsU2lkZSA9IHggLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBsZXQgZHkgPSAocmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogeSAtIHJlY3QuYm90dG9tKSAtIDE7XG4gICAgICAgICAgICBpZiAocmVjdC5sZWZ0IC0gMSA8PSB4ICYmIHJlY3QucmlnaHQgKyAxID49IHggJiYgZHkgPCBjbG9zZXN0RFkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB4ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIGFmdGVyID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFJUTCBvbiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2V0dGluZyBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdHMgZm9yIGVtcHR5IHJhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RCZWZvcmUgPSB0ZXh0UmFuZ2Uobm9kZSwgaSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QmVmb3JlLmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gIXJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZHkgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBpICsgKGFmdGVyID8gMSA6IDApIH07XG4gICAgICAgICAgICAgICAgY2xvc2VzdE9mZnNldCA9IGkgKyAoYWZ0ZXIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERZID0gZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBjbG9zZXN0T2Zmc2V0ID4gLTEgPyBjbG9zZXN0T2Zmc2V0IDogZ2VuZXJhbFNpZGUgPiAwID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogMCB9O1xufVxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzLCBwcmVjaXNlLCBiaWFzID0gLTEpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb2NUb3AgPSBjb250ZW50LnRvcCArIHZpZXcudmlld1N0YXRlLnBhZGRpbmdUb3A7XG4gICAgbGV0IGJsb2NrLCB7IGRvY0hlaWdodCB9ID0gdmlldy52aWV3U3RhdGU7XG4gICAgbGV0IHsgeCwgeSB9ID0gY29vcmRzLCB5T2Zmc2V0ID0geSAtIGRvY1RvcDtcbiAgICBpZiAoeU9mZnNldCA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh5T2Zmc2V0ID4gZG9jSGVpZ2h0KVxuICAgICAgICByZXR1cm4gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgIC8vIFNjYW4gZm9yIGEgdGV4dCBibG9jayBuZWFyIHRoZSBxdWVyaWVkIHkgcG9zaXRpb25cbiAgICBmb3IgKGxldCBoYWxmTGluZSA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0IC8gMiwgYm91bmNlZCA9IGZhbHNlOzspIHtcbiAgICAgICAgYmxvY2sgPSB2aWV3LmVsZW1lbnRBdEhlaWdodCh5T2Zmc2V0KTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgLy8gTW92ZSB0aGUgeSBwb3NpdGlvbiBvdXQgb2YgdGhpcyBibG9ja1xuICAgICAgICAgICAgeU9mZnNldCA9IGJpYXMgPiAwID8gYmxvY2suYm90dG9tICsgaGFsZkxpbmUgOiBibG9jay50b3AgLSBoYWxmTGluZTtcbiAgICAgICAgICAgIGlmICh5T2Zmc2V0ID49IDAgJiYgeU9mZnNldCA8PSBkb2NIZWlnaHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgY29uc2lzdHMgZW50aXJlbHkgb2YgcmVwbGFjZWQgd2lkZ2V0cywgd2VcbiAgICAgICAgICAgIC8vIHdvbid0IGZpbmQgYSB0ZXh0IGJsb2NrLCBzbyByZXR1cm4gMFxuICAgICAgICAgICAgaWYgKGJvdW5jZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpc2UgPyBudWxsIDogMDtcbiAgICAgICAgICAgIGJvdW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgYmlhcyA9IC1iaWFzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHkgPSBkb2NUb3AgKyB5T2Zmc2V0O1xuICAgIGxldCBsaW5lU3RhcnQgPSBibG9jay5mcm9tO1xuICAgIC8vIElmIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGUgcmVuZGVyZWQgdmlld3BvcnQsIHdlIGNhbid0IGRldGVybWluZSBhIHBvc2l0aW9uXG4gICAgaWYgKGxpbmVTdGFydCA8IHZpZXcudmlld3BvcnQuZnJvbSlcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQuZnJvbSA9PSAwID8gMCA6IHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xuICAgIGlmIChsaW5lU3RhcnQgPiB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC50byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGggPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOlxuICAgICAgICAgICAgcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgLy8gUHJlZmVyIFNoYWRvd1Jvb3RPckRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQgaWYgcHJlc2VudCwgZmFsbCBiYWNrIHRvIGRvY3VtZW50IGlmIG5vdFxuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGxldCByb290ID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2M7XG4gICAgbGV0IGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgdW5leHBlY3RlZCwgY2xpcCB4IGF0IHRoZSBzaWRlcyBvZiB0aGUgY29udGVudCBhcmVhIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KGNvbnRlbnQubGVmdCArIDEsIE1hdGgubWluKGNvbnRlbnQucmlnaHQgLSAxLCB4KSk7XG4gICAgICAgIGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlcmUncyB2aXNpYmxlIGVkaXRvciBjb250ZW50IHVuZGVyIHRoZSBwb2ludCwgc28gd2UgY2FuIHRyeVxuICAgIC8vIHVzaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBhcyBhIHNob3J0Y3V0XG4gICAgbGV0IG5vZGUsIG9mZnNldCA9IC0xO1xuICAgIGlmIChlbGVtZW50ICYmICgoX2EgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpICE9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICAoeyBvZmZzZXROb2RlOiBub2RlLCBvZmZzZXQgfSA9IHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgICAgICh7IHN0YXJ0Q29udGFpbmVyOiBub2RlLCBzdGFydE9mZnNldDogb2Zmc2V0IH0gPSByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgJiYgKCF2aWV3LmNvbnRlbnRET00uY29udGFpbnMobm9kZSkgfHxcbiAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkgfHxcbiAgICAgICAgICAgIGJyb3dzZXIuY2hyb21lICYmIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkpKVxuICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2hyb21lIHdpbGwgcmV0dXJuIG9mZnNldHMgaW50byA8aW5wdXQ+IGVsZW1lbnRzIHdpdGhvdXQgY2hpbGRcbiAgICAgICAgLy8gbm9kZXMsIHdoaWNoIHdpbGwgbGVhZCB0byBhIG51bGwgZGVyZWYgYmVsb3csIHNvIGNsaXAgdGhlXG4gICAgICAgIC8vIG9mZnNldCB0byB0aGUgbm9kZSBzaXplLlxuICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKG1heE9mZnNldChub2RlKSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gTm8gbHVjaywgZG8gb3VyIG93biAocG90ZW50aWFsbHkgZXhwZW5zaXZlKSBzZWFyY2hcbiAgICBpZiAoIW5vZGUgfHwgIXZpZXcuZG9jVmlldy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgbGluZVN0YXJ0KTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHlPZmZzZXQgPiBibG9jay50b3AgKyBibG9jay5oZWlnaHQgLyAyID8gYmxvY2sudG8gOiBibG9jay5mcm9tO1xuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGRvbVBvc0F0Q29vcmRzKGxpbmUuZG9tLCB4LCB5KSk7XG4gICAgfVxuICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3Qobm9kZSk7XG4gICAgaWYgKCFuZWFyZXN0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobmVhcmVzdC5pc1dpZGdldCAmJiAoKF9iID0gbmVhcmVzdC5kb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ub2RlVHlwZSkgPT0gMSkge1xuICAgICAgICBsZXQgcmVjdCA9IG5lYXJlc3QuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gY29vcmRzLnkgPCByZWN0LnRvcCB8fCBjb29yZHMueSA8PSByZWN0LmJvdHRvbSAmJiBjb29yZHMueCA8PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyXG4gICAgICAgICAgICA/IG5lYXJlc3QucG9zQXRTdGFydCA6IG5lYXJlc3QucG9zQXRFbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmVhcmVzdC5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIG5lYXJlc3QucG9zQXRTdGFydDtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50UmVjdCwgYmxvY2ssIHgsIHkpIHtcbiAgICBsZXQgaW50byA9IE1hdGgucm91bmQoKHggLSBjb250ZW50UmVjdC5sZWZ0KSAqIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKTtcbiAgICBpZiAodmlldy5saW5lV3JhcHBpbmcgJiYgYmxvY2suaGVpZ2h0ID4gdmlldy5kZWZhdWx0TGluZUhlaWdodCAqIDEuNSkge1xuICAgICAgICBsZXQgdGV4dEhlaWdodCA9IHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0O1xuICAgICAgICBsZXQgbGluZSA9IE1hdGguZmxvb3IoKHkgLSBibG9jay50b3AgLSAodmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHRleHRIZWlnaHQpICogMC41KSAvIHRleHRIZWlnaHQpO1xuICAgICAgICBpbnRvICs9IGxpbmUgKiB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGJsb2NrLmZyb20sIGJsb2NrLnRvKTtcbiAgICByZXR1cm4gYmxvY2suZnJvbSArIGZpbmRDb2x1bW4oY29udGVudCwgaW50bywgdmlldy5zdGF0ZS50YWJTaXplKTtcbn1cbmZ1bmN0aW9uIGlzRW5kT2ZMaW5lQmVmb3JlKG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGxldCBsZW4sIHNjYW4gPSBub2RlO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMgfHwgb2Zmc2V0ICE9IChsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yICg7OykgeyAvLyBDaGVjayB0aGF0IHRoZXJlIGlzIG5vIGNvbnRlbnQgYWZ0ZXIgdGhpcyBub2RlXG4gICAgICAgIGxldCBuZXh0ID0gc2Nhbi5uZXh0U2libGluZztcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0Lm5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZU5hbWUgPT0gXCJESVZcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHNjYW4gPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHRSYW5nZShub2RlLCBsZW4gLSAxLCBsZW4pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID4geDtcbn1cbi8vIEluIGNhc2Ugb2YgYSBoaWdoIGxpbmUgaGVpZ2h0LCBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHRyZWF0c1xuLy8gdGhlIHNwYWNlIGJldHdlZW4gbGluZXMgYXMgYmVsb25naW5nIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGVcbi8vIGxpbmUgYmVmb3JlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IHN1Y2ggYSByZXN1bHQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGlnbm9yZWQgKGlzc3VlICM0MDEpLlxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzU2FmYXJpQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgcmV0dXJuIGlzRW5kT2ZMaW5lQmVmb3JlKG5vZGUsIG9mZnNldCwgeCk7XG59XG4vLyBDaHJvbWUgd2lsbCBtb3ZlIHBvc2l0aW9ucyBiZXR3ZWVuIGxpbmVzIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBsaW5lXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBpZiAob2Zmc2V0ICE9IDApXG4gICAgICAgIHJldHVybiBpc0VuZE9mTGluZUJlZm9yZShub2RlLCBvZmZzZXQsIHgpO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7Oykge1xuICAgICAgICBsZXQgcGFyZW50ID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IHBhcmVudC5maXJzdENoaWxkICE9IGN1cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS1saW5lXCIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN1ciA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IHJlY3QgPSBub2RlLm5vZGVUeXBlID09IDEgPyBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogdGV4dFJhbmdlKG5vZGUsIDAsIE1hdGgubWF4KG5vZGUubm9kZVZhbHVlLmxlbmd0aCwgMSkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB4IC0gcmVjdC5sZWZ0ID4gNTtcbn1cbmZ1bmN0aW9uIGJsb2NrQXQodmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICBsZXQgYmVzdDtcbiAgICAgICAgZm9yIChsZXQgbCBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChsLmZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobC50byA8IHBvcylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChsLmZyb20gPCBwb3MgJiYgbC50byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgICAgIGlmICghYmVzdCB8fCAobC50eXBlID09IEJsb2NrVHlwZS5UZXh0ICYmIChiZXN0LnR5cGUgIT0gbC50eXBlIHx8IChzaWRlIDwgMCA/IGwuZnJvbSA8IHBvcyA6IGwudG8gPiBwb3MpKSkpXG4gICAgICAgICAgICAgICAgYmVzdCA9IGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3QgfHwgbGluZTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiBtb3ZlVG9MaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKSB7XG4gICAgbGV0IGxpbmUgPSBibG9ja0F0KHZpZXcsIHN0YXJ0LmhlYWQsIHN0YXJ0LmFzc29jIHx8IC0xKTtcbiAgICBsZXQgY29vcmRzID0gIWluY2x1ZGVXcmFwIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dCB8fCAhKHZpZXcubGluZVdyYXBwaW5nIHx8IGxpbmUud2lkZ2V0TGluZUJyZWFrcykgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09IChkaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikgPyBlZGl0b3JSZWN0LnJpZ2h0IC0gMSA6IGVkaXRvclJlY3QubGVmdCArIDEsXG4gICAgICAgICAgICB5OiAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMiB9KTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIGRpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gdmlldy52aXN1YWxMaW5lU2lkZShsaW5lLCAhZm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQuaGVhZCwgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRQb3MsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgZ29hbCA9IHN0YXJ0LmdvYWxDb2x1bW4sIHN0YXJ0WTtcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyB8fCAtMSksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0ID4+IDEpO1xuICAgIGZvciAobGV0IGV4dHJhID0gMDs7IGV4dHJhICs9IDEwKSB7XG4gICAgICAgIGxldCBjdXJZID0gc3RhcnRZICsgKGRpc3QgKyBleHRyYSkgKiBkaXI7XG4gICAgICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkcyh2aWV3LCB7IHg6IHJlc29sdmVkR29hbCwgeTogY3VyWSB9LCBmYWxzZSwgZGlyKTtcbiAgICAgICAgaWYgKGN1clkgPCByZWN0LnRvcCB8fCBjdXJZID4gcmVjdC5ib3R0b20gfHwgKGRpciA8IDAgPyBwb3MgPCBzdGFydFBvcyA6IHBvcyA+IHN0YXJ0UG9zKSkge1xuICAgICAgICAgICAgbGV0IGNoYXJSZWN0ID0gdmlldy5kb2NWaWV3LmNvb3Jkc0ZvckNoYXIocG9zKTtcbiAgICAgICAgICAgIGxldCBhc3NvYyA9ICFjaGFyUmVjdCB8fCBjdXJZIDwgY2hhclJlY3QudG9wID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBhc3NvYywgdW5kZWZpbmVkLCBnb2FsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9taWNSYW5nZXMoYXRvbXMsIHBvcywgYmlhcykge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIGF0b21zKSB7XG4gICAgICAgICAgICBzZXQuYmV0d2Vlbihwb3MgLSAxLCBwb3MgKyAxLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBtb3ZlZCB8fCBiaWFzIHx8IChwb3MgLSBmcm9tIDwgdG8gLSBwb3MgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBzaWRlIDwgMCA/IGZyb20gOiB0bztcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSBzaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW92ZWQpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9tc0ZvclNlbGVjdGlvbihhdG9tcywgc2VsKSB7XG4gICAgbGV0IHJhbmdlcyA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5yYW5nZXNbaV0sIHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBza2lwQXRvbWljUmFuZ2VzKGF0b21zLCByYW5nZS5mcm9tLCAwKTtcbiAgICAgICAgICAgIGlmIChwb3MgIT0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gc2tpcEF0b21pY1JhbmdlcyhhdG9tcywgcmFuZ2UuZnJvbSwgLTEpO1xuICAgICAgICAgICAgbGV0IHRvID0gc2tpcEF0b21pY1JhbmdlcyhhdG9tcywgcmFuZ2UudG8sIDEpO1xuICAgICAgICAgICAgaWYgKGZyb20gIT0gcmFuZ2UuZnJvbSB8fCB0byAhPSByYW5nZS50bylcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20gPT0gcmFuZ2UuYW5jaG9yID8gZnJvbSA6IHRvLCByYW5nZS5mcm9tID09IHJhbmdlLmhlYWQgPyBmcm9tIDogdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMgPSBzZWwucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICByYW5nZXNbaV0gPSB1cGRhdGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZXMgPyBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCkgOiBzZWw7XG59XG5mdW5jdGlvbiBza2lwQXRvbXModmlldywgb2xkUG9zLCBwb3MpIHtcbiAgICBsZXQgbmV3UG9zID0gc2tpcEF0b21pY1Jhbmdlcyh2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSksIHBvcy5mcm9tLCBvbGRQb3MuaGVhZCA+IHBvcy5mcm9tID8gLTEgOiAxKTtcbiAgICByZXR1cm4gbmV3UG9zID09IHBvcy5mcm9tID8gcG9zIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXdQb3MsIG5ld1BvcyA8IHBvcy5mcm9tID8gMSA6IC0xKTtcbn1cblxuY29uc3QgTGluZUJyZWFrUGxhY2Vob2xkZXIgPSBcIlxcdWZmZmZcIjtcbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5saW5lU2VwYXJhdG9yID0gc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGFwcGVuZCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgIH1cbiAgICBsaW5lQnJlYWsoKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSBMaW5lQnJlYWtQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmVhZFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBjdXIpO1xuICAgICAgICAgICAgbGV0IG9sZExlbiA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlYWROb2RlKGN1cik7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1ciksIG5leHRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgaWYgKCh2aWV3ICYmIG5leHRWaWV3ID8gdmlldy5icmVha0FmdGVyIDpcbiAgICAgICAgICAgICAgICAodmlldyA/IHZpZXcuYnJlYWtBZnRlciA6IGlzQmxvY2tFbGVtZW50KGN1cikpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0Jsb2NrRWxlbWVudChuZXh0KSAmJiAoY3VyLm5vZGVOYW1lICE9IFwiQlJcIiB8fCBjdXIuY21JZ25vcmUpICYmIHRoaXMudGV4dC5sZW5ndGggPiBvbGRMZW4pKSAmJlxuICAgICAgICAgICAgICAgICFpc0VtcHR5VG9FbmQobmV4dCwgZW5kKSlcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWFkVGV4dE5vZGUobm9kZSkge1xuICAgICAgICBsZXQgdGV4dCA9IG5vZGUubm9kZVZhbHVlO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKHBvaW50Lm9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBvZmYgPSAwLCByZSA9IHRoaXMubGluZVNlcGFyYXRvciA/IG51bGwgOiAvXFxyXFxuP3xcXG4vZzs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEJyZWFrID0gLTEsIGJyZWFrU2l6ZSA9IDEsIG07XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gdGV4dC5pbmRleE9mKHRoaXMubGluZVNlcGFyYXRvciwgb2ZmKTtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobSA9IHJlLmV4ZWModGV4dCkpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmQodGV4dC5zbGljZShvZmYsIG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaykpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgaWYgKGJyZWFrU2l6ZSA+IDEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgcG9pbnQucG9zID4gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnBvcyAtPSBicmVha1NpemUgLSAxO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEJyZWFrICsgYnJlYWtTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY21JZ25vcmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpO1xuICAgICAgICBsZXQgZnJvbVZpZXcgPSB2aWV3ICYmIHZpZXcub3ZlcnJpZGVET01UZXh0O1xuICAgICAgICBpZiAoZnJvbVZpZXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRJbnNpZGUobm9kZSwgZnJvbVZpZXcubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tVmlldy5pdGVyKCk7ICFpLm5leHQoKS5kb25lOykge1xuICAgICAgICAgICAgICAgIGlmIChpLmxpbmVCcmVhaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgdGhpcy5yZWFkVGV4dE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRQb2ludEJlZm9yZShub2RlLCBuZXh0KSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBub2RlLmNoaWxkTm9kZXNbcG9pbnQub2Zmc2V0XSA9PSBuZXh0KVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmRQb2ludEluc2lkZShub2RlLCBsZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzID8gcG9pbnQubm9kZSA9PSBub2RlIDogbm9kZS5jb250YWlucyhwb2ludC5ub2RlKSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgKGlzQXRFbmQobm9kZSwgcG9pbnQubm9kZSwgcG9pbnQub2Zmc2V0KSA/IGxlbmd0aCA6IDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQXRFbmQocGFyZW50LCBub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICghbm9kZSB8fCBvZmZzZXQgPCBtYXhPZmZzZXQobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFbXB0eVRvRW5kKG5vZGUsIGVuZCkge1xuICAgIGxldCB3aWRnZXRzO1xuICAgIGZvciAoOzsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gZW5kIHx8ICFub2RlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoISgodmlldyA9PT0gbnVsbCB8fCB2aWV3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWV3LmlzV2lkZ2V0KSB8fCBub2RlLmNtSWdub3JlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHZpZXcpXG4gICAgICAgICAgICAod2lkZ2V0cyB8fCAod2lkZ2V0cyA9IFtdKSkucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgaWYgKHdpZGdldHMpXG4gICAgICAgIGZvciAobGV0IHcgb2Ygd2lkZ2V0cykge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlID0gdy5vdmVycmlkZURPTVRleHQ7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUgPT09IG51bGwgfHwgb3ZlcnJpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIERPTVBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucG9zID0gLTE7XG4gICAgfVxufVxuXG5jbGFzcyBET01DaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXJ0LCBlbmQsIHR5cGVPdmVyKSB7XG4gICAgICAgIHRoaXMudHlwZU92ZXIgPSB0eXBlT3ZlcjtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBzdGFydCA+IC0xO1xuICAgICAgICBsZXQgeyBpbXByZWNpc2VIZWFkOiBpSGVhZCwgaW1wcmVjaXNlQW5jaG9yOiBpQW5jaG9yIH0gPSB2aWV3LmRvY1ZpZXc7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5ICYmIHN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBjaGFuZ2VzIHdoZW4gdGhlIGVkaXRvciBpcyByZWFkLW9ubHlcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydCA+IC0xICYmICh0aGlzLmJvdW5kcyA9IHZpZXcuZG9jVmlldy5kb21Cb3VuZHNBcm91bmQoc3RhcnQsIGVuZCwgMCkpKSB7XG4gICAgICAgICAgICBsZXQgc2VsUG9pbnRzID0gaUhlYWQgfHwgaUFuY2hvciA/IFtdIDogc2VsZWN0aW9uUG9pbnRzKHZpZXcpO1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBET01SZWFkZXIoc2VsUG9pbnRzLCB2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkUmFuZ2UodGhpcy5ib3VuZHMuc3RhcnRET00sIHRoaXMuYm91bmRzLmVuZERPTSk7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSByZWFkZXIudGV4dDtcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gc2VsZWN0aW9uRnJvbVBvaW50cyhzZWxQb2ludHMsIHRoaXMuYm91bmRzLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgICAgICBsZXQgaGVhZCA9IGlIZWFkICYmIGlIZWFkLm5vZGUgPT0gZG9tU2VsLmZvY3VzTm9kZSAmJiBpSGVhZC5vZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0IHx8XG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmZvY3VzTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZFxuICAgICAgICAgICAgICAgIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBhbmNob3IgPSBpQW5jaG9yICYmIGlBbmNob3Iubm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiBpQW5jaG9yLm9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0IHx8XG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmFuY2hvck5vZGUpXG4gICAgICAgICAgICAgICAgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvclxuICAgICAgICAgICAgICAgIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgLy8gaU9TIHdpbGwgcmVmdXNlIHRvIHNlbGVjdCB0aGUgYmxvY2sgZ2FwcyB3aGVuIGRvaW5nXG4gICAgICAgICAgICAvLyBzZWxlY3QtYWxsLlxuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgcHV0IHRoZSBzZWxlY3Rpb24gKmluc2lkZSogdGhlbSwgY29uZnVzaW5nXG4gICAgICAgICAgICAvLyBwb3NGcm9tRE9NXG4gICAgICAgICAgICBsZXQgdnAgPSB2aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgaWYgKChicm93c2VyLmlvcyB8fCBicm93c2VyLmNocm9tZSkgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiBoZWFkICE9IGFuY2hvciAmJlxuICAgICAgICAgICAgICAgICh2cC5mcm9tID4gMCB8fCB2cC50byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGhlYWQsIGFuY2hvciksIHRvID0gTWF0aC5tYXgoaGVhZCwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2ZmRnJvbSA9IHZwLmZyb20gLSBmcm9tLCBvZmZUbyA9IHZwLnRvIC0gdG87XG4gICAgICAgICAgICAgICAgaWYgKChvZmZGcm9tID09IDAgfHwgb2ZmRnJvbSA9PSAxIHx8IGZyb20gPT0gMCkgJiYgKG9mZlRvID09IDAgfHwgb2ZmVG8gPT0gLTEgfHwgdG8gPT0gdmlldy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gdmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShhbmNob3IsIGhlYWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2UodmlldywgZG9tQ2hhbmdlKSB7XG4gICAgbGV0IGNoYW5nZTtcbiAgICBsZXQgeyBuZXdTZWwgfSA9IGRvbUNoYW5nZSwgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgbGFzdEtleSA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA+IERhdGUubm93KCkgLSAxMDAgPyB2aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgOiAtMTtcbiAgICBpZiAoZG9tQ2hhbmdlLmJvdW5kcykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gZG9tQ2hhbmdlLmJvdW5kcztcbiAgICAgICAgbGV0IHByZWZlcnJlZFBvcyA9IHNlbC5mcm9tLCBwcmVmZXJyZWRTaWRlID0gbnVsbDtcbiAgICAgICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZCAob3IsIG9uXG4gICAgICAgIC8vIEFuZHJvaWQsIHdoZW4gc29tZXRoaW5nIHdhcyBkZWxldGVkKVxuICAgICAgICBpZiAobGFzdEtleSA9PT0gOCB8fCBicm93c2VyLmFuZHJvaWQgJiYgZG9tQ2hhbmdlLnRleHQubGVuZ3RoIDwgdG8gLSBmcm9tKSB7XG4gICAgICAgICAgICBwcmVmZXJyZWRQb3MgPSBzZWwudG87XG4gICAgICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlmZiA9IGZpbmREaWZmKHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCBMaW5lQnJlYWtQbGFjZWhvbGRlciksIGRvbUNoYW5nZS50ZXh0LCBwcmVmZXJyZWRQb3MgLSBmcm9tLCBwcmVmZXJyZWRTaWRlKTtcbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBpbnNlcnRzIHR3byBuZXdsaW5lcyB3aGVuIHByZXNzaW5nIHNoaWZ0LWVudGVyIGF0IHRoZVxuICAgICAgICAgICAgLy8gZW5kIG9mIGEgbGluZS4gRG9tQ2hhbmdlIGRyb3BzIG9uZSBvZiB0aG9zZS5cbiAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBsYXN0S2V5ID09IDEzICYmXG4gICAgICAgICAgICAgICAgZGlmZi50b0IgPT0gZGlmZi5mcm9tICsgMiAmJiBkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKSA9PSBMaW5lQnJlYWtQbGFjZWhvbGRlciArIExpbmVCcmVha1BsYWNlaG9sZGVyKVxuICAgICAgICAgICAgICAgIGRpZmYudG9CLS07XG4gICAgICAgICAgICBjaGFuZ2UgPSB7IGZyb206IGZyb20gKyBkaWZmLmZyb20sIHRvOiBmcm9tICsgZGlmZi50b0EsXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBUZXh0Lm9mKGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpLnNwbGl0KExpbmVCcmVha1BsYWNlaG9sZGVyKSkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgKCF2aWV3Lmhhc0ZvY3VzICYmIHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpIHx8IG5ld1NlbC5tYWluLmVxKHNlbCkpKSB7XG4gICAgICAgIG5ld1NlbCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghY2hhbmdlICYmICFuZXdTZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWNoYW5nZSAmJiBkb21DaGFuZ2UudHlwZU92ZXIgJiYgIXNlbC5lbXB0eSAmJiBuZXdTZWwgJiYgbmV3U2VsLm1haW4uZW1wdHkpIHtcbiAgICAgICAgLy8gSGV1cmlzdGljIHRvIG5vdGljZSB0eXBpbmcgb3ZlciBhIHNlbGVjdGVkIGNoYXJhY3RlclxuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlKHNlbC5mcm9tLCBzZWwudG8pIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKChicm93c2VyLm1hYyB8fCBicm93c2VyLmFuZHJvaWQpICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgLSAxICYmXG4gICAgICAgIC9eXFwuID8kLy50ZXN0KGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSkgJiYgdmlldy5jb250ZW50RE9NLmdldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIpID09IFwib2ZmXCIpIHtcbiAgICAgICAgLy8gRGV0ZWN0IGluc2VydC1wZXJpb2Qtb24tZG91YmxlLXNwYWNlIE1hYyBhbmQgQW5kcm9pZCBiZWhhdmlvcixcbiAgICAgICAgLy8gYW5kIHRyYW5zZm9ybSBpdCBpbnRvIGEgcmVndWxhciBzcGFjZSBpbnNlcnQuXG4gICAgICAgIGlmIChuZXdTZWwgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMilcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCBpbnNlcnQ6IFRleHQub2YoW2NoYW5nZS5pbnNlcnQudG9TdHJpbmcoKS5yZXBsYWNlKFwiLlwiLCBcIiBcIildKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJlxuICAgICAgICAoY2hhbmdlLmZyb20gIT0gc2VsLmZyb20gfHwgY2hhbmdlLnRvICE9IHNlbC50bykgJiZcbiAgICAgICAgKHNlbC50byAtIHNlbC5mcm9tKSAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSkgPD0gNCkge1xuICAgICAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluc2lkZSB0aGUgc2VsZWN0aW9uIGFuZCBjb3ZlcnMgbW9zdCBvZiBpdCxcbiAgICAgICAgLy8gYXNzdW1lIGl0IGlzIGEgc2VsZWN0aW9uIHJlcGxhY2UgKHdpdGggaWRlbnRpY2FsIGNoYXJhY3RlcnMgYXRcbiAgICAgICAgLy8gdGhlIHN0YXJ0L2VuZCBub3QgaW5jbHVkZWQgaW4gdGhlIGRpZmYpXG4gICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLFxuICAgICAgICAgICAgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgY2hhbmdlLmZyb20pLmFwcGVuZChjaGFuZ2UuaW5zZXJ0KS5hcHBlbmQodmlldy5zdGF0ZS5kb2Muc2xpY2UoY2hhbmdlLnRvLCBzZWwudG8pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmZyb20pLnRvIDwgc2VsLnRvICYmIHZpZXcuZG9jVmlldy5saW5lSGFzV2lkZ2V0KHNlbC50bykgJiZcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmluc2VydGluZ1RleHRBdCA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICAvLyBGb3IgYSBjcm9zcy1saW5lIGluc2VydGlvbiwgQ2hyb21lIGFuZCBTYWZhcmkgd2lsbCBjcnVkZWx5IHRha2VcbiAgICAgICAgLy8gdGhlIHRleHQgb2YgdGhlIGxpbmUgYWZ0ZXIgdGhlIHNlbGVjdGlvbiwgZmxhdHRlbmluZyBhbnlcbiAgICAgICAgLy8gd2lkZ2V0cywgYW5kIG1vdmUgaXQgaW50byB0aGUgam9pbmVkIGxpbmUuIFRoaXMgdHJpZXMgdG8gZGV0ZWN0XG4gICAgICAgIC8vIHN1Y2ggYSBzaXR1YXRpb24sIGFuZCByZXBsYWNlcyB0aGUgY2hhbmdlIHdpdGggYSBzZWxlY3Rpb25cbiAgICAgICAgLy8gcmVwbGFjZSBvZiB0aGUgdGV4dCBwcm92aWRlZCBieSB0aGUgYmVmb3JlaW5wdXQgZXZlbnQuXG4gICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLFxuICAgICAgICAgICAgaW5zZXJ0OiB2aWV3LnN0YXRlLnRvVGV4dCh2aWV3LmlucHV0U3RhdGUuaW5zZXJ0aW5nVGV4dClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAmJlxuICAgICAgICBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkgPT0gXCJcXG4gXCIgJiYgdmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBpZiB5b3UgaW5zZXJ0IGEgc3BhY2UgYXQgdGhlIHN0YXJ0IG9mIGEgd3JhcHBlZFxuICAgICAgICAvLyBsaW5lLCBpdCB3aWxsIGFjdHVhbGx5IGluc2VydCBhIG5ld2xpbmUgYW5kIGEgc3BhY2UsIGNhdXNpbmcgYVxuICAgICAgICAvLyBib2d1cyBuZXcgbGluZSB0byBiZSBjcmVhdGVkIGluIENvZGVNaXJyb3IgKCM5NjgpXG4gICAgICAgIGlmIChuZXdTZWwpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5RE9NQ2hhbmdlSW5uZXIodmlldywgY2hhbmdlLCBuZXdTZWwsIGxhc3RLZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgIW5ld1NlbC5tYWluLmVxKHNlbCkpIHtcbiAgICAgICAgbGV0IHNjcm9sbEludG9WaWV3ID0gZmFsc2UsIHVzZXJFdmVudCA9IFwic2VsZWN0XCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbiA9PSBcInNlbGVjdFwiKVxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVzZXJFdmVudCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luO1xuICAgICAgICAgICAgaWYgKHVzZXJFdmVudCA9PSBcInNlbGVjdC5wb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgbmV3U2VsID0gc2tpcEF0b21zRm9yU2VsZWN0aW9uKHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKSwgbmV3U2VsKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHNjcm9sbEludG9WaWV3LCB1c2VyRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RE9NQ2hhbmdlSW5uZXIodmlldywgY2hhbmdlLCBuZXdTZWwsIGxhc3RLZXkgPSAtMSkge1xuICAgIGlmIChicm93c2VyLmlvcyAmJiB2aWV3LmlucHV0U3RhdGUuZmx1c2hJT1NLZXkoY2hhbmdlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXG4gICAgLy8gYmFja3NwYWNlLCBvciBkZWxldGUuIFNvIHRoaXMgZGV0ZWN0cyBjaGFuZ2VzIHRoYXQgbG9vayBsaWtlXG4gICAgLy8gdGhleSdyZSBjYXVzZWQgYnkgdGhvc2Uga2V5cywgYW5kIHJlaW50ZXJwcmV0cyB0aGVtIGFzIGtleVxuICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XG4gICAgLy8gZXZlbnRzIGFuZCB0aGUgcGVuZGluZ0FuZHJvaWRLZXkgbWVjaGFuaXNtLCBidXQgdGhhdCdzIG5vdFxuICAgIC8vIHJlbGlhYmxlIGluIGFsbCBzaXR1YXRpb25zLilcbiAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICgoY2hhbmdlLnRvID09IHNlbC50byAmJlxuICAgICAgICAgICAgLy8gR0JvYXJkIHdpbGwgc29tZXRpbWVzIHJlbW92ZSBhIHNwYWNlIGl0IGp1c3QgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGFmdGVyIGEgY29tcGxldGlvbiB3aGVuIHlvdSBwcmVzcyBlbnRlclxuICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIHx8IGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIC0gMSAmJiB2aWV3LnN0YXRlLnNsaWNlRG9jKGNoYW5nZS5mcm9tLCBzZWwuZnJvbSkgPT0gXCIgXCIpICYmXG4gICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkVudGVyXCIsIDEzKSkgfHxcbiAgICAgICAgICAgICgoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gLSAxICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCB8fFxuICAgICAgICAgICAgICAgIGxhc3RLZXkgPT0gOCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA8IGNoYW5nZS50byAtIGNoYW5nZS5mcm9tICYmIGNoYW5nZS50byA+IHNlbC5oZWFkKSAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJCYWNrc3BhY2VcIiwgOCkpIHx8XG4gICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byArIDEgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJEZWxldGVcIiwgNDYpKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCB0ZXh0ID0gY2hhbmdlLmluc2VydC50b1N0cmluZygpO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcrKztcbiAgICBsZXQgZGVmYXVsdFRyO1xuICAgIGxldCBkZWZhdWx0SW5zZXJ0ID0gKCkgPT4gZGVmYXVsdFRyIHx8IChkZWZhdWx0VHIgPSBhcHBseURlZmF1bHRJbnNlcnQodmlldywgY2hhbmdlLCBuZXdTZWwpKTtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmFjZXQoaW5wdXRIYW5kbGVyKS5zb21lKGggPT4gaCh2aWV3LCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvLCB0ZXh0LCBkZWZhdWx0SW5zZXJ0KSkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goZGVmYXVsdEluc2VydCgpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdEluc2VydCh2aWV3LCBjaGFuZ2UsIG5ld1NlbCkge1xuICAgIGxldCB0ciwgc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGUsIHNlbCA9IHN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW4sIGluQXRvbWljID0gLTE7XG4gICAgaWYgKGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA8IHNlbC5mcm9tIHx8IGNoYW5nZS5mcm9tID4gc2VsLnRvKSB7XG4gICAgICAgIGxldCBzaWRlID0gY2hhbmdlLmZyb20gPCBzZWwuZnJvbSA/IC0xIDogMSwgcG9zID0gc2lkZSA8IDAgPyBzZWwuZnJvbSA6IHNlbC50bztcbiAgICAgICAgbGV0IG1vdmVkID0gc2tpcEF0b21pY1JhbmdlcyhzdGFydFN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSksIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChjaGFuZ2UuZnJvbSA9PSBtb3ZlZClcbiAgICAgICAgICAgIGluQXRvbWljID0gbW92ZWQ7XG4gICAgfVxuICAgIGlmIChpbkF0b21pYyA+IC0xKSB7XG4gICAgICAgIHRyID0ge1xuICAgICAgICAgICAgY2hhbmdlczogY2hhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGNoYW5nZS5mcm9tICsgY2hhbmdlLmluc2VydC5sZW5ndGgsIC0xKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byAtIGNoYW5nZS5mcm9tID49IChzZWwudG8gLSBzZWwuZnJvbSkgLyAzICYmXG4gICAgICAgICghbmV3U2VsIHx8IG5ld1NlbC5tYWluLmVtcHR5ICYmIG5ld1NlbC5tYWluLmZyb20gPT0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCkgJiZcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHNlbC5mcm9tIDwgY2hhbmdlLmZyb20gPyBzdGFydFN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBjaGFuZ2UuZnJvbSkgOiBcIlwiO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBzZWwudG8gPiBjaGFuZ2UudG8gPyBzdGFydFN0YXRlLnNsaWNlRG9jKGNoYW5nZS50bywgc2VsLnRvKSA6IFwiXCI7XG4gICAgICAgIHRyID0gc3RhcnRTdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHZpZXcuc3RhdGUudG9UZXh0KGJlZm9yZSArIGNoYW5nZS5pbnNlcnQuc2xpY2VTdHJpbmcoMCwgdW5kZWZpbmVkLCB2aWV3LnN0YXRlLmxpbmVCcmVhaykgKyBhZnRlcikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgbGV0IG1haW5TZWwgPSBuZXdTZWwgJiYgbmV3U2VsLm1haW4udG8gPD0gY2hhbmdlcy5uZXdMZW5ndGggPyBuZXdTZWwubWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVHJ5IHRvIGFwcGx5IGEgY29tcG9zaXRpb24gY2hhbmdlIHRvIGFsbCBjdXJzb3JzXG4gICAgICAgIGlmIChzdGFydFN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoID4gMSAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiZcbiAgICAgICAgICAgIGNoYW5nZS50byA8PSBzZWwudG8gKyAxMCAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcbiAgICAgICAgICAgIGxldCByZXBsYWNlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSwgY29tcG9zaXRpb24gPSBuZXdTZWwgJiYgZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBuZXdTZWwubWFpbi5oZWFkKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBkTGVuID0gY2hhbmdlLmluc2VydC5sZW5ndGggLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pO1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB7IGZyb206IGNvbXBvc2l0aW9uLmZyb20sIHRvOiBjb21wb3NpdGlvbi50byAtIGRMZW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHNlbC50byAtIGNoYW5nZS50bywgc2l6ZSA9IHNlbC50byAtIHNlbC5mcm9tO1xuICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIHJhbmdlLnRvID09IHNlbC50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlcywgcmFuZ2U6IG1haW5TZWwgfHwgcmFuZ2UubWFwKGNoYW5nZXMpIH07XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gcmFuZ2UudG8gLSBvZmZzZXQsIGZyb20gPSB0byAtIHJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gLSByYW5nZS5mcm9tICE9IHNpemUgfHwgdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0bykgIT0gcmVwbGFjZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUncyBubyB3YXkgdG8gbWFrZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSBzYW1lIG5vZGUgd29yayB3aXRob3V0IGFib3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0aW9uLCBzbyBjdXJzb3JzIGluIHRoZSBjb21wb3NpdGlvbiByYW5nZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UudG8gPj0gY29tcG9zaXRpb25SYW5nZS5mcm9tICYmIHJhbmdlLmZyb20gPD0gY29tcG9zaXRpb25SYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VDaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKHsgZnJvbSwgdG8sIGluc2VydDogY2hhbmdlLmluc2VydCB9KSwgc2VsT2ZmID0gcmFuZ2UudG8gLSBzZWwudG87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogIW1haW5TZWwgPyByYW5nZS5tYXAocmFuZ2VDaGFuZ2VzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5tYXgoMCwgbWFpblNlbC5hbmNob3IgKyBzZWxPZmYpLCBNYXRoLm1heCgwLCBtYWluU2VsLmhlYWQgKyBzZWxPZmYpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyID0ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBtYWluU2VsICYmIHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJlcGxhY2VSYW5nZShtYWluU2VsKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdXNlckV2ZW50ID0gXCJpbnB1dC50eXBlXCI7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHVzZXJFdmVudCArPSBcIi5jb21wb3NlXCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLnN0YXJ0XCI7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydFN0YXRlLnVwZGF0ZSh0ciwgeyB1c2VyRXZlbnQsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cblxuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKG9yaWdpbikge1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIC8vIE9uIGlPUywgc29tZSBrZXlzIG5lZWQgdG8gaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIGhhcHBlblxuICAgICAgICAvLyAoYWZ0ZXIgd2hpY2ggd2UgcmV0cm9hY3RpdmVseSBoYW5kbGUgdGhlbSBhbmQgcmVzZXQgdGhlIERPTSkgdG9cbiAgICAgICAgLy8gYXZvaWQgbWVzc2luZyB1cCB0aGUgdmlydHVhbCBrZXlib2FyZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlbmFibGVkICg+LTEpLCB0YWIgcHJlc3NlcyBhcmUgbm90IGdpdmVuIHRvIGtleSBoYW5kbGVycyxcbiAgICAgICAgbGVhdmluZyB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IuIElmID4wLCB0aGUgbW9kZSBleHBpcmVzXG4gICAgICAgIGF0IHRoYXQgdGltZXN0YW1wLCBhbmQgYW55IG90aGVyIGtleXByZXNzIGNsZWFycyBpdC5cbiAgICAgICAgRXNjIGVuYWJsZXMgdGVtcG9yYXJ5IHRhYiBmb2N1cyBtb2RlIGZvciB0d28gc2Vjb25kcyB3aGVuIG5vdFxuICAgICAgICBvdGhlcndpc2UgaGFuZGxlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJGb2N1c01vZGUgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbnRleHRNZW51ID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLy8gLTEgbWVhbnMgbm90IGluIGEgY29tcG9zaXRpb24uIE90aGVyd2lzZSwgdGhpcyBjb3VudHMgdGhlIG51bWJlclxuICAgICAgICAvLyBvZiBjaGFuZ2VzIG1hZGUgZHVyaW5nIHRoZSBjb21wb3NpdGlvbi4gVGhlIGNvdW50IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gYXZvaWQgdHJlYXRpbmcgdGhlIHN0YXJ0IHN0YXRlIG9mIHRoZSBjb21wb3NpdGlvbiwgYmVmb3JlIGFueVxuICAgICAgICAvLyBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlLCBhcyBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbi5cbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAtMTtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIG5leHQgY2hhbmdlIHNob3VsZCBiZSBtYXJrZWQgYXMgc3RhcnRpbmcgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIChudWxsIG1lYW5zIG5vIGNvbXBvc2l0aW9uLCB0cnVlIG1lYW5zIG5leHQgaXMgdGhlXG4gICAgICAgIC8vIGZpcnN0LCBmYWxzZSBtZWFucyBmaXJzdCBoYXMgYWxyZWFkeSBiZWVuIG1hcmtlZCBmb3IgdGhpc1xuICAgICAgICAvLyBjb21wb3NpdGlvbilcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgLy8gRW5kIHRpbWUgb2YgdGhlIHByZXZpb3VzIGNvbXBvc2l0aW9uXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMDtcbiAgICAgICAgLy8gVXNlZCBpbiBhIGtsdWRnZSB0byBkZXRlY3Qgd2hlbiBhbiBFbnRlciBrZXlwcmVzcyBzaG91bGQgYmVcbiAgICAgICAgLy8gY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBjb21wb3NpdGlvbiBvbiBTYWZhcmksIHdoaWNoIGZpcmVzIGV2ZW50c1xuICAgICAgICAvLyBpbiB0aGUgd3Jvbmcgb3JkZXJcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCB0byBjYXRlZ29yaXplIGNoYW5nZXMgYXMgcGFydCBvZiBhIGNvbXBvc2l0aW9uLCBldmVuIHdoZW5cbiAgICAgICAgLy8gdGhlIG11dGF0aW9uIGV2ZW50cyBmaXJlIHNob3J0bHkgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIC8vIFNldCBieSBiZWZvcmVpbnB1dCwgdXNlZCBpbiBET00gY2hhbmdlIHJlYWRlclxuICAgICAgICB0aGlzLmluc2VydGluZ1RleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmluc2VydGluZ1RleHRBdCA9IDA7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAvLyBXaGVuIGEgZHJhZyBmcm9tIHRoZSBlZGl0b3IgaXMgYWN0aXZlLCB0aGlzIHBvaW50cyBhdCB0aGUgcmFuZ2VcbiAgICAgICAgLy8gYmVpbmcgZHJhZ2dlZC5cbiAgICAgICAgdGhpcy5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubm90aWZpZWRGb2N1c2VkID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgLy8gT24gU2FmYXJpIGFkZGluZyBhbiBpbnB1dCBldmVudCBoYW5kbGVyIHNvbWVob3cgcHJldmVudHMgYW5cbiAgICAgICAgLy8gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW4geW91IHByZXNzIGVudGVyLlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkpXG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbylcbiAgICAgICAgICAgIGZpcmVmb3hDb3B5Q3V0SGFjayh2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudCk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodGhpcy52aWV3LCBldmVudCkgfHwgdGhpcy5pZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIHRoaXMua2V5ZG93bihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnZpZXcudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLnJ1bkhhbmRsZXJzKGV2ZW50LnR5cGUsIGV2ZW50KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucnVuSGFuZGxlcnMoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH1cbiAgICBydW5IYW5kbGVycyh0eXBlLCBldmVudCkge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9ic2VydmVyIG9mIGhhbmRsZXJzLm9ic2VydmVycylcbiAgICAgICAgICAgICAgICBvYnNlcnZlcih0aGlzLnZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgaGFuZGxlcnMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIodGhpcy52aWV3LCBldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVuc3VyZUhhbmRsZXJzKHBsdWdpbnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gY29tcHV0ZUhhbmRsZXJzKHBsdWdpbnMpLCBwcmV2ID0gdGhpcy5oYW5kbGVycywgZG9tID0gdGhpcy52aWV3LmNvbnRlbnRET007XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhc3NpdmUgPSAhaGFuZGxlcnNbdHlwZV0uaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBleGlzdHMgPSBwcmV2W3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHMgJiYgcGFzc2l2ZSAhPSAhZXhpc3RzLmhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQsIHsgcGFzc2l2ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKHR5cGUgIT0gXCJzY3JvbGxcIiAmJiAhaGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB9XG4gICAga2V5ZG93bihldmVudCkge1xuICAgICAgICAvLyBNdXN0IGFsd2F5cyBydW4sIGV2ZW4gaWYgYSBjdXN0b20gaGFuZGxlciBoYW5kbGVkIHRoZSBldmVudFxuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDkgJiYgdGhpcy50YWJGb2N1c01vZGUgPiAtMSAmJiAoIXRoaXMudGFiRm9jdXNNb2RlIHx8IERhdGUubm93KCkgPD0gdGhpcy50YWJGb2N1c01vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLnRhYkZvY3VzTW9kZSA+IDAgJiYgZXZlbnQua2V5Q29kZSAhPSAyNyAmJiBtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy50YWJGb2N1c01vZGUgPSAtMTtcbiAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkIHVzdWFsbHkgZG9lc24ndCBmaXJlIHByb3BlciBrZXkgZXZlbnRzLCBidXRcbiAgICAgICAgLy8gb2NjYXNpb25hbGx5IGRvZXMsIHVzdWFsbHkgc3Vycm91bmRlZCBieSBhIGJ1bmNoIG9mIGNvbXBsaWNhdGVkXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIGNoYW5nZXMuIFdoZW4gYW4gZW50ZXIgb3IgYmFja3NwYWNlIGtleSBldmVudCBpc1xuICAgICAgICAvLyBzZWVuLCBob2xkIG9mZiBvbiBoYW5kbGluZyBET00gZXZlbnRzIGZvciBhIGJpdCwgYW5kIHRoZW5cbiAgICAgICAgLy8gZGlzcGF0Y2ggaXQuXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJlxuICAgICAgICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShldmVudC5rZXksIGV2ZW50LmtleUNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBFbnRlciBvbiBpT1MgbWFrZXMgdGhlXG4gICAgICAgIC8vIHZpcnR1YWwga2V5Ym9hcmQgZ2V0IHN0dWNrIGluIHRoZSB3cm9uZyAobG93ZXJjYXNlKVxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxuICAgICAgICAvLyBhcHBseURPTUNoYW5nZSwgbm90aWZ5IGtleSBoYW5kbGVycyBvZiBpdCBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gdGhlIHN0YXRlIHRoZXkgcHJvZHVjZS5cbiAgICAgICAgbGV0IHBlbmRpbmc7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiAhZXZlbnQuc3ludGhldGljICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiZcbiAgICAgICAgICAgICgocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5rZXlDb2RlID09IGV2ZW50LmtleUNvZGUpKSAmJiAhZXZlbnQuY3RybEtleSB8fFxuICAgICAgICAgICAgICAgIEVtYWNzeVBlbmRpbmdLZXlzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gcGVuZGluZyB8fCBldmVudDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaElPU0tleSgpLCAyNTApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmbHVzaElPU0tleShjaGFuZ2UpIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMucGVuZGluZ0lPU0tleTtcbiAgICAgICAgaWYgKCFrZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhbiBhdXRvY29ycmVjdGlvbiBiZWZvcmUgRW50ZXJcbiAgICAgICAgaWYgKGtleS5rZXkgPT0gXCJFbnRlclwiICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA8IGNoYW5nZS50byAmJiAvXlxcUyskLy50ZXN0KGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KHRoaXMudmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSwga2V5IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCA/IGtleSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkgfHwgZXZlbnQuc3ludGhldGljKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAgICAgLy8gT24gc29tZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0b1xuICAgICAgICAvLyBjb25maXJtIGNoYXJhY3RlciBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLFxuICAgICAgICAvLyBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlIHNvbWV0aW1lcyBlbWl0dGVkIGluIHRoZVxuICAgICAgICAvLyB3cm9uZyBvcmRlci4gVGhlIGtleSBldmVudCBzaG91bGQgc3RpbGwgYmUgaWdub3JlZCwgZXZlbiB3aGVuXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgYWZ0ZXIgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50LlxuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWJyb3dzZXIuaW9zICYmIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ICYmIERhdGUubm93KCkgLSB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA8IDEwMCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRNb3VzZVNlbGVjdGlvbihtb3VzZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbW91c2VTZWxlY3Rpb247XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnZWRDb250ZW50ICYmIHVwZGF0ZS5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkQ29udGVudCA9IHRoaXMuZHJhZ2dlZENvbnRlbnQubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJpbmRIYW5kbGVyKHBsdWdpbiwgaGFuZGxlcikge1xuICAgIHJldHVybiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwocGx1Z2luLCBldmVudCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSGFuZGxlcnMocGx1Z2lucykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIHJlY29yZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbdHlwZV0gfHwgKHJlc3VsdFt0eXBlXSA9IHsgb2JzZXJ2ZXJzOiBbXSwgaGFuZGxlcnM6IFtdIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBsZXQgc3BlYyA9IHBsdWdpbi5zcGVjLCBoYW5kbGVycyA9IHNwZWMgJiYgc3BlYy5wbHVnaW4uZG9tRXZlbnRIYW5kbGVycywgb2JzZXJ2ZXJzID0gc3BlYyAmJiBzcGVjLnBsdWdpbi5kb21FdmVudE9ic2VydmVycztcbiAgICAgICAgaWYgKGhhbmRsZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGxldCBmID0gaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBvYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IG9ic2VydmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkKHR5cGUpLm9ic2VydmVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCB0eXBlIGluIGhhbmRsZXJzKVxuICAgICAgICByZWNvcmQodHlwZSkuaGFuZGxlcnMucHVzaChoYW5kbGVyc1t0eXBlXSk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiBvYnNlcnZlcnMpXG4gICAgICAgIHJlY29yZCh0eXBlKS5vYnNlcnZlcnMucHVzaChvYnNlcnZlcnNbdHlwZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBQZW5kaW5nS2V5cyA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwga2V5Q29kZTogOCwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRQYXJhZ3JhcGhcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0TGluZUJyZWFrXCIgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwga2V5Q29kZTogNDYsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiIH1cbl07XG5jb25zdCBFbWFjc3lQZW5kaW5nS2V5cyA9IFwiZHRoa29cIjtcbi8vIEtleSBjb2RlcyBmb3IgbW9kaWZpZXIga2V5c1xuY29uc3QgbW9kaWZpZXJDb2RlcyA9IFsxNiwgMTcsIDE4LCAyMCwgOTEsIDkyLCAyMjQsIDIyNV07XG5jb25zdCBkcmFnU2Nyb2xsTWFyZ2luID0gNjtcbmZ1bmN0aW9uIGRyYWdTY3JvbGxTcGVlZChkaXN0KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGRpc3QpICogMC43ICsgODtcbn1cbmZ1bmN0aW9uIGRpc3QoYSwgYikge1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyhhLmNsaWVudFggLSBiLmNsaWVudFgpLCBNYXRoLmFicyhhLmNsaWVudFkgLSBiLmNsaWVudFkpKTtcbn1cbmNsYXNzIE1vdXNlU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydEV2ZW50LCBzdHlsZSwgbXVzdFNlbGVjdCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IG11c3RTZWxlY3Q7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBzdGFydEV2ZW50O1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMgPSBzY3JvbGxhYmxlUGFyZW50cyh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmF0b21zID0gdmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpO1xuICAgICAgICBsZXQgZG9jID0gdmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IHN0YXJ0RXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubXVsdGlwbGUgPSB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSAmJiBhZGRzU2VsZWN0aW9uUmFuZ2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KSAmJiBnZXRDbGlja1R5cGUoc3RhcnRFdmVudCkgPT0gMSA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb24sIGltbWVkaWF0ZWx5IGFwcGx5IHRoZVxuICAgICAgICAvLyBlZmZlY3Qgb2Ygc3RhcnRpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdChldmVudCk7XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgfHwgdGhpcy5kcmFnZ2luZyA9PSBudWxsICYmIGRpc3QodGhpcy5zdGFydEV2ZW50LCBldmVudCkgPCAxMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQgPSBldmVudCk7XG4gICAgICAgIGxldCBzeCA9IDAsIHN5ID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwLCB0b3AgPSAwLCByaWdodCA9IHRoaXMudmlldy53aW4uaW5uZXJXaWR0aCwgYm90dG9tID0gdGhpcy52aWV3Lndpbi5pbm5lckhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50cy54KVxuICAgICAgICAgICAgKHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMuc2Nyb2xsUGFyZW50cy54LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50cy55KVxuICAgICAgICAgICAgKHsgdG9wLCBib3R0b20gfSA9IHRoaXMuc2Nyb2xsUGFyZW50cy55LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYIC0gbWFyZ2lucy5sZWZ0IDw9IGxlZnQgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3ggPSAtZHJhZ1Njcm9sbFNwZWVkKGxlZnQgLSBldmVudC5jbGllbnRYKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCArIG1hcmdpbnMucmlnaHQgPj0gcmlnaHQgLSBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3ggPSBkcmFnU2Nyb2xsU3BlZWQoZXZlbnQuY2xpZW50WCAtIHJpZ2h0KTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFkgLSBtYXJnaW5zLnRvcCA8PSB0b3AgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSAtZHJhZ1Njcm9sbFNwZWVkKHRvcCAtIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRZICsgbWFyZ2lucy5ib3R0b20gPj0gYm90dG9tIC0gZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN5ID0gZHJhZ1Njcm9sbFNwZWVkKGV2ZW50LmNsaWVudFkgLSBib3R0b20pO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKHN4LCBzeSk7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKDAsIDApO1xuICAgICAgICBsZXQgZG9jID0gdGhpcy52aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IHRoaXMudmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsU3BlZWQoc3gsIHN5KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IHN4LCB5OiBzeSB9O1xuICAgICAgICBpZiAoc3ggfHwgc3kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbGluZyA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNjcm9sbCgpLCA1MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxpbmcgPiAtMSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbGluZyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjcm9sbCgpIHtcbiAgICAgICAgbGV0IHsgeCwgeSB9ID0gdGhpcy5zY3JvbGxTcGVlZDtcbiAgICAgICAgaWYgKHggJiYgdGhpcy5zY3JvbGxQYXJlbnRzLngpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cy54LnNjcm9sbExlZnQgKz0geDtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ICYmIHRoaXMuc2Nyb2xsUGFyZW50cy55KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMueS5zY3JvbGxUb3AgKz0geTtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IHx8IHkpXG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLnNjcm9sbEJ5KHgsIHkpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgfVxuICAgIHNlbGVjdChldmVudCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWxlY3Rpb24gPSBza2lwQXRvbXNGb3JTZWxlY3Rpb24odGhpcy5hdG9tcywgdGhpcy5zdHlsZS5nZXQoZXZlbnQsIHRoaXMuZXh0ZW5kLCB0aGlzLm11bHRpcGxlKSk7XG4gICAgICAgIGlmICh0aGlzLm11c3RTZWxlY3QgfHwgIXNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgdGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5wb2ludGVyXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSkpXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdHlsZS51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpLCAyMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChjbGlja0FkZHNTZWxlY3Rpb25SYW5nZSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGRyYWdNb3Zlc1NlbGVjdGlvbiQxKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyAhZXZlbnQuYWx0S2V5IDogIWV2ZW50LmN0cmxLZXk7XG59XG5mdW5jdGlvbiBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCB7IG1haW4gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChtYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gT24gYm91bmRhcnkgY2xpY2tzLCBjaGVjayB3aGV0aGVyIHRoZSBjb29yZGluYXRlcyBhcmUgaW5zaWRlIHRoZVxuICAgIC8vIHNlbGVjdGlvbidzIGNsaWVudCByZWN0YW5nbGVzXG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgIGlmICghc2VsIHx8IHNlbC5yYW5nZUNvdW50ID09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCByZWN0cyA9IHNlbC5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICByZWN0LnRvcCA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tID49IGV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldCwgY1ZpZXc7IG5vZGUgIT0gdmlldy5jb250ZW50RE9NOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fCAoKGNWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpKSAmJiBjVmlldy5pZ25vcmVFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgaGFuZGxlcnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG9ic2VydmVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gVGhpcyBpcyB2ZXJ5IGNydWRlLCBidXQgdW5mb3J0dW5hdGVseSBib3RoIHRoZXNlIGJyb3dzZXJzIF9wcmV0ZW5kX1xuLy8gdGhhdCB0aGV5IGhhdmUgYSBjbGlwYm9hcmQgQVBJ4oCUYWxsIHRoZSBvYmplY3RzIGFuZCBtZXRob2RzIGFyZVxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxuY29uc3QgYnJva2VuQ2xpcGJvYXJkQVBJID0gKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGJyb3dzZXIuaW9zICYmIGJyb3dzZXIud2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcpIHtcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gdGV4dEZpbHRlcihzdGF0ZSwgZmFjZXQsIHRleHQpIHtcbiAgICBmb3IgKGxldCBmaWx0ZXIgb2Ygc3RhdGUuZmFjZXQoZmFjZXQpKVxuICAgICAgICB0ZXh0ID0gZmlsdGVyKHRleHQsIHN0YXRlKTtcbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgaW5wdXQpIHtcbiAgICBpbnB1dCA9IHRleHRGaWx0ZXIodmlldy5zdGF0ZSwgY2xpcGJvYXJkSW5wdXRGaWx0ZXIsIGlucHV0KTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcywgaSA9IDEsIHRleHQgPSBzdGF0ZS50b1RleHQoaW5wdXQpO1xuICAgIGxldCBieUxpbmUgPSB0ZXh0LmxpbmVzID09IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoO1xuICAgIGxldCBsaW5ld2lzZSA9IGxhc3RMaW5ld2lzZUNvcHkgIT0gbnVsbCAmJiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmV2ZXJ5KHIgPT4gci5lbXB0eSkgJiYgbGFzdExpbmV3aXNlQ29weSA9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IC0xO1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3RMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsYXN0TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBzdGF0ZS50b1RleHQoKGJ5TGluZSA/IHRleHQubGluZShpKyspLnRleHQgOiBpbnB1dCkgKyBzdGF0ZS5saW5lQnJlYWspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGV4dC5saW5lKGkrKyk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBsaW5lLnRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgbGluZS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywge1xuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucGFzdGVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICB9KTtcbn1cbm9ic2VydmVycy5zY3JvbGwgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcDtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0O1xufTtcbmhhbmRsZXJzLmtleWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0XCIpO1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3ICYmIHZpZXcuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgIT0gMClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA9IERhdGUubm93KCkgKyAyMDAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5vYnNlcnZlcnMudG91Y2hzdGFydCA9ICh2aWV3LCBlKSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5vYnNlcnZlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPiBEYXRlLm5vdygpIC0gMjAwMClcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJZ25vcmUgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICBsZXQgc3R5bGUgPSBudWxsO1xuICAgIGZvciAobGV0IG1ha2VTdHlsZSBvZiB2aWV3LnN0YXRlLmZhY2V0KG1vdXNlU2VsZWN0aW9uU3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gbWFrZVN0eWxlKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghc3R5bGUgJiYgZXZlbnQuYnV0dG9uID09IDApXG4gICAgICAgIHN0eWxlID0gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGxldCBtdXN0Rm9jdXMgPSAhdmlldy5oYXNGb2N1cztcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnN0YXJ0TW91c2VTZWxlY3Rpb24obmV3IE1vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50LCBzdHlsZSwgbXVzdEZvY3VzKSk7XG4gICAgICAgIGlmIChtdXN0Rm9jdXMpXG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUgJiYgIWFjdGl2ZS5jb250YWlucyh2aWV3LmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUuYmx1cigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGxldCBtb3VzZVNlbCA9IHZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG1vdXNlU2VsKSB7XG4gICAgICAgICAgICBtb3VzZVNlbC5zdGFydChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gbW91c2VTZWwuZHJhZ2dpbmcgPT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiByYW5nZUZvckNsaWNrKHZpZXcsIHBvcywgYmlhcywgdHlwZSkge1xuICAgIGlmICh0eXBlID09IDEpIHsgLy8gU2luZ2xlIGNsaWNrXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT0gMikgeyAvLyBEb3VibGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIGdyb3VwQXQodmlldy5zdGF0ZSwgcG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIFRyaXBsZSBjbGlja1xuICAgICAgICBsZXQgdmlzdWFsID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyksIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogcG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRTdGFydCA6IGxpbmUuZnJvbSwgdG8gPSB2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBsaW5lLnRvO1xuICAgICAgICBpZiAodG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGggJiYgdG8gPT0gbGluZS50bylcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbmxldCBpbnNpZGUgPSAoeCwgeSwgcmVjdCkgPT4geSA+PSByZWN0LnRvcCAmJiB5IDw9IHJlY3QuYm90dG9tICYmIHggPj0gcmVjdC5sZWZ0ICYmIHggPD0gcmVjdC5yaWdodDtcbi8vIFRyeSB0byBkZXRlcm1pbmUsIGZvciB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbi8vIGdpdmVuIHBvc2l0aW9uLCB3aGV0aGVyIHRoZXkgYXJlIHJlbGF0ZWQgdG8gdGhlIGVsZW1lbnQgYmVmb3JlIG9yXG4vLyB0aGUgZWxlbWVudCBhZnRlciB0aGUgcG9zaXRpb24uXG5mdW5jdGlvbiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgeCwgeSkge1xuICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyk7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgb2ZmID0gcG9zIC0gbGluZS5wb3NBdFN0YXJ0O1xuICAgIC8vIExpbmUgYm91bmRhcmllcyBwb2ludCBpbnRvIHRoZSBsaW5lXG4gICAgaWYgKG9mZiA9PSAwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAob2ZmID09IGxpbmUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgLy8gUG9zaXRpb25zIG9uIHRvcCBvZiBhbiBlbGVtZW50IHBvaW50IGF0IHRoYXQgZWxlbWVudFxuICAgIGxldCBiZWZvcmUgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgLTEpO1xuICAgIGlmIChiZWZvcmUgJiYgaW5zaWRlKHgsIHksIGJlZm9yZSkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgYWZ0ZXIgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgMSk7XG4gICAgaWYgKGFmdGVyICYmIGluc2lkZSh4LCB5LCBhZnRlcikpXG4gICAgICAgIHJldHVybiAxO1xuICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBsaW5lIHdyYXAgcG9pbnQuIFBpY2sgYmVmb3JlIGlmIHRoZSBwb2ludCBpc1xuICAgIC8vIGFib3ZlIGl0cyBib3R0b20uXG4gICAgcmV0dXJuIGJlZm9yZSAmJiBiZWZvcmUuYm90dG9tID49IHkgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBxdWVyeVBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBiaWFzOiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkgfTtcbn1cbmNvbnN0IEJhZE1vdXNlRGV0YWlsID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5sZXQgbGFzdE1vdXNlRG93biA9IG51bGwsIGxhc3RNb3VzZURvd25Db3VudCA9IDAsIGxhc3RNb3VzZURvd25UaW1lID0gMDtcbmZ1bmN0aW9uIGdldENsaWNrVHlwZShldmVudCkge1xuICAgIGlmICghQmFkTW91c2VEZXRhaWwpXG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWw7XG4gICAgbGV0IGxhc3QgPSBsYXN0TW91c2VEb3duLCBsYXN0VGltZSA9IGxhc3RNb3VzZURvd25UaW1lO1xuICAgIGxhc3RNb3VzZURvd24gPSBldmVudDtcbiAgICBsYXN0TW91c2VEb3duVGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGxhc3RNb3VzZURvd25Db3VudCA9ICFsYXN0IHx8IChsYXN0VGltZSA+IERhdGUubm93KCkgLSA0MDAgJiYgTWF0aC5hYnMobGFzdC5jbGllbnRYIC0gZXZlbnQuY2xpZW50WCkgPCAyICYmXG4gICAgICAgIE1hdGguYWJzKGxhc3QuY2xpZW50WSAtIGV2ZW50LmNsaWVudFkpIDwgMikgPyAobGFzdE1vdXNlRG93bkNvdW50ICsgMSkgJSAzIDogMTtcbn1cbmZ1bmN0aW9uIGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHR5cGUgPSBnZXRDbGlja1R5cGUoZXZlbnQpO1xuICAgIGxldCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnBvcyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhzdGFydC5wb3MpO1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBleHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcXVlcnlQb3ModmlldywgZXZlbnQpLCByZW1vdmVkO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBjdXIucG9zLCBjdXIuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQucG9zICE9IGN1ci5wb3MgJiYgIWV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBzdGFydC5wb3MsIHN0YXJ0LmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oc3RhcnRSYW5nZS5mcm9tLCByYW5nZS5mcm9tKSwgdG8gPSBNYXRoLm1heChzdGFydFJhbmdlLnRvLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBmcm9tIDwgcmFuZ2UuZnJvbSA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwucmVwbGFjZVJhbmdlKHN0YXJ0U2VsLm1haW4uZXh0ZW5kKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSAmJiB0eXBlID09IDEgJiYgc3RhcnRTZWwucmFuZ2VzLmxlbmd0aCA+IDEgJiYgKHJlbW92ZWQgPSByZW1vdmVSYW5nZUFyb3VuZChzdGFydFNlbCwgY3VyLnBvcykpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiByZW1vdmVSYW5nZUFyb3VuZChzZWwsIHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsLnJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGZyb20gPD0gcG9zICYmIHRvID49IHBvcylcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMuc2xpY2UoMCwgaSkuY29uY2F0KHNlbC5yYW5nZXMuc2xpY2UoaSArIDEpKSwgc2VsLm1haW5JbmRleCA9PSBpID8gMCA6IHNlbC5tYWluSW5kZXggLSAoc2VsLm1haW5JbmRleCA+IGkgPyAxIDogMCkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbjogeyBtYWluOiByYW5nZSB9IH0gPSB2aWV3LnN0YXRlO1xuICAgIGlmIChldmVudC50YXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGxldCBjVmlldyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmIChjVmlldyAmJiBjVmlldy5pc1dpZGdldCkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjVmlldy5wb3NBdFN0YXJ0LCB0byA9IGZyb20gKyBjVmlldy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA+PSByYW5nZS50byB8fCB0byA8PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgeyBpbnB1dFN0YXRlIH0gPSB2aWV3O1xuICAgIGlmIChpbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICBpbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICBpbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gcmFuZ2U7XG4gICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIiwgdGV4dEZpbHRlcih2aWV3LnN0YXRlLCBjbGlwYm9hcmRPdXRwdXRGaWx0ZXIsIHZpZXcuc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKSk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuaGFuZGxlcnMuZHJhZ2VuZCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCBkaXJlY3QpIHtcbiAgICB0ZXh0ID0gdGV4dEZpbHRlcih2aWV3LnN0YXRlLCBjbGlwYm9hcmRJbnB1dEZpbHRlciwgdGV4dCk7XG4gICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRyb3BQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgbGV0IHsgZHJhZ2dlZENvbnRlbnQgfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBsZXQgZGVsID0gZGlyZWN0ICYmIGRyYWdnZWRDb250ZW50ICYmIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudClcbiAgICAgICAgPyB7IGZyb206IGRyYWdnZWRDb250ZW50LmZyb20sIHRvOiBkcmFnZ2VkQ29udGVudC50byB9IDogbnVsbDtcbiAgICBsZXQgaW5zID0geyBmcm9tOiBkcm9wUG9zLCBpbnNlcnQ6IHRleHQgfTtcbiAgICBsZXQgY2hhbmdlcyA9IHZpZXcuc3RhdGUuY2hhbmdlcyhkZWwgPyBbZGVsLCBpbnNdIDogaW5zKTtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIC0xKSwgaGVhZDogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgMSkgfSxcbiAgICAgICAgdXNlckV2ZW50OiBkZWwgPyBcIm1vdmUuZHJvcFwiIDogXCJpbnB1dC5kcm9wXCJcbiAgICB9KTtcbiAgICB2aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xufVxuaGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBmaWxlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoKSB7IC8vIEZvciBhIGZpbGUgZHJvcCwgcmVhZCB0aGUgZmlsZSdzIHRleHQuXG4gICAgICAgIGxldCB0ZXh0ID0gQXJyYXkoZmlsZXMubGVuZ3RoKSwgcmVhZCA9IDA7XG4gICAgICAgIGxldCBmaW5pc2hGaWxlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCsrcmVhZCA9PSBmaWxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQuZmlsdGVyKHMgPT4gcyAhPSBudWxsKS5qb2luKHZpZXcuc3RhdGUubGluZUJyZWFrKSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZpbmlzaEZpbGU7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghL1tcXHgwMC1cXHgwOFxceDBlLVxceDFmXXsyfS8udGVzdChyZWFkZXIucmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGV4dFtpXSA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgZmluaXNoRmlsZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRvUGFzdGUodmlldywgZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSB8fCBkYXRhLmdldERhdGEoXCJ0ZXh0L3VyaS1saXN0XCIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlUGFzdGUodmlldyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgdGV4dCkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LnZhbHVlID0gdGV4dDtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICB0YXJnZXQuc2VsZWN0aW9uRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgdGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gY29waWVkUmFuZ2Uoc3RhdGUpIHtcbiAgICBsZXQgY29udGVudCA9IFtdLCByYW5nZXMgPSBbXSwgbGluZXdpc2UgPSBmYWxzZTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZG8gYSBsaW5lLXdpc2UgY29weVxuICAgICAgICBsZXQgdXB0byA9IC0xO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20gfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPiB1cHRvKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGxpbmUudGV4dCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cHRvID0gbGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXdpc2UgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geyB0ZXh0OiB0ZXh0RmlsdGVyKHN0YXRlLCBjbGlwYm9hcmRPdXRwdXRGaWx0ZXIsIGNvbnRlbnQuam9pbihzdGF0ZS5saW5lQnJlYWspKSwgcmFuZ2VzLCBsaW5ld2lzZSB9O1xufVxubGV0IGxhc3RMaW5ld2lzZUNvcHkgPSBudWxsO1xuaGFuZGxlcnMuY29weSA9IGhhbmRsZXJzLmN1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHRleHQsIHJhbmdlcywgbGluZXdpc2UgfSA9IGNvcGllZFJhbmdlKHZpZXcuc3RhdGUpO1xuICAgIGlmICghdGV4dCAmJiAhbGluZXdpc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsYXN0TGluZXdpc2VDb3B5ID0gbGluZXdpc2UgPyB0ZXh0IDogbnVsbDtcbiAgICBpZiAoZXZlbnQudHlwZSA9PSBcImN1dFwiICYmICF2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlcyxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgdXNlckV2ZW50OiBcImRlbGV0ZS5jdXRcIlxuICAgICAgICB9KTtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgdGV4dCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuY29uc3QgaXNGb2N1c0NoYW5nZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbihzdGF0ZSwgZm9jdXMpIHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGdldEVmZmVjdCBvZiBzdGF0ZS5mYWNldChmb2N1c0NoYW5nZUVmZmVjdCkpIHtcbiAgICAgICAgbGV0IGVmZmVjdCA9IGdldEVmZmVjdChzdGF0ZSwgZm9jdXMpO1xuICAgICAgICBpZiAoZWZmZWN0KVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuICAgIHJldHVybiBlZmZlY3RzLmxlbmd0aCA/IHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHMsIGFubm90YXRpb25zOiBpc0ZvY3VzQ2hhbmdlLm9mKHRydWUpIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IGZvY3VzID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgaWYgKGZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24odmlldy5zdGF0ZSwgZm9jdXMpO1xuICAgICAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfVxuICAgIH0sIDEwKTtcbn1cbm9ic2VydmVycy5mb2N1cyA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBXaGVuIGZvY3VzaW5nIHJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24sIG1vdmUgaXQgYmFjayB0byB3aGVyZSBpdCB3YXNcbiAgICBpZiAoIXZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAmJiAodmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3AgfHwgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0KSkge1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xub2JzZXJ2ZXJzLmJsdXIgPSB2aWV3ID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmNsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5vYnNlcnZlcnMuY29tcG9zaXRpb25zdGFydCA9IG9ic2VydmVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3Lm9ic2VydmVyLmVkaXRDb250ZXh0KVxuICAgICAgICByZXR1cm47IC8vIENvbXBvc2l0aW9uIGhhbmRsZWQgYnkgZWRpdCBjb250ZXh0XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID09IG51bGwpXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gdHJ1ZTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgLy8gRklYTUUgcG9zc2libHkgc2V0IGEgdGltZW91dCB0byBjbGVhciBpdCBhZ2FpbiBvbiBBbmRyb2lkXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAwO1xuICAgIH1cbn07XG5vYnNlcnZlcnMuY29tcG9zaXRpb25lbmQgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5vYnNlcnZlci5lZGl0Q29udGV4dClcbiAgICAgICAgcmV0dXJuOyAvLyBDb21wb3NpdGlvbiBoYW5kbGVkIGJ5IGVkaXQgY29udGV4dFxuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAtMTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25FbmRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gdHJ1ZTtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gdmlldy5vYnNlcnZlci5wZW5kaW5nUmVjb3JkcygpLmxlbmd0aCA+IDA7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQpIHtcbiAgICAgICAgLy8gRGVsYXkgZmx1c2hpbmcgZm9yIGEgYml0IG9uIEFuZHJvaWQgYmVjYXVzZSBpdCdsbCBvZnRlbiBmaXJlIGFcbiAgICAgICAgLy8gYnVuY2ggb2YgY29udHJhZGljdG9yeSBjaGFuZ2VzIGluIGEgcm93IGF0IGVuZCBvZiBjb21wb3NpdG9uXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UpIHtcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgcGVuZGluZyByZWNvcmRzLCBzY2hlZHVsZSBhIGZsdXNoLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZpZXcub2JzZXJ2ZXIuZmx1c2goKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIG1ha2Ugc3VyZSB0aGF0LCBpZiBubyBjaGFuZ2VzIGNvbWUgaW4gc29vbiwgdGhlXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIHZpZXcgaXMgY2xlYXJlZC5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDAgJiYgdmlldy5kb2NWaWV3Lmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH1cbn07XG5vYnNlcnZlcnMuY29udGV4dG1lbnUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdENvbnRleHRNZW51ID0gRGF0ZS5ub3coKTtcbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGV2ZW50LmlucHV0VHlwZSA9PSBcImluc2VydFRleHRcIiB8fCBldmVudC5pbnB1dFR5cGUgPT0gXCJpbnNlcnRDb21wb3NpdGlvblRleHRcIikge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuaW5zZXJ0aW5nVGV4dCA9IGV2ZW50LmRhdGE7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5pbnNlcnRpbmdUZXh0QXQgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICAvLyBJbiBFZGl0Q29udGV4dCBtb2RlLCB3ZSBtdXN0IGhhbmRsZSBpbnNlcnRSZXBsYWNlbWVudFRleHQgZXZlbnRzXG4gICAgLy8gZGlyZWN0bHksIHRvIG1ha2Ugc3BlbGwgY2hlY2tpbmcgY29ycmVjdGlvbnMgd29ya1xuICAgIGlmIChldmVudC5pbnB1dFR5cGUgPT0gXCJpbnNlcnRSZXBsYWNlbWVudFRleHRcIiAmJiB2aWV3Lm9ic2VydmVyLmVkaXRDb250ZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gKF9hID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksIHJhbmdlcyA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuICAgICAgICBpZiAodGV4dCAmJiByYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgciA9IHJhbmdlc1swXTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmlldy5wb3NBdERPTShyLnN0YXJ0Q29udGFpbmVyLCByLnN0YXJ0T2Zmc2V0KSwgdG8gPSB2aWV3LnBvc0F0RE9NKHIuZW5kQ29udGFpbmVyLCByLmVuZE9mZnNldCk7XG4gICAgICAgICAgICBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIHsgZnJvbSwgdG8sIGluc2VydDogdmlldy5zdGF0ZS50b1RleHQodGV4dCkgfSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCZWNhdXNlIENocm9tZSBBbmRyb2lkIGRvZXNuJ3QgZmlyZSB1c2VmdWwga2V5IGV2ZW50cywgdXNlXG4gICAgLy8gYmVmb3JlaW5wdXQgdG8gZGV0ZWN0IGJhY2tzcGFjZSAoYW5kIHBvc3NpYmx5IGVudGVyIGFuZCBkZWxldGUsXG4gICAgLy8gYnV0IHRob3NlIHVzdWFsbHkgZG9uJ3QgZXZlbiBzZWVtIHRvIGZpcmUgYmVmb3JlaW5wdXQgZXZlbnRzIGF0XG4gICAgLy8gdGhlIG1vbWVudCkgYW5kIGZha2UgYSBrZXkgZXZlbnQgZm9yIGl0LlxuICAgIC8vXG4gICAgLy8gKHByZXZlbnREZWZhdWx0IG9uIGJlZm9yZWlucHV0LCB0aG91Z2ggc3VwcG9ydGVkIGluIHRoZSBzcGVjLFxuICAgIC8vIHNlZW1zIHRvIGRvIG5vdGhpbmcgYXQgYWxsIG9uIENocm9tZSkuXG4gICAgbGV0IHBlbmRpbmc7XG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCAmJiAocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5pbnB1dFR5cGUgPT0gZXZlbnQuaW5wdXRUeXBlKSkpIHtcbiAgICAgICAgdmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkocGVuZGluZy5rZXksIHBlbmRpbmcua2V5Q29kZSk7XG4gICAgICAgIGlmIChwZW5kaW5nLmtleSA9PSBcIkJhY2tzcGFjZVwiIHx8IHBlbmRpbmcua2V5ID09IFwiRGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydFZpZXdIZWlnaHQgPSAoKF9iID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSB8fCAwO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIEJhY2tzcGFjaW5nIG5lYXIgdW5lZGl0YWJsZSBub2RlcyBvbiBDaHJvbWUgQW5kcm9pZCBzb21ldGltZXNcbiAgICAgICAgICAgICAgICAvLyBjbG9zZXMgdGhlIHZpcnR1YWwga2V5Ym9hcmQuIFRoaXMgdHJpZXMgdG8gY3J1ZGVseSBkZXRlY3RcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFuZCByZWZvY3VzIHRvIGdldCBpdCBiYWNrLlxuICAgICAgICAgICAgICAgIGlmICgoKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMCkgPiBzdGFydFZpZXdIZWlnaHQgKyAxMCAmJiB2aWV3Lmhhc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChicm93c2VyLmlvcyAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiKSB7XG4gICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgRE9NIGNoYW5nZXMgKGFuZCBiZWZvcmVpbnB1dCkgaGFwcGVuIF9iZWZvcmVfXG4gICAgICAgIC8vIHRoZSBrZXkgZXZlbnQgZm9yIGN0cmwtZCBvbiBpT1Mgd2hlbiB1c2luZyBhbiBleHRlcm5hbFxuICAgICAgICAvLyBrZXlib2FyZC5cbiAgICAgICAgdmlldy5vYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICB9XG4gICAgLy8gU2FmYXJpIHdpbGwgb2NjYXNpb25hbGx5IGZvcmdldCB0byBmaXJlIGNvbXBvc2l0aW9uZW5kIGF0IHRoZSBlbmQgb2YgYSBkZWFkLWtleSBjb21wb3NpdGlvblxuICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJpbnNlcnRUZXh0XCIgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gb2JzZXJ2ZXJzLmNvbXBvc2l0aW9uZW5kKHZpZXcsIGV2ZW50KSwgMjApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgYXBwbGllZEZpcmVmb3hIYWNrID0gLypAX19QVVJFX18qL25ldyBTZXQ7XG4vLyBJbiBGaXJlZm94LCB3aGVuIGN1dC9jb3B5IGhhbmRsZXJzIGFyZSBhZGRlZCB0byB0aGUgZG9jdW1lbnQsIHRoYXRcbi8vIHNvbWVob3cgYXZvaWRzIGEgYnVnIHdoZXJlIHRob3NlIGV2ZW50cyBhcmVuJ3QgZmlyZWQgd2hlbiB0aGVcbi8vIHNlbGVjdGlvbiBpcyBlbXB0eS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvMTA4MlxuLy8gYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTk5NTk2MVxuZnVuY3Rpb24gZmlyZWZveENvcHlDdXRIYWNrKGRvYykge1xuICAgIGlmICghYXBwbGllZEZpcmVmb3hIYWNrLmhhcyhkb2MpKSB7XG4gICAgICAgIGFwcGxpZWRGaXJlZm94SGFjay5hZGQoZG9jKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsICgpID0+IHsgfSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsICgpID0+IHsgfSk7XG4gICAgfVxufVxuXG5jb25zdCB3cmFwcGluZ1doaXRlU3BhY2UgPSBbXCJwcmUtd3JhcFwiLCBcIm5vcm1hbFwiLCBcInByZS1saW5lXCIsIFwiYnJlYWstc3BhY2VzXCJdO1xuLy8gVXNlZCB0byB0cmFjaywgZHVyaW5nIHVwZGF0ZUhlaWdodCwgaWYgYW55IGFjdHVhbCBoZWlnaHRzIGNoYW5nZWRcbmxldCBoZWlnaHRDaGFuZ2VGbGFnID0gZmFsc2U7XG5mdW5jdGlvbiBjbGVhckhlaWdodENoYW5nZUZsYWcoKSB7IGhlaWdodENoYW5nZUZsYWcgPSBmYWxzZTsgfVxuY2xhc3MgSGVpZ2h0T3JhY2xlIHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lV3JhcHBpbmcpIHtcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMuZG9jID0gVGV4dC5lbXB0eTtcbiAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IDE0OyAvLyBUaGUgaGVpZ2h0IG9mIGFuIGVudGlyZSBsaW5lIChsaW5lLWhlaWdodClcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSA3O1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSAxNDsgLy8gVGhlIGhlaWdodCBvZiB0aGUgYWN0dWFsIGZvbnQgKGZvbnQtc2l6ZSlcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gMzA7XG4gICAgfVxuICAgIGhlaWdodEZvckdhcChmcm9tLCB0bykge1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmRvYy5saW5lQXQodG8pLm51bWJlciAtIHRoaXMuZG9jLmxpbmVBdChmcm9tKS5udW1iZXIgKyAxO1xuICAgICAgICBpZiAodGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICBsaW5lcyArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKCh0byAtIGZyb20pIC0gKGxpbmVzICogdGhpcy5saW5lTGVuZ3RoICogMC41KSkgLyB0aGlzLmxpbmVMZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodCAqIGxpbmVzO1xuICAgIH1cbiAgICBoZWlnaHRGb3JMaW5lKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgbGV0IGxpbmVzID0gMSArIE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVuZ3RoIC0gdGhpcy5saW5lTGVuZ3RoKSAvIE1hdGgubWF4KDEsIHRoaXMubGluZUxlbmd0aCAtIDUpKSk7XG4gICAgICAgIHJldHVybiBsaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICB9XG4gICAgc2V0RG9jKGRvYykgeyB0aGlzLmRvYyA9IGRvYzsgcmV0dXJuIHRoaXM7IH1cbiAgICBtdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpIHtcbiAgICAgICAgcmV0dXJuICh3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xKSAhPSB0aGlzLmxpbmVXcmFwcGluZztcbiAgICB9XG4gICAgbXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSB7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBsaW5lSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSkgeyAvLyBSb3VuZCB0byAuMSBwaXhlbHNcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SGVpZ2h0O1xuICAgIH1cbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgbGluZUxlbmd0aCwga25vd25IZWlnaHRzKSB7XG4gICAgICAgIGxldCBsaW5lV3JhcHBpbmcgPSB3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IE1hdGgucm91bmQobGluZUhlaWdodCkgIT0gTWF0aC5yb3VuZCh0aGlzLmxpbmVIZWlnaHQpIHx8IHRoaXMubGluZVdyYXBwaW5nICE9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSB0ZXh0SGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnQpLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBJdHMgaGVpZ2h0LlxuICAgICovXG4gICAgaGVpZ2h0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWwgV2VpcmQgcGFja2VkIGZpZWxkIHRoYXQgaG9sZHMgYW4gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBmb3IgY29tcG9zaXRlIGJsb2NrcywgYSBkZWNvcmF0aW9uIGZvciBibG9jayB3aWRnZXRzLCBhbmQgYVxuICAgIG51bWJlciBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2Ygd2lkZ2V0LWNyZWF0ZSBsaW5lIGJyZWFrcyBmb3JcbiAgICB0ZXh0IGJsb2Nrcy5cbiAgICAqL1xuICAgIF9jb250ZW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBfY29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgZWxlbWVudCB0aGlzIGlzLiBXaGVuIHF1ZXJ5aW5nIGxpbmVzLCB0aGlzIG1heSBiZVxuICAgIGFuIGFycmF5IG9mIGFsbCB0aGUgYmxvY2tzIHRoYXQgbWFrZSB1cCB0aGUgbGluZS5cbiAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IEJsb2NrVHlwZS5UZXh0IDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogdGhpcy5fY29udGVudC50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBlbGVtZW50IGFzIGEgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYm90dG9tKCkgeyByZXR1cm4gdGhpcy50b3AgKyB0aGlzLmhlaWdodDsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB3aWRnZXQgYmxvY2ssIHRoaXMgd2lsbCByZXR1cm4gdGhlIHdpZGdldFxuICAgIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAqL1xuICAgIGdldCB3aWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50IGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uID8gdGhpcy5fY29udGVudC53aWRnZXQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgdGV4dGJsb2NrLCB0aGlzIGhvbGRzIHRoZSBudW1iZXIgb2YgbGluZSBicmVha3NcbiAgICB0aGF0IGFwcGVhciBpbiB3aWRnZXRzIGluc2lkZSB0aGUgYmxvY2suXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0TGluZUJyZWFrcygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9jb250ZW50ID09IFwibnVtYmVyXCIgPyB0aGlzLl9jb250ZW50IDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gKEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogW3RoaXNdKVxuICAgICAgICAgICAgLmNvbmNhdChBcnJheS5pc0FycmF5KG90aGVyLl9jb250ZW50KSA/IG90aGVyLl9jb250ZW50IDogW290aGVyXSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKHRoaXMuZnJvbSwgdGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGgsIHRoaXMudG9wLCB0aGlzLmhlaWdodCArIG90aGVyLmhlaWdodCwgY29udGVudCk7XG4gICAgfVxufVxudmFyIFF1ZXJ5VHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFF1ZXJ5VHlwZSkge1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc1wiXSA9IDBdID0gXCJCeVBvc1wiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeUhlaWdodFwiXSA9IDFdID0gXCJCeUhlaWdodFwiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc05vSGVpZ2h0XCJdID0gMl0gPSBcIkJ5UG9zTm9IZWlnaHRcIjtcbnJldHVybiBRdWVyeVR5cGV9KShRdWVyeVR5cGUgfHwgKFF1ZXJ5VHlwZSA9IHt9KSk7XG5jb25zdCBFcHNpbG9uID0gMWUtMztcbmNsYXNzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCAvLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY292ZXJlZFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHRoaXMgcGFydCBvZiB0aGUgZG9jdW1lbnRcbiAgICBmbGFncyA9IDIgLyogRmxhZy5PdXRkYXRlZCAqLykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgZ2V0IG91dGRhdGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pID4gMDsgfVxuICAgIHNldCBvdXRkYXRlZCh2YWx1ZSkgeyB0aGlzLmZsYWdzID0gKHZhbHVlID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkgfCAodGhpcy5mbGFncyAmIH4yIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pOyB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5oZWlnaHQgLSBoZWlnaHQpID4gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJhc2UgY2FzZSBpcyB0byByZXBsYWNlIGEgbGVhZiBub2RlLCB3aGljaCBzaW1wbHkgYnVpbGRzIGEgdHJlZVxuICAgIC8vIGZyb20gdGhlIG5ldyBub2RlcyBhbmQgcmV0dXJucyB0aGF0IChIZWlnaHRNYXBCcmFuY2ggYW5kXG4gICAgLy8gSGVpZ2h0TWFwR2FwIG92ZXJyaWRlIHRoaXMgdG8gYWN0dWFsbHkgdXNlIGZyb20vdG8pXG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgLy8gQWdhaW4sIHRoZXNlIGFyZSBiYXNlIGNhc2VzLCBhbmQgYXJlIG92ZXJyaWRkZW4gZm9yIGJyYW5jaCBhbmQgZ2FwIG5vZGVzLlxuICAgIGRlY29tcG9zZUxlZnQoX3RvLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBkZWNvbXBvc2VSaWdodChfZnJvbSwgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgYXBwbHlDaGFuZ2VzKGRlY29yYXRpb25zLCBvbGREb2MsIG9yYWNsZSwgY2hhbmdlcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLCBkb2MgPSBvcmFjbGUuZG9jO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZS5zZXREb2Mob2xkRG9jKSwgMCwgMCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQudG8gPj0gdG9BID8gc3RhcnQgOiBtZS5saW5lQXQodG9BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIHRvQiArPSBlbmQudG8gLSB0b0E7XG4gICAgICAgICAgICB0b0EgPSBlbmQudG87XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgc3RhcnQuZnJvbSA8PSBjaGFuZ2VzW2kgLSAxXS50b0EpIHtcbiAgICAgICAgICAgICAgICBmcm9tQSA9IGNoYW5nZXNbaSAtIDFdLmZyb21BO1xuICAgICAgICAgICAgICAgIGZyb21CID0gY2hhbmdlc1tpIC0gMV0uZnJvbUI7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQSA8IHN0YXJ0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21CICs9IHN0YXJ0LmZyb20gLSBmcm9tQTtcbiAgICAgICAgICAgIGZyb21BID0gc3RhcnQuZnJvbTtcbiAgICAgICAgICAgIGxldCBub2RlcyA9IE5vZGVCdWlsZGVyLmJ1aWxkKG9yYWNsZS5zZXREb2MoZG9jKSwgZGVjb3JhdGlvbnMsIGZyb21CLCB0b0IpO1xuICAgICAgICAgICAgbWUgPSByZXBsYWNlKG1lLCBtZS5yZXBsYWNlKGZyb21BLCB0b0EsIG5vZGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLnVwZGF0ZUhlaWdodChvcmFjbGUsIDApO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7IHJldHVybiBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAwKTsgfVxuICAgIC8vIG5vZGVzIHVzZXMgbnVsbCB2YWx1ZXMgdG8gaW5kaWNhdGUgdGhlIHBvc2l0aW9uIG9mIGxpbmUgYnJlYWtzLlxuICAgIC8vIFRoZXJlIGFyZSBuZXZlciBsaW5lIGJyZWFrcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBhcnJheSwgb3JcbiAgICAvLyB0d28gbGluZSBicmVha3MgbmV4dCB0byBlYWNoIG90aGVyLCBhbmQgdGhlIGFycmF5IGlzbid0IGFsbG93ZWRcbiAgICAvLyB0byBiZSBlbXB0eSAoc2FtZSByZXN0cmljdGlvbnMgYXMgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGJ1aWxkZXIpLlxuICAgIHN0YXRpYyBvZihub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCwgYmVmb3JlID0gMCwgYWZ0ZXIgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA+IGFmdGVyICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDEgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyID4gYmVmb3JlICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAyICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUgPCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbLS1qXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBicmsgPSAwO1xuICAgICAgICBpZiAobm9kZXNbaSAtIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhlaWdodE1hcEJyYW5jaChIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoMCwgaSkpLCBicmssIEhlaWdodE1hcC5vZihub2Rlcy5zbGljZShqKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2Uob2xkLCB2YWwpIHtcbiAgICBpZiAob2xkID09IHZhbClcbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICBpZiAob2xkLmNvbnN0cnVjdG9yICE9IHZhbC5jb25zdHJ1Y3RvcilcbiAgICAgICAgaGVpZ2h0Q2hhbmdlRmxhZyA9IHRydWU7XG4gICAgcmV0dXJuIHZhbDtcbn1cbkhlaWdodE1hcC5wcm90b3R5cGUuc2l6ZSA9IDE7XG5jbGFzcyBIZWlnaHRNYXBCbG9jayBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQsIGRlY28pIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmRlY28gPSBkZWNvO1xuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuZGVjbyB8fCAwKTtcbiAgICB9XG4gICAgbGluZUF0KF92YWx1ZSwgX3R5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgaWYgKGZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgdG8gPj0gb2Zmc2V0KVxuICAgICAgICAgICAgZih0aGlzLmJsb2NrQXQoMCwgb3JhY2xlLCB0b3AsIG9mZnNldCkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBfZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgYmxvY2soJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gMDsgLy8gQW1vdW50IG9mIGNvbGxhcHNlZCBjb250ZW50IGluIHRoZSBsaW5lXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxuICAgICAgICB0aGlzLmJyZWFrcyA9IDA7IC8vIE51bWJlciBvZiB3aWRnZXQtaW50cm9kdWNlZCBsaW5lIGJyZWFrcyBvbiB0aGUgbGluZVxuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuYnJlYWtzKTtcbiAgICB9XG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEgJiYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0IHx8IG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiYgKG5vZGUuZmxhZ3MgJiA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IEhlaWdodE1hcFRleHQobm9kZS5sZW5ndGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KE1hdGgubWF4KHRoaXMud2lkZ2V0SGVpZ2h0LCBvcmFjbGUuaGVpZ2h0Rm9yTGluZSh0aGlzLmxlbmd0aCAtIHRoaXMuY29sbGFwc2VkKSkgK1xuICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtzICogb3JhY2xlLmxpbmVIZWlnaHQpO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBsaW5lKCR7dGhpcy5sZW5ndGh9JHt0aGlzLmNvbGxhcHNlZCA/IC10aGlzLmNvbGxhcHNlZCA6IFwiXCJ9JHt0aGlzLndpZGdldEhlaWdodCA/IFwiOlwiICsgdGhpcy53aWRnZXRIZWlnaHQgOiBcIlwifSlgO1xuICAgIH1cbn1cbmNsYXNzIEhlaWdodE1hcEdhcCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7IHN1cGVyKGxlbmd0aCwgMCk7IH1cbiAgICBoZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQpLm51bWJlciwgbGFzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICBsZXQgbGluZXMgPSBsYXN0TGluZSAtIGZpcnN0TGluZSArIDE7XG4gICAgICAgIGxldCBwZXJMaW5lLCBwZXJDaGFyID0gMDtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbFBlckxpbmUgPSBNYXRoLm1pbih0aGlzLmhlaWdodCwgb3JhY2xlLmxpbmVIZWlnaHQgKiBsaW5lcyk7XG4gICAgICAgICAgICBwZXJMaW5lID0gdG90YWxQZXJMaW5lIC8gbGluZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBsaW5lcyArIDEpXG4gICAgICAgICAgICAgICAgcGVyQ2hhciA9ICh0aGlzLmhlaWdodCAtIHRvdGFsUGVyTGluZSkgLyAodGhpcy5sZW5ndGggLSBsaW5lcyAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyTGluZSA9IHRoaXMuaGVpZ2h0IC8gbGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9O1xuICAgIH1cbiAgICBibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IGd1ZXNzID0gb2Zmc2V0ICsgKGhlaWdodCA8IG9yYWNsZS5saW5lSGVpZ2h0ID8gMFxuICAgICAgICAgICAgICAgIDogTWF0aC5yb3VuZChNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoaGVpZ2h0IC0gdG9wKSAvIHRoaXMuaGVpZ2h0KSkgKiB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChndWVzcyksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICAgICAgbGV0IGxpbmVUb3AgPSBNYXRoLm1heCh0b3AsIGhlaWdodCAtIGxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsYXN0TGluZSAtIGZpcnN0TGluZSwgTWF0aC5mbG9vcigoaGVpZ2h0IC0gdG9wKSAvIHBlckxpbmUpKSk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGggfSA9IG9yYWNsZS5kb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgcGVyTGluZSAqIGxpbmUsIHBlckxpbmUsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KHZhbHVlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICBsZXQgbGluZVRvcCA9IHRvcCArIHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChsaW5lLmZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgTWF0aC5tYXgodG9wLCBNYXRoLm1pbihsaW5lVG9wLCB0b3AgKyB0aGlzLmhlaWdodCAtIGxpbmVIZWlnaHQpKSwgbGluZUhlaWdodCwgMCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpO1xuICAgICAgICB0byA9IE1hdGgubWluKHRvLCBvZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbSwgbGluZVRvcCA9IHRvcDsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgICAgICAgICBsaW5lVG9wICs9IHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChmcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBlckxpbmUgKyBwZXJDaGFyICogbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgbGluZVRvcCwgbGluZUhlaWdodCwgMCkpO1xuICAgICAgICAgICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzaW5nbGVIZWlnaHQpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkucGVyTGluZSkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLmhlaWdodEZvckdhcChvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGdhcCgke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBCcmFuY2ggZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJyaywgcmlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVmdC5sZW5ndGggKyBicmsgKyByaWdodC5sZW5ndGgsIGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0LCBicmsgfCAobGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZCA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgIH1cbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBGbGFnLkJyZWFrICovOyB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1pZCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCA6IHZhbHVlIDwgcmlnaHRPZmZzZXQ7XG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrIHx8IChsZWZ0ID8gYmFzZS50byA8IHJpZ2h0T2Zmc2V0IDogYmFzZS5mcm9tID4gcmlnaHRPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBzdWJRdWVyeSA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgPyBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA6IFF1ZXJ5VHlwZS5CeVBvcztcbiAgICAgICAgaWYgKGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KS5qb2luKGJhc2UpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSB0aGlzLmxpbmVBdChyaWdodE9mZnNldCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgbWlkLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAobWlkLnRvID49IGZyb20gJiYgbWlkLmZyb20gPD0gdG8pXG4gICAgICAgICAgICAgICAgZihtaWQpO1xuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUobWlkLnRvICsgMSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LnJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSwgdGhpcy5yaWdodCk7XG4gICAgICAgIGlmIChmcm9tID4gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCBsZWZ0IC0gMSk7XG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodCh0bywgcmVzdWx0KTtcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxlZnQpO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgaWYgKHRvID49IGxlZnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gbGVmdClcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmIChmcm9tID49IHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZGVjb21wb3NlUmlnaHQoZnJvbSAtIHJpZ2h0LCByZXN1bHQpO1xuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgJiYgZnJvbSA8IHJpZ2h0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5zaXplID4gMiAqIHJpZ2h0LnNpemUgfHwgcmlnaHQuc2l6ZSA+IDIgKiBsZWZ0LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHRoaXMuYnJlYWsgPyBbbGVmdCwgbnVsbCwgcmlnaHRdIDogW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgIHRoaXMubGVmdCA9IHJlcGxhY2UodGhpcy5sZWZ0LCBsZWZ0KTtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJlcGxhY2UodGhpcy5yaWdodCwgcmlnaHQpO1xuICAgICAgICB0aGlzLnNldEhlaWdodChsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodCk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkO1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgdGhpcy5icmVhayArIHJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLCByaWdodFN0YXJ0ID0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrLCByZWJhbGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gbGVmdCA9IGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UpO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSByaWdodFN0YXJ0ICsgcmlnaHQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSByaWdodCA9IHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlKTtcbiAgICAgICAgaWYgKHJlYmFsYW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5sZWZ0ICsgKHRoaXMuYnJlYWsgPyBcIiBcIiA6IFwiLVwiKSArIHRoaXMucmlnaHQ7IH1cbn1cbmZ1bmN0aW9uIG1lcmdlR2Fwcyhub2RlcywgYXJvdW5kKSB7XG4gICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgaWYgKG5vZGVzW2Fyb3VuZF0gPT0gbnVsbCAmJlxuICAgICAgICAoYmVmb3JlID0gbm9kZXNbYXJvdW5kIC0gMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmXG4gICAgICAgIChhZnRlciA9IG5vZGVzW2Fyb3VuZCArIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgbm9kZXMuc3BsaWNlKGFyb3VuZCAtIDEsIDMsIG5ldyBIZWlnaHRNYXBHYXAoYmVmb3JlLmxlbmd0aCArIDEgKyBhZnRlci5sZW5ndGgpKTtcbn1cbmNvbnN0IHJlbGV2YW50V2lkZ2V0SGVpZ2h0ID0gNTtcbmNsYXNzIE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG9yYWNsZSkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5vcmFjbGUgPSBvcmFjbGU7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gLTE7XG4gICAgICAgIHRoaXMuY292ZXJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHBvcztcbiAgICB9XG4gICAgZ2V0IGlzQ292ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJpbmcgJiYgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IHRoaXMuY292ZXJpbmc7XG4gICAgfVxuICAgIHNwYW4oX2Zyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4odG8sIHRoaXMubGluZUVuZCksIGxhc3QgPSB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbGFzdC5sZW5ndGggKz0gZW5kIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPiB0aGlzLnBvcyB8fCAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KGVuZCAtIHRoaXMucG9zLCAtMSkpO1xuICAgICAgICAgICAgdGhpcy53cml0dGVuVG8gPSBlbmQ7XG4gICAgICAgICAgICBpZiAodG8gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0dGVuVG8rKztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgZGVjby5oZWlnaHRSZWxldmFudCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0IDogMDtcbiAgICAgICAgICAgIGxldCBicmVha3MgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmxpbmVCcmVha3MgOiAwO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2sobmV3IEhlaWdodE1hcEJsb2NrKGxlbiwgaGVpZ2h0LCBkZWNvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gfHwgYnJlYWtzIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBicmVha3MsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnNwYW4oZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVFbmQgPiAtMSAmJiB0aGlzLmxpbmVFbmQgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHRoaXMubGluZUVuZCA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xuICAgIH1cbiAgICBlbnRlckxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gdG87XG4gICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20gLSAxIHx8IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KHRoaXMucG9zIC0gZnJvbSwgLTEpKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcztcbiAgICB9XG4gICAgYmxhbmtDb250ZW50KGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBnYXAgPSBuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLm9yYWNsZS5kb2MubGluZUF0KGZyb20pLnRvID09IHRvKVxuICAgICAgICAgICAgZ2FwLmZsYWdzIHw9IDQgLyogRmxhZy5TaW5nbGVMaW5lICovO1xuICAgICAgICByZXR1cm4gZ2FwO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKCkge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID8gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQoMCwgLTEpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBhZGRCbG9jayhibG9jaykge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgZGVjbyA9IGJsb2NrLmRlY287XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgYmxvY2subGVuZ3RoO1xuICAgICAgICBpZiAoZGVjbyAmJiBkZWNvLmVuZFNpZGUgPiAwKVxuICAgICAgICAgICAgdGhpcy5jb3ZlcmluZyA9IGJsb2NrO1xuICAgIH1cbiAgICBhZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIGxpbmUubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLndpZGdldEhlaWdodCA9IE1hdGgubWF4KGxpbmUud2lkZ2V0SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICBsaW5lLmJyZWFrcyArPSBicmVha3M7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGxldCBsZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0KSwgcmlnaHQgPSBNYXRoLm1pbih3aW4uaW5uZXJXaWR0aCwgcmVjdC5yaWdodCk7XG4gICAgbGV0IHRvcCA9IE1hdGgubWF4KDAsIHJlY3QudG9wKSwgYm90dG9tID0gTWF0aC5taW4od2luLmlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT0gZG9jLmJvZHk7KSB7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCk7XG4gICAgICAgICAgICBpZiAoKGVsdC5zY3JvbGxIZWlnaHQgPiBlbHQuY2xpZW50SGVpZ2h0IHx8IGVsdC5zY3JvbGxXaWR0aCA+IGVsdC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBwYXJlbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgcGFyZW50UmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKHBhcmVudCA9PSBkb20ucGFyZW50Tm9kZSA/IHdpbi5pbm5lckhlaWdodCA6IGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc3R5bGUucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiIHx8IHN0eWxlLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IGVsdC5vZmZzZXRQYXJlbnQgOiBlbHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IE1hdGgubWF4KGxlZnQsIHJpZ2h0KSAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuZnVuY3Rpb24gaW5XaW5kb3coZWx0KSB7XG4gICAgbGV0IHJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpbiA9IGVsdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICByZXR1cm4gcmVjdC5sZWZ0IDwgd2luLmlubmVyV2lkdGggJiYgcmVjdC5yaWdodCA+IDAgJiZcbiAgICAgICAgcmVjdC50b3AgPCB3aW4uaW5uZXJIZWlnaHQgJiYgcmVjdC5ib3R0b20gPiAwO1xufVxuZnVuY3Rpb24gZnVsbFBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogcGFkZGluZ1RvcCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG4vLyBMaW5lIGdhcHMgYXJlIHBsYWNlaG9sZGVyIHdpZGdldHMgdXNlZCB0byBoaWRlIHBpZWNlcyBvZiBvdmVybG9uZ1xuLy8gbGluZXMgd2l0aGluIHRoZSB2aWV3cG9ydCwgYXMgYSBrbHVkZ2UgdG8ga2VlcCB0aGUgZWRpdG9yXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxuY2xhc3MgTGluZUdhcCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHNpemUsIGRpc3BsYXlTaXplKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5kaXNwbGF5U2l6ZSA9IGRpc3BsYXlTaXplO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ0EgPSBhW2ldLCBnQiA9IGJbaV07XG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyYXcodmlld1N0YXRlLCB3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgIHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5kaXNwbGF5U2l6ZSAqICh3cmFwcGluZyA/IHZpZXdTdGF0ZS5zY2FsZVkgOiB2aWV3U3RhdGUuc2NhbGVYKSwgd3JhcHBpbmcpXG4gICAgICAgIH0pLnJhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgTGluZUdhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHZlcnRpY2FsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNpemUgPT0gdGhpcy5zaXplICYmIG90aGVyLnZlcnRpY2FsID09IHRoaXMudmVydGljYWw7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmVydGljYWwgPyB0aGlzLnNpemUgOiAtMTsgfVxufVxuY2xhc3MgVmlld1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBjb250ZW50RE9NLWxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHsgbGVmdDogMCwgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7IC8vIFBhZGRpbmcgYWJvdmUgdGhlIGRvY3VtZW50LCBzY2FsZWRcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDsgLy8gUGFkZGluZyBiZWxvdyB0aGUgZG9jdW1lbnQsIHNjYWxlZFxuICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IDA7IC8vIGNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gMDsgLy8gY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSAwOyAvLyBzY3JvbGxET00uY2xpZW50SGVpZ2h0LCB1bnNjYWxlZFxuICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gMDsgLy8gc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB1bnNjYWxlZFxuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7IC8vIExhc3Qgc2VlbiBzY3JvbGxET00uc2Nyb2xsVG9wLCBzY2FsZWRcbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBDU1MtdHJhbnNmb3JtYXRpb24gc2NhbGUgb2YgdGhlIGVkaXRvciAodHJhbnNmb3JtZWQgc2l6ZSAvXG4gICAgICAgIC8vIGNvbmNyZXRlIHNpemUpXG4gICAgICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xuICAgICAgICAvLyBUaGUgdmVydGljYWwgcG9zaXRpb24gKGRvY3VtZW50LXJlbGF0aXZlKSB0byB3aGljaCB0byBhbmNob3IgdGhlXG4gICAgICAgIC8vIHNjcm9sbCBwb3NpdGlvbi4gLTEgbWVhbnMgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IDA7XG4gICAgICAgIC8vIFRoZSBoZWlnaHQgYXQgdGhlIGFuY2hvciBwb3NpdGlvbi4gU2V0IGJ5IHRoZSBET00gdXBkYXRlIHBoYXNlLlxuICAgICAgICAvLyAtMSBtZWFucyBubyBoZWlnaHQgYXZhaWxhYmxlLlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XG4gICAgICAgIHRoaXMuc2NhbGVyID0gSWRTY2FsZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXG4gICAgICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hlbiBlZGl0b3IgY29udGVudCB3YXMgcmVkcmF3biwgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduaWZpY2FudCwgdGhpcyBmbGFnIGlzIHNldC4gVGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcbiAgICAgICAgLy8gYm91bmRhcnkgYW5kLCBpZiBzbywgcmVzZXQgaXQgdG8gbWFrZSBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgaW5cbiAgICAgICAgLy8gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgbGV0IGd1ZXNzV3JhcHBpbmcgPSBzdGF0ZS5mYWNldChjb250ZW50QXR0cmlidXRlcykuc29tZSh2ID0+IHR5cGVvZiB2ICE9IFwiZnVuY3Rpb25cIiAmJiB2LmNsYXNzID09IFwiY20tbGluZVdyYXBwaW5nXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE9yYWNsZSA9IG5ldyBIZWlnaHRPcmFjbGUoZ3Vlc3NXcmFwcGluZyk7XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2Moc3RhdGUuZG9jKSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgc3RhdGUuZG9jLmxlbmd0aCldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIG51bGwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIHRoaXMubGluZUdhcHMgPSB0aGlzLmVuc3VyZUxpbmVHYXBzKFtdKTtcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCBmYWxzZSkpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0cyA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydHMuc29tZSgoeyBmcm9tLCB0byB9KSA9PiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMubGluZUJsb2NrQXQocG9zKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHMucHVzaChuZXcgVmlld3BvcnQoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVTY2FsZXIoKTtcbiAgICB9XG4gICAgdXBkYXRlU2NhbGVyKCkge1xuICAgICAgICBsZXQgc2NhbGVyID0gdGhpcy5zY2FsZXI7XG4gICAgICAgIHRoaXMuc2NhbGVyID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0IDw9IDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovID8gSWRTY2FsZXIgOlxuICAgICAgICAgICAgbmV3IEJpZ1NjYWxlcih0aGlzLmhlaWdodE9yYWNsZSwgdGhpcy5oZWlnaHRNYXAsIHRoaXMudmlld3BvcnRzKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlci5lcSh0aGlzLnNjYWxlcikgPyAwIDogMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICB9XG4gICAgdXBkYXRlVmlld3BvcnRMaW5lcygpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzID0gW107XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwLmZvckVhY2hMaW5lKHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgMCwgMCwgYmxvY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLnB1c2goc2NhbGVCbG9jayhibG9jaywgdGhpcy5zY2FsZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gdGhpcy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbnRlbnRDaGFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMocHJldkRlY28sIHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgICAgIGxldCBwcmV2SGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICBsZXQgc2Nyb2xsQW5jaG9yID0gdGhpcy5zY3JvbGxlZFRvQm90dG9tID8gbnVsbCA6IHRoaXMuc2Nyb2xsQW5jaG9yQXQodGhpcy5zY3JvbGxUb3ApO1xuICAgICAgICBjbGVhckhlaWdodENoYW5nZUZsYWcoKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSB0aGlzLmhlaWdodE1hcC5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIHVwZGF0ZS5zdGFydFN0YXRlLmRvYywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgaGVpZ2h0Q2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE1hcC5oZWlnaHQgIT0gcHJldkhlaWdodCB8fCBoZWlnaHRDaGFuZ2VGbGFnKVxuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIGlmIChzY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHNjcm9sbEFuY2hvci5mcm9tLCAtMSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvci50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSBwcmV2SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IGhlaWdodENoYW5nZXMubGVuZ3RoID8gdGhpcy5tYXBWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB1cGRhdGUuY2hhbmdlcykgOiB0aGlzLnZpZXdwb3J0O1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0ICYmIChzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB2aWV3cG9ydC50bykgfHxcbiAgICAgICAgICAgICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh2aWV3cG9ydCkpXG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gdmlld3BvcnQuZnJvbSAhPSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdmlld3BvcnQudG8gIT0gdGhpcy52aWV3cG9ydC50bztcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UgfHwgIXVwZGF0ZS5jaGFuZ2VzLmVtcHR5IHx8ICh1cGRhdGUuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2Fwcyh0aGlzLm1hcExpbmVHYXBzKHRoaXMubGluZUdhcHMsIHVwZGF0ZS5jaGFuZ2VzKSkpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcyh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldDtcbiAgICAgICAgaWYgKCF0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgJiYgdXBkYXRlLnNlbGVjdGlvblNldCAmJiB1cGRhdGUudmlldy5saW5lV3JhcHBpbmcgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uYXNzb2MgJiZcbiAgICAgICAgICAgICF1cGRhdGUuc3RhdGUuZmFjZXQobmF0aXZlU2VsZWN0aW9uSGlkZGVuKSlcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IHRydWU7XG4gICAgfVxuICAgIG1lYXN1cmUodmlldykge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5jb250ZW50RE9NLCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSk7XG4gICAgICAgIGxldCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gc3R5bGUuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgbGV0IHJlZnJlc2ggPSB0aGlzLmhlaWdodE9yYWNsZS5tdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpO1xuICAgICAgICBsZXQgZG9tUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IG1lYXN1cmVDb250ZW50ID0gcmVmcmVzaCB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLm11c3RNZWFzdXJlQ29udGVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XG4gICAgICAgIGlmIChkb21SZWN0LndpZHRoICYmIGRvbVJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gZ2V0U2NhbGUoZG9tLCBkb21SZWN0KTtcbiAgICAgICAgICAgIGlmIChzY2FsZVggPiAuMDA1ICYmIE1hdGguYWJzKHRoaXMuc2NhbGVYIC0gc2NhbGVYKSA+IC4wMDUgfHxcbiAgICAgICAgICAgICAgICBzY2FsZVkgPiAuMDA1ICYmIE1hdGguYWJzKHRoaXMuc2NhbGVZIC0gc2NhbGVZKSA+IC4wMDUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFZlcnRpY2FsIHBhZGRpbmdcbiAgICAgICAgbGV0IHBhZGRpbmdUb3AgPSAocGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCkgfHwgMCkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSAocGFyc2VJbnQoc3R5bGUucGFkZGluZ0JvdHRvbSkgfHwgMCkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ1RvcCAhPSBwYWRkaW5nVG9wIHx8IHRoaXMucGFkZGluZ0JvdHRvbSAhPSBwYWRkaW5nQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wO1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSAxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JXaWR0aCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDE2IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgIT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gaXNTY3JvbGxlZFRvQm90dG9tKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgLy8gUGl4ZWwgdmlld3BvcnRcbiAgICAgICAgbGV0IHBpeGVsVmlld3BvcnQgPSAodGhpcy5wcmludGluZyA/IGZ1bGxQaXhlbFJhbmdlIDogdmlzaWJsZVBpeGVsUmFuZ2UpKGRvbSwgdGhpcy5wYWRkaW5nVG9wKTtcbiAgICAgICAgbGV0IGRUb3AgPSBwaXhlbFZpZXdwb3J0LnRvcCAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3AsIGRCb3R0b20gPSBwaXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b207XG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHBpeGVsVmlld3BvcnQ7XG4gICAgICAgIGxldCBpblZpZXcgPSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tID4gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCAmJiB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgPiB0aGlzLnBpeGVsVmlld3BvcnQubGVmdDtcbiAgICAgICAgaWYgKGluVmlldyAhPSB0aGlzLmluVmlldykge1xuICAgICAgICAgICAgdGhpcy5pblZpZXcgPSBpblZpZXc7XG4gICAgICAgICAgICBpZiAoaW5WaWV3KVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3ICYmICF0aGlzLnNjcm9sbFRhcmdldCAmJiAhaW5XaW5kb3codmlldy5kb20pKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NV2lkdGggIT0gY29udGVudFdpZHRoIHx8IHRoaXMuZWRpdG9ySGVpZ2h0ICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhc3VyZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0cyA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHRoaXMudmlld3BvcnQpO1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5tdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpKVxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2ggfHwgb3JhY2xlLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhjb250ZW50V2lkdGggLSB0aGlzLmNvbnRlbnRET01XaWR0aCkgPiBvcmFjbGUuY2hhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0IH0gPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IGxpbmVIZWlnaHQgPiAwICYmIG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgTWF0aC5tYXgoNSwgY29udGVudFdpZHRoIC8gY2hhcldpZHRoKSwgbGluZUhlaWdodHMpO1xuICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9jVmlldy5taW5XaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkVG9wID4gMCAmJiBkQm90dG9tID4gMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5tYXgoZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChkVG9wIDwgMCAmJiBkQm90dG9tIDwgMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5taW4oZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBjbGVhckhlaWdodENoYW5nZUZsYWcoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHZwIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodHMgPSB2cC5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IGxpbmVIZWlnaHRzIDogdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModnApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gKHJlZnJlc2ggPyBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSkgOiB0aGlzLmhlaWdodE1hcCkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh2cC5mcm9tLCBoZWlnaHRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0Q2hhbmdlRmxhZylcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnRDaGFuZ2UgPSAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodGhpcy52aWV3cG9ydCwgYmlhcykgfHxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ICYmICh0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHRoaXMudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKVxuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSB0aGlzLnVwZGF0ZVNjYWxlcigpO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoYmlhcywgdGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgcmVzdWx0IHw9IHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHJlc3VsdCAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8IHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHJlZnJlc2ggPyBbXSA6IHRoaXMubGluZUdhcHMsIHZpZXcpKTtcbiAgICAgICAgcmVzdWx0IHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYykge1xuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHRvIGEgbGluZSBlbmQgaXMgZ29pbmcgdG8gdHJpZ2dlciBhIGxheW91dCBhbnl3YXksIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBhIHB1cmUgd3JpdGUuIEl0IHNob3VsZCBiZSByYXJlIHRoYXQgaXQgZG9lcyBhbnlcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcuZW5mb3JjZUN1cnNvckFzc29jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IHZpc2libGVUb3AoKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApOyB9XG4gICAgZ2V0IHZpc2libGVCb3R0b20oKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20pOyB9XG4gICAgZ2V0Vmlld3BvcnQoYmlhcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBkaXZpZGUgVlAuTWFyZ2luIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuIEl0J2xsIGhvbGQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgIGxldCBtYXJnaW5Ub3AgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGJpYXMgLyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIpKTtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBvcmFjbGUgPSB0aGlzLmhlaWdodE9yYWNsZTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodmlzaWJsZVRvcCAtIG1hcmdpblRvcCAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh2aXNpYmxlQm90dG9tICsgKDEgLSBtYXJnaW5Ub3ApICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgb3JhY2xlLCAwLCAwKS50byk7XG4gICAgICAgIC8vIElmIHNjcm9sbFRhcmdldCBpcyBnaXZlbiwgbWFrZSBzdXJlIHRoZSB2aWV3cG9ydCBpbmNsdWRlcyB0aGF0IHBvc2l0aW9uXG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlYWQgfSA9IHNjcm9sbFRhcmdldC5yYW5nZTtcbiAgICAgICAgICAgIGlmIChoZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBoZWFkID4gdmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9IE1hdGgubWluKHRoaXMuZWRpdG9ySGVpZ2h0LCB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gbWFwLmxpbmVBdChoZWFkLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCksIHRvcFBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJjZW50ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gKGJsb2NrLnRvcCArIGJsb2NrLmJvdHRvbSkgLyAyIC0gdmlld0hlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsVGFyZ2V0LnkgPT0gXCJzdGFydFwiIHx8IHNjcm9sbFRhcmdldC55ID09IFwibmVhcmVzdFwiICYmIGhlYWQgPCB2aWV3cG9ydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSBibG9jay5ib3R0b20gLSB2aWV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodG9wUG9zIC0gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh0b3BQb3MgKyB2aWV3SGVpZ2h0ICsgMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gICAgbWFwVmlld3BvcnQodmlld3BvcnQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdwb3J0KHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS5mcm9tLCB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLnRvKTtcbiAgICB9XG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gdmlld3BvcnQgY292ZXJzIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlXG4gICAgLy8gZG9jdW1lbnQgYW5kIG5vdCB0b28gbXVjaCBiZXlvbmQgdGhhdC5cbiAgICB2aWV3cG9ydElzQXBwcm9wcmlhdGUoeyBmcm9tLCB0byB9LCBiaWFzID0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCB7IHRvcCB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyBib3R0b20gfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCk7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IHRvcCA8PSB2aXNpYmxlVG9wIC0gTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKC1iaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0byA9PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICBib3R0b20gPj0gdmlzaWJsZUJvdHRvbSArIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbihiaWFzLCAyNTAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi8pKSkgJiZcbiAgICAgICAgICAgICh0b3AgPiB2aXNpYmxlVG9wIC0gMiAqIDEwMDAgLyogVlAuTWFyZ2luICovICYmIGJvdHRvbSA8IHZpc2libGVCb3R0b20gKyAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8pO1xuICAgIH1cbiAgICBtYXBMaW5lR2FwcyhnYXBzLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghZ2Fwcy5sZW5ndGggfHwgY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBnYXBzO1xuICAgICAgICBsZXQgbWFwcGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VzLnRvdWNoZXNSYW5nZShnYXAuZnJvbSwgZ2FwLnRvKSlcbiAgICAgICAgICAgICAgICBtYXBwZWQucHVzaChuZXcgTGluZUdhcChjaGFuZ2VzLm1hcFBvcyhnYXAuZnJvbSksIGNoYW5nZXMubWFwUG9zKGdhcC50byksIGdhcC5zaXplLCBnYXAuZGlzcGxheVNpemUpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAgIC8vIGFwcHJvcHJpYXRlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlZHJhd3MuXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxuICAgIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gICAgLy8gcHJlZGljdGFibGUuIFJlbGllcyBvbiBnZW5lcm91cyBtYXJnaW5zIChzZWUgTEcuTWFyZ2luKSB0byBoaWRlXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cbiAgICBlbnN1cmVMaW5lR2FwcyhjdXJyZW50LCBtYXlNZWFzdXJlKSB7XG4gICAgICAgIGxldCB3cmFwcGluZyA9IHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZztcbiAgICAgICAgbGV0IG1hcmdpbiA9IHdyYXBwaW5nID8gMTAwMDAgLyogTEcuTWFyZ2luV3JhcCAqLyA6IDIwMDAgLyogTEcuTWFyZ2luICovLCBoYWxmTWFyZ2luID0gbWFyZ2luID4+IDEsIGRvdWJsZU1hcmdpbiA9IG1hcmdpbiA8PCAxO1xuICAgICAgICAvLyBUaGUgbm9uLXdyYXBwaW5nIGxvZ2ljIHdvbid0IHdvcmsgYXQgYWxsIGluIHByZWRvbWluYW50bHkgcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSICYmICF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEdhcCA9IChmcm9tLCB0bywgbGluZSwgc3RydWN0dXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgYXZvaWQgPSBbc2VsLmZyb21dO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXG4gICAgICAgICAgICAgICAgYXZvaWQucHVzaChzZWwudG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGF2b2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKGZyb20sIHBvcyAtIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKHBvcyArIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgdG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IGhhbGZNYXJnaW4gJiYgTWF0aC5hYnMoZ2FwLnRvIC0gdG8pIDwgaGFsZk1hcmdpbiAmJlxuICAgICAgICAgICAgICAgICFhdm9pZC5zb21lKHBvcyA9PiBnYXAuZnJvbSA8IHBvcyAmJiBnYXAudG8gPiBwb3MpKTtcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biwgc25hcCBnYXAgZW5kcyB0byBsaW5lIHN0YXJ0cyB0byBhdm9pZCBzaGlmdHMgaW4gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICBpZiAodG8gPCBsaW5lLnRvICYmIG1heU1lYXN1cmUgJiYgd3JhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IG1heU1lYXN1cmUubW92ZVRvTGluZUJvdW5kYXJ5KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pLCBmYWxzZSwgdHJ1ZSkuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLmdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3BsYXlTaXplID0gd3JhcHBpbmcgfHwgc2l6ZSA8IDIwMDAwMDAgLyogVlAuTWF4SG9yaXpHYXAgKi8gPyBzaXplIDogMjAwMDAwMCAvKiBWUC5NYXhIb3JpekdhcCAqLztcbiAgICAgICAgICAgICAgICBnYXAgPSBuZXcgTGluZUdhcChmcm9tLCB0bywgc2l6ZSwgZGlzcGxheVNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2Fwcy5wdXNoKGdhcCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjaGVja0xpbmUgPSAobGluZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgZG91YmxlTWFyZ2luIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc3RydWN0dXJlID0gbGluZVN0cnVjdHVyZShsaW5lLmZyb20sIGxpbmUudG8sIHRoaXMuc3RhdGVEZWNvKTtcbiAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmUudG90YWwgPCBkb3VibGVNYXJnaW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID8gdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA6IG51bGw7XG4gICAgICAgICAgICBsZXQgdmlld0Zyb20sIHZpZXdUbztcbiAgICAgICAgICAgIGlmICh3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5IZWlnaHQgPSAobWFyZ2luIC8gdGhpcy5oZWlnaHRPcmFjbGUubGluZUxlbmd0aCkgKiB0aGlzLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB0b3AsIGJvdDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnZpc2libGVCb3R0b20gLSB0aGlzLnZpc2libGVUb3ApIC8gMiArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0aGlzLnZpc2libGVUb3AgLSBsaW5lLnRvcCAtIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gKHRoaXMudmlzaWJsZUJvdHRvbSAtIGxpbmUudG9wICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHRvcCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5XaWR0aCA9IG1hcmdpbiAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgaG9yaXpPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoID4gMjAwMDAwMCAvKiBWUC5NYXhIb3JpekdhcCAqLylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgb2xkIG9mIGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGQuZnJvbSA+PSBsaW5lLmZyb20gJiYgb2xkLmZyb20gPCBsaW5lLnRvICYmIG9sZC5zaXplICE9IG9sZC5kaXNwbGF5U2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5mcm9tICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICsgaG9yaXpPZmZzZXQgPCB0aGlzLnBpeGVsVmlld3BvcnQubGVmdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3Jpek9mZnNldCA9IG9sZC5zaXplIC0gb2xkLmRpc3BsYXlTaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHB4TGVmdCA9IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0ICsgaG9yaXpPZmZzZXQsIHB4UmlnaHQgPSB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgKyBob3Jpek9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgocHhSaWdodCAtIHB4TGVmdCkgLyAyICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAocHhMZWZ0IC0gbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAocHhSaWdodCArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID4gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIGFkZEdhcChsaW5lLmZyb20sIHZpZXdGcm9tLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgaWYgKHZpZXdUbyA8IGxpbmUudG8pXG4gICAgICAgICAgICAgICAgYWRkR2FwKHZpZXdUbywgbGluZS50bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXG4gICAgICAgICAgICAgICAgbGluZS50eXBlLmZvckVhY2goY2hlY2tMaW5lKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGVja0xpbmUobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgfVxuICAgIGdhcFNpemUobGluZSwgZnJvbSwgdG8sIHN0cnVjdHVyZSkge1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0bykgLSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuaGVpZ2h0ICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICogZnJhY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTGluZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAoIUxpbmVHYXAuc2FtZShnYXBzLCB0aGlzLmxpbmVHYXBzKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwcyA9IGdhcHM7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQoZ2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KHRoaXMsIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlVmlzaWJsZVJhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBkZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aClcbiAgICAgICAgICAgIGRlY28gPSBkZWNvLmNvbmNhdCh0aGlzLmxpbmVHYXBEZWNvKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvLCB0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHtcbiAgICAgICAgICAgIHNwYW4oZnJvbSwgdG8pIHsgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTsgfSxcbiAgICAgICAgICAgIHBvaW50KCkgeyB9XG4gICAgICAgIH0sIDIwKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSAwO1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gOCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0TW92ZWQgKi8gfCA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGggJiYgIShjaGFuZ2VkICYgOCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0TW92ZWQgKi8pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb2xkID0gdGhpcy52aXNpYmxlUmFuZ2VzW2ldLCBudyA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkLmZyb20gIT0gbncuZnJvbSB8fCBvbGQudG8gIT0gbncudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCB8PSA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi87XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGNoYW5nZXMgJiYgY2hhbmdlcy5tYXBQb3Mob2xkLmZyb20sIC0xKSA9PSBudy5mcm9tICYmIGNoYW5nZXMubWFwUG9zKG9sZC50bywgMSkgPT0gbncudG8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCB8PSA4IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnRNb3ZlZCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiAocG9zID49IHRoaXMudmlld3BvcnQuZnJvbSAmJiBwb3MgPD0gdGhpcy52aWV3cG9ydC50byAmJlxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQoYiA9PiBiLmZyb20gPD0gcG9zICYmIGIudG8gPj0gcG9zKSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHBvcywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiAoaGVpZ2h0ID49IHRoaXMudmlld3BvcnRMaW5lc1swXS50b3AgJiYgaGVpZ2h0IDw9IHRoaXMudmlld3BvcnRMaW5lc1t0aGlzLnZpZXdwb3J0TGluZXMubGVuZ3RoIC0gMV0uYm90dG9tICYmXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMuZmluZChsID0+IGwudG9wIDw9IGhlaWdodCAmJiBsLmJvdHRvbSA+PSBoZWlnaHQpKSB8fFxuICAgICAgICAgICAgc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQodGhpcy5zY2FsZXIuZnJvbURPTShoZWlnaHQpLCBRdWVyeVR5cGUuQnlIZWlnaHQsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBzY3JvbGxBbmNob3JBdChzY3JvbGxUb3ApIHtcbiAgICAgICAgbGV0IGJsb2NrID0gdGhpcy5saW5lQmxvY2tBdEhlaWdodChzY3JvbGxUb3AgKyA4KTtcbiAgICAgICAgcmV0dXJuIGJsb2NrLmZyb20gPj0gdGhpcy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlld3BvcnRMaW5lc1swXS50b3AgLSBzY3JvbGxUb3AgPiAyMDAgPyBibG9jayA6IHRoaXMudmlld3BvcnRMaW5lc1swXTtcbiAgICB9XG4gICAgZWxlbWVudEF0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5ibG9ja0F0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGdldCBkb2NIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlci50b0RPTSh0aGlzLmhlaWdodE1hcC5oZWlnaHQpO1xuICAgIH1cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jSGVpZ2h0ICsgdGhpcy5wYWRkaW5nVG9wICsgdGhpcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cbn1cbmNsYXNzIFZpZXdwb3J0IHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbGluZVN0cnVjdHVyZShmcm9tLCB0bywgc3RhdGVEZWNvKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBwb3MgPSBmcm9tLCB0b3RhbCA9IDA7XG4gICAgUmFuZ2VTZXQuc3BhbnMoc3RhdGVEZWNvLCBmcm9tLCB0bywge1xuICAgICAgICBzcGFuKCkgeyB9LFxuICAgICAgICBwb2ludChmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IGZyb20gfSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZnJvbSAtIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgfSwgMjApOyAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gY29sbGFwc2VkIHJhbmdlcyBvZiBhIHNpZ25pZmljYW50IHNpemVcbiAgICBpZiAocG9zIDwgdG8pIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvIH0pO1xuICAgICAgICB0b3RhbCArPSB0byAtIHBvcztcbiAgICB9XG4gICAgcmV0dXJuIHsgdG90YWwsIHJhbmdlcyB9O1xufVxuZnVuY3Rpb24gZmluZFBvc2l0aW9uKHsgdG90YWwsIHJhbmdlcyB9LCByYXRpbykge1xuICAgIGlmIChyYXRpbyA8PSAwKVxuICAgICAgICByZXR1cm4gcmFuZ2VzWzBdLmZyb207XG4gICAgaWYgKHJhdGlvID49IDEpXG4gICAgICAgIHJldHVybiByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgIGxldCBkaXN0ID0gTWF0aC5mbG9vcih0b3RhbCAqIHJhdGlvKTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldLCBzaXplID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGlzdCA8PSBzaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZyb20gKyBkaXN0O1xuICAgICAgICBkaXN0IC09IHNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgcG9zKSB7XG4gICAgbGV0IGNvdW50ZWQgPSAwO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBzdHJ1Y3R1cmUucmFuZ2VzKSB7XG4gICAgICAgIGlmIChwb3MgPD0gdG8pIHtcbiAgICAgICAgICAgIGNvdW50ZWQgKz0gcG9zIC0gZnJvbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ZWQgKz0gdG8gLSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4gY291bnRlZCAvIHN0cnVjdHVyZS50b3RhbDtcbn1cbmZ1bmN0aW9uIGZpbmQoYXJyYXksIGYpIHtcbiAgICBmb3IgKGxldCB2YWwgb2YgYXJyYXkpXG4gICAgICAgIGlmIChmKHZhbCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBEb24ndCBzY2FsZSB3aGVuIHRoZSBkb2N1bWVudCBoZWlnaHQgaXMgd2l0aGluIHRoZSByYW5nZSBvZiB3aGF0XG4vLyB0aGUgRE9NIGNhbiBoYW5kbGUuXG5jb25zdCBJZFNjYWxlciA9IHtcbiAgICB0b0RPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIGZyb21ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBzY2FsZTogMSxcbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgPT0gdGhpczsgfVxufTtcbi8vIFdoZW4gdGhlIGhlaWdodCBpcyB0b28gYmlnICg+IFZQLk1heERPTUhlaWdodCksIHNjYWxlIGRvd24gdGhlXG4vLyByZWdpb25zIG91dHNpZGUgdGhlIHZpZXdwb3J0cyBzbyB0aGF0IHRoZSB0b3RhbCBoZWlnaHQgaXNcbi8vIFZQLk1heERPTUhlaWdodC5cbmNsYXNzIEJpZ1NjYWxlciB7XG4gICAgY29uc3RydWN0b3Iob3JhY2xlLCBoZWlnaHRNYXAsIHZpZXdwb3J0cykge1xuICAgICAgICBsZXQgdnBIZWlnaHQgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgdG9wID0gaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCkudG9wO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCAwLCAwKS5ib3R0b207XG4gICAgICAgICAgICB2cEhlaWdodCArPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdG9wLCBib3R0b20sIGRvbVRvcDogMCwgZG9tQm90dG9tOiAwIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjYWxlID0gKDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovIC0gdnBIZWlnaHQpIC8gKGhlaWdodE1hcC5oZWlnaHQgLSB2cEhlaWdodCk7XG4gICAgICAgIGZvciAobGV0IG9iaiBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgb2JqLmRvbVRvcCA9IGRvbUJhc2UgKyAob2JqLnRvcCAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSBvYmouZG9tQm90dG9tID0gb2JqLmRvbVRvcCArIChvYmouYm90dG9tIC0gb2JqLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gb2JqLmJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0RPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC50b3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJhc2UgKyAobiAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAuZG9tVG9wICsgKG4gLSB2cC50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbURPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC5kb21Ub3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UgKyAobiAtIGRvbUJhc2UpIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmRvbUJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAudG9wICsgKG4gLSB2cC5kb21Ub3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBCaWdTY2FsZXIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSA9PSBvdGhlci5zY2FsZSAmJiB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPT0gb3RoZXIudmlld3BvcnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydHMuZXZlcnkoKHZwLCBpKSA9PiB2cC5mcm9tID09IG90aGVyLnZpZXdwb3J0c1tpXS5mcm9tICYmIHZwLnRvID09IG90aGVyLnZpZXdwb3J0c1tpXS50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbGVCbG9jayhibG9jaywgc2NhbGVyKSB7XG4gICAgaWYgKHNjYWxlci5zY2FsZSA9PSAxKVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgbGV0IGJUb3AgPSBzY2FsZXIudG9ET00oYmxvY2sudG9wKSwgYkJvdHRvbSA9IHNjYWxlci50b0RPTShibG9jay5ib3R0b20pO1xuICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGJsb2NrLmZyb20sIGJsb2NrLmxlbmd0aCwgYlRvcCwgYkJvdHRvbSAtIGJUb3AsIEFycmF5LmlzQXJyYXkoYmxvY2suX2NvbnRlbnQpID8gYmxvY2suX2NvbnRlbnQubWFwKGIgPT4gc2NhbGVCbG9jayhiLCBzY2FsZXIpKSA6IGJsb2NrLl9jb250ZW50KTtcbn1cblxuY29uc3QgdGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogc3RycyA9PiBzdHJzLmpvaW4oXCIgXCIpIH0pO1xuY29uc3QgZGFya1RoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuaW5kZXhPZih0cnVlKSA+IC0xIH0pO1xuY29uc3QgYmFzZVRoZW1lSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlTGlnaHRJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VEYXJrSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuY29uc3QgbGlnaHREYXJrSURzID0geyBcIiZsaWdodFwiOiBcIi5cIiArIGJhc2VMaWdodElELCBcIiZkYXJrXCI6IFwiLlwiICsgYmFzZURhcmtJRCB9O1xuZnVuY3Rpb24gYnVpbGRUaGVtZShtYWluLCBzcGVjLCBzY29wZXMpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlTW9kdWxlKHNwZWMsIHtcbiAgICAgICAgZmluaXNoKHNlbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8mLy50ZXN0KHNlbCkgPyBzZWwucmVwbGFjZSgvJlxcdyovLCBtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobSA9PSBcIiZcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW47XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZXMgfHwgIXNjb3Blc1ttXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuc3VwcG9ydGVkIHNlbGVjdG9yOiAke219YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3Blc1ttXTtcbiAgICAgICAgICAgIH0pIDogbWFpbiArIFwiIFwiICsgc2VsO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9idWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHtcbiAgICBcIiZcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZSAhaW1wb3J0YW50XCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIFwiJi5jbS1mb2N1c2VkXCI6IHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSBzaW1wbGUgZGVmYXVsdCBvdXRsaW5lIHRvIG1ha2Ugc3VyZSBhIGZvY3VzZWRcbiAgICAgICAgICAgIC8vIGVkaXRvciBpcyB2aXN1YWxseSBkaXN0aW5jdC4gQ2FuJ3QgbGVhdmUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3aWxsIGFwcGx5IHRvIHRoZSBjb250ZW50IGVsZW1lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGFuZCBkb2Vzbid0IGluY2x1ZGUgdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXJzLiBXZSBhbHNvIGNhbid0IHVzZSBhbiAnYXV0bycgb3V0bGluZSwgc2luY2UgdGhvc2VcbiAgICAgICAgICAgIC8vIGFyZSwgZm9yIHNvbWUgcmVhc29uLCBkcmF3biBiZWhpbmQgdGhlIGVsZW1lbnQgY29udGVudCwgd2hpY2hcbiAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgdGhpbmdzIGxpa2UgdGhlIGFjdGl2ZSBsaW5lIGJhY2tncm91bmQgdG8gY292ZXJcbiAgICAgICAgICAgIC8vIHRoZSBvdXRsaW5lICgjMjk3KS5cbiAgICAgICAgICAgIG91dGxpbmU6IFwiMXB4IGRvdHRlZCAjMjEyMTIxXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICAgIH0sXG4gICAgXCIuY20tc2Nyb2xsZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnQgIWltcG9ydGFudFwiLFxuICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93WDogXCJhdXRvXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHpJbmRleDogMCxcbiAgICAgICAgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiLFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgZmxleEdyb3c6IDIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDU2XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiNHB4IDBcIixcbiAgICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAgIFwiJltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cIjoge1xuICAgICAgICAgICAgV2Via2l0VXNlck1vZGlmeTogXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbmVXcmFwcGluZ1wiOiB7XG4gICAgICAgIHdoaXRlU3BhY2VfZmFsbGJhY2s6IFwicHJlLXdyYXBcIiwgLy8gRm9yIElFXG4gICAgICAgIHdoaXRlU3BhY2U6IFwiYnJlYWstc3BhY2VzXCIsXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsIC8vIEZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBvdmVyZmxvdy13cmFwOiBhbnl3aGVyZVxuICAgICAgICBvdmVyZmxvd1dyYXA6IFwiYW55d2hlcmVcIixcbiAgICAgICAgZmxleFNocmluazogMVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcImJsYWNrXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJ3aGl0ZVwiIH0sXG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDJweCAwIDZweFwiXG4gICAgfSxcbiAgICBcIi5jbS1sYXllclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgY29udGFpbjogXCJzaXplIHN0eWxlXCIsXG4gICAgICAgIFwiJiA+ICpcIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q5ZDlkOVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjIyXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0LmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkN2Q0ZjBcIlxuICAgIH0sXG4gICAgXCImZGFyay5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLXNlbGVjdGlvbkxheWVyIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjMzXCJcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBcInN0ZXBzKDEpIGNtLWJsaW5rIDEuMnMgaW5maW5pdGVcIlxuICAgIH0sXG4gICAgLy8gVHdvIGFuaW1hdGlvbnMgZGVmaW5lZCBzbyB0aGF0IHdlIGNhbiBzd2l0Y2ggYmV0d2VlbiB0aGVtIHRvXG4gICAgLy8gcmVzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGhvdXQgZm9yY2luZyBhbm90aGVyIHN0eWxlXG4gICAgLy8gcmVjb21wdXRhdGlvbi5cbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmtcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rMlwiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjJweCBzb2xpZCBibGFja1wiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0wLjZweFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IFwiI2RkZFwiXG4gICAgfSxcbiAgICBcIi5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tY3Vyc29yTGF5ZXIgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0sXG4gICAgXCIuY20taXNvXCI6IHtcbiAgICAgICAgdW5pY29kZUJpZGk6IFwiaXNvbGF0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hbm5vdW5jZWRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICB0b3A6IFwiLTEwMDAwcHhcIlxuICAgIH0sXG4gICAgXCJAbWVkaWEgcHJpbnRcIjoge1xuICAgICAgICBcIi5jbS1hbm5vdW5jZWRcIjogeyBkaXNwbGF5OiBcIm5vbmVcIiB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjY2NlZWZmNDRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZWVmZjMzXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwiI2Y3OFwiIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICB6SW5kZXg6IDIwMCxcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlcnMtYmVmb3JlXCI6IHsgaW5zZXRJbmxpbmVTdGFydDogMCB9LFxuICAgIFwiLmNtLWd1dHRlcnMtYWZ0ZXJcIjogeyBpbnNldElubGluZUVuZDogMCB9LFxuICAgIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiIzZjNmM2Y1wiLFxuICAgICAgICBib3JkZXI6IFwiMHB4IHNvbGlkICNkZGRcIixcbiAgICAgICAgXCImLmNtLWd1dHRlcnMtYmVmb3JlXCI6IHsgYm9yZGVyUmlnaHRXaWR0aDogXCIxcHhcIiB9LFxuICAgICAgICBcIiYuY20tZ3V0dGVycy1hZnRlclwiOiB7IGJvcmRlckxlZnRXaWR0aDogXCIxcHhcIiB9LFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIiNjY2NcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIiwgLy8gTmVjZXNzYXJ5IC0tIHByZXZlbnRzIG1hcmdpbiBjb2xsYXBzaW5nXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tbGluZU51bWJlcnMgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgM3B4IDAgNXB4XCIsXG4gICAgICAgIG1pbldpZHRoOiBcIjIwcHhcIixcbiAgICAgICAgdGV4dEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlMmYyZmZcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMjIyMjI3XCJcbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgekluZGV4OiAzMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS1kaWFsb2dcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCAxOXB4IDRweCA2cHhcIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIGxhYmVsXCI6IHsgZm9udFNpemU6IFwiODAlXCIgfSxcbiAgICB9LFxuICAgIFwiLmNtLWRpYWxvZy1jbG9zZVwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHRvcDogXCIzcHhcIixcbiAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCIxNHB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiXG4gICAgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20td2lkZ2V0QnVmZmVyXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICAgICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFNwYWNlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcInJhZGlhbC1ncmFkaWVudChjaXJjbGUgYXQgNTAlIDU1JSwgI2FhYSAyMCUsIHRyYW5zcGFyZW50IDUlKVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwiY2VudGVyXCIsXG4gICAgfSxcbiAgICBcIi5jbS1oaWdobGlnaHRUYWJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwXCI+PHBhdGggc3Ryb2tlPVwiJTIzODg4XCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZD1cIk0xIDEwSDE5NkwxOTAgNU0xOTAgMTVMMTk2IDEwTTE5NyA0TDE5NyAxNlwiLz48L3N2Zz4nKWAsXG4gICAgICAgIGJhY2tncm91bmRTaXplOiBcImF1dG8gMTAwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwicmlnaHQgOTAlXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCJcbiAgICB9LFxuICAgIFwiLmNtLXRyYWlsaW5nU3BhY2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMzMyMjU1XCJcbiAgICB9LFxuICAgIFwiLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAxZW1cIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjFweFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjZWZmMWY1LCAjZDlkOWRmKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNiNGI0YjQsICNkMGQzZDYpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImZGFyayAuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMzkzOTM5LCAjMTExKVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICAgICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMxMTEsICMzMzMpXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIC41ZW1cIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM1NTVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIlxuICAgIH1cbn0sIGxpZ2h0RGFya0lEcyk7XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvXG4vLyBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQgdGhlcmVcbmNvbnN0IHVzZUNoYXJEYXRhID0gYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBET01PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGtub3duIHNlbGVjdGlvbi4gS2VwdCBpbiBvdXIgb3duIG9iamVjdCwgYXMgb3Bwb3NlZCB0byBqdXN0XG4gICAgICAgIC8vIGRpcmVjdGx5IGFjY2Vzc2luZyB0aGUgc2VsZWN0aW9uIGJlY2F1c2U6XG4gICAgICAgIC8vICAtIFNhZmFyaSBkb2Vzbid0IHJlcG9ydCB0aGUgcmlnaHQgc2VsZWN0aW9uIGluIHNoYWRvdyBET01cbiAgICAgICAgLy8gIC0gUmVhZGluZyBmcm9tIHRoZSBzZWxlY3Rpb24gZm9yY2VzIGEgRE9NIGxheW91dFxuICAgICAgICAvLyAgLSBUaGlzIHdheSwgd2UgY2FuIGlnbm9yZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnRzIGlmIHdlIGhhdmVcbiAgICAgICAgLy8gICAgYWxyZWFkeSBzZWVuIHRoZSAnbmV3JyBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZSA9IG5ldyBET01TZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgLy8gU2V0IHdoZW4gYSBzZWxlY3Rpb24gY2hhbmdlIGlzIGRldGVjdGVkLCBjbGVhcmVkIG9uIGZsdXNoXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXRzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2FwcyA9IFtdO1xuICAgICAgICB0aGlzLnByaW50UXVlcnkgPSBudWxsO1xuICAgICAgICAvLyBUaW1lb3V0IGZvciBzY2hlZHVsaW5nIGNoZWNrIG9mIHRoZSBwYXJlbnRzIHRoYXQgbmVlZCBzY3JvbGwgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuY29udGVudERPTTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgbXV0YXRpb25zKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gdHlwaW5nIG92ZXIgYSBzZWxlY3Rpb24gb3JcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXIgdGV4dCBub2RlKSBjYWxsIHRoZVxuICAgICAgICAgICAgLy8gb2JzZXJ2ZXIgY2FsbGJhY2sgYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVW5yZWxhdGVkbHksIGlPUyBTYWZhcmkgd2lsbCwgd2hlbiBlbmRpbmcgYSBjb21wb3NpdGlvbixcbiAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBmaXJzdCBjbGVhciBpdCwgZGVsaXZlciB0aGUgbXV0YXRpb25zLCBhbmQgdGhlblxuICAgICAgICAgICAgLy8gcmVpbnNlcnQgdGhlIGZpbmlzaGVkIHRleHQuIENvZGVNaXJyb3IncyBoYW5kbGluZyBvZiB0aGVcbiAgICAgICAgICAgIC8vIGRlbGV0aW9uIHdpbGwgcHJldmVudCB0aGUgcmVpbnNlcnRpb24gZnJvbSBoYXBwZW5pbmcsXG4gICAgICAgICAgICAvLyBicmVha2luZyBjb21wb3NpdGlvbi5cbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5pb3MgJiYgdmlldy5jb21wb3NpbmcpICYmXG4gICAgICAgICAgICAgICAgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAod2luZG93LkVkaXRDb250ZXh0ICYmIGJyb3dzZXIuYW5kcm9pZCAmJiB2aWV3LmNvbnN0cnVjdG9yLkVESVRfQ09OVEVYVCAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIC8vIENocm9tZSA8MTI2IGRvZXNuJ3Qgc3VwcG9ydCBpbnZlcnRlZCBzZWxlY3Rpb25zIGluIGVkaXQgY29udGV4dCAoIzEzOTIpXG4gICAgICAgICAgICAhKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuY2hyb21lX3ZlcnNpb24gPCAxMjYpKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0ID0gbmV3IEVkaXRDb250ZXh0TWFuYWdlcih2aWV3KTtcbiAgICAgICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSlcbiAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uZWRpdENvbnRleHQgPSB0aGlzLmVkaXRDb250ZXh0LmVkaXRDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNoYXJhY3RlckRhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50LnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSA9IHRoaXMub25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblByaW50ID0gdGhpcy5vblByaW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TY3JvbGwgPSB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSlcbiAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKFwicHJpbnRcIik7XG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbCA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy52aWV3LmRvY1ZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0VXBkYXRlKSA8IERhdGUubm93KCkgLSA3NSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbC5vYnNlcnZlKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbiA9IHZpZXcud2luKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Q2hlY2sgPCAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gc2V0VGltZW91dCh0aGlzLmxpc3RlbkZvclNjcm9sbC5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIChlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSAhPSB0aGlzLmludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9ICF0aGlzLmludGVyc2VjdGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nICE9IHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7IHRocmVzaG9sZDogWzAsIC4wMDFdIH0pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24ub2JzZXJ2ZSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuRm9yU2Nyb2xsKCk7XG4gICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsQ2hhbmdlZChlKSB7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLnJ1bkhhbmRsZXJzKFwic2Nyb2xsXCIsIGUpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLnZpZXcubWVhc3VyZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbChlKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5lZGl0Q29udGV4dClcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLmVkaXRDb250ZXh0Lm1lYXN1cmVSZXEpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChlKTtcbiAgICB9XG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIG9uUHJpbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKChldmVudC50eXBlID09IFwiY2hhbmdlXCIgfHwgIWV2ZW50LnR5cGUpICYmICFldmVudC5tYXRjaGVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgdXBkYXRlR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICh0aGlzLmdhcEludGVyc2VjdGlvbiAmJiAoZ2Fwcy5sZW5ndGggIT0gdGhpcy5nYXBzLmxlbmd0aCB8fCB0aGlzLmdhcHMuc29tZSgoZywgaSkgPT4gZyAhPSBnYXBzW2ldKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLm9ic2VydmUoZ2FwKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwcyA9IGdhcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHdhc0NoYW5nZWQgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgICAgIGlmICghdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKSB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWwgPSB0aGlzLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB0aGlzLmRvbSA6ICFoYXNTZWxlY3Rpb24odGhpcy5kb20sIHNlbCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb250ZXh0ID0gc2VsLmFuY2hvck5vZGUgJiYgdmlldy5kb2NWaWV3Lm5lYXJlc3Qoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lmlnbm9yZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgaWYgKCF3YXNDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0aW9ucyBvbiBJRTExIGZpcmUgdGhlaXIgZXZlbnRzIGluIHRoZSB3cm9uZyBvcmRlciwgZ2l2aW5nXG4gICAgICAgIC8vIHVzIGEgc2VsZWN0aW9uIGNoYW5nZSBldmVudCBiZWZvcmUgdGhlIERPTSBjaGFuZ2VzIGFyZVxuICAgICAgICAvLyByZXBvcnRlZC5cbiAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgaGFzIGEgc2ltaWxhciBpc3N1ZSB3aGVuIGJhY2tzcGFjaW5nIG91dCBhXG4gICAgICAgIC8vIHNlbGVjdGlvbiAoIzY0NSkuXG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lKSAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJlxuICAgICAgICAgICAgLy8gKFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRSlcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICB9XG4gICAgcmVhZFNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICAvLyBUaGUgU2VsZWN0aW9uIG9iamVjdCBpcyBicm9rZW4gaW4gc2hhZG93IHJvb3RzIGluIFNhZmFyaS4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCByYW5nZSA9IGJyb3dzZXIuc2FmYXJpICYmIHZpZXcucm9vdC5ub2RlVHlwZSA9PSAxMSAmJlxuICAgICAgICAgICAgdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb20gJiZcbiAgICAgICAgICAgIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh0aGlzLnZpZXcsIHNlbGVjdGlvbikgfHwgc2VsZWN0aW9uO1xuICAgICAgICBpZiAoIXJhbmdlIHx8IHRoaXMuc2VsZWN0aW9uUmFuZ2UuZXEocmFuZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbG9jYWwgPSBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHJhbmdlKTtcbiAgICAgICAgLy8gRGV0ZWN0IHRoZSBzaXR1YXRpb24gd2hlcmUgdGhlIGJyb3dzZXIgaGFzLCBvbiBmb2N1cywgbW92ZWQgdGhlXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQgZWxlbWVudC4gUmVzZXQgaXQgdG8gdGhlXG4gICAgICAgIC8vIHBvc2l0aW9uIGZyb20gdGhlIGVkaXRvciBzdGF0ZS5cbiAgICAgICAgaWYgKGxvY2FsICYmICF0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPCBEYXRlLm5vdygpIC0gMzAwICYmXG4gICAgICAgICAgICBhdEVsZW1lbnRTdGFydCh0aGlzLmRvbSwgcmFuZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgICAgIHZpZXcuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKGxvY2FsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjbGVhclNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldChudWxsLCAwLCBudWxsLCAwKTtcbiAgICB9XG4gICAgbGlzdGVuRm9yU2Nyb2xsKCkge1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIGxldCBpID0gMCwgY2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHRoaXMuZG9tOyBkb207KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgdGhpcy5zY3JvbGxUYXJnZXRzW2ldID09IGRvbSlcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkLnB1c2goZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uYXNzaWduZWRTbG90IHx8IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgIWNoYW5nZWQpXG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMgPSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZShmKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICB9XG4gICAgLy8gVGhyb3cgYXdheSBhbnkgcGVuZGluZyBjaGFuZ2VzXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQsIGVzcGVjaWFsbHkgaW4gY29tYmluYXRpb24gd2l0aCBHQm9hcmQsIG5vdCBvbmx5XG4gICAgLy8gZG9lc24ndCByZWxpYWJseSBmaXJlIHJlZ3VsYXIga2V5IGV2ZW50cywgYnV0IGFsc28gb2Z0ZW5cbiAgICAvLyBzdXJyb3VuZHMgdGhlIGVmZmVjdCBvZiBlbnRlciBvciBiYWNrc3BhY2Ugd2l0aCBhIGJ1bmNoIG9mXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIHRoYXQsIHdoZW4gaW50ZXJydXB0ZWQsIGNhdXNlIHRleHQgZHVwbGljYXRpb25cbiAgICAvLyBvciBvdGhlciBraW5kcyBvZiBjb3JydXB0aW9uLiBUaGlzIGhhY2sgbWFrZXMgdGhlIGVkaXRvciBiYWNrIG9mZlxuICAgIC8vIGZyb20gaGFuZGxpbmcgRE9NIGNoYW5nZXMgZm9yIGEgbW9tZW50IHdoZW4gc3VjaCBhIGtleSBpc1xuICAgIC8vIGRldGVjdGVkICh2aWEgYmVmb3JlaW5wdXQgb3Iga2V5ZG93biksIGFuZCB0aGVuIHRyaWVzIHRvIGZsdXNoXG4gICAgLy8gdGhlbSBvciwgaWYgdGhhdCBoYXMgbm8gZWZmZWN0LCBkaXNwYXRjaGVzIHRoZSBnaXZlbiBrZXkuXG4gICAgZGVsYXlBbmRyb2lkS2V5KGtleSwga2V5Q29kZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgICAgICAgbGV0IGZsdXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlID0ga2V5LmtleUNvZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RLZXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZsdXNoZWQgPSB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmx1c2hlZCAmJiBrZXkuZm9yY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmRvbSwga2V5LmtleSwga2V5LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBiYWNrc3BhY2UgYmVmb3JlaW5wdXQgaXMgc29tZXRpbWVzIHNpZ25hbGxlZCBzcHVyaW91c2x5LFxuICAgICAgICAvLyBFbnRlciBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5IHx8IGtleSA9PSBcIkVudGVyXCIpXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0ge1xuICAgICAgICAgICAgICAgIGtleSwga2V5Q29kZSxcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biB0aGUga2V5IGhhbmRsZXIgd2hlbiBubyBjaGFuZ2VzIGFyZSBkZXRlY3RlZCBpZlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgY29taW5nIHJpZ2h0IGFmdGVyIGFub3RoZXIgY2hhbmdlLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgcHJvYmFibHkgcGFydCBvZiBhIHdlaXJkIGNoYWluIG9mIHVwZGF0ZXMsIGFuZCBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBiZSBpZ25vcmVkIGlmIGl0IHJldHVybnMgdGhlIERPTSB0byBpdHMgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgICAgICAgICAgZm9yY2U6IHRoaXMubGFzdENoYW5nZSA8IERhdGUubm93KCkgLSA1MCB8fCAhISgoX2EgPSB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2UpXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBjbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCkge1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XG4gICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IC0xO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA8IDApXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTsgdGhpcy5mbHVzaCgpOyB9KTtcbiAgICB9XG4gICAgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDApIHtcbiAgICAgICAgICAgIHRoaXMudmlldy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIHBlbmRpbmdSZWNvcmRzKCkge1xuICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlO1xuICAgIH1cbiAgICBwcm9jZXNzUmVjb3JkcygpIHtcbiAgICAgICAgbGV0IHJlY29yZHMgPSB0aGlzLnBlbmRpbmdSZWNvcmRzKCk7XG4gICAgICAgIGlmIChyZWNvcmRzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMucmVhZE11dGF0aW9uKHJlY29yZCk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGVPdmVyKVxuICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID09IC0xKSB7XG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyb20gPSBNYXRoLm1pbihyYW5nZS5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHR5cGVPdmVyIH07XG4gICAgfVxuICAgIHJlYWRDaGFuZ2UoKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvLCB0eXBlT3ZlciB9ID0gdGhpcy5wcm9jZXNzUmVjb3JkcygpO1xuICAgICAgICBsZXQgbmV3U2VsID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmIGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgdGhpcy5zZWxlY3Rpb25SYW5nZSk7XG4gICAgICAgIGlmIChmcm9tIDwgMCAmJiAhbmV3U2VsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChmcm9tID4gLTEpXG4gICAgICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBjaGFuZ2UgPSBuZXcgRE9NQ2hhbmdlKHRoaXMudmlldywgZnJvbSwgdG8sIHR5cGVPdmVyKTtcbiAgICAgICAgdGhpcy52aWV3LmRvY1ZpZXcuZG9tQ2hhbmdlZCA9IHsgbmV3U2VsOiBjaGFuZ2UubmV3U2VsID8gY2hhbmdlLm5ld1NlbC5tYWluIDogbnVsbCB9O1xuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICAvLyBBcHBseSBwZW5kaW5nIGNoYW5nZXMsIGlmIGFueVxuICAgIGZsdXNoKHJlYWRTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgICAgIC8vIENvbXBsZXRlbHkgaG9sZCBvZmYgZmx1c2hpbmcgd2hlbiBwZW5kaW5nIGtleXMgYXJlIHNldOKAlHRoZSBjb2RlXG4gICAgICAgIC8vIG1hbmFnaW5nIHRob3NlIHdpbGwgbWFrZSBzdXJlIHByb2Nlc3NSZWNvcmRzIGlzIGNhbGxlZCBhbmQgdGhlXG4gICAgICAgIC8vIHZpZXcgaXMgcmVzeW5jaHJvbml6ZWQgYWZ0ZXJcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoID49IDAgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHJlYWRTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgZG9tQ2hhbmdlID0gdGhpcy5yZWFkQ2hhbmdlKCk7XG4gICAgICAgIGlmICghZG9tQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZTtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBhcHBseURPTUNoYW5nZSh0aGlzLnZpZXcsIGRvbUNoYW5nZSk7XG4gICAgICAgIC8vIFRoZSB2aWV3IHdhc24ndCB1cGRhdGVkIGJ1dCBET00vc2VsZWN0aW9uIGNoYW5nZXMgd2VyZSBzZWVuLiBSZXNldCB0aGUgdmlldy5cbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PSBzdGFydFN0YXRlICYmXG4gICAgICAgICAgICAoZG9tQ2hhbmdlLmRvbUNoYW5nZWQgfHwgZG9tQ2hhbmdlLm5ld1NlbCAmJiAhZG9tQ2hhbmdlLm5ld1NlbC5tYWluLmVxKHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbikpKVxuICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgIH1cbiAgICByZWFkTXV0YXRpb24ocmVjKSB7XG4gICAgICAgIGxldCBjVmlldyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3QocmVjLnRhcmdldCk7XG4gICAgICAgIGlmICghY1ZpZXcgfHwgY1ZpZXcuaWdub3JlTXV0YXRpb24ocmVjKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjVmlldy5tYXJrRGlydHkocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpXG4gICAgICAgICAgICBjVmlldy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi87XG4gICAgICAgIGlmIChyZWMudHlwZSA9PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRCZWZvcmUgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5wcmV2aW91c1NpYmxpbmcgfHwgcmVjLnRhcmdldC5wcmV2aW91c1NpYmxpbmcsIC0xKTtcbiAgICAgICAgICAgIGxldCBjaGlsZEFmdGVyID0gZmluZENoaWxkKGNWaWV3LCByZWMubmV4dFNpYmxpbmcgfHwgcmVjLnRhcmdldC5uZXh0U2libGluZywgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjaGlsZEJlZm9yZSA/IGNWaWV3LnBvc0FmdGVyKGNoaWxkQmVmb3JlKSA6IGNWaWV3LnBvc0F0U3RhcnQsXG4gICAgICAgICAgICAgICAgdG86IGNoaWxkQWZ0ZXIgPyBjVmlldy5wb3NCZWZvcmUoY2hpbGRBZnRlcikgOiBjVmlldy5wb3NBdEVuZCwgdHlwZU92ZXI6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVjLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNWaWV3LnBvc0F0U3RhcnQsIHRvOiBjVmlldy5wb3NBdEVuZCwgdHlwZU92ZXI6IHJlYy50YXJnZXQubm9kZVZhbHVlID09IHJlYy5vbGRWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0V2luZG93KHdpbikge1xuICAgICAgICBpZiAod2luICE9IHRoaXMud2luKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgICAgICB0aGlzLndpbiA9IHdpbjtcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50UXVlcnkuYWRkTGlzdGVuZXIodGhpcy5vblByaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgcmVtb3ZlV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLnByaW50UXVlcnkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW50UXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50UXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeS5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uUHJpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZWRpdGFibGUpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChlZGl0YWJsZSkpXG4gICAgICAgICAgICAgICAgdXBkYXRlLnZpZXcuY29udGVudERPTS5lZGl0Q29udGV4dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB0aGlzLmVkaXRDb250ZXh0LmVkaXRDb250ZXh0IDogbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIChfYSA9IHRoaXMuaW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2IgPSB0aGlzLmdhcEludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9jID0gdGhpcy5yZXNpemVTY3JvbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wYXJlbnRDaGVjayk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5jb250ZW50RE9NLmVkaXRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZENoaWxkKGNWaWV3LCBkb20sIGRpcikge1xuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgbGV0IGN1clZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgaWYgKGN1clZpZXcgJiYgY3VyVmlldy5wYXJlbnQgPT0gY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm4gY3VyVmlldztcbiAgICAgICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICBkb20gPSBwYXJlbnQgIT0gY1ZpZXcuZG9tID8gcGFyZW50IDogZGlyID4gMCA/IGRvbS5uZXh0U2libGluZyA6IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYnVpbGRTZWxlY3Rpb25SYW5nZUZyb21SYW5nZSh2aWV3LCByYW5nZSkge1xuICAgIGxldCBhbmNob3JOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSByYW5nZS5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJBbmNob3IgPSB2aWV3LmRvY1ZpZXcuZG9tQXRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1ckFuY2hvci5ub2RlLCBjdXJBbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSlcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcbiAgICByZXR1cm4geyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfTtcbn1cbi8vIFVzZWQgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgU2VsZWN0aW9uL3NoYWRvdyBET00gYnVnICgjNDE0KVxuZnVuY3Rpb24gc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHZpZXcsIHNlbGVjdGlvbikge1xuICAgIGlmIChzZWxlY3Rpb24uZ2V0Q29tcG9zZWRSYW5nZXMpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsZWN0aW9uLmdldENvbXBvc2VkUmFuZ2VzKHZpZXcucm9vdClbMF07XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBidWlsZFNlbGVjdGlvblJhbmdlRnJvbVJhbmdlKHZpZXcsIHJhbmdlKTtcbiAgICB9XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIxKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd3Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5jb250ZW50RE9NLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICByZXR1cm4gZm91bmQgPyBidWlsZFNlbGVjdGlvblJhbmdlRnJvbVJhbmdlKHZpZXcsIGZvdW5kKSA6IG51bGw7XG59XG5jbGFzcyBFZGl0Q29udGV4dE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgLy8gVGhlIGRvY3VtZW50IHdpbmRvdyBmb3Igd2hpY2ggdGhlIHRleHQgaW4gdGhlIGNvbnRleHQgaXNcbiAgICAgICAgLy8gbWFpbnRhaW5lZC4gRm9yIGxhcmdlIGRvY3VtZW50cywgdGhpcyBtYXkgYmUgc21hbGxlciB0aGFuIHRoZVxuICAgICAgICAvLyBlZGl0b3IgZG9jdW1lbnQuIFRoaXMgd2luZG93IGFsd2F5cyBpbmNsdWRlcyB0aGUgc2VsZWN0aW9uIGhlYWQuXG4gICAgICAgIHRoaXMuZnJvbSA9IDA7XG4gICAgICAgIHRoaXMudG8gPSAwO1xuICAgICAgICAvLyBXaGVuIGFwcGx5aW5nIGEgdHJhbnNhY3Rpb24sIHRoaXMgaXMgdXNlZCB0byBjb21wYXJlIHRoZSBjaGFuZ2VcbiAgICAgICAgLy8gbWFkZSB0byB0aGUgY29udGV4dCBjb250ZW50IHRvIHRoZSBjaGFuZ2UgaW4gdGhlIHRyYW5zYWN0aW9uIGluXG4gICAgICAgIC8vIG9yZGVyIHRvIG1ha2UgdGhlIG1pbmltYWwgY2hhbmdlcyB0byB0aGUgY29udGV4dCAoc2luY2UgdG91Y2hpbmdcbiAgICAgICAgLy8gdGhhdCBzb21ldGltZXMgYnJlYWtzIHNlcmllcyBvZiBtdWx0aXBsZSBlZGl0cyBtYWRlIGZvciBhIHNpbmdsZVxuICAgICAgICAvLyB1c2VyIGFjdGlvbiBvbiBzb21lIEFuZHJvaWQga2V5Ym9hcmRzKVxuICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCB0aGUgZmFjdCB0aGF0IEVkaXRDb250ZXh0IGRvZXMgbm90IHJlc3BvbmRcbiAgICAgICAgLy8gd2VsbCB0byBoYXZpbmcgaXRzIGNvbnRlbnQgdXBkYXRlZCBkdXJpbmcgYSBjb21wb3NpdGlvbiAoc2VlICMxNDcyKVxuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzZXRSYW5nZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLmVkaXRDb250ZXh0ID0gbmV3IHdpbmRvdy5FZGl0Q29udGV4dCh7XG4gICAgICAgICAgICB0ZXh0OiB2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyh0aGlzLmZyb20sIHRoaXMudG8pLFxuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHRoaXMudG9Db250ZXh0UG9zKE1hdGgubWF4KHRoaXMuZnJvbSwgTWF0aC5taW4odGhpcy50bywgdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IpKSksXG4gICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHRoaXMudG9Db250ZXh0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMudGV4dHVwZGF0ZSA9IGUgPT4ge1xuICAgICAgICAgICAgbGV0IG1haW4gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLCB7IGFuY2hvciwgaGVhZCB9ID0gbWFpbjtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy50b0VkaXRvclBvcyhlLnVwZGF0ZVJhbmdlU3RhcnQpLCB0byA9IHRoaXMudG9FZGl0b3JQb3MoZS51cGRhdGVSYW5nZUVuZCk7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmICF0aGlzLmNvbXBvc2luZylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IHsgY29udGV4dEJhc2U6IGUudXBkYXRlUmFuZ2VTdGFydCwgZWRpdG9yQmFzZTogZnJvbSwgZHJpZnRlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIGxldCBkZWxldGVzID0gdG8gLSBmcm9tID4gZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3aW5kb3cgZG9lc24ndCBpbmNsdWRlIHRoZSBhbmNob3IsIGFzc3VtZSBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBhZGphY2VudCB0byBhIHNpZGUgZ28gdXAgdG8gdGhlIGFuY2hvci5cbiAgICAgICAgICAgIGlmIChmcm9tID09IHRoaXMuZnJvbSAmJiBhbmNob3IgPCB0aGlzLmZyb20pXG4gICAgICAgICAgICAgICAgZnJvbSA9IGFuY2hvcjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvID09IHRoaXMudG8gJiYgYW5jaG9yID4gdGhpcy50bylcbiAgICAgICAgICAgICAgICB0byA9IGFuY2hvcjtcbiAgICAgICAgICAgIGxldCBkaWZmID0gZmluZERpZmYodmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0byksIGUudGV4dCwgKGRlbGV0ZXMgPyBtYWluLmZyb20gOiBtYWluLnRvKSAtIGZyb20sIGRlbGV0ZXMgPyBcImVuZFwiIDogbnVsbCk7XG4gICAgICAgICAgICAvLyBFZGl0IGNvbnRleHRzIHNvbWV0aW1lcyBmaXJlIGVtcHR5IGNoYW5nZXNcbiAgICAgICAgICAgIGlmICghZGlmZikge1xuICAgICAgICAgICAgICAgIGxldCBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKHRoaXMudG9FZGl0b3JQb3MoZS5zZWxlY3Rpb25TdGFydCksIHRoaXMudG9FZGl0b3JQb3MoZS5zZWxlY3Rpb25FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld1NlbC5tYWluLmVxKG1haW4pKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hhbmdlID0geyBmcm9tOiBkaWZmLmZyb20gKyBmcm9tLCB0bzogZGlmZi50b0EgKyBmcm9tLFxuICAgICAgICAgICAgICAgIGluc2VydDogVGV4dC5vZihlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikuc3BsaXQoXCJcXG5cIikpIH07XG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIubWFjIHx8IGJyb3dzZXIuYW5kcm9pZCkgJiYgY2hhbmdlLmZyb20gPT0gaGVhZCAtIDEgJiZcbiAgICAgICAgICAgICAgICAvXlxcLiA/JC8udGVzdChlLnRleHQpICYmIHZpZXcuY29udGVudERPTS5nZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiKSA9PSBcIm9mZlwiKVxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZihbZS50ZXh0LnJlcGxhY2UoXCIuXCIsIFwiIFwiKV0pIH07XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gY2hhbmdlO1xuICAgICAgICAgICAgaWYgKCF2aWV3LnN0YXRlLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xlbiA9IHRoaXMudG8gLSB0aGlzLmZyb20gKyAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYXBwbHlET01DaGFuZ2VJbm5lcih2aWV3LCBjaGFuZ2UsIEVkaXRvclNlbGVjdGlvbi5zaW5nbGUodGhpcy50b0VkaXRvclBvcyhlLnNlbGVjdGlvblN0YXJ0LCBuZXdMZW4pLCB0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uRW5kLCBuZXdMZW4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gZGlkbid0IGZsdXNoIG91ciBjaGFuZ2UsIHJldmVydCBpdCBzb1xuICAgICAgICAgICAgLy8gdGhhdCB0aGUgY29udGV4dCBpcyBpbiBzeW5jIHdpdGggdGhlIGVkaXRvciBzdGF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXZlcnRQZW5kaW5nKHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgbWlzc2VkIGNvbXBvc2l0aW9uZW5kIGV2ZW50cy4gU2VlIGh0dHBzOi8vZGlzY3Vzcy5jb2RlbWlycm9yLm5ldC90L2EvOTUxNFxuICAgICAgICAgICAgaWYgKGNoYW5nZS5mcm9tIDwgY2hhbmdlLnRvICYmICFjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiZcbiAgICAgICAgICAgICAgICAhL1tcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXS8udGVzdChjb250ZXh0LnRleHQuc2xpY2UoTWF0aC5tYXgoMCwgZS51cGRhdGVSYW5nZVN0YXJ0IC0gMSksIE1hdGgubWluKGNvbnRleHQudGV4dC5sZW5ndGgsIGUudXBkYXRlUmFuZ2VTdGFydCArIDEpKSkpXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5jb21wb3NpdGlvbmVuZChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jaGFyYWN0ZXJib3VuZHN1cGRhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGxldCByZWN0cyA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnRvRWRpdG9yUG9zKGUucmFuZ2VTdGFydCksIGVuZCA9IHRoaXMudG9FZGl0b3JQb3MoZS5yYW5nZUVuZCk7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdmlldy5jb29yZHNGb3JDaGFyKGkpO1xuICAgICAgICAgICAgICAgIHByZXYgPSAocmVjdCAmJiBuZXcgRE9NUmVjdChyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCByZWN0LmJvdHRvbSAtIHJlY3QudG9wKSlcbiAgICAgICAgICAgICAgICAgICAgfHwgcHJldiB8fCBuZXcgRE9NUmVjdDtcbiAgICAgICAgICAgICAgICByZWN0cy5wdXNoKHByZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC51cGRhdGVDaGFyYWN0ZXJCb3VuZHMoZS5yYW5nZVN0YXJ0LCByZWN0cyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlcnMudGV4dGZvcm1hdHVwZGF0ZSA9IGUgPT4ge1xuICAgICAgICAgICAgbGV0IGRlY28gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGZvcm1hdCBvZiBlLmdldFRleHRGb3JtYXRzKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZVN0eWxlID0gZm9ybWF0LnVuZGVybGluZVN0eWxlLCB0aGlja25lc3MgPSBmb3JtYXQudW5kZXJsaW5lVGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIGlmICghL25vbmUvaS50ZXN0KGxpbmVTdHlsZSkgJiYgIS9ub25lL2kudGVzdCh0aGlja25lc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy50b0VkaXRvclBvcyhmb3JtYXQucmFuZ2VTdGFydCksIHRvID0gdGhpcy50b0VkaXRvclBvcyhmb3JtYXQucmFuZ2VFbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSB2YWx1ZXMgY2hhbmdlZCBmcm9tIGNhcGl0YWxpemVkIGN1c3RvbSBzdHJpbmdzIHRvIGxvd2VyLWNhc2UgQ1NTIGtleXdvcmRzIGluIDIwMjVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IGB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSAkey9eW2Etel0vLnRlc3QobGluZVN0eWxlKSA/IGxpbmVTdHlsZSArIFwiIFwiIDogbGluZVN0eWxlID09IFwiRGFzaGVkXCIgPyBcImRhc2hlZCBcIiA6IGxpbmVTdHlsZSA9PSBcIlNxdWlnZ2xlXCIgPyBcIndhdnkgXCIgOiBcIlwifSR7L3RoaW4vaS50ZXN0KHRoaWNrbmVzcykgPyAxIDogMn1weGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2goRGVjb3JhdGlvbi5tYXJrKHsgYXR0cmlidXRlczogeyBzdHlsZSB9IH0pLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RWRpdENvbnRleHRGb3JtYXR0aW5nLm9mKERlY29yYXRpb24uc2V0KGRlY28pKSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZHJpZnRlZCB9ID0gdGhpcy5jb21wb3Npbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChkcmlmdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiB0aGlzLmhhbmRsZXJzKVxuICAgICAgICAgICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZXJzW2V2ZW50XSk7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVDb250cm9sQm91bmRzKHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgJiYgc2VsLnJhbmdlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlU2VsZWN0aW9uQm91bmRzKHNlbC5nZXRSYW5nZUF0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgIH0gfTtcbiAgICB9XG4gICAgYXBwbHlFZGl0cyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IG9mZiA9IDAsIGFib3J0ID0gZmFsc2UsIHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlO1xuICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoZnJvbUEsIHRvQSwgX2Zyb21CLCBfdG9CLCBpbnNlcnQpID0+IHtcbiAgICAgICAgICAgIGlmIChhYm9ydClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZExlbiA9IGluc2VydC5sZW5ndGggLSAodG9BIC0gZnJvbUEpO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcgJiYgdG9BID49IHBlbmRpbmcudG8pIHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZy5mcm9tID09IGZyb21BICYmIHBlbmRpbmcudG8gPT0gdG9BICYmIHBlbmRpbmcuaW5zZXJ0LmVxKGluc2VydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZyA9IHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsOyAvLyBNYXRjaFxuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZExlbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byArPSBkTGVuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBNaXNtYXRjaCwgcmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tQSArPSBvZmY7XG4gICAgICAgICAgICB0b0EgKz0gb2ZmO1xuICAgICAgICAgICAgaWYgKHRvQSA8PSB0aGlzLmZyb20pIHsgLy8gQmVmb3JlIHRoZSB3aW5kb3dcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gKz0gZExlbjtcbiAgICAgICAgICAgICAgICB0aGlzLnRvICs9IGRMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQSA8IHRoaXMudG8pIHsgLy8gT3ZlcmxhcHMgd2l0aCB3aW5kb3dcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUEgPCB0aGlzLmZyb20gfHwgdG9BID4gdGhpcy50byB8fCAodGhpcy50byAtIHRoaXMuZnJvbSkgKyBpbnNlcnQubGVuZ3RoID4gMzAwMDAgLyogQ3hWcC5NYXhTaXplICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVRleHQodGhpcy50b0NvbnRleHRQb3MoZnJvbUEpLCB0aGlzLnRvQ29udGV4dFBvcyh0b0EpLCBpbnNlcnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy50byArPSBkTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmICs9IGRMZW47XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGVuZGluZyAmJiAhYWJvcnQpXG4gICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuICFhYm9ydDtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcmV2ZXJ0ZWQgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlLCBzdGFydFNlbCA9IHVwZGF0ZS5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbXBvc2luZy5kcmlmdGVkIHx8XG4gICAgICAgICAgICAgICAgKCF1cGRhdGUuY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnRTZWwuZnJvbSwgc3RhcnRTZWwudG8pICYmXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50bykpKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nLmRyaWZ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcuZWRpdG9yQmFzZSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbXBvc2luZy5lZGl0b3JCYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5hcHBseUVkaXRzKHVwZGF0ZSkgfHwgIXRoaXMucmFuZ2VJc1ZhbGlkKHVwZGF0ZS5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNldCh1cGRhdGUuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgcmV2ZXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHVwZGF0ZS52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgfVxuICAgIHJlc2V0UmFuZ2Uoc3RhdGUpIHtcbiAgICAgICAgbGV0IHsgaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIHRoaXMuZnJvbSA9IE1hdGgubWF4KDAsIGhlYWQgLSAxMDAwMCAvKiBDeFZwLk1hcmdpbiAqLyk7XG4gICAgICAgIHRoaXMudG8gPSBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBoZWFkICsgMTAwMDAgLyogQ3hWcC5NYXJnaW4gKi8pO1xuICAgIH1cbiAgICByZXNldChzdGF0ZSkge1xuICAgICAgICB0aGlzLnJlc2V0UmFuZ2Uoc3RhdGUpO1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVRleHQoMCwgdGhpcy5lZGl0Q29udGV4dC50ZXh0Lmxlbmd0aCwgc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHRoaXMuZnJvbSwgdGhpcy50bykpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzdGF0ZSk7XG4gICAgfVxuICAgIHJldmVydFBlbmRpbmcoc3RhdGUpIHtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlO1xuICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVUZXh0KHRoaXMudG9Db250ZXh0UG9zKHBlbmRpbmcuZnJvbSksIHRoaXMudG9Db250ZXh0UG9zKHBlbmRpbmcuZnJvbSArIHBlbmRpbmcuaW5zZXJ0Lmxlbmd0aCksIHN0YXRlLmRvYy5zbGljZVN0cmluZyhwZW5kaW5nLmZyb20sIHBlbmRpbmcudG8pKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKHN0YXRlKSB7XG4gICAgICAgIGxldCB7IG1haW4gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy50b0NvbnRleHRQb3MoTWF0aC5tYXgodGhpcy5mcm9tLCBNYXRoLm1pbih0aGlzLnRvLCBtYWluLmFuY2hvcikpKTtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMudG9Db250ZXh0UG9zKG1haW4uaGVhZCk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRDb250ZXh0LnNlbGVjdGlvblN0YXJ0ICE9IHN0YXJ0IHx8IHRoaXMuZWRpdENvbnRleHQuc2VsZWN0aW9uRW5kICE9IGVuZClcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlU2VsZWN0aW9uKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICByYW5nZUlzVmFsaWQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHsgaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIHJldHVybiAhKHRoaXMuZnJvbSA+IDAgJiYgaGVhZCAtIHRoaXMuZnJvbSA8IDUwMCAvKiBDeFZwLk1pbk1hcmdpbiAqLyB8fFxuICAgICAgICAgICAgdGhpcy50byA8IHN0YXRlLmRvYy5sZW5ndGggJiYgdGhpcy50byAtIGhlYWQgPCA1MDAgLyogQ3hWcC5NaW5NYXJnaW4gKi8gfHxcbiAgICAgICAgICAgIHRoaXMudG8gLSB0aGlzLmZyb20gPiAxMDAwMCAvKiBDeFZwLk1hcmdpbiAqLyAqIDMpO1xuICAgIH1cbiAgICB0b0VkaXRvclBvcyhjb250ZXh0UG9zLCBjbGlwTGVuID0gdGhpcy50byAtIHRoaXMuZnJvbSkge1xuICAgICAgICBjb250ZXh0UG9zID0gTWF0aC5taW4oY29udGV4dFBvcywgY2xpcExlbik7XG4gICAgICAgIGxldCBjID0gdGhpcy5jb21wb3Npbmc7XG4gICAgICAgIHJldHVybiBjICYmIGMuZHJpZnRlZCA/IGMuZWRpdG9yQmFzZSArIChjb250ZXh0UG9zIC0gYy5jb250ZXh0QmFzZSkgOiBjb250ZXh0UG9zICsgdGhpcy5mcm9tO1xuICAgIH1cbiAgICB0b0NvbnRleHRQb3MoZWRpdG9yUG9zKSB7XG4gICAgICAgIGxldCBjID0gdGhpcy5jb21wb3Npbmc7XG4gICAgICAgIHJldHVybiBjICYmIGMuZHJpZnRlZCA/IGMuY29udGV4dEJhc2UgKyAoZWRpdG9yUG9zIC0gYy5lZGl0b3JCYXNlKSA6IGVkaXRvclBvcyAtIHRoaXMuZnJvbTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gdGhpcy5oYW5kbGVycylcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVyc1tldmVudF0pO1xuICAgIH1cbn1cblxuLy8gVGhlIGVkaXRvcidzIHVwZGF0ZSBzdGF0ZSBtYWNoaW5lIGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gICAgIElkbGUg4oaSIFVwZGF0aW5nIOKHhiBJZGxlICh1bmNoZWNrZWQpIOKGkiBNZWFzdXJpbmcg4oaSIElkbGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgICAgICDihpNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGluZyAobWVhc3VyZSlcbi8vXG4vLyBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdJZGxlJyBhbmQgJ0lkbGUgKHVuY2hlY2tlZCknIGxpZXMgaW5cbi8vIHdoZXRoZXIgYSBsYXlvdXQgY2hlY2sgaGFzIGJlZW4gc2NoZWR1bGVkLiBBIHJlZ3VsYXIgdXBkYXRlIHRocm91Z2hcbi8vIHRoZSBgdXBkYXRlYCBtZXRob2QgdXBkYXRlcyB0aGUgRE9NIGluIGEgd3JpdGUtb25seSBmYXNoaW9uLCBhbmRcbi8vIHJlbGllcyBvbiBhIGNoZWNrIChzY2hlZHVsZWQgd2l0aCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCkgdG8gbWFrZVxuLy8gc3VyZSBldmVyeXRoaW5nIGlzIHdoZXJlIGl0IHNob3VsZCBiZSBhbmQgdGhlIHZpZXdwb3J0IGNvdmVycyB0aGVcbi8vIHZpc2libGUgY29kZS4gVGhhdCBjaGVjayBjb250aW51ZXMgdG8gbWVhc3VyZSBhbmQgdGhlbiBvcHRpb25hbGx5XG4vLyB1cGRhdGUgdW50aWwgaXQgcmVhY2hlcyBhIGNvaGVyZW50IHN0YXRlLlxuLyoqXG5BbiBlZGl0b3IgdmlldyByZXByZXNlbnRzIHRoZSBlZGl0b3IncyB1c2VyIGludGVyZmFjZS4gSXQgaG9sZHNcbnRoZSBlZGl0YWJsZSBET00gc3VyZmFjZSwgYW5kIHBvc3NpYmx5IG90aGVyIGVsZW1lbnRzIHN1Y2ggYXMgdGhlXG5saW5lIG51bWJlciBndXR0ZXIuIEl0IGhhbmRsZXMgZXZlbnRzIGFuZCBkaXNwYXRjaGVzIHN0YXRlXG50cmFuc2FjdGlvbnMgZm9yIGVkaXRpbmcgYWN0aW9ucy5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zdGF0ZTsgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGlzcGxheSBsYXJnZSBkb2N1bWVudHMgd2l0aG91dCBjb25zdW1pbmcgdG9vIG11Y2hcbiAgICBtZW1vcnkgb3Igb3ZlcmxvYWRpbmcgdGhlIGJyb3dzZXIsIENvZGVNaXJyb3Igb25seSBkcmF3cyB0aGVcbiAgICBjb2RlIHRoYXQgaXMgdmlzaWJsZSAocGx1cyBhIG1hcmdpbiBhcm91bmQgaXQpIHRvIHRoZSBET00uIFRoaXNcbiAgICBwcm9wZXJ0eSB0ZWxscyB5b3UgdGhlIGV4dGVudCBvZiB0aGUgY3VycmVudCBkcmF3biB2aWV3cG9ydCwgaW5cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgYXJlLCBmb3IgZXhhbXBsZSwgbGFyZ2UgY29sbGFwc2VkIHJhbmdlcyBpbiB0aGVcbiAgICB2aWV3cG9ydCwgaXRzIHNpemUgY2FuIGJlIGEgbG90IGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgdmlzaWJsZVxuICAgIGNvbnRlbnQuIFRodXMsIGlmIHlvdSBhcmUgZG9pbmcgc29tZXRoaW5nIGxpa2Ugc3R5bGluZyB0aGVcbiAgICBjb250ZW50IGluIHRoZSB2aWV3cG9ydCwgaXQgaXMgcHJlZmVyYWJsZSB0byBvbmx5IGRvIHNvIGZvclxuICAgIHRoZXNlIHJhbmdlcywgd2hpY2ggYXJlIHRoZSBzdWJzZXQgb2YgdGhlIHZpZXdwb3J0IHRoYXQgaXNcbiAgICBhY3R1YWxseSBkcmF3bi5cbiAgICAqL1xuICAgIGdldCB2aXNpYmxlUmFuZ2VzKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlzaWJsZVJhbmdlczsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgZWRpdG9yIGlzIGVudGlyZWx5IHNjcm9sbGVkIG91dCBvZiB2aWV3XG4gICAgb3Igb3RoZXJ3aXNlIGhpZGRlbi5cbiAgICAqL1xuICAgIGdldCBpblZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5pblZpZXc7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgY29tcG9zaW5nIHRleHQgdmlhXG4gICAgW0lNRV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5wdXRfbWV0aG9kKSwgYW5kIGF0IGxlYXN0XG4gICAgb25lIGNoYW5nZSBoYXMgYmVlbiBtYWRlIGluIHRoZSBjdXJyZW50IGNvbXBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuICEhdGhpcy5pbnB1dFN0YXRlICYmIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGluIGNvbXBvc2luZyBzdGF0ZS4gTm90ZVxuICAgIHRoYXQgb24gc29tZSBwbGF0Zm9ybXMsIGxpa2UgQW5kcm9pZCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIGFcbiAgICBsb3QsIHNpbmNlIGp1c3QgcHV0dGluZyB0aGUgY3Vyc29yIG9uIGEgd29yZCBzdGFydHMgYVxuICAgIGNvbXBvc2l0aW9uIHRoZXJlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2l0aW9uU3RhcnRlZCgpIHsgcmV0dXJuICEhdGhpcy5pbnB1dFN0YXRlICYmIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMDsgfVxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBvciBzaGFkb3cgcm9vdCB0aGF0IHRoZSB2aWV3IGxpdmVzIGluLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLl9yb290OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2luKCkgeyByZXR1cm4gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IH1cbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdmlldy4gWW91J2xsIHdhbnQgdG8gZWl0aGVyIHByb3ZpZGUgYSBgcGFyZW50YFxuICAgIG9wdGlvbiwgb3IgcHV0IGB2aWV3LmRvbWAgaW50byB5b3VyIGRvY3VtZW50IGFmdGVyIGNyZWF0aW5nIGFcbiAgICB2aWV3LCBzbyB0aGF0IHRoZSB1c2VyIGNhbiBzZWUgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luTWFwID0gbmV3IE1hcDtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzID0gW107XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00udGFiSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uY2xhc3NOYW1lID0gXCJjbS1zY3JvbGxlclwiO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5jbGFzc05hbWUgPSBcImNtLWFubm91bmNlZFwiO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmFubm91bmNlRE9NKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxET00pO1xuICAgICAgICBpZiAoY29uZmlnLnBhcmVudClcbiAgICAgICAgICAgIGNvbmZpZy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICBsZXQgeyBkaXNwYXRjaCB9ID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zID0gY29uZmlnLmRpc3BhdGNoVHJhbnNhY3Rpb25zIHx8XG4gICAgICAgICAgICAoZGlzcGF0Y2ggJiYgKCh0cnMpID0+IHRycy5mb3JFYWNoKHRyID0+IGRpc3BhdGNoKHRyLCB0aGlzKSkpKSB8fFxuICAgICAgICAgICAgKCh0cnMpID0+IHRoaXMudXBkYXRlKHRycykpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yb290ID0gKGNvbmZpZy5yb290IHx8IGdldFJvb3QoY29uZmlnLnBhcmVudCkgfHwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUoY29uZmlnLnN0YXRlIHx8IEVkaXRvclN0YXRlLmNyZWF0ZShjb25maWcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5zY3JvbGxUbyAmJiBjb25maWcuc2Nyb2xsVG8uaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gY29uZmlnLnNjcm9sbFRvLnZhbHVlLmNsaXAodGhpcy52aWV3U3RhdGUuc3RhdGUpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAoKF9hID0gZG9jdW1lbnQuZm9udHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeSlcbiAgICAgICAgICAgIGRvY3VtZW50LmZvbnRzLnJlYWR5LnRoZW4oKCkgPT4gdGhpcy5yZXF1ZXN0TWVhc3VyZSgpKTtcbiAgICB9XG4gICAgZGlzcGF0Y2goLi4uaW5wdXQpIHtcbiAgICAgICAgbGV0IHRycyA9IGlucHV0Lmxlbmd0aCA9PSAxICYmIGlucHV0WzBdIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24gPyBpbnB1dFxuICAgICAgICAgICAgOiBpbnB1dC5sZW5ndGggPT0gMSAmJiBBcnJheS5pc0FycmF5KGlucHV0WzBdKSA/IGlucHV0WzBdXG4gICAgICAgICAgICAgICAgOiBbdGhpcy5zdGF0ZS51cGRhdGUoLi4uaW5wdXQpXTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9ucyh0cnMsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiB0cmFuc2FjdGlvbnMuIFRoaXMgd2lsbFxuICAgIHVwZGF0ZSB0aGUgdmlzaWJsZSBkb2N1bWVudCBhbmQgc2VsZWN0aW9uIHRvIG1hdGNoIHRoZSBzdGF0ZVxuICAgIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbnMsIGFuZCBub3RpZnkgdmlldyBwbHVnaW5zIG9mIHRoZVxuICAgIGNoYW5nZS4gWW91IHNob3VsZCB1c3VhbGx5IGNhbGxcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQsIHdoaWNoIHVzZXMgdGhpc1xuICAgIGFzIGEgcHJpbWl0aXZlLlxuICAgICovXG4gICAgdXBkYXRlKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnVwZGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBsZXQgcmVkcmF3biA9IGZhbHNlLCBhdHRyc0NoYW5nZWQgPSBmYWxzZSwgdXBkYXRlO1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0ci5zdGFydFN0YXRlICE9IHN0YXRlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIHVwZGF0ZSBzdGF0ZSB3aXRoIGEgdHJhbnNhY3Rpb24gdGhhdCBkb2Vzbid0IHN0YXJ0IGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLlwiKTtcbiAgICAgICAgICAgIHN0YXRlID0gdHIuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb2N1cyA9IHRoaXMuaGFzRm9jdXMsIGZvY3VzRmxhZyA9IDAsIGRpc3BhdGNoRm9jdXMgPSBudWxsO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuYW5ub3RhdGlvbihpc0ZvY3VzQ2hhbmdlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIC8vIElmIGEgZm9jdXMtY2hhbmdlIHRyYW5zYWN0aW9uIGlzIGJlaW5nIGRpc3BhdGNoZWQsIHNldCB0aGlzIHVwZGF0ZSBmbGFnLlxuICAgICAgICAgICAgZm9jdXNGbGFnID0gMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvY3VzICE9IHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgc2VwYXJhdGUgZm9jdXMgdHJhbnNhY3Rpb24gaWYgbmVjZXNzYXJ5LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFkZCBhIGZsYWcgdG8gdGhpcyB1cGRhdGVcbiAgICAgICAgICAgIGRpc3BhdGNoRm9jdXMgPSBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHN0YXRlLCBmb2N1cyk7XG4gICAgICAgICAgICBpZiAoIWRpc3BhdGNoRm9jdXMpXG4gICAgICAgICAgICAgICAgZm9jdXNGbGFnID0gMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHBlbmRpbmcgRE9NIGNoYW5nZSwgZWFnZXJseSByZWFkIGl0IGFuZCB0cnkgdG9cbiAgICAgICAgLy8gYXBwbHkgaXQgYWZ0ZXIgdGhlIGdpdmVuIHRyYW5zYWN0aW9ucy5cbiAgICAgICAgbGV0IHBlbmRpbmdLZXkgPSB0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5LCBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAocGVuZGluZ0tleSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XG4gICAgICAgICAgICBkb21DaGFuZ2UgPSB0aGlzLm9ic2VydmVyLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJ5IHRvIGFwcGx5IERPTSBjaGFuZ2VzIGlmIHRoZSB0cmFuc2FjdGlvbnMgZGlkbid0XG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIGRvYyBvciBzZWxlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZG9tQ2hhbmdlICYmICF0aGlzLnN0YXRlLmRvYy5lcShzdGF0ZS5kb2MpIHx8ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgcGhyYXNlcyBjaGFuZ2UsIHJlZHJhdyB0aGUgZWRpdG9yXG4gICAgICAgIGlmIChzdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSAhPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGZvY3VzRmxhZztcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldCA9IHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0Lm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAodHIuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgbWFpbiB9ID0gdHIuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBuZXcgU2Nyb2xsVGFyZ2V0KG1haW4uZW1wdHkgPyBtYWluIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihtYWluLmhlYWQsIG1haW4uaGVhZCA+IG1haW4uYW5jaG9yID8gLTEgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gZS52YWx1ZS5jbGlwKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUudXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gQ2FjaGVkT3JkZXIudXBkYXRlKHRoaXMuYmlkaUNhY2hlLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSkgIT0gdGhpcy5zdHlsZU1vZHVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgYXR0cnNDaGFuZ2VkID0gdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5zaG93QW5ub3VuY2VtZW50cyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbihyZWRyYXduLCB0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcInNlbGVjdC5wb2ludGVyXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh0aGVtZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoZW1lKSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWRyYXduIHx8IGF0dHJzQ2hhbmdlZCB8fCBzY3JvbGxUYXJnZXQgfHwgdGhpcy52aWV3U3RhdGUubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgdGhpcy5kb2NWaWV3VXBkYXRlKCk7XG4gICAgICAgIGlmICghdXBkYXRlLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSwgXCJ1cGRhdGUgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGF0Y2hGb2N1cyB8fCBkb21DaGFuZ2UpXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2hGb2N1cyAmJiB0aGlzLnN0YXRlID09IGRpc3BhdGNoRm9jdXMuc3RhcnRTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChkaXNwYXRjaEZvY3VzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXBwbHlET01DaGFuZ2UodGhpcywgZG9tQ2hhbmdlKSAmJiBwZW5kaW5nS2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5jb250ZW50RE9NLCBwZW5kaW5nS2V5LmtleSwgcGVuZGluZ0tleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgdGhlIHZpZXcgdG8gdGhlIGdpdmVuIHN0YXRlLiAoVGhpcyB3aWxsIGNhdXNlIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudCB0byBiZSByZWRyYXduIGFuZCBhbGwgdmlldyBwbHVnaW5zIHRvIGJlIHJlaW5pdGlhbGl6ZWQsXG4gICAgc28geW91IHNob3VsZCBwcm9iYWJseSBvbmx5IHVzZSBpdCB3aGVuIHRoZSBuZXcgc3RhdGUgaXNuJ3RcbiAgICBkZXJpdmVkIGZyb20gdGhlIG9sZCBzdGF0ZS4gT3RoZXJ3aXNlLCB1c2VcbiAgICBbYGRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpIGluc3RlYWQuKVxuICAgICovXG4gICAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy5zZXRTdGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIGxldCBoYWRGb2N1cyA9IHRoaXMuaGFzRm9jdXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1N0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFkRm9jdXMpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbaV0udXBkYXRlKHRoaXMpO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgfVxuICAgIGRvY1ZpZXdVcGRhdGUoKSB7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBwbHVnaW4udmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbC5kb2NWaWV3VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRvY1ZpZXdVcGRhdGUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlLCBcImRvYyB2aWV3IHVwZGF0ZSBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtZWFzdXJlKGZsdXNoID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBsZXQgc0RPTSA9IHRoaXMuc2Nyb2xsRE9NLCBzY3JvbGxUb3AgPSBzRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgeyBzY3JvbGxBbmNob3JQb3MsIHNjcm9sbEFuY2hvckhlaWdodCB9ID0gdGhpcy52aWV3U3RhdGU7XG4gICAgICAgIGlmIChNYXRoLmFicyhzY3JvbGxUb3AgLSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUb3ApID4gMSlcbiAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEFuY2hvckhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsZWRUb0JvdHRvbShzRE9NKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IGJsb2NrLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDEgLyogVXBkYXRlU3RhdGUuTWVhc3VyaW5nICovO1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy52aWV3U3RhdGUubWVhc3VyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgIXRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCAmJiB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJNZWFzdXJlIGxvb3AgcmVzdGFydGVkIG1vcmUgdGhhbiA1IHRpbWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJWaWV3cG9ydCBmYWlsZWQgdG8gc3RhYmlsaXplXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmluZyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIG1lYXN1cmUgcmVxdWVzdHMgaW4gdGhpcyBjeWNsZSB3aGVuIHRoZSB2aWV3cG9ydCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhbmdlZCAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykpXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLm1lYXN1cmVSZXF1ZXN0cywgbWVhc3VyaW5nXSA9IFttZWFzdXJpbmcsIHRoaXMubWVhc3VyZVJlcXVlc3RzXTtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZWQgPSBtZWFzdXJpbmcubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ucmVhZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhZE1lYXN1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgdGhpcy5zdGF0ZSwgW10pLCByZWRyYXduID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXdVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZFtpXSAhPSBCYWRNZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWVhc3VyaW5nW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLndyaXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLndyaXRlKG1lYXN1cmVkW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUudmlld3BvcnRDaGFuZ2VkICYmIHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuc2Nyb2xsSW50b1ZpZXcodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0FuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvclBvcyA8IDAgPyB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQoc2Nyb2xsQW5jaG9yUG9zKS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBuZXdBbmNob3JIZWlnaHQgLSBzY3JvbGxBbmNob3JIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAxIHx8IGRpZmYgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgKyBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzRE9NLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCAvIHRoaXMuc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCAmJiAhdXBkYXRlZC5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIENTUyBjbGFzc2VzIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3IgdGhlbWVzLlxuICAgICovXG4gICAgZ2V0IHRoZW1lQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VUaGVtZUlEICsgXCIgXCIgK1xuICAgICAgICAgICAgKHRoaXMuc3RhdGUuZmFjZXQoZGFya1RoZW1lKSA/IGJhc2VEYXJrSUQgOiBiYXNlTGlnaHRJRCkgKyBcIiBcIiArXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZhY2V0KHRoZW1lKTtcbiAgICB9XG4gICAgdXBkYXRlQXR0cnMoKSB7XG4gICAgICAgIGxldCBlZGl0b3JBdHRycyA9IGF0dHJzRnJvbUZhY2V0KHRoaXMsIGVkaXRvckF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWVkaXRvclwiICsgKHRoaXMuaGFzRm9jdXMgPyBcIiBjbS1mb2N1c2VkIFwiIDogXCIgXCIpICsgdGhpcy50aGVtZUNsYXNzZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb250ZW50QXR0cnMgPSB7XG4gICAgICAgICAgICBzcGVsbGNoZWNrOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBhdXRvY29ycmVjdDogXCJvZmZcIixcbiAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiBcIm9mZlwiLFxuICAgICAgICAgICAgd3JpdGluZ3N1Z2dlc3Rpb25zOiBcImZhbHNlXCIsXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFwibm9cIixcbiAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogIXRoaXMuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gXCJmYWxzZVwiIDogXCJ0cnVlXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1jb250ZW50XCIsXG4gICAgICAgICAgICBzdHlsZTogYCR7YnJvd3Nlci50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcbiAgICAgICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiBcInRydWVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIGNvbnRlbnRBdHRyc1tcImFyaWEtcmVhZG9ubHlcIl0gPSBcInRydWVcIjtcbiAgICAgICAgYXR0cnNGcm9tRmFjZXQodGhpcywgY29udGVudEF0dHJpYnV0ZXMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRDb250ZW50ID0gdXBkYXRlQXR0cnModGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgY29udGVudEF0dHJzKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkRWRpdG9yID0gdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMuZWRpdG9yQXR0cnMsIGVkaXRvckF0dHJzKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkQ29udGVudCB8fCBjaGFuZ2VkRWRpdG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IGVkaXRvckF0dHJzO1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IGNvbnRlbnRBdHRycztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIHNob3dBbm5vdW5jZW1lbnRzKHRycykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKEVkaXRvclZpZXcuYW5ub3VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VET00udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5hbm5vdW5jZURPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbW91bnRTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNb2R1bGVzID0gdGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSk7XG4gICAgICAgIGxldCBub25jZSA9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5jc3BOb25jZSk7XG4gICAgICAgIFN0eWxlTW9kdWxlLm1vdW50KHRoaXMucm9vdCwgdGhpcy5zdHlsZU1vZHVsZXMuY29uY2F0KGJhc2VUaGVtZSQxKS5yZXZlcnNlKCksIG5vbmNlID8geyBub25jZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmVkKCkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhZGluZyB0aGUgZWRpdG9yIGxheW91dCBpc24ndCBhbGxvd2VkIGR1cmluZyBhbiB1cGRhdGVcIik7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLyAmJiB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZShmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNjaGVkdWxlIGEgbGF5b3V0IG1lYXN1cmVtZW50LCBvcHRpb25hbGx5IHByb3ZpZGluZyBjYWxsYmFja3MgdG9cbiAgICBkbyBjdXN0b20gRE9NIG1lYXN1cmluZyBmb2xsb3dlZCBieSBhIERPTSB3cml0ZSBwaGFzZS4gVXNpbmdcbiAgICB0aGlzIGlzIHByZWZlcmFibGUgcmVhZGluZyBET00gbGF5b3V0IGRpcmVjdGx5IGZyb20sIGZvclxuICAgIGV4YW1wbGUsIGFuIGV2ZW50IGhhbmRsZXIsIGJlY2F1c2UgaXQnbGwgbWFrZSBzdXJlIG1lYXN1cmluZyBhbmRcbiAgICBkcmF3aW5nIGRvbmUgYnkgb3RoZXIgY29tcG9uZW50cyBpcyBzeW5jaHJvbml6ZWQsIGF2b2lkaW5nXG4gICAgdW5uZWNlc3NhcnkgRE9NIGxheW91dCBjb21wdXRhdGlvbnMuXG4gICAgKi9cbiAgICByZXF1ZXN0TWVhc3VyZShyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPCAwKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gdGhpcy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMubWVhc3VyZSgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHNbaV0ua2V5ID09PSByZXF1ZXN0LmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHNbaV0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgcGx1Z2luLCBpZiBwcmVzZW50LiBOb3RlIHRoYXRcbiAgICBwbHVnaW5zIHRoYXQgY3Jhc2ggY2FuIGJlIGRyb3BwZWQgZnJvbSBhIHZpZXcsIHNvIGV2ZW4gd2hlbiB5b3VcbiAgICBrbm93IHlvdSByZWdpc3RlcmVkIGEgZ2l2ZW4gcGx1Z2luLCBpdCBpcyByZWNvbW1lbmRlZCB0byBjaGVja1xuICAgIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBtZXRob2QuXG4gICAgKi9cbiAgICBwbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGxldCBrbm93biA9IHRoaXMucGx1Z2luTWFwLmdldChwbHVnaW4pO1xuICAgICAgICBpZiAoa25vd24gPT09IHVuZGVmaW5lZCB8fCBrbm93biAmJiBrbm93bi5wbHVnaW4gIT0gcGx1Z2luKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuc2V0KHBsdWdpbiwga25vd24gPSB0aGlzLnBsdWdpbnMuZmluZChwID0+IHAucGx1Z2luID09IHBsdWdpbikgfHwgbnVsbCk7XG4gICAgICAgIHJldHVybiBrbm93biAmJiBrbm93bi51cGRhdGUodGhpcykudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50LCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFRoaXNcbiAgICBtYXkgYmUgbmVnYXRpdmUgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGVkIGRvd24uIFBvaW50c1xuICAgIGRpcmVjdGx5IHRvIHRoZSB0b3Agb2YgdGhlIGZpcnN0IGxpbmUsIG5vdCBhYm92ZSB0aGUgcGFkZGluZy5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBvcnRzIHRoZSBwYWRkaW5nIGFib3ZlIGFuZCBiZWxvdyB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3AsIGJvdHRvbTogdGhpcy52aWV3U3RhdGUucGFkZGluZ0JvdHRvbSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGUgZWRpdG9yIGlzIHRyYW5zZm9ybWVkIHdpdGggQ1NTLCB0aGlzIHByb3ZpZGVzIHRoZSBzY2FsZVxuICAgIGFsb25nIHRoZSBYIGF4aXMuIE90aGVyd2lzZSwgaXQgd2lsbCBqdXN0IGJlIDEuIE5vdGUgdGhhdFxuICAgIHRyYW5zZm9ybXMgb3RoZXIgdGhhbiB0cmFuc2xhdGlvbiBhbmQgc2NhbGluZyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAqL1xuICAgIGdldCBzY2FsZVgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVg7IH1cbiAgICAvKipcbiAgICBQcm92aWRlIHRoZSBDU1MgdHJhbnNmb3JtZWQgc2NhbGUgYWxvbmcgdGhlIFkgYXhpcy5cbiAgICAqL1xuICAgIGdldCBzY2FsZVkoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVk7IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGxpbmUgb3IgYmxvY2sgd2lkZ2V0IGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbFxuICAgIHBvc2l0aW9uICh3aGljaCBpcyBpbnRlcnByZXRlZCBhcyByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApKS5cbiAgICAqL1xuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmVsZW1lbnRBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIChzZWVcbiAgICBbYGxpbmVCbG9ja0F0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpKSBhdCB0aGUgZ2l2ZW5cbiAgICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcbiAgICBibG9ja3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBpbiB0aGUgdmlld3BvcnQuIFBvc2l0aW9uc1xuICAgIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXG4gICAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICAgIG5vbi1baGlkZGVuXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBsaW5lIGJyZWFrLCBvciB0aGVcbiAgICBzdGFydC9lbmQgb2YgdGhlIGRvY3VtZW50LiBJdCB3aWxsIHVzdWFsbHkganVzdCBob2xkIGEgbGluZSBvZlxuICAgIHRleHQsIGJ1dCBtYXkgYmUgYnJva2VuIGludG8gbXVsdGlwbGUgdGV4dGJsb2NrcyBieSBibG9ja1xuICAgIHdpZGdldHMuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IncyB0b3RhbCBjb250ZW50IGhlaWdodC5cbiAgICAqL1xuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuY29udGVudEhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBieSBbZ3JhcGhlbWVcbiAgICBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspLiBgZm9yd2FyZGAgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gICAgdGhlIG1vdGlvbiBpcyBhd2F5IGZyb20gdGhlIGxpbmUgc3RhcnQsIG9yIHRvd2FyZHMgaXQuIEluXG4gICAgYmlkaXJlY3Rpb25hbCB0ZXh0LCB0aGUgbGluZSBpcyB0cmF2ZXJzZWQgaW4gdmlzdWFsIG9yZGVyLCB1c2luZ1xuICAgIHRoZSBlZGl0b3IncyBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuICAgIFdoZW4gdGhlIHN0YXJ0IHBvc2l0aW9uIHdhcyB0aGUgbGFzdCBvbmUgb24gdGhlIGxpbmUsIHRoZVxuICAgIHJldHVybmVkIHBvc2l0aW9uIHdpbGwgYmUgYWNyb3NzIHRoZSBsaW5lIGJyZWFrLiBJZiB0aGVyZSBpcyBub1xuICAgIGZ1cnRoZXIgbGluZSwgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIG1vdmVzIG92ZXIgYSBzaW5nbGUgY2x1c3Rlci4gVGhlXG4gICAgb3B0aW9uYWwgYGJ5YCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFjcm9zcyBtb3JlLiBJdCB3aWxsXG4gICAgYmUgY2FsbGVkIHdpdGggdGhlIGZpcnN0IGNsdXN0ZXIgYXMgYXJndW1lbnQsIGFuZCBzaG91bGQgcmV0dXJuXG4gICAgYSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzLCBmb3IgZWFjaCBzdWJzZXF1ZW50IGNsdXN0ZXIsXG4gICAgd2hldGhlciBpdCBzaG91bGQgYWxzbyBiZSBtb3ZlZCBvdmVyLlxuICAgICovXG4gICAgbW92ZUJ5Q2hhcihzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgYnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBhY3Jvc3MgdGhlIG5leHQgZ3JvdXAgb2YgZWl0aGVyXG4gICAgW2xldHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBvciBub24tbGV0dGVyXG4gICAgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIG1vdmVCeUdyb3VwKHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGluaXRpYWwgPT4gYnlHcm91cCh0aGlzLCBzdGFydC5oZWFkLCBpbml0aWFsKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnNvciBwb3NpdGlvbiB2aXN1YWxseSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbGluZS5cbiAgICBOb3RlIHRoYXQgdGhpcyBtYXkgZGlmZmVyIGZyb20gdGhlIF9sb2dpY2FsXyBwb3NpdGlvbiBhdCBpdHNcbiAgICBzdGFydCBvciBlbmQgKHdoaWNoIGlzIHNpbXBseSBhdCBgbGluZS5mcm9tYC9gbGluZS50b2ApIGlmIHRleHRcbiAgICBhdCB0aGUgc3RhcnQgb3IgZW5kIGdvZXMgYWdhaW5zdCB0aGUgbGluZSdzIGJhc2UgdGV4dCBkaXJlY3Rpb24uXG4gICAgKi9cbiAgICB2aXN1YWxMaW5lU2lkZShsaW5lLCBlbmQpIHtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5iaWRpU3BhbnMobGluZSksIGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBzcGFuID0gb3JkZXJbZW5kID8gb3JkZXIubGVuZ3RoIC0gMSA6IDBdO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzcGFuLnNpZGUoZW5kLCBkaXIpICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoIWVuZCwgZGlyKSA/IDEgOiAtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLiBJZlxuICAgIGBpbmNsdWRlV3JhcGAgaXMgdHJ1ZSwgbGluZSB3cmFwcGluZyBpcyBvbiwgYW5kIHRoZXJlIGlzIGFcbiAgICBmdXJ0aGVyIHdyYXAgcG9pbnQgb24gdGhlIGN1cnJlbnQgbGluZSwgdGhlIHdyYXAgcG9pbnQgd2lsbCBiZVxuICAgIHJldHVybmVkLiBPdGhlcndpc2UgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc3RhcnQgb3IgZW5kXG4gICAgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBtb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbW92ZVRvTGluZUJvdW5kYXJ5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gdmVydGljYWxseS4gV2hlbiBgZGlzdGFuY2VgIGlzbid0IGdpdmVuLFxuICAgIGl0IGRlZmF1bHRzIHRvIG1vdmluZyB0byB0aGUgbmV4dCBsaW5lIChpbmNsdWRpbmcgd3JhcHBlZFxuICAgIGxpbmVzKS4gT3RoZXJ3aXNlLCBgZGlzdGFuY2VgIHNob3VsZCBwcm92aWRlIGEgcG9zaXRpdmUgZGlzdGFuY2VcbiAgICBpbiBwaXhlbHMuXG4gICAgXG4gICAgV2hlbiBgc3RhcnRgIGhhcyBhXG4gICAgW2Bnb2FsQ29sdW1uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5nb2FsQ29sdW1uKSwgdGhlIHZlcnRpY2FsXG4gICAgbW90aW9uIHdpbGwgdXNlIHRoYXQgYXMgYSB0YXJnZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLFxuICAgIHRoZSBjdXJzb3IncyBvd24gaG9yaXpvbnRhbCBwb3NpdGlvbiBpcyB1c2VkLiBUaGUgcmV0dXJuZWRcbiAgICBjdXJzb3Igd2lsbCBoYXZlIGl0cyBnb2FsIGNvbHVtbiBzZXQgdG8gd2hpY2hldmVyIGNvbHVtbiB3YXNcbiAgICB1c2VkLlxuICAgICovXG4gICAgbW92ZVZlcnRpY2FsbHkoc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVWZXJ0aWNhbGx5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcGFyZW50IG5vZGUgYW5kIG9mZnNldCAoY2hpbGQgb2Zmc2V0IGlmIGBub2RlYCBpc1xuICAgIGFuIGVsZW1lbnQsIGNoYXJhY3RlciBvZmZzZXQgd2hlbiBpdCBpcyBhIHRleHQgbm9kZSkgYXQgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IGluXG4gICAgYHZpc2libGVSYW5nZXNgLCB0aGUgcmVzdWx0aW5nIERPTSBwb3NpdGlvbiBpc24ndCBuZWNlc3NhcmlseVxuICAgIG1lYW5pbmdmdWwgKGl0IG1heSBqdXN0IHBvaW50IGJlZm9yZSBvciBhZnRlciBhIHBsYWNlaG9sZGVyXG4gICAgZWxlbWVudCkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21BdFBvcyhwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gRE9NIG5vZGUuIENhbiBiZSB1c2VmdWxcbiAgICBmb3IgYXNzb2NpYXRpbmcgcG9zaXRpb25zIHdpdGggRE9NIGV2ZW50cy4gV2lsbCByYWlzZSBhbiBlcnJvclxuICAgIHdoZW4gYG5vZGVgIGlzbid0IHBhcnQgb2YgdGhlIGVkaXRvciBjb250ZW50LlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcG9zQXRDb29yZHMoY29vcmRzLCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzLCBwcmVjaXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgYXQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBzaWRlYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBiYXNlZCBvbiB0aGVcbiAgICBlbGVtZW50IGJlZm9yZSAoLTEpIG9yIGFmdGVyICgxKSB0aGUgcG9zaXRpb24gKGlmIG5vIGVsZW1lbnQgaXNcbiAgICBhdmFpbGFibGUgb24gdGhlIGdpdmVuIHNpZGUsIHRoZSBtZXRob2Qgd2lsbCB0cmFuc3BhcmVudGx5IHVzZVxuICAgIGFub3RoZXIgc3RyYXRlZ3kgdG8gZ2V0IHJlYXNvbmFibGUgY29vcmRpbmF0ZXMpLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZG9jVmlldy5jb29yZHNBdChwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKSwgb3JkZXIgPSB0aGlzLmJpZGlTcGFucyhsaW5lKTtcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltCaWRpU3Bhbi5maW5kKG9yZGVyLCBwb3MgLSBsaW5lLmZyb20sIC0xLCBzaWRlKV07XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAoc3Bhbi5kaXIgPT0gRGlyZWN0aW9uLkxUUikgPT0gKHNpZGUgPiAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgcmVjdGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGNoYXJhY3Rlci4gSWYgYHBvc2AgZG9lcyBub3RcbiAgICBwb2ludCBpbiBmcm9udCBvZiBhIGNoYXJhY3RlciB0aGF0IGlzIGluIHRoZSB2aWV3cG9ydCBhbmRcbiAgICByZW5kZXJlZCAoaS5lLiBub3QgcmVwbGFjZWQsIG5vdCBhIGxpbmUgYnJlYWspLCB0aGlzIHdpbGwgcmV0dXJuXG4gICAgbnVsbC4gRm9yIHNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgYSBsaW5lIHdyYXAgcG9pbnQsIHRoaXMgd2lsbFxuICAgIHJldHVybiB0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBsaW5lIGJyZWFrLlxuICAgICovXG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5jb29yZHNGb3JDaGFyKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHdpZHRoIG9mIGEgY2hhcmFjdGVyIGluIHRoZSBlZGl0b3IuIE1heSBub3RcbiAgICBhY2N1cmF0ZWx5IHJlZmxlY3QgdGhlIHdpZHRoIG9mIGFsbCBjaGFyYWN0ZXJzIChnaXZlbiB2YXJpYWJsZVxuICAgIHdpZHRoIGZvbnRzIG9yIHN0eWxpbmcgb2YgaW52aWRpZHVhbCByYW5nZXMpLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRDaGFyYWN0ZXJXaWR0aCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7IH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBoZWlnaHQgb2YgYSBsaW5lIGluIHRoZSBlZGl0b3IuIE1heSBub3QgYmUgYWNjdXJhdGVcbiAgICBmb3IgYWxsIGxpbmVzLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRMaW5lSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7IH1cbiAgICAvKipcbiAgICBUaGUgdGV4dCBkaXJlY3Rpb25cbiAgICAoW2BkaXJlY3Rpb25gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uKVxuICAgIENTUyBwcm9wZXJ0eSkgb2YgdGhlIGVkaXRvcidzIGNvbnRlbnQgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCB0ZXh0RGlyZWN0aW9uKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuZGVmYXVsdFRleHREaXJlY3Rpb247IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYmxvY2sgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhc1xuICAgIGFzc2lnbmVkIGJ5IENTUy4gSWZcbiAgICBbYHBlckxpbmVUZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdecGVyTGluZVRleHREaXJlY3Rpb24pXG4gICAgaXNuJ3QgZW5hYmxlZCwgb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LFxuICAgIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGFzXG4gICAgW2B0ZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuIE5vdGUgdGhhdFxuICAgIHRoaXMgbWF5IHRyaWdnZXIgYSBET00gbGF5b3V0LlxuICAgICovXG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgcGVyTGluZSA9IHRoaXMuc3RhdGUuZmFjZXQocGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXBlckxpbmUgfHwgcG9zIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHBvcyA+IHRoaXMudmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnRleHREaXJlY3Rpb25BdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoaXMgZWRpdG9yIFt3cmFwcyBsaW5lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZVdyYXBwaW5nKVxuICAgIChhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgIFtgd2hpdGUtc3BhY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvd2hpdGUtc3BhY2UpXG4gICAgQ1NTIHByb3BlcnR5IG9mIGl0cyBjb250ZW50IGVsZW1lbnQpLlxuICAgICovXG4gICAgZ2V0IGxpbmVXcmFwcGluZygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBiaWRpcmVjdGlvbmFsIHRleHQgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBsaW5lXG4gICAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxuICAgIG9iamVjdHMuIFRoZSBvcmRlciBvZiB0aGVzZSBzcGFucyBtYXRjaGVzIHRoZSBbdGV4dFxuICAgIGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbinigJRpZiB0aGF0IGlzXG4gICAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcbiAgICByaWdodG1vc3Qgc3BhbnMgY29tZSBmaXJzdC5cbiAgICAqL1xuICAgIGJpZGlTcGFucyhsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IE1heEJpZGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgICAgIGxldCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pLCBpc29sYXRlcztcbiAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgdGhpcy5iaWRpQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5mcm9tID09IGxpbmUuZnJvbSAmJiBlbnRyeS5kaXIgPT0gZGlyICYmXG4gICAgICAgICAgICAgICAgKGVudHJ5LmZyZXNoIHx8IGlzb2xhdGVzRXEoZW50cnkuaXNvbGF0ZXMsIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZSkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkub3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc29sYXRlcylcbiAgICAgICAgICAgIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZSk7XG4gICAgICAgIGxldCBvcmRlciA9IGNvbXB1dGVPcmRlcihsaW5lLnRleHQsIGRpciwgaXNvbGF0ZXMpO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgaXNvbGF0ZXMsIHRydWUsIG9yZGVyKSk7XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGdldCBoYXNGb2N1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTYWZhcmkgcmV0dXJuIGZhbHNlIGZvciBoYXNGb2N1cyB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgb3BlblxuICAgICAgICAvLyBvciBjbG9zaW5nLCB3aGljaCBsZWFkcyB1cyB0byBpZ25vcmUgc2VsZWN0aW9uIGNoYW5nZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gY29udGV4dCBtZW51IGJlY2F1c2UgaXQgbG9va3MgbGlrZSB0aGUgZWRpdG9yIGlzbid0IGZvY3VzZWQuXG4gICAgICAgIC8vIFRoaXMga2x1ZGdlcyBhcm91bmQgdGhhdC5cbiAgICAgICAgcmV0dXJuICh0aGlzLmRvbS5vd25lckRvY3VtZW50Lmhhc0ZvY3VzKCkgfHwgYnJvd3Nlci5zYWZhcmkgJiYgKChfYSA9IHRoaXMuaW5wdXRTdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RDb250ZXh0TWVudSkgPiBEYXRlLm5vdygpIC0gM2U0KSAmJlxuICAgICAgICAgICAgdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NO1xuICAgIH1cbiAgICAvKipcbiAgICBQdXQgZm9jdXMgb24gdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgW3Jvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5yb290KSBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLiBUaGlzIGlzIG9ubHlcbiAgICBuZWNlc3Nhcnkgd2hlbiBtb3ZpbmcgdGhlIGVkaXRvcidzIGV4aXN0aW5nIERPTSB0byBhIG5ldyB3aW5kb3cgb3Igc2hhZG93IHJvb3QuXG4gICAgKi9cbiAgICBzZXRSb290KHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT0gcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnNldFdpbmRvdygocm9vdC5ub2RlVHlwZSA9PSA5ID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudCkuZGVmYXVsdFZpZXcgfHwgd2luZG93KTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDbGVhbiB1cCB0aGlzIGVkaXRvciB2aWV3LCByZW1vdmluZyBpdHMgZWxlbWVudCBmcm9tIHRoZVxuICAgIGRvY3VtZW50LCB1bnJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzLCBhbmQgbm90aWZ5aW5nXG4gICAgcGx1Z2lucy4gVGhlIHZpZXcgaW5zdGFuY2UgY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyXG4gICAgY2FsbGluZyB0aGlzLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTS5ibHVyKCk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IGNhbiBiZVxuICAgIFthZGRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdG8gYSB0cmFuc2FjdGlvbiB0b1xuICAgIGNhdXNlIGl0IHRvIHNjcm9sbCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgcmFuZ2UgaW50byB2aWV3LlxuICAgICovXG4gICAgc3RhdGljIHNjcm9sbEludG9WaWV3KHBvcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxJbnRvVmlldy5vZihuZXcgU2Nyb2xsVGFyZ2V0KHR5cGVvZiBwb3MgPT0gXCJudW1iZXJcIiA/IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKSA6IHBvcywgb3B0aW9ucy55LCBvcHRpb25zLngsIG9wdGlvbnMueU1hcmdpbiwgb3B0aW9ucy54TWFyZ2luKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhbiBlZmZlY3QgdGhhdCByZXNldHMgdGhlIGVkaXRvciB0byBpdHMgY3VycmVudCAoYXQgdGhlXG4gICAgdGltZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkKSBzY3JvbGwgcG9zaXRpb24uIE5vdGUgdGhhdCB0aGlzXG4gICAgb25seSBhZmZlY3RzIHRoZSBlZGl0b3IncyBvd24gc2Nyb2xsYWJsZSBlbGVtZW50LCBub3QgcGFyZW50cy5cbiAgICBTZWUgYWxzb1xuICAgIFtgRWRpdG9yVmlld0NvbmZpZy5zY3JvbGxUb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvKS5cbiAgICBcbiAgICBUaGUgZWZmZWN0IHNob3VsZCBiZSB1c2VkIHdpdGggYSBkb2N1bWVudCBpZGVudGljYWwgdG8gdGhlIG9uZVxuICAgIGl0IHdhcyBjcmVhdGVkIGZvci4gRmFpbGluZyB0byBkbyBzbyBpcyBub3QgYW4gZXJyb3IsIGJ1dCBtYXlcbiAgICBub3Qgc2Nyb2xsIHRvIHRoZSBleHBlY3RlZCBwb3NpdGlvbi4gWW91IGNhblxuICAgIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0aGUgZWZmZWN0IHRvIGFjY291bnQgZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBzY3JvbGxTbmFwc2hvdCgpIHtcbiAgICAgICAgbGV0IHsgc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0IH0gPSB0aGlzLnNjcm9sbERPTTtcbiAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCk7XG4gICAgICAgIHJldHVybiBzY3JvbGxJbnRvVmlldy5vZihuZXcgU2Nyb2xsVGFyZ2V0KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmVmLmZyb20pLCBcInN0YXJ0XCIsIFwic3RhcnRcIiwgcmVmLnRvcCAtIHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCwgdHJ1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBFbmFibGUgb3IgZGlzYWJsZSB0YWItZm9jdXMgbW9kZSwgd2hpY2ggZGlzYWJsZXMga2V5IGJpbmRpbmdzXG4gICAgZm9yIFRhYiBhbmQgU2hpZnQtVGFiLCBsZXR0aW5nIHRoZSBicm93c2VyJ3MgZGVmYXVsdFxuICAgIGZvY3VzLWNoYW5naW5nIGJlaGF2aW9yIGdvIHRocm91Z2ggaW5zdGVhZC4gVGhpcyBpcyB1c2VmdWwgdG9cbiAgICBwcmV2ZW50IHRyYXBwaW5nIGtleWJvYXJkIHVzZXJzIGluIHlvdXIgZWRpdG9yLlxuICAgIFxuICAgIFdpdGhvdXQgYXJndW1lbnQsIHRoaXMgdG9nZ2xlcyB0aGUgbW9kZS4gV2l0aCBhIGJvb2xlYW4sIGl0XG4gICAgZW5hYmxlcyAodHJ1ZSkgb3IgZGlzYWJsZXMgaXQgKGZhbHNlKS4gR2l2ZW4gYSBudW1iZXIsIGl0XG4gICAgdGVtcG9yYXJpbHkgZW5hYmxlcyB0aGUgbW9kZSB1bnRpbCB0aGF0IG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICBoYXZlIHBhc3NlZCBvciBhbm90aGVyIG5vbi1UYWIga2V5IGlzIHByZXNzZWQuXG4gICAgKi9cbiAgICBzZXRUYWJGb2N1c01vZGUodG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlID0gdGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA8IDAgPyAwIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0byA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPSB0byA/IDAgOiAtMTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSAhPSAwKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA9IERhdGUubm93KCkgKyB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICAgIFRoZSB2YWx1ZSBzaG91bGQgYmUgYW4gb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gaGFuZGxlclxuICAgIGZ1bmN0aW9ucy4gRm9yIGFueSBnaXZlbiBldmVudCwgc3VjaCBmdW5jdGlvbnMgYXJlIG9yZGVyZWQgYnlcbiAgICBleHRlbnNpb24gcHJlY2VkZW5jZSwgYW5kIHRoZSBmaXJzdCBoYW5kbGVyIHRvIHJldHVybiB0cnVlIHdpbGxcbiAgICBiZSBhc3N1bWVkIHRvIGhhdmUgaGFuZGxlZCB0aGF0IGV2ZW50LCBhbmQgbm8gb3RoZXIgaGFuZGxlcnMgb3JcbiAgICBidWlsdC1pbiBiZWhhdmlvciB3aWxsIGJlIGFjdGl2YXRlZCBmb3IgaXQuIFRoZXNlIGFyZSByZWdpc3RlcmVkXG4gICAgb24gdGhlIFtjb250ZW50IGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnRlbnRET00pLCBleGNlcHRcbiAgICBmb3IgYHNjcm9sbGAgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIHRoZVxuICAgIGVkaXRvcidzIFtzY3JvbGwgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2Nyb2xsRE9NKSBvciBvbmUgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGVzIGlzIHNjcm9sbGVkLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50SGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRIYW5kbGVyczogaGFuZGxlcnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCByZWdpc3RlcnMgRE9NIGV2ZW50IG9ic2VydmVycy4gQ29udHJhcnlcbiAgICB0byBldmVudCBbaGFuZGxlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRvbUV2ZW50SGFuZGxlcnMpLFxuICAgIG9ic2VydmVycyBjYW4ndCBiZSBwcmV2ZW50ZWQgZnJvbSBydW5uaW5nIGJ5IGEgaGlnaGVyLXByZWNlZGVuY2VcbiAgICBoYW5kbGVyIHJldHVybmluZyB0cnVlLiBUaGV5IGFsc28gZG9uJ3QgcHJldmVudCBvdGhlciBoYW5kbGVyc1xuICAgIGFuZCBvYnNlcnZlcnMgZnJvbSBydW5uaW5nIHdoZW4gdGhleSByZXR1cm4gdHJ1ZSwgYW5kIHNob3VsZCBub3RcbiAgICBjYWxsIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRPYnNlcnZlcnMob2JzZXJ2ZXJzKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSgoKSA9PiAoe30pLCB7IGV2ZW50T2JzZXJ2ZXJzOiBvYnNlcnZlcnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRoZW1lIGV4dGVuc2lvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IGNhbiBiZSBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbilcbiAgICBzdHlsZSBzcGVjIHByb3ZpZGluZyB0aGUgc3R5bGVzIGZvciB0aGUgdGhlbWUuIFRoZXNlIHdpbGwgYmVcbiAgICBwcmVmaXhlZCB3aXRoIGEgZ2VuZXJhdGVkIGNsYXNzIGZvciB0aGUgc3R5bGUuXG4gICAgXG4gICAgQmVjYXVzZSB0aGUgc2VsZWN0b3JzIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCBhIHNjb3BlIGNsYXNzLCBydWxlXG4gICAgdGhhdCBkaXJlY3RseSBtYXRjaCB0aGUgZWRpdG9yJ3MgW3dyYXBwZXJcbiAgICBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb20p4oCUdG8gd2hpY2ggdGhlIHNjb3BlIGNsYXNzIHdpbGwgYmVcbiAgICBhZGRlZOKAlG5lZWQgdG8gYmUgZXhwbGljaXRseSBkaWZmZXJlbnRpYXRlZCBieSBhZGRpbmcgYW4gYCZgIHRvXG4gICAgdGhlIHNlbGVjdG9yIGZvciB0aGF0IGVsZW1lbnTigJRmb3IgZXhhbXBsZVxuICAgIGAmLmNtLWZvY3VzZWRgLlxuICAgIFxuICAgIFdoZW4gYGRhcmtgIGlzIHNldCB0byB0cnVlLCB0aGUgdGhlbWUgd2lsbCBiZSBtYXJrZWQgYXMgZGFyayxcbiAgICB3aGljaCB3aWxsIGNhdXNlIHRoZSBgJmRhcmtgIHJ1bGVzIGZyb20gW2Jhc2VcbiAgICB0aGVtZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmJhc2VUaGVtZSkgdG8gYmUgdXNlZCAoYXMgb3Bwb3NlZCB0b1xuICAgIGAmbGlnaHRgIHdoZW4gYSBsaWdodCB0aGVtZSBpcyBhY3RpdmUpLlxuICAgICovXG4gICAgc3RhdGljIHRoZW1lKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFt0aGVtZS5vZihwcmVmaXgpLCBzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKGAuJHtwcmVmaXh9YCwgc3BlYykpXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kYXJrKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGFya1RoZW1lLm9mKHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgc3R5bGVzIHRvIHRoZSBiYXNlIHRoZW1lLiBMaWtlXG4gICAgd2l0aCBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpLCB1c2UgYCZgIHRvIGluZGljYXRlIHRoZVxuICAgIHBsYWNlIG9mIHRoZSBlZGl0b3Igd3JhcHBlciBlbGVtZW50IHdoZW4gZGlyZWN0bHkgdGFyZ2V0aW5nXG4gICAgdGhhdC4gWW91IGNhbiBhbHNvIHVzZSBgJmRhcmtgIG9yIGAmbGlnaHRgIGluc3RlYWQgdG8gb25seVxuICAgIHRhcmdldCBlZGl0b3JzIHdpdGggYSBkYXJrIG9yIGxpZ2h0IHRoZW1lLlxuICAgICovXG4gICAgc3RhdGljIGJhc2VUaGVtZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBQcmVjLmxvd2VzdChzdHlsZU1vZHVsZS5vZihidWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHNwZWMsIGxpZ2h0RGFya0lEcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgYW4gZWRpdG9yIHZpZXcgaW5zdGFuY2UgZnJvbSB0aGUgdmlldydzIERPTVxuICAgIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZpbmRGcm9tRE9NKGRvbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjb250ZW50ID0gZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tY29udGVudFwiKTtcbiAgICAgICAgbGV0IGNWaWV3ID0gY29udGVudCAmJiBDb250ZW50Vmlldy5nZXQoY29udGVudCkgfHwgQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIHJldHVybiAoKF9hID0gY1ZpZXcgPT09IG51bGwgfHwgY1ZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNWaWV3LnJvb3RWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlldykgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkZhY2V0IHRvIGFkZCBhIFtzdHlsZVxubW9kdWxlXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbikgdG9cbmFuIGVkaXRvciB2aWV3LiBUaGUgdmlldyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBtb2R1bGUgaXNcbm1vdW50ZWQgaW4gaXRzIFtkb2N1bWVudFxucm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29uc3RydWN0b3JeY29uZmlnLnJvb3QpLlxuKi9cbkVkaXRvclZpZXcuc3R5bGVNb2R1bGUgPSBzdHlsZU1vZHVsZTtcbi8qKlxuQW4gaW5wdXQgaGFuZGxlciBjYW4gb3ZlcnJpZGUgdGhlIHdheSBjaGFuZ2VzIHRvIHRoZSBlZGl0YWJsZVxuRE9NIGNvbnRlbnQgYXJlIGhhbmRsZWQuIEhhbmRsZXJzIGFyZSBwYXNzZWQgdGhlIGRvY3VtZW50XG5wb3NpdGlvbnMgYmV0d2VlbiB3aGljaCB0aGUgY2hhbmdlIHdhcyBmb3VuZCwgYW5kIHRoZSBuZXdcbmNvbnRlbnQuIFdoZW4gb25lIHJldHVybnMgdHJ1ZSwgbm8gZnVydGhlciBpbnB1dCBoYW5kbGVycyBhcmVcbmNhbGxlZCBhbmQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgcHJldmVudGVkLlxuXG5UaGUgYGluc2VydGAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBkZWZhdWx0IHRyYW5zYWN0aW9uXG50aGF0IHdvdWxkIGJlIGFwcGxpZWQgZm9yIHRoaXMgaW5wdXQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuXG5kaXNwYXRjaGluZyB0aGUgY3VzdG9tIGJlaGF2aW9yIGFzIGEgc2VwYXJhdGUgdHJhbnNhY3Rpb24uXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcbkZ1bmN0aW9ucyBwcm92aWRlZCBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgdXNlZCB0byB0cmFuc2Zvcm0gdGV4dFxucGFzdGVkIG9yIGRyb3BwZWQgaW50byB0aGUgZWRpdG9yLlxuKi9cbkVkaXRvclZpZXcuY2xpcGJvYXJkSW5wdXRGaWx0ZXIgPSBjbGlwYm9hcmRJbnB1dEZpbHRlcjtcbi8qKlxuVHJhbnNmb3JtIHRleHQgY29waWVkIG9yIGRyYWdnZWQgZnJvbSB0aGUgZWRpdG9yLlxuKi9cbkVkaXRvclZpZXcuY2xpcGJvYXJkT3V0cHV0RmlsdGVyID0gY2xpcGJvYXJkT3V0cHV0RmlsdGVyO1xuLyoqXG5TY3JvbGwgaGFuZGxlcnMgY2FuIG92ZXJyaWRlIGhvdyB0aGluZ3MgYXJlIHNjcm9sbGVkIGludG8gdmlldy5cbklmIHRoZXkgcmV0dXJuIGB0cnVlYCwgbm8gZnVydGhlciBoYW5kbGluZyBoYXBwZW5zIGZvciB0aGVcbnNjcm9sbGluZy4gSWYgdGhleSByZXR1cm4gZmFsc2UsIHRoZSBkZWZhdWx0IHNjcm9sbCBiZWhhdmlvciBpc1xuYXBwbGllZC4gU2Nyb2xsIGhhbmRsZXJzIHNob3VsZCBuZXZlciBpbml0aWF0ZSBlZGl0b3IgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbEhhbmRsZXIgPSBzY3JvbGxIYW5kbGVyO1xuLyoqXG5UaGlzIGZhY2V0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgZnVuY3Rpb25zIHRoYXQgY3JlYXRlIGVmZmVjdHNcbnRvIGJlIGRpc3BhdGNoZWQgd2hlbiB0aGUgZWRpdG9yJ3MgZm9jdXMgc3RhdGUgY2hhbmdlcy5cbiovXG5FZGl0b3JWaWV3LmZvY3VzQ2hhbmdlRWZmZWN0ID0gZm9jdXNDaGFuZ2VFZmZlY3Q7XG4vKipcbkJ5IGRlZmF1bHQsIHRoZSBlZGl0b3IgYXNzdW1lcyBhbGwgaXRzIGNvbnRlbnQgaGFzIHRoZSBzYW1lXG5bdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EaXJlY3Rpb24pLiBDb25maWd1cmUgdGhpcyB3aXRoIGEgYHRydWVgXG52YWx1ZSB0byBtYWtlIGl0IHJlYWQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIGV2ZXJ5IChyZW5kZXJlZClcbmxpbmUgc2VwYXJhdGVseS5cbiovXG5FZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uID0gcGVyTGluZVRleHREaXJlY3Rpb247XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxuV2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdpbGxcbm5vdCBoYXZlIGl0cyBgY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgc2V0LiAoTm90ZSB0aGF0IHRoaXNcbmRvZXNuJ3QgYWZmZWN0IEFQSSBjYWxscyB0aGF0IGNoYW5nZSB0aGUgZWRpdG9yIGNvbnRlbnQsIGV2ZW5cbndoZW4gdGhvc2UgYXJlIGJvdW5kIHRvIGtleXMgb3IgYnV0dG9ucy4gU2VlIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGZhY2V0IGZvciB0aGF0LilcbiovXG5FZGl0b3JWaWV3LmVkaXRhYmxlID0gZWRpdGFibGU7XG4vKipcbkFsbG93cyB5b3UgdG8gaW5mbHVlbmNlIHRoZSB3YXkgbW91c2Ugc2VsZWN0aW9uIGhhcHBlbnMuIFRoZVxuZnVuY3Rpb25zIGluIHRoaXMgZmFjZXQgd2lsbCBiZSBjYWxsZWQgZm9yIGEgYG1vdXNlZG93bmAgZXZlbnRcbm9uIHRoZSBlZGl0b3IsIGFuZCBjYW4gcmV0dXJuIGFuIG9iamVjdCB0aGF0IG92ZXJyaWRlcyB0aGUgd2F5IGFcbnNlbGVjdGlvbiBpcyBjb21wdXRlZCBmcm9tIHRoYXQgbW91c2UgY2xpY2sgb3IgZHJhZy5cbiovXG5FZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUgPSBtb3VzZVNlbGVjdGlvblN0eWxlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW9uIGRyYWcgZXZlbnRcbnNob3VsZCBtb3ZlIG9yIGNvcHkgdGhlIHNlbGVjdGlvbi4gVGhlIGdpdmVuIHByZWRpY2F0ZSB3aWxsIGJlXG5jYWxsZWQgd2l0aCB0aGUgYG1vdXNlZG93bmAgZXZlbnQsIGFuZCBjYW4gcmV0dXJuIGB0cnVlYCB3aGVuXG50aGUgZHJhZyBzaG91bGQgbW92ZSB0aGUgY29udGVudC5cbiovXG5FZGl0b3JWaWV3LmRyYWdNb3Zlc1NlbGVjdGlvbiA9IGRyYWdNb3Zlc1NlbGVjdGlvbiQxO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW5nIGNsaWNrIGFkZHMgYVxubmV3IHJhbmdlIHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb24gb3IgcmVwbGFjZXMgaXQgZW50aXJlbHkuIFRoZVxuZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjaGVjayBgZXZlbnQubWV0YUtleWAgb24gbWFjT1MsIGFuZFxuYGV2ZW50LmN0cmxLZXlgIGVsc2V3aGVyZS5cbiovXG5FZGl0b3JWaWV3LmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2U7XG4vKipcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXG5hcmUgc2hvd24gaW4gdGhlIHZpZXcuIERlY29yYXRpb25zIGNhbiBiZSBwcm92aWRlZCBpbiB0d29cbndheXPigJRkaXJlY3RseSwgb3IgdmlhIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlZGl0b3Igdmlldy5cblxuT25seSBkZWNvcmF0aW9uIHNldHMgcHJvdmlkZWQgZGlyZWN0bHkgYXJlIGFsbG93ZWQgdG8gaW5mbHVlbmNlXG50aGUgZWRpdG9yJ3MgdmVydGljYWwgbGF5b3V0IHN0cnVjdHVyZS4gVGhlIG9uZXMgcHJvdmlkZWQgYXNcbmZ1bmN0aW9ucyBhcmUgY2FsbGVkIF9hZnRlcl8gdGhlIG5ldyB2aWV3cG9ydCBoYXMgYmVlbiBjb21wdXRlZCxcbmFuZCB0aHVzICoqbXVzdCBub3QqKiBpbnRyb2R1Y2UgYmxvY2sgd2lkZ2V0cyBvciByZXBsYWNpbmdcbmRlY29yYXRpb25zIHRoYXQgY292ZXIgbGluZSBicmVha3MuXG5cbklmIHlvdSB3YW50IGRlY29yYXRlZCByYW5nZXMgdG8gYmVoYXZlIGxpa2UgYXRvbWljIHVuaXRzIGZvclxuY3Vyc29yIG1vdGlvbiBhbmQgZGVsZXRpb24gcHVycG9zZXMsIGFsc28gcHJvdmlkZSB0aGUgcmFuZ2Ugc2V0XG5jb250YWluaW5nIHRoZSBkZWNvcmF0aW9ucyB0b1xuW2BFZGl0b3JWaWV3LmF0b21pY1Jhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmF0b21pY1JhbmdlcykuXG4qL1xuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuLyoqXG5GYWNldCB0aGF0IHdvcmtzIG11Y2ggbGlrZVxuW2BkZWNvcmF0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgYnV0IHB1dHMgaXRzXG5pbnB1dHMgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSBwcmVjZWRlbmNlIHN0YWNrLCBtZWFuaW5nIG1hcmtcbmRlY29yYXRpb25zIHByb3ZpZGVkIGhlcmUgd2lsbCBvbmx5IGJlIHNwbGl0IGJ5IG90aGVyLCBwYXJ0aWFsbHlcbm92ZXJsYXBwaW5nIGBvdXRlckRlY29yYXRpb25zYCByYW5nZXMsIGFuZCB3cmFwIGFyb3VuZCBhbGxcbnJlZ3VsYXIgZGVjb3JhdGlvbnMuIFVzZSB0aGlzIGZvciBtYXJrIGVsZW1lbnRzIHRoYXQgc2hvdWxkLCBhc1xubXVjaCBhcyBwb3NzaWJsZSwgcmVtYWluIGluIG9uZSBwaWVjZS5cbiovXG5FZGl0b3JWaWV3Lm91dGVyRGVjb3JhdGlvbnMgPSBvdXRlckRlY29yYXRpb25zO1xuLyoqXG5Vc2VkIHRvIHByb3ZpZGUgcmFuZ2VzIHRoYXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXRvbXMgYXMgZmFyIGFzXG5jdXJzb3IgbW90aW9uIGlzIGNvbmNlcm5lZC4gVGhpcyBjYXVzZXMgbWV0aG9kcyBsaWtlXG5bYG1vdmVCeUNoYXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlDaGFyKSBhbmRcbltgbW92ZVZlcnRpY2FsbHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgKGFuZCB0aGVcbmNvbW1hbmRzIGJ1aWx0IG9uIHRvcCBvZiB0aGVtKSB0byBza2lwIGFjcm9zcyBzdWNoIHJlZ2lvbnMgd2hlblxuYSBzZWxlY3Rpb24gZW5kcG9pbnQgd291bGQgZW50ZXIgdGhlbS4gVGhpcyBkb2VzIF9ub3RfIHByZXZlbnRcbmRpcmVjdCBwcm9ncmFtbWF0aWMgW3NlbGVjdGlvblxudXBkYXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBmcm9tIG1vdmluZyBpbnRvIHN1Y2hcbnJlZ2lvbnMuXG4qL1xuRWRpdG9yVmlldy5hdG9taWNSYW5nZXMgPSBhdG9taWNSYW5nZXM7XG4vKipcbldoZW4gcmFuZ2UgZGVjb3JhdGlvbnMgYWRkIGEgYHVuaWNvZGUtYmlkaTogaXNvbGF0ZWAgc3R5bGUsIHRoZXlcbnNob3VsZCBhbHNvIGluY2x1ZGUgYVxuW2BiaWRpSXNvbGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5NYXJrRGVjb3JhdGlvblNwZWMuYmlkaUlzb2xhdGUpIHByb3BlcnR5XG5pbiB0aGVpciBkZWNvcmF0aW9uIHNwZWMsIGFuZCBiZSBleHBvc2VkIHRocm91Z2ggdGhpcyBmYWNldCwgc29cbnRoYXQgdGhlIGVkaXRvciBjYW4gY29tcHV0ZSB0aGUgcHJvcGVyIHRleHQgb3JkZXIuIChPdGhlciB2YWx1ZXNcbmZvciBgdW5pY29kZS1iaWRpYCwgZXhjZXB0IG9mIGNvdXJzZSBgbm9ybWFsYCwgYXJlIG5vdFxuc3VwcG9ydGVkLilcbiovXG5FZGl0b3JWaWV3LmJpZGlJc29sYXRlZFJhbmdlcyA9IGJpZGlJc29sYXRlZFJhbmdlcztcbi8qKlxuRmFjZXQgdGhhdCBhbGxvd3MgZXh0ZW5zaW9ucyB0byBwcm92aWRlIGFkZGl0aW9uYWwgc2Nyb2xsXG5tYXJnaW5zIChzcGFjZSBhcm91bmQgdGhlIHNpZGVzIG9mIHRoZSBzY3JvbGxpbmcgZWxlbWVudCB0aGF0XG5zaG91bGQgYmUgY29uc2lkZXJlZCBpbnZpc2libGUpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGVcbnBsdWdpbiBpbnRyb2R1Y2VzIGVsZW1lbnRzIHRoYXQgY292ZXIgcGFydCBvZiB0aGF0IGVsZW1lbnQgKGZvclxuZXhhbXBsZSBhIGhvcml6b250YWxseSBmaXhlZCBndXR0ZXIpLlxuKi9cbkVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucyA9IHNjcm9sbE1hcmdpbnM7XG4vKipcblRoaXMgZmFjZXQgcmVjb3JkcyB3aGV0aGVyIGEgZGFyayB0aGVtZSBpcyBhY3RpdmUuIFRoZSBleHRlbnNpb25cbnJldHVybmVkIGJ5IFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSkgYXV0b21hdGljYWxseVxuaW5jbHVkZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyB3aGVuIHRoZSBgZGFya2Agb3B0aW9uIGlzIHNldCB0b1xudHJ1ZS5cbiovXG5FZGl0b3JWaWV3LmRhcmtUaGVtZSA9IGRhcmtUaGVtZTtcbi8qKlxuUHJvdmlkZXMgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBub25jZSB0byB1c2Ugd2hlbiBjcmVhdGluZ1xudGhlIHN0eWxlIHNoZWV0cyBmb3IgdGhlIGVkaXRvci4gSG9sZHMgdGhlIGVtcHR5IHN0cmluZyB3aGVuIG5vXG5ub25jZSBoYXMgYmVlbiBwcm92aWRlZC5cbiovXG5FZGl0b3JWaWV3LmNzcE5vbmNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogXCJcIiB9KTtcbi8qKlxuRmFjZXQgdGhhdCBwcm92aWRlcyBhZGRpdGlvbmFsIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3NcbmVkaXRhYmxlIERPTSBlbGVtZW50LlxuKi9cbkVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMgPSBjb250ZW50QXR0cmlidXRlcztcbi8qKlxuRmFjZXQgdGhhdCBwcm92aWRlcyBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzIG91dGVyXG5lbGVtZW50LlxuKi9cbkVkaXRvclZpZXcuZWRpdG9yQXR0cmlidXRlcyA9IGVkaXRvckF0dHJpYnV0ZXM7XG4vKipcbkFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgbGluZSB3cmFwcGluZyBpbiB0aGUgZWRpdG9yIChieVxuc2V0dGluZyBDU1MgYHdoaXRlLXNwYWNlYCB0byBgcHJlLXdyYXBgIGluIHRoZSBjb250ZW50KS5cbiovXG5FZGl0b3JWaWV3LmxpbmVXcmFwcGluZyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgXCJjbGFzc1wiOiBcImNtLWxpbmVXcmFwcGluZ1wiIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdXNlZCB0byBpbmNsdWRlIHNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50cyBpbiBhXG50cmFuc2FjdGlvbi4gVGhlc2Ugd2lsbCBiZSBhZGRlZCB0byB0aGUgRE9NIGluIGEgdmlzdWFsbHkgaGlkZGVuXG5lbGVtZW50IHdpdGggYGFyaWEtbGl2ZT1cInBvbGl0ZVwiYCBzZXQsIGFuZCBzaG91bGQgYmUgdXNlZCB0b1xuZGVzY3JpYmUgZWZmZWN0cyB0aGF0IGFyZSB2aXN1YWxseSBvYnZpb3VzIGJ1dCBtYXkgbm90IGJlXG5ub3RpY2VkIGJ5IHNjcmVlbiByZWFkZXIgdXNlcnMgKHN1Y2ggYXMgbW92aW5nIHRvIHRoZSBuZXh0XG5zZWFyY2ggbWF0Y2gpLlxuKi9cbkVkaXRvclZpZXcuYW5ub3VuY2UgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vLyBNYXhpbXVtIGxpbmUgbGVuZ3RoIGZvciB3aGljaCB3ZSBjb21wdXRlIGFjY3VyYXRlIGJpZGkgaW5mb1xuY29uc3QgTWF4QmlkaUxpbmUgPSA0MDk2O1xuY29uc3QgQmFkTWVhc3VyZSA9IHt9O1xuY2xhc3MgQ2FjaGVkT3JkZXIge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBkaXIsIGlzb2xhdGVzLCBmcmVzaCwgb3JkZXIpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5pc29sYXRlcyA9IGlzb2xhdGVzO1xuICAgICAgICB0aGlzLmZyZXNoID0gZnJlc2g7XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcbiAgICB9XG4gICAgc3RhdGljIHVwZGF0ZShjYWNoZSwgY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSAmJiAhY2FjaGUuc29tZShjID0+IGMuZnJlc2gpKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIGxhc3REaXIgPSBjYWNoZS5sZW5ndGggPyBjYWNoZVtjYWNoZS5sZW5ndGggLSAxXS5kaXIgOiBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBpID0gTWF0aC5tYXgoMCwgY2FjaGUubGVuZ3RoIC0gMTApOyBpIDwgY2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IGNhY2hlW2ldO1xuICAgICAgICAgICAgaWYgKGVudHJ5LmRpciA9PSBsYXN0RGlyICYmICFjaGFuZ2VzLnRvdWNoZXNSYW5nZShlbnRyeS5mcm9tLCBlbnRyeS50bykpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IENhY2hlZE9yZGVyKGNoYW5nZXMubWFwUG9zKGVudHJ5LmZyb20sIDEpLCBjaGFuZ2VzLm1hcFBvcyhlbnRyeS50bywgLTEpLCBlbnRyeS5kaXIsIGVudHJ5Lmlzb2xhdGVzLCBmYWxzZSwgZW50cnkub3JkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJzRnJvbUZhY2V0KHZpZXcsIGZhY2V0LCBiYXNlKSB7XG4gICAgZm9yIChsZXQgc291cmNlcyA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpLCBpID0gc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgc291cmNlID0gc291cmNlc1tpXSwgdmFsdWUgPSB0eXBlb2Ygc291cmNlID09IFwiZnVuY3Rpb25cIiA/IHNvdXJjZSh2aWV3KSA6IHNvdXJjZTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgY29tYmluZUF0dHJzKHZhbHVlLCBiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG59XG5cbmNvbnN0IGN1cnJlbnRQbGF0Zm9ybSA9IGJyb3dzZXIubWFjID8gXCJtYWNcIiA6IGJyb3dzZXIud2luZG93cyA/IFwid2luXCIgOiBicm93c2VyLmxpbnV4ID8gXCJsaW51eFwiIDogXCJrZXlcIjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSwgcGxhdGZvcm0pIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xuICAgIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgbW9kID0gcGFydHNbaV07XG4gICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgYWx0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBpZiAocGxhdGZvcm0gPT0gXCJtYWNcIilcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHNoaWZ0KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIG5hbWUgPSBcIk1ldGEtXCIgKyBuYW1lO1xuICAgIGlmIChzaGlmdCAhPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmNvbnN0IGhhbmRsZUtleUV2ZW50cyA9IC8qQF9fUFVSRV9fKi9QcmVjLmRlZmF1bHQoLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAga2V5ZG93bihldmVudCwgdmlldykge1xuICAgICAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgXCJlZGl0b3JcIik7XG4gICAgfVxufSkpO1xuLyoqXG5GYWNldCB1c2VkIGZvciByZWdpc3RlcmluZyBrZXltYXBzLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXBzIHRvIGFuIGVkaXRvci4gVGhlaXIgcHJpb3JpdGllc1xuZGV0ZXJtaW5lIHRoZWlyIHByZWNlZGVuY2UgKHRoZSBvbmVzIHNwZWNpZmllZCBlYXJseSBvciB3aXRoIGhpZ2hcbnByaW9yaXR5IGdldCBjaGVja2VkIGZpcnN0KS4gV2hlbiBhIGhhbmRsZXIgaGFzIHJldHVybmVkIGB0cnVlYFxuZm9yIGEgZ2l2ZW4ga2V5LCBubyBmdXJ0aGVyIGhhbmRsZXJzIGFyZSBjYWxsZWQuXG4qL1xuY29uc3Qga2V5bWFwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGVuYWJsZXM6IGhhbmRsZUtleUV2ZW50cyB9KTtcbmNvbnN0IEtleW1hcHMgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFRoaXMgaXMgaGlkZGVuIGJlaGluZCBhbiBpbmRpcmVjdGlvbiwgcmF0aGVyIHRoYW4gZGlyZWN0bHkgY29tcHV0ZWRcbi8vIGJ5IHRoZSBmYWNldCwgdG8ga2VlcCBpbnRlcm5hbCB0eXBlcyBvdXQgb2YgdGhlIGZhY2V0J3MgdHlwZS5cbmZ1bmN0aW9uIGdldEtleW1hcChzdGF0ZSkge1xuICAgIGxldCBiaW5kaW5ncyA9IHN0YXRlLmZhY2V0KGtleW1hcCk7XG4gICAgbGV0IG1hcCA9IEtleW1hcHMuZ2V0KGJpbmRpbmdzKTtcbiAgICBpZiAoIW1hcClcbiAgICAgICAgS2V5bWFwcy5zZXQoYmluZGluZ3MsIG1hcCA9IGJ1aWxkS2V5bWFwKGJpbmRpbmdzLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKSkpO1xuICAgIHJldHVybiBtYXA7XG59XG4vKipcblJ1biB0aGUga2V5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gc2NvcGUuIFRoZSBldmVudFxub2JqZWN0IHNob3VsZCBiZSBhIGBcImtleWRvd25cImAgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlXG5oYW5kbGVycyBoYW5kbGVkIGl0LlxuKi9cbmZ1bmN0aW9uIHJ1blNjb3BlSGFuZGxlcnModmlldywgZXZlbnQsIHNjb3BlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIHNjb3BlKTtcbn1cbmxldCBzdG9yZWRQcmVmaXggPSBudWxsO1xuY29uc3QgUHJlZml4VGltZW91dCA9IDQwMDA7XG5mdW5jdGlvbiBidWlsZEtleW1hcChiaW5kaW5ncywgcGxhdGZvcm0gPSBjdXJyZW50UGxhdGZvcm0pIHtcbiAgICBsZXQgYm91bmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBpc1ByZWZpeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoZWNrUHJlZml4ID0gKG5hbWUsIGlzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXNQcmVmaXhbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpXG4gICAgICAgICAgICBpc1ByZWZpeFtuYW1lXSA9IGlzO1xuICAgICAgICBlbHNlIGlmIChjdXJyZW50ICE9IGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJpbmRpbmcgXCIgKyBuYW1lICsgXCIgaXMgdXNlZCBib3RoIGFzIGEgcmVndWxhciBiaW5kaW5nIGFuZCBhcyBhIG11bHRpLXN0cm9rZSBwcmVmaXhcIik7XG4gICAgfTtcbiAgICBsZXQgYWRkID0gKHNjb3BlLCBrZXksIGNvbW1hbmQsIHByZXZlbnREZWZhdWx0LCBzdG9wUHJvcGFnYXRpb24pID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHNjb3BlT2JqID0gYm91bmRbc2NvcGVdIHx8IChib3VuZFtzY29wZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgbGV0IHBhcnRzID0ga2V5LnNwbGl0KC8gKD8hJCkvKS5tYXAoayA9PiBub3JtYWxpemVLZXlOYW1lKGssIHBsYXRmb3JtKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcmVmaXggPSBwYXJ0cy5zbGljZSgwLCBpKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIGNoZWNrUHJlZml4KHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXNjb3BlT2JqW3ByZWZpeF0pXG4gICAgICAgICAgICAgICAgc2NvcGVPYmpbcHJlZml4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJ1bjogWyh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91ck9iaiA9IHN0b3JlZFByZWZpeCA9IHsgdmlldywgcHJlZml4LCBzY29wZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBpZiAoc3RvcmVkUHJlZml4ID09IG91ck9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDsgfSwgUHJlZml4VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGwgPSBwYXJ0cy5qb2luKFwiIFwiKTtcbiAgICAgICAgY2hlY2tQcmVmaXgoZnVsbCwgZmFsc2UpO1xuICAgICAgICBsZXQgYmluZGluZyA9IHNjb3BlT2JqW2Z1bGxdIHx8IChzY29wZU9ialtmdWxsXSA9IHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBydW46ICgoX2IgPSAoX2EgPSBzY29wZU9iai5fYW55KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2xpY2UoKSkgfHwgW11cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb21tYW5kKVxuICAgICAgICAgICAgYmluZGluZy5ydW4ucHVzaChjb21tYW5kKTtcbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgYmluZGluZy5wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGlmIChzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICBiaW5kaW5nLnN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgfTtcbiAgICBmb3IgKGxldCBiIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgIGxldCBzY29wZXMgPSBiLnNjb3BlID8gYi5zY29wZS5zcGxpdChcIiBcIikgOiBbXCJlZGl0b3JcIl07XG4gICAgICAgIGlmIChiLmFueSlcbiAgICAgICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZU9iai5fYW55KVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9iai5fYW55ID0geyBwcmV2ZW50RGVmYXVsdDogZmFsc2UsIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsIHJ1bjogW10gfTtcbiAgICAgICAgICAgICAgICBsZXQgeyBhbnkgfSA9IGI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9ialtrZXldLnJ1bi5wdXNoKHZpZXcgPT4gYW55KHZpZXcsIGN1cnJlbnRLZXlFdmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IGJbcGxhdGZvcm1dIHx8IGIua2V5O1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgICAgICBhZGQoc2NvcGUsIG5hbWUsIGIucnVuLCBiLnByZXZlbnREZWZhdWx0LCBiLnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICBpZiAoYi5zaGlmdClcbiAgICAgICAgICAgICAgICBhZGQoc2NvcGUsIFwiU2hpZnQtXCIgKyBuYW1lLCBiLnNoaWZ0LCBiLnByZXZlbnREZWZhdWx0LCBiLnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kO1xufVxubGV0IGN1cnJlbnRLZXlFdmVudCA9IG51bGw7XG5mdW5jdGlvbiBydW5IYW5kbGVycyhtYXAsIGV2ZW50LCB2aWV3LCBzY29wZSkge1xuICAgIGN1cnJlbnRLZXlFdmVudCA9IGV2ZW50O1xuICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCk7XG4gICAgbGV0IGNoYXJDb2RlID0gY29kZVBvaW50QXQobmFtZSwgMCksIGlzQ2hhciA9IGNvZGVQb2ludFNpemUoY2hhckNvZGUpID09IG5hbWUubGVuZ3RoICYmIG5hbWUgIT0gXCIgXCI7XG4gICAgbGV0IHByZWZpeCA9IFwiXCIsIGhhbmRsZWQgPSBmYWxzZSwgcHJldmVudGVkID0gZmFsc2UsIHN0b3BQcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgIGlmIChzdG9yZWRQcmVmaXggJiYgc3RvcmVkUHJlZml4LnZpZXcgPT0gdmlldyAmJiBzdG9yZWRQcmVmaXguc2NvcGUgPT0gc2NvcGUpIHtcbiAgICAgICAgcHJlZml4ID0gc3RvcmVkUHJlZml4LnByZWZpeCArIFwiIFwiO1xuICAgICAgICBpZiAobW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMCkge1xuICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbiA9IG5ldyBTZXQ7XG4gICAgbGV0IHJ1bkZvciA9IChiaW5kaW5nKSA9PiB7XG4gICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjbWQgb2YgYmluZGluZy5ydW4pXG4gICAgICAgICAgICAgICAgaWYgKCFyYW4uaGFzKGNtZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuLmFkZChjbWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21kKHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBsZXQgc2NvcGVPYmogPSBtYXBbc2NvcGVdLCBiYXNlTmFtZSwgc2hpZnROYW1lO1xuICAgIGlmIChzY29wZU9iaikge1xuICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgIWlzQ2hhcildKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaGFyICYmIChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxuICAgICAgICAgICAgLy8gQ3RybC1BbHQgbWF5IGJlIHVzZWQgZm9yIEFsdEdyIG9uIFdpbmRvd3NcbiAgICAgICAgICAgICEoYnJvd3Nlci53aW5kb3dzICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5KSAmJlxuICAgICAgICAgICAgLy8gQWx0LWNvbWJpbmF0aW9ucyBvbiBtYWNPUyB0ZW5kIHRvIGJlIHR5cGVkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICEoYnJvd3Nlci5tYWMgJiYgZXZlbnQuYWx0S2V5ICYmICEoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSkgJiZcbiAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgKHNoaWZ0TmFtZSA9IHNoaWZ0W2V2ZW50LmtleUNvZGVdKSAhPSBuYW1lICYmIHNoaWZ0TmFtZSAhPSBiYXNlTmFtZSAmJlxuICAgICAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoc2hpZnROYW1lLCBldmVudCwgZmFsc2UpXSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkgJiZcbiAgICAgICAgICAgIHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHRydWUpXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFuZGxlZCAmJiBydW5Gb3Ioc2NvcGVPYmouX2FueSkpXG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByZXZlbnRlZClcbiAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgaWYgKGhhbmRsZWQgJiYgc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjdXJyZW50S2V5RXZlbnQgPSBudWxsO1xuICAgIHJldHVybiBoYW5kbGVkO1xufVxuXG4vKipcbkltcGxlbWVudGF0aW9uIG9mIFtgTGF5ZXJNYXJrZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTGF5ZXJNYXJrZXIpIHRoYXQgY3JlYXRlc1xuYSByZWN0YW5nbGUgYXQgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMuXG4qL1xuY2xhc3MgUmVjdGFuZ2xlTWFya2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrZXIgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgYW5kIGRpbWVuc2lvbnMuIElmIGB3aWR0aGBcbiAgICBpcyBudWxsLCB0aGUgRE9NIGVsZW1lbnQgd2lsbCBnZXQgbm8gd2lkdGggc3R5bGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIFxuICAgIC8qKlxuICAgIFRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIgKGluIHBpeGVscywgZG9jdW1lbnQtcmVsYXRpdmUpLlxuICAgICovXG4gICAgbGVmdCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBUaGUgd2lkdGggb2YgdGhlIG1hcmtlciwgb3IgbnVsbCBpZiBpdCBzaG91bGRuJ3QgZ2V0IGEgd2lkdGggYXNzaWduZWQuXG4gICAgKi9cbiAgICB3aWR0aCwgXG4gICAgLyoqXG4gICAgVGhlIGhlaWdodCBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgdXBkYXRlKGVsdCwgcHJldikge1xuICAgICAgICBpZiAocHJldi5jbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGp1c3QoZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLndpZHRoICE9IG51bGwpXG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICAgIGVxKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBwLmxlZnQgJiYgdGhpcy50b3AgPT0gcC50b3AgJiYgdGhpcy53aWR0aCA9PSBwLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9PSBwLmNsYXNzTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIHJlY3RhbmdsZXMgZm9yIHRoZSBnaXZlbiBzZWxlY3Rpb24gcmFuZ2UsXG4gICAgYXNzaWduaW5nIHRoZW0gdGhlY2xhc3NgY2xhc3NOYW1lYC4gV2lsbCBjcmVhdGUgYSBzaW5nbGVcbiAgICByZWN0YW5nbGUgZm9yIGVtcHR5IHJhbmdlcywgYW5kIGEgc2V0IG9mIHNlbGVjdGlvbi1zdHlsZVxuICAgIHJlY3RhbmdsZXMgY292ZXJpbmcgdGhlIHJhbmdlJ3MgY29udGVudCAoaW4gYSBiaWRpLWF3YXJlXG4gICAgd2F5KSBmb3Igbm9uLWVtcHR5IG9uZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHJhbmdlLmhlYWQsIHJhbmdlLmFzc29jIHx8IDEpO1xuICAgICAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgUmVjdGFuZ2xlTWFya2VyKGNsYXNzTmFtZSwgcG9zLmxlZnQgLSBiYXNlLmxlZnQsIHBvcy50b3AgLSBiYXNlLnRvcCwgbnVsbCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCYXNlKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGggKiB2aWV3LnNjYWxlWDtcbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLCB0b3A6IHJlY3QudG9wIC0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdmlldy5zY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRMaW5lKHZpZXcsIHBvcywgc2lkZSwgaW5zaWRlKSB7XG4gICAgbGV0IGNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zLCBzaWRlICogMik7XG4gICAgaWYgKCFjb29yZHMpXG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgbGV0IGVkaXRvclJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgeSA9IChjb29yZHMudG9wICsgY29vcmRzLmJvdHRvbSkgLyAyO1xuICAgIGxldCBsZWZ0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGVkaXRvclJlY3QubGVmdCArIDEsIHkgfSk7XG4gICAgbGV0IHJpZ2h0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGVkaXRvclJlY3QucmlnaHQgLSAxLCB5IH0pO1xuICAgIGlmIChsZWZ0ID09IG51bGwgfHwgcmlnaHQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICByZXR1cm4geyBmcm9tOiBNYXRoLm1heChpbnNpZGUuZnJvbSwgTWF0aC5taW4obGVmdCwgcmlnaHQpKSwgdG86IE1hdGgubWluKGluc2lkZS50bywgTWF0aC5tYXgobGVmdCwgcmlnaHQpKSB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlc0ZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UudG8gPD0gdmlldy52aWV3cG9ydC5mcm9tIHx8IHJhbmdlLmZyb20gPj0gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBmcm9tID0gTWF0aC5tYXgocmFuZ2UuZnJvbSwgdmlldy52aWV3cG9ydC5mcm9tKSwgdG8gPSBNYXRoLm1pbihyYW5nZS50bywgdmlldy52aWV3cG9ydC50byk7XG4gICAgbGV0IGx0ciA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLCBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgIGxldCBsaW5lRWx0ID0gY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLmNtLWxpbmVcIiksIGxpbmVTdHlsZSA9IGxpbmVFbHQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUobGluZUVsdCk7XG4gICAgbGV0IGxlZnRTaWRlID0gY29udGVudFJlY3QubGVmdCArXG4gICAgICAgIChsaW5lU3R5bGUgPyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ0xlZnQpICsgTWF0aC5taW4oMCwgcGFyc2VJbnQobGluZVN0eWxlLnRleHRJbmRlbnQpKSA6IDApO1xuICAgIGxldCByaWdodFNpZGUgPSBjb250ZW50UmVjdC5yaWdodCAtIChsaW5lU3R5bGUgPyBwYXJzZUludChsaW5lU3R5bGUucGFkZGluZ1JpZ2h0KSA6IDApO1xuICAgIGxldCBzdGFydEJsb2NrID0gYmxvY2tBdCh2aWV3LCBmcm9tLCAxKSwgZW5kQmxvY2sgPSBibG9ja0F0KHZpZXcsIHRvLCAtMSk7XG4gICAgbGV0IHZpc3VhbFN0YXJ0ID0gc3RhcnRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gc3RhcnRCbG9jayA6IG51bGw7XG4gICAgbGV0IHZpc3VhbEVuZCA9IGVuZEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBlbmRCbG9jayA6IG51bGw7XG4gICAgaWYgKHZpc3VhbFN0YXJ0ICYmICh2aWV3LmxpbmVXcmFwcGluZyB8fCBzdGFydEJsb2NrLndpZGdldExpbmVCcmVha3MpKVxuICAgICAgICB2aXN1YWxTdGFydCA9IHdyYXBwZWRMaW5lKHZpZXcsIGZyb20sIDEsIHZpc3VhbFN0YXJ0KTtcbiAgICBpZiAodmlzdWFsRW5kICYmICh2aWV3LmxpbmVXcmFwcGluZyB8fCBlbmRCbG9jay53aWRnZXRMaW5lQnJlYWtzKSlcbiAgICAgICAgdmlzdWFsRW5kID0gd3JhcHBlZExpbmUodmlldywgdG8sIC0xLCB2aXN1YWxFbmQpO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgJiYgdmlzdWFsU3RhcnQuZnJvbSA9PSB2aXN1YWxFbmQuZnJvbSAmJiB2aXN1YWxTdGFydC50byA9PSB2aXN1YWxFbmQudG8pIHtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyhkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCByYW5nZS50bywgdmlzdWFsU3RhcnQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0b3AgPSB2aXN1YWxTdGFydCA/IGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIG51bGwsIHZpc3VhbFN0YXJ0KSA6IGRyYXdGb3JXaWRnZXQoc3RhcnRCbG9jaywgZmFsc2UpO1xuICAgICAgICBsZXQgYm90dG9tID0gdmlzdWFsRW5kID8gZHJhd0ZvckxpbmUobnVsbCwgcmFuZ2UudG8sIHZpc3VhbEVuZCkgOiBkcmF3Rm9yV2lkZ2V0KGVuZEJsb2NrLCB0cnVlKTtcbiAgICAgICAgbGV0IGJldHdlZW4gPSBbXTtcbiAgICAgICAgaWYgKCh2aXN1YWxTdGFydCB8fCBzdGFydEJsb2NrKS50byA8ICh2aXN1YWxFbmQgfHwgZW5kQmxvY2spLmZyb20gLSAodmlzdWFsU3RhcnQgJiYgdmlzdWFsRW5kID8gMSA6IDApIHx8XG4gICAgICAgICAgICBzdGFydEJsb2NrLndpZGdldExpbmVCcmVha3MgPiAxICYmIHRvcC5ib3R0b20gKyB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC8gMiA8IGJvdHRvbS50b3ApXG4gICAgICAgICAgICBiZXR3ZWVuLnB1c2gocGllY2UobGVmdFNpZGUsIHRvcC5ib3R0b20sIHJpZ2h0U2lkZSwgYm90dG9tLnRvcCkpO1xuICAgICAgICBlbHNlIGlmICh0b3AuYm90dG9tIDwgYm90dG9tLnRvcCAmJiB2aWV3LmVsZW1lbnRBdEhlaWdodCgodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMikudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIHRvcC5ib3R0b20gPSBib3R0b20udG9wID0gKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDI7XG4gICAgICAgIHJldHVybiBwaWVjZXModG9wKS5jb25jYXQoYmV0d2VlbikuY29uY2F0KHBpZWNlcyhib3R0b20pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2UobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlTWFya2VyKGNsYXNzTmFtZSwgbGVmdCAtIGJhc2UubGVmdCwgdG9wIC0gYmFzZS50b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgaWYgKCFmcm9tQ29vcmRzIHx8ICF0b0Nvb3JkcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gRGlyZWN0aW9uLkxUUilcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2gobHRyICYmIGZyb21PcGVuID8gbGVmdFNpZGUgOiBmcm9tQ29vcmRzLmxlZnQsIGx0ciAmJiB0b09wZW4gPyByaWdodFNpZGUgOiB0b0Nvb3Jkcy5yaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKCFsdHIgJiYgdG9PcGVuID8gbGVmdFNpZGUgOiB0b0Nvb3Jkcy5sZWZ0LCAhbHRyICYmIGZyb21PcGVuID8gcmlnaHRTaWRlIDogZnJvbUNvb3Jkcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogbGluZS5mcm9tLCBlbmQgPSB0byAhPT0gbnVsbCAmJiB0byAhPT0gdm9pZCAwID8gdG8gOiBsaW5lLnRvO1xuICAgICAgICAvLyBTcGxpdCB0aGUgcmFuZ2UgYnkgdmlzaWJsZSByYW5nZSBhbmQgZG9jdW1lbnQgbGluZVxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcylcbiAgICAgICAgICAgIGlmIChyLnRvID4gc3RhcnQgJiYgci5mcm9tIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gTWF0aC5tYXgoci5mcm9tLCBzdGFydCksIGVuZFBvcyA9IE1hdGgubWluKHIudG8sIGVuZCk7Oykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9jTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzcGFuIG9mIHZpZXcuYmlkaVNwYW5zKGRvY0xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhbkZyb20gPSBzcGFuLmZyb20gKyBkb2NMaW5lLmZyb20sIHNwYW5UbyA9IHNwYW4udG8gKyBkb2NMaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkZyb20gPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5UbyA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTcGFuKE1hdGgubWF4KHNwYW5Gcm9tLCBwb3MpLCBmcm9tID09IG51bGwgJiYgc3BhbkZyb20gPD0gc3RhcnQsIE1hdGgubWluKHNwYW5UbywgZW5kUG9zKSwgdG8gPT0gbnVsbCAmJiBzcGFuVG8gPj0gZW5kLCBzcGFuLmRpcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZG9jTGluZS50byArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaG9yaXpvbnRhbC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGFkZFNwYW4oc3RhcnQsIGZyb20gPT0gbnVsbCwgZW5kLCB0byA9PSBudWxsLCB2aWV3LnRleHREaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4geyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3Rm9yV2lkZ2V0KGJsb2NrLCB0b3ApIHtcbiAgICAgICAgbGV0IHkgPSBjb250ZW50UmVjdC50b3AgKyAodG9wID8gYmxvY2sudG9wIDogYmxvY2suYm90dG9tKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGhvcml6b250YWw6IFtdIH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29uc3RydWN0b3IgPT0gYi5jb25zdHJ1Y3RvciAmJiBhLmVxKGIpO1xufVxuY2xhc3MgTGF5ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBsYXllcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuZHJhd24gPSBbXTtcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5tZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXcuYmluZCh0aGlzKSB9O1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXJcIik7XG4gICAgICAgIGlmIChsYXllci5hYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllci1hYm92ZVwiKTtcbiAgICAgICAgaWYgKGxheWVyLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChsYXllci5jbGFzcyk7XG4gICAgICAgIHRoaXMuc2NhbGUoKTtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLnNldE9yZGVyKHZpZXcuc3RhdGUpO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIGlmIChsYXllci5tb3VudClcbiAgICAgICAgICAgIGxheWVyLm1vdW50KHRoaXMuZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGF5ZXJPcmRlcikgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxheWVyT3JkZXIpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcmRlcih1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGUodXBkYXRlLCB0aGlzLmRvbSkgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICAgICAgdXBkYXRlLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb2NWaWV3VXBkYXRlKHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIudXBkYXRlT25Eb2NWaWV3VXBkYXRlICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICB9XG4gICAgc2V0T3JkZXIoc3RhdGUpIHtcbiAgICAgICAgbGV0IHBvcyA9IDAsIG9yZGVyID0gc3RhdGUuZmFjZXQobGF5ZXJPcmRlcik7XG4gICAgICAgIHdoaWxlIChwb3MgPCBvcmRlci5sZW5ndGggJiYgb3JkZXJbcG9zXSAhPSB0aGlzLmxheWVyKVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLnpJbmRleCA9IFN0cmluZygodGhpcy5sYXllci5hYm92ZSA/IDE1MCA6IC0xKSAtIHBvcyk7XG4gICAgfVxuICAgIG1lYXN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyLm1hcmtlcnModGhpcy52aWV3KTtcbiAgICB9XG4gICAgc2NhbGUoKSB7XG4gICAgICAgIGxldCB7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIGlmIChzY2FsZVggIT0gdGhpcy5zY2FsZVggfHwgc2NhbGVZICE9IHRoaXMuc2NhbGVZKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7MSAvIHNjYWxlWH0sICR7MSAvIHNjYWxlWX0pYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoICE9IHRoaXMuZHJhd24ubGVuZ3RoIHx8IG1hcmtlcnMuc29tZSgocCwgaSkgPT4gIXNhbWVNYXJrZXIocCwgdGhpcy5kcmF3bltpXSkpKSB7XG4gICAgICAgICAgICBsZXQgb2xkID0gdGhpcy5kb20uZmlyc3RDaGlsZCwgb2xkSSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBtYXJrZXIgb2YgbWFya2Vycykge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIudXBkYXRlICYmIG9sZCAmJiBtYXJrZXIuY29uc3RydWN0b3IgJiYgdGhpcy5kcmF3bltvbGRJXS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIudXBkYXRlKG9sZCwgdGhpcy5kcmF3bltvbGRJXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkID0gb2xkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvbGRJKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobWFya2VyLmRyYXcoKSwgb2xkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAob2xkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgb2xkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIG9sZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYXduID0gbWFya2VycztcbiAgICAgICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiBicm93c2VyLnNhZmFyaV92ZXJzaW9uID49IDI2KSAvLyBJc3N1ZSAjMTYwMCwgMTYyN1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmRpc3BsYXkgPSB0aGlzLmRvbS5maXJzdENoaWxkID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLmxheWVyLmRlc3Ryb3kodGhpcy5kb20sIHRoaXMudmlldyk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIH1cbn1cbmNvbnN0IGxheWVyT3JkZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhIGxheWVyLlxuKi9cbmZ1bmN0aW9uIGxheWVyKGNvbmZpZykge1xuICAgIHJldHVybiBbXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHYgPT4gbmV3IExheWVyVmlldyh2LCBjb25maWcpKSxcbiAgICAgICAgbGF5ZXJPcmRlci5vZihjb25maWcpXG4gICAgXTtcbn1cblxuY29uc3Qgc2VsZWN0aW9uQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogMTIwMCxcbiAgICAgICAgICAgIGRyYXdSYW5nZUN1cnNvcjogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IChhLCBiKSA9PiBNYXRoLm1pbihhLCBiKSxcbiAgICAgICAgICAgIGRyYXdSYW5nZUN1cnNvcjogKGEsIGIpID0+IGEgfHwgYlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWRlcyB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzZWxlY3Rpb24gYW5kXG5jdXJzb3IsIHJlcGxhY2luZyB0aGUgc2VsZWN0aW9uIHdpdGggYSBiYWNrZ3JvdW5kIGJlaGluZCB0aGUgdGV4dFxuKHdpdGggdGhlIGBjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kYCBjbGFzcyksIGFuZCB0aGVcbmN1cnNvcnMgd2l0aCBlbGVtZW50cyBvdmVybGFpZCBvdmVyIHRoZSBjb2RlICh1c2luZ1xuYGNtLWN1cnNvci1wcmltYXJ5YCBhbmQgYGNtLWN1cnNvci1zZWNvbmRhcnlgKS5cblxuVGhpcyBhbGxvd3MgdGhlIGVkaXRvciB0byBkaXNwbGF5IHNlY29uZGFyeSBzZWxlY3Rpb24gcmFuZ2VzLCBhbmRcbnRlbmRzIHRvIHByb2R1Y2UgYSB0eXBlIG9mIHNlbGVjdGlvbiBtb3JlIGluIGxpbmUgd2l0aCB0aGF0IHVzZXJzXG5leHBlY3QgaW4gYSB0ZXh0IGVkaXRvciAodGhlIG5hdGl2ZSBzZWxlY3Rpb24gc3R5bGluZyB3aWxsIG9mdGVuXG5sZWF2ZSBnYXBzIGJldHdlZW4gbGluZXMgYW5kIHdvbid0IGZpbGwgdGhlIGhvcml6b250YWwgc3BhY2UgYWZ0ZXJcbmEgbGluZSB3aGVuIHRoZSBzZWxlY3Rpb24gY29udGludWVzIHBhc3QgaXQpLlxuXG5JdCBkb2VzIGhhdmUgYSBwZXJmb3JtYW5jZSBjb3N0LCBpbiB0aGF0IGl0IHJlcXVpcmVzIGFuIGV4dHJhIERPTVxubGF5b3V0IGN5Y2xlIGZvciBtYW55IHVwZGF0ZXMgKHRoZSBzZWxlY3Rpb24gaXMgZHJhd24gYmFzZWQgb24gRE9NXG5sYXlvdXQgaW5mb3JtYXRpb24gdGhhdCdzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIGxheWluZyBvdXQgdGhlXG5jb250ZW50KS5cbiovXG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGN1cnNvckxheWVyLFxuICAgICAgICBzZWxlY3Rpb25MYXllcixcbiAgICAgICAgaGlkZU5hdGl2ZVNlbGVjdGlvbixcbiAgICAgICAgbmF0aXZlU2VsZWN0aW9uSGlkZGVuLm9mKHRydWUpXG4gICAgXTtcbn1cbi8qKlxuUmV0cmlldmUgdGhlIFtgZHJhd1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSBjb25maWd1cmF0aW9uXG5mb3IgdGhpcyBzdGF0ZS4gKE5vdGUgdGhhdCB0aGlzIHdpbGwgcmV0dXJuIGEgc2V0IG9mIGRlZmF1bHRzIGV2ZW5cbmlmIGBkcmF3U2VsZWN0aW9uYCBpc24ndCBlbmFibGVkLilcbiovXG5mdW5jdGlvbiBnZXREcmF3U2VsZWN0aW9uQ29uZmlnKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG59XG5mdW5jdGlvbiBjb25maWdDaGFuZ2VkKHVwZGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xufVxuY29uc3QgY3Vyc29yTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiB0cnVlLFxuICAgIG1hcmtlcnModmlldykge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBjdXJzb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IHByaW0gPSByID09IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgaWYgKHIuZW1wdHkgfHwgY29uZi5kcmF3UmFuZ2VDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gcHJpbSA/IFwiY20tY3Vyc29yIGNtLWN1cnNvci1wcmltYXJ5XCIgOiBcImNtLWN1cnNvciBjbS1jdXJzb3Itc2Vjb25kYXJ5XCI7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IHIuZW1wdHkgPyByIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyLmhlYWQsIHIuaGVhZCA+IHIuYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwaWVjZSBvZiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCBjdXJzb3IpKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3JzLnB1c2gocGllY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3JzO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5hbmltYXRpb25OYW1lID0gZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPT0gXCJjbS1ibGlua1wiID8gXCJjbS1ibGluazJcIiA6IFwiY20tYmxpbmtcIjtcbiAgICAgICAgbGV0IGNvbmZDaGFuZ2UgPSBjb25maWdDaGFuZ2VkKHVwZGF0ZSk7XG4gICAgICAgIGlmIChjb25mQ2hhbmdlKVxuICAgICAgICAgICAgc2V0QmxpbmtSYXRlKHVwZGF0ZS5zdGF0ZSwgZG9tKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgY29uZkNoYW5nZTtcbiAgICB9LFxuICAgIG1vdW50KGRvbSwgdmlldykge1xuICAgICAgICBzZXRCbGlua1JhdGUodmlldy5zdGF0ZSwgZG9tKTtcbiAgICB9LFxuICAgIGNsYXNzOiBcImNtLWN1cnNvckxheWVyXCJcbn0pO1xuZnVuY3Rpb24gc2V0QmxpbmtSYXRlKHN0YXRlLCBkb20pIHtcbiAgICBkb20uc3R5bGUuYW5pbWF0aW9uRHVyYXRpb24gPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpLmN1cnNvckJsaW5rUmF0ZSArIFwibXNcIjtcbn1cbmNvbnN0IHNlbGVjdGlvbkxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogZmFsc2UsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4gci5lbXB0eSA/IFtdIDogUmVjdGFuZ2xlTWFya2VyLmZvclJhbmdlKHZpZXcsIFwiY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiLCByKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh1cGRhdGUsIGRvbSkge1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICB9LFxuICAgIGNsYXNzOiBcImNtLXNlbGVjdGlvbkxheWVyXCJcbn0pO1xuY29uc3QgaGlkZU5hdGl2ZVNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUoe1xuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBcIiYgOjpzZWxlY3Rpb24sICY6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfSxcbiAgICAgICAgY2FyZXRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBjYXJldENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIixcbiAgICAgICAgXCImIDpmb2N1c1wiOiB7XG4gICAgICAgICAgICBjYXJldENvbG9yOiBcImluaXRpYWwgIWltcG9ydGFudFwiLFxuICAgICAgICAgICAgXCImOjpzZWxlY3Rpb24sICYgOjpzZWxlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJIaWdobGlnaHQgIWltcG9ydGFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KSk7XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XG59KTtcbmNvbnN0IGRyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHBvcywgdHIpIHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKChwb3MsIGUpID0+IGUuaXMoc2V0RHJvcEN1cnNvclBvcykgPyBlLnZhbHVlIDogcG9zLCBwb3MpO1xuICAgIH1cbn0pO1xuY29uc3QgZHJhd0Ryb3BDdXJzb3IgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGxldCByZWN0ID0gcG9zICE9IG51bGwgJiYgdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG91dGVyID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5oZWlnaHQgPSBwb3MuaGVpZ2h0IC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IFwiLTEwMDAwMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIHNldERyb3BQb3MocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gcG9zKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RHJvcEN1cnNvclBvcy5vZihwb3MpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy52aWV3LmNvbnRlbnRET00gfHwgIXRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5EcmF3cyBhIGN1cnNvciBhdCB0aGUgY3VycmVudCBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nIGlzXG5kcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKCkge1xuICAgIHJldHVybiBbZHJvcEN1cnNvclBvcywgZHJhd0Ryb3BDdXJzb3JdO1xufVxuXG5mdW5jdGlvbiBpdGVyTWF0Y2hlcyhkb2MsIHJlLCBmcm9tLCB0bywgZikge1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY3Vyc29yID0gZG9jLml0ZXJSYW5nZShmcm9tLCB0byksIHBvcyA9IGZyb20sIG07ICFjdXJzb3IubmV4dCgpLmRvbmU7IHBvcyArPSBjdXJzb3IudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmxpbmVCcmVhaylcbiAgICAgICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyhjdXJzb3IudmFsdWUpKVxuICAgICAgICAgICAgICAgIGYocG9zICsgbS5pbmRleCwgbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hSYW5nZXModmlldywgbWF4TGVuZ3RoKSB7XG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKHZpc2libGUubGVuZ3RoID09IDEgJiYgdmlzaWJsZVswXS5mcm9tID09IHZpZXcudmlld3BvcnQuZnJvbSAmJlxuICAgICAgICB2aXNpYmxlWzBdLnRvID09IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgdmlzaWJsZSkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xuICAgICAgICB0byA9IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG8sIHRvICsgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA+PSBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyByZWdleHAsIGRlY29yYXRpb24sIGRlY29yYXRlLCBib3VuZGFyeSwgbWF4TGVuZ3RoID0gMTAwMCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIGlmIChkZWNvcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiBkZWNvcmF0ZShhZGQsIGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIG1hdGNoLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWNvID0gZGVjb3JhdGlvbihtYXRjaCwgdmlldywgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgICAgIGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgX3ZpZXcsIGZyb20sIGFkZCkgPT4gYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgJ2RlY29yYXRlJyBvciAnZGVjb3JhdGlvbicgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIE1hdGNoRGVjb3JhdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGZ1bGwgc2V0IG9mIGRlY29yYXRpb25zIGZvciBtYXRjaGVzIGluIHRoZSBnaXZlblxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgICBwbHVnaW4uXG4gICAgKi9cbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpLCBhZGQgPSBidWlsZC5hZGQuYmluZChidWlsZCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtYXRjaFJhbmdlcyh2aWV3LCB0aGlzLm1heExlbmd0aCkpXG4gICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIGZyb20sIHRvLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIGEgdmlldyB1cGRhdGUuIGBkZWNvYCBfbXVzdF8gYmVcbiAgICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICovXG4gICAgdXBkYXRlRGVjbyh1cGRhdGUsIGRlY28pIHtcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChfZiwgX3QsIGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID49IHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20gJiYgZnJvbSA8PSB1cGRhdGUudmlldy52aWV3cG9ydC50bykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VGcm9tID0gTWF0aC5taW4oZnJvbSwgY2hhbmdlRnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRvID0gTWF0aC5tYXgodG8sIGNoYW5nZVRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVwZGF0ZS52aWV3cG9ydE1vdmVkIHx8IGNoYW5nZVRvIC0gY2hhbmdlRnJvbSA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgaWYgKGNoYW5nZVRvID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSYW5nZSh1cGRhdGUudmlldywgZGVjby5tYXAodXBkYXRlLmNoYW5nZXMpLCBjaGFuZ2VGcm9tLCBjaGFuZ2VUbyk7XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2aWV3LCBkZWNvLCB1cGRhdGVGcm9tLCB1cGRhdGVUbykge1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChyLmZyb20sIHVwZGF0ZUZyb20pLCB0byA9IE1hdGgubWluKHIudG8sIHVwZGF0ZVRvKTtcbiAgICAgICAgICAgIGlmICh0byA+PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCB0b0xpbmUgPSBmcm9tTGluZS50byA8IHRvID8gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKSA6IGZyb21MaW5lO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHIuZnJvbSwgZnJvbUxpbmUuZnJvbSksIGVuZCA9IE1hdGgubWluKHIudG8sIHRvTGluZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZyb20gPiBmcm9tTGluZS5mcm9tOyBmcm9tLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KGZyb21MaW5lLnRleHRbZnJvbSAtIDEgLSBmcm9tTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB0byA8IHRvTGluZS50bzsgdG8rKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QodG9MaW5lLnRleHRbdG8gLSB0b0xpbmUuZnJvbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXSwgbTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gKGZyb20sIHRvLCBkZWNvKSA9PiByYW5nZXMucHVzaChkZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21MaW5lID09IHRvTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydCAtIGZyb21MaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHRoaXMucmVnZXhwLmV4ZWMoZnJvbUxpbmUudGV4dCkpICYmIG0uaW5kZXggPCBlbmQgLSBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBtLmluZGV4ICsgZnJvbUxpbmUuZnJvbSwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgc3RhcnQsIGVuZCwgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY28gPSBkZWNvLnVwZGF0ZSh7IGZpbHRlckZyb206IHN0YXJ0LCBmaWx0ZXJUbzogZW5kLCBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZnJvbSA8IHN0YXJ0IHx8IHRvID4gZW5kLCBhZGQ6IHJhbmdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG59XG5cbmNvbnN0IFVuaWNvZGVSZWdleHBTdXBwb3J0ID0gL3gvLnVuaWNvZGUgIT0gbnVsbCA/IFwiZ3VcIiA6IFwiZ1wiO1xuY29uc3QgU3BlY2lhbHMgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXHUwMDAwLVxcdTAwMDhcXHUwMDBhLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1MjAyZFxcdTIwMmVcXHUyMDY2XFx1MjA2N1xcdTIwNjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXVwiLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG5jb25zdCBOYW1lcyA9IHtcbiAgICAwOiBcIm51bGxcIixcbiAgICA3OiBcImJlbGxcIixcbiAgICA4OiBcImJhY2tzcGFjZVwiLFxuICAgIDEwOiBcIm5ld2xpbmVcIixcbiAgICAxMTogXCJ2ZXJ0aWNhbCB0YWJcIixcbiAgICAxMzogXCJjYXJyaWFnZSByZXR1cm5cIixcbiAgICAyNzogXCJlc2NhcGVcIixcbiAgICA4MjAzOiBcInplcm8gd2lkdGggc3BhY2VcIixcbiAgICA4MjA0OiBcInplcm8gd2lkdGggbm9uLWpvaW5lclwiLFxuICAgIDgyMDU6IFwiemVybyB3aWR0aCBqb2luZXJcIixcbiAgICA4MjA2OiBcImxlZnQtdG8tcmlnaHQgbWFya1wiLFxuICAgIDgyMDc6IFwicmlnaHQtdG8tbGVmdCBtYXJrXCIsXG4gICAgODIzMjogXCJsaW5lIHNlcGFyYXRvclwiLFxuICAgIDgyMzc6IFwibGVmdC10by1yaWdodCBvdmVycmlkZVwiLFxuICAgIDgyMzg6IFwicmlnaHQtdG8tbGVmdCBvdmVycmlkZVwiLFxuICAgIDgyOTQ6IFwibGVmdC10by1yaWdodCBpc29sYXRlXCIsXG4gICAgODI5NTogXCJyaWdodC10by1sZWZ0IGlzb2xhdGVcIixcbiAgICA4Mjk3OiBcInBvcCBkaXJlY3Rpb25hbCBpc29sYXRlXCIsXG4gICAgODIzMzogXCJwYXJhZ3JhcGggc2VwYXJhdG9yXCIsXG4gICAgNjUyNzk6IFwiemVybyB3aWR0aCBuby1icmVhayBzcGFjZVwiLFxuICAgIDY1NTMyOiBcIm9iamVjdCByZXBsYWNlbWVudFwiXG59O1xubGV0IF9zdXBwb3J0c1RhYlNpemUgPSBudWxsO1xuZnVuY3Rpb24gc3VwcG9ydHNUYWJTaXplKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX3N1cHBvcnRzVGFiU2l6ZSA9PSBudWxsICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIF9zdXBwb3J0c1RhYlNpemUgPSAoKF9hID0gc3R5bGVzLnRhYlNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0eWxlcy5Nb3pUYWJTaXplKSAhPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3N1cHBvcnRzVGFiU2l6ZSB8fCBmYWxzZTtcbn1cbmNvbnN0IHNwZWNpYWxDaGFyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyczogU3BlY2lhbHMsXG4gICAgICAgICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcucmVwbGFjZVRhYnMgPSAhc3VwcG9ydHNUYWJTaXplKCkpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlxcdHxcIiArIGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UgKyBcInxcIiArIGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcbmNoYXJhY3RlcnMuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxuLyoqXG5Db25maWd1cmF0aW9uIG9wdGlvbnMuXG4qL1xuY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW3NwZWNpYWxDaGFyQ29uZmlnLm9mKGNvbmZpZyksIHNwZWNpYWxDaGFyUGx1Z2luKCldO1xufVxubGV0IF9wbHVnaW4gPSBudWxsO1xuZnVuY3Rpb24gc3BlY2lhbENoYXJQbHVnaW4oKSB7XG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3Iodmlldy5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZURlY29yYXRvcihjb25mKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICAgICAgICAgICAgICByZWdleHA6IGNvbmYuc3BlY2lhbENoYXJzLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IChtLCB2aWV3LCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIHNpemUsIHBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBUYWJXaWRnZXQoKHNpemUgLSAoY29sICUgc2l6ZSkpICogdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAvIHRoaXMudmlldy5zY2FsZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9uQ2FjaGVbY29kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSA9IERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFNwZWNpYWxDaGFyV2lkZ2V0KGNvbmYsIGNvZGUpIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5OiBjb25mLnJlcGxhY2VUYWJzID8gdW5kZWZpbmVkIDogL1teXS9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykgIT0gY29uZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKGNvbmYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci51cGRhdGVEZWNvKHVwZGF0ZSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KSk7XG59XG5jb25zdCBEZWZhdWx0UGxhY2Vob2xkZXIgPSBcIlxcdTIwMjJcIjtcbi8vIEFzc2lnbnMgcGxhY2Vob2xkZXIgY2hhcmFjdGVycyBmcm9tIHRoZSBDb250cm9sIFBpY3R1cmVzIGJsb2NrIHRvXG4vLyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyJDEoY29kZSkge1xuICAgIGlmIChjb2RlID49IDMyKVxuICAgICAgICByZXR1cm4gRGVmYXVsdFBsYWNlaG9sZGVyO1xuICAgIGlmIChjb2RlID09IDEwKVxuICAgICAgICByZXR1cm4gXCJcXHUyNDI0XCI7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTIxNiArIGNvZGUpO1xufVxuY2xhc3MgU3BlY2lhbENoYXJXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5jb2RlID09IHRoaXMuY29kZTsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHBoID0gcGxhY2Vob2xkZXIkMSh0aGlzLmNvZGUpO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuc3RhdGUucGhyYXNlKFwiQ29udHJvbCBjaGFyYWN0ZXJcIikgKyBcIiBcIiArIChOYW1lc1t0aGlzLmNvZGVdIHx8IFwiMHhcIiArIHRoaXMuY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgZGVzYywgcGgpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHBoO1xuICAgICAgICBzcGFuLnRpdGxlID0gZGVzYztcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRlc2MpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc3BlY2lhbENoYXJcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmNsYXNzIFRhYldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLndpZHRoID09IHRoaXMud2lkdGg7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiXFx0XCI7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS10YWJcIjtcbiAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmNvbnN0IHBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTAwMDtcbiAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IFwicGFkZGluZy1ib3R0b206IDEwMDBweFwiIH07XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdXBkYXRlO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0IC1cbiAgICAgICAgICAgIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLSB2aWV3LmRvY3VtZW50UGFkZGluZy50b3AgLSAwLjU7XG4gICAgICAgIGlmIChoZWlnaHQgPj0gMCAmJiBoZWlnaHQgIT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IGBwYWRkaW5nLWJvdHRvbTogJHtoZWlnaHR9cHhgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBtYWtlcyBzdXJlIHRoZSBjb250ZW50IGhhcyBhIGJvdHRvbVxubWFyZ2luIGVxdWl2YWxlbnQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZWRpdG9yLCBtaW51cyBvbmUgbGluZVxuaGVpZ2h0LCBzbyB0aGF0IGV2ZXJ5IGxpbmUgaW4gdGhlIGRvY3VtZW50IGNhbiBiZSBzY3JvbGxlZCB0byB0aGVcbnRvcCBvZiB0aGUgZWRpdG9yLlxuXG5UaGlzIGlzIG9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBlZGl0b3IgaXMgc2Nyb2xsYWJsZSwgYW5kIHNob3VsZFxubm90IGJlIGVuYWJsZWQgaW4gZWRpdG9ycyB0aGF0IHRha2UgdGhlIHNpemUgb2YgdGhlaXIgY29udGVudC5cbiovXG5mdW5jdGlvbiBzY3JvbGxQYXN0RW5kKCkge1xuICAgIHJldHVybiBbcGx1Z2luLCBjb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRycykgfHwgbnVsbDsgfSldO1xufVxuXG4vKipcbk1hcmsgbGluZXMgdGhhdCBoYXZlIGEgY3Vyc29yIG9uIHRoZW0gd2l0aCB0aGUgYFwiY20tYWN0aXZlTGluZVwiYFxuRE9NIGNsYXNzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUxpbmUoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUxpbmVIaWdobGlnaHRlcjtcbn1cbmNvbnN0IGxpbmVEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubGluZSh7IGNsYXNzOiBcImNtLWFjdGl2ZUxpbmVcIiB9KTtcbmNvbnN0IGFjdGl2ZUxpbmVIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgbGFzdExpbmVTdGFydCA9IC0xLCBkZWNvID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoci5oZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBsYXN0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKGxpbmVEZWNvLnJhbmdlKGxpbmUuZnJvbSkpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lU3RhcnQgPSBsaW5lLmZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcblxuY2xhc3MgUGxhY2Vob2xkZXIgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuY29udGVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmNvbnRlbnQodmlldykgOlxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGNvb3Jkc0F0KGRvbSkge1xuICAgICAgICBsZXQgcmVjdHMgPSBkb20uZmlyc3RDaGlsZCA/IGNsaWVudFJlY3RzRm9yKGRvbS5maXJzdENoaWxkKSA6IFtdO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20ucGFyZW50Tm9kZSk7XG4gICAgICAgIGxldCByZWN0ID0gZmxhdHRlblJlY3QocmVjdHNbMF0sIHN0eWxlLmRpcmVjdGlvbiAhPSBcInJ0bFwiKTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwYXJzZUludChzdHlsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBsaW5lSGVpZ2h0ICogMS41KVxuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGxpbmVIZWlnaHQgfTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVy4oCUYSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICBsZXQgcGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICA/IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSlcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVjb3JhdGlvbnMoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IERlY29yYXRpb24ubm9uZSA6IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICB9LCB7IGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnMgfSk7XG4gICAgcmV0dXJuIHR5cGVvZiBjb250ZW50ID09IFwic3RyaW5nXCIgPyBbXG4gICAgICAgIHBsdWdpbiwgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiYXJpYS1wbGFjZWhvbGRlclwiOiBjb250ZW50IH0pXG4gICAgXSA6IHBsdWdpbjtcbn1cblxuLy8gRG9uJ3QgY29tcHV0ZSBwcmVjaXNlIGNvbHVtbiBwb3NpdGlvbnMgZm9yIGxpbmUgb2Zmc2V0cyBhYm92ZSB0aGlzXG4vLyAoc2luY2UgaXQgY291bGQgZ2V0IGV4cGVuc2l2ZSkuIEFzc3VtZSBvZmZzZXQ9PWNvbHVtbiBmb3IgdGhlbS5cbmNvbnN0IE1heE9mZiA9IDIwMDA7XG5mdW5jdGlvbiByZWN0YW5nbGVGb3Ioc3RhdGUsIGEsIGIpIHtcbiAgICBsZXQgc3RhcnRMaW5lID0gTWF0aC5taW4oYS5saW5lLCBiLmxpbmUpLCBlbmRMaW5lID0gTWF0aC5tYXgoYS5saW5lLCBiLmxpbmUpO1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBpZiAoYS5vZmYgPiBNYXhPZmYgfHwgYi5vZmYgPiBNYXhPZmYgfHwgYS5jb2wgPCAwIHx8IGIuY29sIDwgMCkge1xuICAgICAgICBsZXQgc3RhcnRPZmYgPSBNYXRoLm1pbihhLm9mZiwgYi5vZmYpLCBlbmRPZmYgPSBNYXRoLm1heChhLm9mZiwgYi5vZmYpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8PSBlbmRPZmYpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0T2ZmLCBsaW5lLnRvICsgZW5kT2ZmKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBzdGFydENvbCA9IE1hdGgubWluKGEuY29sLCBiLmNvbCksIGVuZENvbCA9IE1hdGgubWF4KGEuY29sLCBiLmNvbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZmluZENvbHVtbihsaW5lLnRleHQsIHN0YXJ0Q29sLCBzdGF0ZS50YWJTaXplLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgZW5kQ29sLCBzdGF0ZS50YWJTaXplKTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnQsIGxpbmUuZnJvbSArIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5mdW5jdGlvbiBhYnNvbHV0ZUNvbHVtbih2aWV3LCB4KSB7XG4gICAgbGV0IHJlZiA9IHZpZXcuY29vcmRzQXRQb3Modmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICByZXR1cm4gcmVmID8gTWF0aC5yb3VuZChNYXRoLmFicygocmVmLmxlZnQgLSB4KSAvIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKSkgOiAtMTtcbn1cbmZ1bmN0aW9uIGdldFBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBvZmZzZXQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQob2Zmc2V0KSwgb2ZmID0gb2Zmc2V0IC0gbGluZS5mcm9tO1xuICAgIGxldCBjb2wgPSBvZmYgPiBNYXhPZmYgPyAtMVxuICAgICAgICA6IG9mZiA9PSBsaW5lLmxlbmd0aCA/IGFic29sdXRlQ29sdW1uKHZpZXcsIGV2ZW50LmNsaWVudFgpXG4gICAgICAgICAgICA6IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgdmlldy5zdGF0ZS50YWJTaXplLCBvZmZzZXQgLSBsaW5lLmZyb20pO1xuICAgIHJldHVybiB7IGxpbmU6IGxpbmUubnVtYmVyLCBjb2wsIG9mZiB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUodmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBnZXRQb3ModmlldywgZXZlbnQpLCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghc3RhcnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdTdGFydCA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZShzdGFydC5saW5lKS5mcm9tKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TGluZSA9IHVwZGF0ZS5zdGF0ZS5kb2MubGluZUF0KG5ld1N0YXJ0KTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHsgbGluZTogbmV3TGluZS5udW1iZXIsIGNvbDogc3RhcnQuY29sLCBvZmY6IE1hdGgubWluKHN0YXJ0Lm9mZiwgbmV3TGluZS5sZW5ndGgpIH07XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIF9leHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gZ2V0UG9zKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghY3VyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSByZWN0YW5nbGVGb3Iodmlldy5zdGF0ZSwgc3RhcnQsIGN1cik7XG4gICAgICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5jb25jYXQoc3RhcnRTZWwucmFuZ2VzKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHJlY3Rhbmd1bGFyIHNlbGVjdGlvbnMuIEJ5XG5kZWZhdWx0LCBpdCB3aWxsIHJlYWN0IHRvIGxlZnQgbW91c2UgZHJhZyB3aXRoIHRoZSBBbHQga2V5IGhlbGRcbmRvd24uIFdoZW4gc3VjaCBhIHNlbGVjdGlvbiBvY2N1cnMsIHRoZSB0ZXh0IHdpdGhpbiB0aGUgcmVjdGFuZ2xlXG50aGF0IHdhcyBkcmFnZ2VkIG92ZXIgd2lsbCBiZSBzZWxlY3RlZCwgYXMgb25lIHNlbGVjdGlvblxuW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlKSBwZXIgbGluZS5cbiovXG5mdW5jdGlvbiByZWN0YW5ndWxhclNlbGVjdGlvbihvcHRpb25zKSB7XG4gICAgbGV0IGZpbHRlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnRGaWx0ZXIpIHx8IChlID0+IGUuYWx0S2V5ICYmIGUuYnV0dG9uID09IDApO1xuICAgIHJldHVybiBFZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUub2YoKHZpZXcsIGV2ZW50KSA9PiBmaWx0ZXIoZXZlbnQpID8gcmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUodmlldywgZXZlbnQpIDogbnVsbCk7XG59XG5jb25zdCBrZXlzID0ge1xuICAgIEFsdDogWzE4LCBlID0+ICEhZS5hbHRLZXldLFxuICAgIENvbnRyb2w6IFsxNywgZSA9PiAhIWUuY3RybEtleV0sXG4gICAgU2hpZnQ6IFsxNiwgZSA9PiAhIWUuc2hpZnRLZXldLFxuICAgIE1ldGE6IFs5MSwgZSA9PiAhIWUubWV0YUtleV1cbn07XG5jb25zdCBzaG93Q3Jvc3NoYWlyID0geyBzdHlsZTogXCJjdXJzb3I6IGNyb3NzaGFpclwiIH07XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgdHVybnMgdGhlIHBvaW50ZXIgY3Vyc29yIGludG8gYVxuY3Jvc3NoYWlyIHdoZW4gYSBnaXZlbiBtb2RpZmllciBrZXksIGRlZmF1bHRpbmcgdG8gQWx0LCBpcyBoZWxkXG5kb3duLiBDYW4gc2VydmUgYXMgYSB2aXN1YWwgaGludCB0aGF0IHJlY3Rhbmd1bGFyIHNlbGVjdGlvbiBpc1xuZ29pbmcgdG8gaGFwcGVuIHdoZW4gcGFpcmVkIHdpdGhcbltgcmVjdGFuZ3VsYXJTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcucmVjdGFuZ3VsYXJTZWxlY3Rpb24pLlxuKi9cbmZ1bmN0aW9uIGNyb3NzaGFpckN1cnNvcihvcHRpb25zID0ge30pIHtcbiAgICBsZXQgW2NvZGUsIGdldHRlcl0gPSBrZXlzW29wdGlvbnMua2V5IHx8IFwiQWx0XCJdO1xuICAgIGxldCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNldChpc0Rvd24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRG93biAhPSBpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRG93biA9IGlzRG93bjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZXZlbnRPYnNlcnZlcnM6IHtcbiAgICAgICAgICAgIGtleWRvd24oZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGUua2V5Q29kZSA9PSBjb2RlIHx8IGdldHRlcihlKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5dXAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gY29kZSB8fCAhZ2V0dGVyKGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2Vtb3ZlKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcGx1Z2luLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRG93bikgPyBzaG93Q3Jvc3NoYWlyIDogbnVsbDsgfSlcbiAgICBdO1xufVxuXG5jb25zdCBPdXRzaWRlID0gXCItMTAwMDBweFwiO1xuY2xhc3MgVG9vbHRpcFZpZXdNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBmYWNldCwgY3JlYXRlVG9vbHRpcFZpZXcsIHJlbW92ZVRvb2x0aXBWaWV3KSB7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwVmlldyA9IGNyZWF0ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLnJlbW92ZVRvb2x0aXBWaWV3ID0gcmVtb3ZlVG9vbHRpcFZpZXc7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRoaXMuaW5wdXQuZmlsdGVyKHQgPT4gdCk7XG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0aGlzLnRvb2x0aXBzLm1hcCh0ID0+IHByZXYgPSBjcmVhdGVUb29sdGlwVmlldyh0LCBwcmV2KSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIGFib3ZlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoaXMuZmFjZXQpO1xuICAgICAgICBsZXQgdG9vbHRpcHMgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIGlmICh0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9vbHRpcFZpZXdzID0gW10sIG5ld0Fib3ZlID0gYWJvdmUgPyBbXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aXAgPSB0b29sdGlwc1tpXSwga25vd24gPSAtMTtcbiAgICAgICAgICAgIGlmICghdGlwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG90aGVyID0gdGhpcy50b29sdGlwc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgJiYgb3RoZXIuY3JlYXRlID09IHRpcC5jcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIGtub3duID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwVmlld3NbaV0gPSB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3KHRpcCwgaSA/IHRvb2x0aXBWaWV3c1tpIC0gMV0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3QWJvdmUpXG4gICAgICAgICAgICAgICAgICAgIG5ld0Fib3ZlW2ldID0gISF0aXAuYWJvdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwVmlld3NbaV0gPSB0aGlzLnRvb2x0aXBWaWV3c1trbm93bl07XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Fib3ZlKVxuICAgICAgICAgICAgICAgICAgICBuZXdBYm92ZVtpXSA9IGFib3ZlW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcFZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3cy5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcFZpZXcodCk7XG4gICAgICAgICAgICAgICAgKF9hID0gdC5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGFib3ZlKSB7XG4gICAgICAgICAgICBuZXdBYm92ZS5mb3JFYWNoKCh2YWwsIGkpID0+IGFib3ZlW2ldID0gdmFsKTtcbiAgICAgICAgICAgIGFib3ZlLmxlbmd0aCA9IG5ld0Fib3ZlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0b29sdGlwVmlld3M7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlcyBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIHRvb2x0aXAgYmVoYXZpb3IuXG4qL1xuZnVuY3Rpb24gdG9vbHRpcHMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gdG9vbHRpcENvbmZpZy5vZihjb25maWcpO1xufVxuZnVuY3Rpb24gd2luZG93U3BhY2Uodmlldykge1xuICAgIGxldCBkb2NFbHQgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogZG9jRWx0LmNsaWVudEhlaWdodCwgcmlnaHQ6IGRvY0VsdC5jbGllbnRXaWR0aCB9O1xufVxuY29uc3QgdG9vbHRpcENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBicm93c2VyLmlvcyA/IFwiYWJzb2x1dGVcIiA6ICgoX2EgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucG9zaXRpb24pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zaXRpb24pIHx8IFwiZml4ZWRcIixcbiAgICAgICAgICAgIHBhcmVudDogKChfYiA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wYXJlbnQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFyZW50KSB8fCBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcFNwYWNlOiAoKF9jID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnRvb2x0aXBTcGFjZSkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b29sdGlwU3BhY2UpIHx8IHdpbmRvd1NwYWNlLFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IGtub3duSGVpZ2h0ID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5jb25zdCB0b29sdGlwUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWJvdmUgPSBbXTtcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hZGVBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XG4gICAgICAgIHRoaXMucGFyZW50ID0gY29uZmlnLnBhcmVudDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gdmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkTWVhc3VyZS5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy53cml0ZU1lYXN1cmUuYmluZCh0aGlzKSwga2V5OiB0aGlzIH07XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMubWVhc3VyZVNvb24oKSkgOiBudWxsO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dUb29sdGlwLCAodCwgcCkgPT4gdGhpcy5jcmVhdGVUb29sdGlwKHQsIHApLCB0ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHQuZG9tKTtcbiAgICAgICAgICAgIHQuZG9tLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hYm92ZSA9IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAodCA9PiAhIXQuYWJvdmUpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gdGhpcy5sYXN0VHJhbnNhY3Rpb24gLSA1MCAmJlxuICAgICAgICAgICAgICAgIGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPCAxKVxuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVNvb24oKTtcbiAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFsxXSB9KSA6IG51bGw7XG4gICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICB2aWV3Lndpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24gPSB0aGlzLm1lYXN1cmVTb29uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodG9vbHRpcC5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlLCB0aGlzLmFib3ZlKTtcbiAgICAgICAgaWYgKHVwZGF0ZWQpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNob3VsZE1lYXN1cmUgPSB1cGRhdGVkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQ7XG4gICAgICAgIGxldCBuZXdDb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIGlmIChuZXdDb25maWcucG9zaXRpb24gIT0gdGhpcy5wb3NpdGlvbiAmJiAhdGhpcy5tYWRlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXdDb25maWcucG9zaXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdC5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wYXJlbnQgIT0gdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbmV3Q29uZmlnLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodC5kb20pO1xuICAgICAgICAgICAgc2hvdWxkTWVhc3VyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy52aWV3LnRoZW1lQ2xhc3NlcyAhPSB0aGlzLmNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZE1lYXN1cmUpXG4gICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVUb29sdGlwKHRvb2x0aXAsIHByZXYpIHtcbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHByZXYgPyBwcmV2LmRvbSA6IG51bGw7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcFwiKTtcbiAgICAgICAgaWYgKHRvb2x0aXAuYXJyb3cgJiYgIXRvb2x0aXBWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAgPiAuY20tdG9vbHRpcC1hcnJvd1wiKSkge1xuICAgICAgICAgICAgbGV0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGFycm93LmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hcnJvd1wiO1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUodG9vbHRpcFZpZXcuZG9tLCBiZWZvcmUpO1xuICAgICAgICBpZiAodG9vbHRpcFZpZXcubW91bnQpXG4gICAgICAgICAgICB0b29sdGlwVmlldy5tb3VudCh0aGlzLnZpZXcpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcilcbiAgICAgICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwVmlldy5kb20pO1xuICAgICAgICByZXR1cm4gdG9vbHRpcFZpZXc7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnZpZXcud2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbik7XG4gICAgICAgIGZvciAobGV0IHRvb2x0aXBWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgIChfYSA9IHRvb2x0aXBWaWV3LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRvb2x0aXBWaWV3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgKF9iID0gdGhpcy5yZXNpemVPYnNlcnZlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9jID0gdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVhc3VyZVRpbWVvdXQpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZSgpIHtcbiAgICAgICAgbGV0IHNjYWxlWCA9IDEsIHNjYWxlWSA9IDEsIG1ha2VBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImZpeGVkXCIgJiYgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGRvbSB9ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1swXTtcbiAgICAgICAgICAgIGlmIChicm93c2VyLnNhZmFyaSkge1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBhbHdheXMgc2V0cyBvZmZzZXRQYXJlbnQgdG8gbnVsbCwgZXZlbiBpZiBhIGZpeGVkXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIGEgdHJhbnNmb3JtZWQgcGFyZW50LiBTb1xuICAgICAgICAgICAgICAgIC8vIHdlIHVzZSB0aGlzIGtsdWRnZSB0byB0cnkgYW5kIGRldGVjdCB0aGlzLlxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9IE1hdGguYWJzKHJlY3QudG9wICsgMTAwMDApID4gMSB8fCBNYXRoLmFicyhyZWN0LmxlZnQpID4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1vcmUgY29uZm9ybWluZyBicm93c2VycyB3aWxsIHNldCBvZmZzZXRQYXJlbnQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBtYWtlQWJzb2x1dGUgPSAhIWRvbS5vZmZzZXRQYXJlbnQgJiYgZG9tLm9mZnNldFBhcmVudCAhPSB0aGlzLmNvbnRhaW5lci5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ha2VBYnNvbHV0ZSB8fCB0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSB0aGlzLnBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVggPSByZWN0LndpZHRoIC8gdGhpcy5wYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gdGhpcy5wYXJlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICh7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXcudmlld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlzaWJsZSA9IHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogdmlzaWJsZS5sZWZ0ICsgbWFyZ2lucy5sZWZ0LCB0b3A6IHZpc2libGUudG9wICsgbWFyZ2lucy50b3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHZpc2libGUucmlnaHQgLSBtYXJnaW5zLnJpZ2h0LCBib3R0b206IHZpc2libGUuYm90dG9tIC0gbWFyZ2lucy5ib3R0b21cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMucGFyZW50ID8gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB0aGlzLnZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgcG9zOiB0aGlzLm1hbmFnZXIudG9vbHRpcHMubWFwKCh0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR2ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHYuZ2V0Q29vcmRzID8gdHYuZ2V0Q29vcmRzKHQucG9zKSA6IHRoaXMudmlldy5jb29yZHNBdFBvcyh0LnBvcyk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubWFwKCh7IGRvbSB9KSA9PiBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLFxuICAgICAgICAgICAgc3BhY2U6IHRoaXMudmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKS50b29sdGlwU3BhY2UodGhpcy52aWV3KSxcbiAgICAgICAgICAgIHNjYWxlWCwgc2NhbGVZLCBtYWtlQWJzb2x1dGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd3JpdGVNZWFzdXJlKG1lYXN1cmVkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG1lYXN1cmVkLm1ha2VBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5tYWRlQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyB2aXNpYmxlLCBzcGFjZSwgc2NhbGVYLCBzY2FsZVkgfSA9IG1lYXN1cmVkO1xuICAgICAgICBsZXQgb3RoZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMubWFuYWdlci50b29sdGlwc1tpXSwgdFZpZXcgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldLCB7IGRvbSB9ID0gdFZpZXc7XG4gICAgICAgICAgICBsZXQgcG9zID0gbWVhc3VyZWQucG9zW2ldLCBzaXplID0gbWVhc3VyZWQuc2l6ZVtpXTtcbiAgICAgICAgICAgIC8vIEhpZGUgdG9vbHRpcHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgZWRpdG9yLlxuICAgICAgICAgICAgaWYgKCFwb3MgfHwgdG9vbHRpcC5jbGlwICE9PSBmYWxzZSAmJiAocG9zLmJvdHRvbSA8PSBNYXRoLm1heCh2aXNpYmxlLnRvcCwgc3BhY2UudG9wKSB8fFxuICAgICAgICAgICAgICAgIHBvcy50b3AgPj0gTWF0aC5taW4odmlzaWJsZS5ib3R0b20sIHNwYWNlLmJvdHRvbSkgfHxcbiAgICAgICAgICAgICAgICBwb3MucmlnaHQgPCBNYXRoLm1heCh2aXNpYmxlLmxlZnQsIHNwYWNlLmxlZnQpIC0gLjEgfHxcbiAgICAgICAgICAgICAgICBwb3MubGVmdCA+IE1hdGgubWluKHZpc2libGUucmlnaHQsIHNwYWNlLnJpZ2h0KSArIC4xKSkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFycm93ID0gdG9vbHRpcC5hcnJvdyA/IHRWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAtYXJyb3dcIikgOiBudWxsO1xuICAgICAgICAgICAgbGV0IGFycm93SGVpZ2h0ID0gYXJyb3cgPyA3IC8qIEFycm93LlNpemUgKi8gOiAwO1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gc2l6ZS5yaWdodCAtIHNpemUubGVmdCwgaGVpZ2h0ID0gKF9hID0ga25vd25IZWlnaHQuZ2V0KHRWaWV3KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2l6ZS5ib3R0b20gLSBzaXplLnRvcDtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0Vmlldy5vZmZzZXQgfHwgbm9PZmZzZXQsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNpemUud2lkdGggPiBzcGFjZS5yaWdodCAtIHNwYWNlLmxlZnRcbiAgICAgICAgICAgICAgICA/IChsdHIgPyBzcGFjZS5sZWZ0IDogc3BhY2UucmlnaHQgLSBzaXplLndpZHRoKVxuICAgICAgICAgICAgICAgIDogbHRyID8gTWF0aC5tYXgoc3BhY2UubGVmdCwgTWF0aC5taW4ocG9zLmxlZnQgLSAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSArIG9mZnNldC54LCBzcGFjZS5yaWdodCAtIHdpZHRoKSlcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihNYXRoLm1heChzcGFjZS5sZWZ0LCBwb3MubGVmdCAtIHdpZHRoICsgKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgLSBvZmZzZXQueCksIHNwYWNlLnJpZ2h0IC0gd2lkdGgpO1xuICAgICAgICAgICAgbGV0IGFib3ZlID0gdGhpcy5hYm92ZVtpXTtcbiAgICAgICAgICAgIGlmICghdG9vbHRpcC5zdHJpY3RTaWRlICYmIChhYm92ZVxuICAgICAgICAgICAgICAgID8gcG9zLnRvcCAtIGhlaWdodCAtIGFycm93SGVpZ2h0IC0gb2Zmc2V0LnkgPCBzcGFjZS50b3BcbiAgICAgICAgICAgICAgICA6IHBvcy5ib3R0b20gKyBoZWlnaHQgKyBhcnJvd0hlaWdodCArIG9mZnNldC55ID4gc3BhY2UuYm90dG9tKSAmJlxuICAgICAgICAgICAgICAgIGFib3ZlID09IChzcGFjZS5ib3R0b20gLSBwb3MuYm90dG9tID4gcG9zLnRvcCAtIHNwYWNlLnRvcCkpXG4gICAgICAgICAgICAgICAgYWJvdmUgPSB0aGlzLmFib3ZlW2ldID0gIWFib3ZlO1xuICAgICAgICAgICAgbGV0IHNwYWNlVmVydCA9IChhYm92ZSA/IHBvcy50b3AgLSBzcGFjZS50b3AgOiBzcGFjZS5ib3R0b20gLSBwb3MuYm90dG9tKSAtIGFycm93SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHNwYWNlVmVydCA8IGhlaWdodCAmJiB0Vmlldy5yZXNpemUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlVmVydCA8IHRoaXMudmlldy5kZWZhdWx0TGluZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtub3duSGVpZ2h0LnNldCh0VmlldywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gKGhlaWdodCA9IHNwYWNlVmVydCkgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20uc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gYWJvdmUgPyBwb3MudG9wIC0gaGVpZ2h0IC0gYXJyb3dIZWlnaHQgLSBvZmZzZXQueSA6IHBvcy5ib3R0b20gKyBhcnJvd0hlaWdodCArIG9mZnNldC55O1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBvdGhlcnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmxlZnQgPCByaWdodCAmJiByLnJpZ2h0ID4gbGVmdCAmJiByLnRvcCA8IHRvcCArIGhlaWdodCAmJiByLmJvdHRvbSA+IHRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGFib3ZlID8gci50b3AgLSBoZWlnaHQgLSAyIC0gYXJyb3dIZWlnaHQgOiByLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgMjtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIikge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSAodG9wIC0gbWVhc3VyZWQucGFyZW50LnRvcCkgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc2V0TGVmdFN0eWxlKGRvbSwgKGxlZnQgLSBtZWFzdXJlZC5wYXJlbnQubGVmdCkgLyBzY2FsZVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IHRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZXRMZWZ0U3R5bGUoZG9tLCBsZWZ0IC8gc2NhbGVYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcnJvdykge1xuICAgICAgICAgICAgICAgIGxldCBhcnJvd0xlZnQgPSBwb3MubGVmdCArIChsdHIgPyBvZmZzZXQueCA6IC1vZmZzZXQueCkgLSAobGVmdCArIDE0IC8qIEFycm93Lk9mZnNldCAqLyAtIDcgLyogQXJyb3cuU2l6ZSAqLyk7XG4gICAgICAgICAgICAgICAgYXJyb3cuc3R5bGUubGVmdCA9IGFycm93TGVmdCAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIG90aGVycy5wdXNoKHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tOiB0b3AgKyBoZWlnaHQgfSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYWJvdmVcIiwgYWJvdmUpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWJlbG93XCIsICFhYm92ZSk7XG4gICAgICAgICAgICBpZiAodFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICB0Vmlldy5wb3NpdGlvbmVkKG1lYXN1cmVkLnNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZU1lYXN1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluVmlldyAhPSB0aGlzLnZpZXcuaW5WaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pblZpZXcgPSB0aGlzLnZpZXcuaW5WaWV3O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR2IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB0di5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBzY3JvbGwoKSB7IHRoaXMubWF5YmVNZWFzdXJlKCk7IH1cbiAgICB9XG59KTtcbmZ1bmN0aW9uIHNldExlZnRTdHlsZShlbHQsIHZhbHVlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBwYXJzZUludChlbHQuc3R5bGUubGVmdCwgMTApO1xuICAgIGlmIChpc05hTihjdXJyZW50KSB8fCBNYXRoLmFicyh2YWx1ZSAtIGN1cnJlbnQpID4gMSlcbiAgICAgICAgZWx0LnN0eWxlLmxlZnQgPSB2YWx1ZSArIFwicHhcIjtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIHpJbmRleDogNTAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2JiYlwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1zZWN0aW9uOm5vdCg6Zmlyc3QtY2hpbGQpXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIGhlaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgd2lkdGg6IGAkezcgLyogQXJyb3cuU2l6ZSAqLyAqIDJ9cHhgLFxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgXCImOmJlZm9yZSwgJjphZnRlclwiOiB7XG4gICAgICAgICAgICBjb250ZW50OiBcIicnXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYWJvdmUgJlwiOiB7XG4gICAgICAgICAgICBib3R0b206IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICBib3R0b206IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1iZWxvdyAmXCI6IHtcbiAgICAgICAgICAgIHRvcDogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIHRvcDogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzMzMzMzOFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCBub09mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuLyoqXG5GYWNldCB0byB3aGljaCBhbiBleHRlbnNpb24gY2FuIGFkZCBhIHZhbHVlIHRvIHNob3cgYSB0b29sdGlwLlxuKi9cbmNvbnN0IHNob3dUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogW3Rvb2x0aXBQbHVnaW4sIGJhc2VUaGVtZV1cbn0pO1xuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IGlucHV0cyA9PiBpbnB1dHMucmVkdWNlKChhLCBpKSA9PiBhLmNvbmNhdChpKSwgW10pXG59KTtcbmNsYXNzIEhvdmVyVG9vbHRpcEhvc3Qge1xuICAgIC8vIE5lZWRzIHRvIGJlIHN0YXRpYyBzbyB0aGF0IGhvc3QgdG9vbHRpcCBpbnN0YW5jZXMgYWx3YXlzIG1hdGNoXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgSG92ZXJUb29sdGlwSG9zdCh2aWV3KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1ob3ZlclwiKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93SG92ZXJUb29sdGlwLCAodCwgcCkgPT4gdGhpcy5jcmVhdGVIb3N0ZWRWaWV3KHQsIHApLCB0ID0+IHQuZG9tLnJlbW92ZSgpKTtcbiAgICB9XG4gICAgY3JlYXRlSG9zdGVkVmlldyh0b29sdGlwLCBwcmV2KSB7XG4gICAgICAgIGxldCBob3N0ZWRWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcbiAgICAgICAgaG9zdGVkVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXAtc2VjdGlvblwiKTtcbiAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKGhvc3RlZFZpZXcuZG9tLCBwcmV2ID8gcHJldi5kb20ubmV4dFNpYmxpbmcgOiB0aGlzLmRvbS5maXJzdENoaWxkKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCAmJiBob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh0aGlzLnZpZXcpO1xuICAgICAgICByZXR1cm4gaG9zdGVkVmlldztcbiAgICB9XG4gICAgbW91bnQodmlldykge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zaXRpb25lZChzcGFjZSkge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3LnBvc2l0aW9uZWQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5wb3NpdGlvbmVkKHNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAoX2EgPSB0LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHQpO1xuICAgIH1cbiAgICBwYXNzUHJvcChuYW1lKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgZ2l2ZW4gPSB2aWV3W25hbWVdO1xuICAgICAgICAgICAgaWYgKGdpdmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnaXZlbjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gZ2l2ZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcIm9mZnNldFwiKTsgfVxuICAgIGdldCBnZXRDb29yZHMoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwiZ2V0Q29vcmRzXCIpOyB9XG4gICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwib3ZlcmxhcFwiKTsgfVxuICAgIGdldCByZXNpemUoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwicmVzaXplXCIpOyB9XG59XG5jb25zdCBzaG93SG92ZXJUb29sdGlwSG9zdCA9IC8qQF9fUFVSRV9fKi9zaG93VG9vbHRpcC5jb21wdXRlKFtzaG93SG92ZXJUb29sdGlwXSwgc3RhdGUgPT4ge1xuICAgIGxldCB0b29sdGlwcyA9IHN0YXRlLmZhY2V0KHNob3dIb3ZlclRvb2x0aXApO1xuICAgIGlmICh0b29sdGlwcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvczogTWF0aC5taW4oLi4udG9vbHRpcHMubWFwKHQgPT4gdC5wb3MpKSxcbiAgICAgICAgZW5kOiBNYXRoLm1heCguLi50b29sdGlwcy5tYXAodCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHQuZW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0LnBvczsgfSkpLFxuICAgICAgICBjcmVhdGU6IEhvdmVyVG9vbHRpcEhvc3QuY3JlYXRlLFxuICAgICAgICBhYm92ZTogdG9vbHRpcHNbMF0uYWJvdmUsXG4gICAgICAgIGFycm93OiB0b29sdGlwcy5zb21lKHQgPT4gdC5hcnJvdyksXG4gICAgfTtcbn0pO1xuY2xhc3MgSG92ZXJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHNvdXJjZSwgZmllbGQsIHNldEhvdmVyLCBob3ZlclRpbWUpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5zZXRIb3ZlciA9IHNldEhvdmVyO1xuICAgICAgICB0aGlzLmhvdmVyVGltZSA9IGhvdmVyVGltZTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiAwLCB5OiAwLCB0YXJnZXQ6IHZpZXcuZG9tLCB0aW1lOiAwIH07XG4gICAgICAgIHRoaXMuY2hlY2tIb3ZlciA9IHRoaXMuY2hlY2tIb3Zlci5iaW5kKHRoaXMpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUgPSB0aGlzLm1vdXNlbGVhdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUgPSB0aGlzLm1vdXNlbW92ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydEhvdmVyKCksIDIwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgIH1cbiAgICBjaGVja0hvdmVyKCkge1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgaG92ZXJlZCA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RNb3ZlLnRpbWU7XG4gICAgICAgIGlmIChob3ZlcmVkIDwgdGhpcy5ob3ZlclRpbWUpXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSAtIGhvdmVyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SG92ZXIoKTtcbiAgICB9XG4gICAgc3RhcnRIb3ZlcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICBsZXQgeyB2aWV3LCBsYXN0TW92ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChsYXN0TW92ZS50YXJnZXQpO1xuICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MsIHNpZGUgPSAxO1xuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHtcbiAgICAgICAgICAgIHBvcyA9IGRlc2MucG9zQXRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IHZpZXcucG9zQXRDb29yZHMobGFzdE1vdmUpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBwb3NDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgICAgICBpZiAoIXBvc0Nvb3JkcyB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnkgPCBwb3NDb29yZHMudG9wIHx8IGxhc3RNb3ZlLnkgPiBwb3NDb29yZHMuYm90dG9tIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0IC0gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGggfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS54ID4gcG9zQ29vcmRzLnJpZ2h0ICsgdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGJpZGkgPSB2aWV3LmJpZGlTcGFucyh2aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKSkuZmluZChzID0+IHMuZnJvbSA8PSBwb3MgJiYgcy50byA+PSBwb3MpO1xuICAgICAgICAgICAgbGV0IHJ0bCA9IGJpZGkgJiYgYmlkaS5kaXIgPT0gRGlyZWN0aW9uLlJUTCA/IC0xIDogMTtcbiAgICAgICAgICAgIHNpZGUgPSAobGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0ID8gLXJ0bCA6IHJ0bCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLnNvdXJjZSh2aWV3LCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAob3BlbiA9PT0gbnVsbCB8fCBvcGVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuLnRoZW4pIHtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nID0geyBwb3MgfTtcbiAgICAgICAgICAgIG9wZW4udGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcgPT0gcGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmICEoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmICFyZXN1bHQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdCA6IFtyZXN1bHRdKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlID0+IGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcImhvdmVyIHRvb2x0aXBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZW4gJiYgIShBcnJheS5pc0FycmF5KG9wZW4pICYmICFvcGVuLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKEFycmF5LmlzQXJyYXkob3BlbikgPyBvcGVuIDogW29wZW5dKSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdG9vbHRpcCgpIHtcbiAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMudmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgICAgIGxldCBpbmRleCA9IHBsdWdpbiA/IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmZpbmRJbmRleCh0ID0+IHQuY3JlYXRlID09IEhvdmVyVG9vbHRpcEhvc3QuY3JlYXRlKSA6IC0xO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpbmRleF0gOiBudWxsO1xuICAgIH1cbiAgICBtb3VzZW1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdGFyZ2V0OiBldmVudC50YXJnZXQsIHRpbWU6IERhdGUubm93KCkgfTtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lKTtcbiAgICAgICAgbGV0IHsgYWN0aXZlLCB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCAmJiB0b29sdGlwICYmICFpc0luVG9vbHRpcCh0b29sdGlwLmRvbSwgZXZlbnQpIHx8IHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgbGV0IHsgcG9zIH0gPSBhY3RpdmVbMF0gfHwgdGhpcy5wZW5kaW5nLCBlbmQgPSAoX2IgPSAoX2EgPSBhY3RpdmVbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHBvcztcbiAgICAgICAgICAgIGlmICgocG9zID09IGVuZCA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyh0aGlzLmxhc3RNb3ZlKSAhPSBwb3NcbiAgICAgICAgICAgICAgICA6ICFpc092ZXJSYW5nZSh0aGlzLnZpZXcsIHBvcywgZW5kLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKFtdKSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1vdXNlbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgbGV0IHsgYWN0aXZlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgdG9vbHRpcCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBpblRvb2x0aXAgPSB0b29sdGlwICYmIHRvb2x0aXAuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgICAgaWYgKCFpblRvb2x0aXApXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihbXSkgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53YXRjaFRvb2x0aXBMZWF2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2F0Y2hUb29sdGlwTGVhdmUodG9vbHRpcCkge1xuICAgICAgICBsZXQgd2F0Y2ggPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgd2F0Y2gpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlLmxlbmd0aCAmJiAhdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKFtdKSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdG9vbHRpcC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3YXRjaCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhvdmVyVGltZW91dCk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlKTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICB9XG59XG5jb25zdCB0b29sdGlwTWFyZ2luID0gNDtcbmZ1bmN0aW9uIGlzSW5Ub29sdGlwKHRvb2x0aXAsIGV2ZW50KSB7XG4gICAgbGV0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSB0b29sdGlwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhcnJvdztcbiAgICBpZiAoYXJyb3cgPSB0b29sdGlwLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hcnJvd1wiKSkge1xuICAgICAgICBsZXQgYXJyb3dSZWN0ID0gYXJyb3cuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKGFycm93UmVjdC50b3AsIHRvcCk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGFycm93UmVjdC5ib3R0b20sIGJvdHRvbSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudC5jbGllbnRYID49IGxlZnQgLSB0b29sdGlwTWFyZ2luICYmIGV2ZW50LmNsaWVudFggPD0gcmlnaHQgKyB0b29sdGlwTWFyZ2luICYmXG4gICAgICAgIGV2ZW50LmNsaWVudFkgPj0gdG9wIC0gdG9vbHRpcE1hcmdpbiAmJiBldmVudC5jbGllbnRZIDw9IGJvdHRvbSArIHRvb2x0aXBNYXJnaW47XG59XG5mdW5jdGlvbiBpc092ZXJSYW5nZSh2aWV3LCBmcm9tLCB0bywgeCwgeSwgbWFyZ2luKSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jQm90dG9tID0gdmlldy5kb2N1bWVudFRvcCArIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCArIHZpZXcuY29udGVudEhlaWdodDtcbiAgICBpZiAocmVjdC5sZWZ0ID4geCB8fCByZWN0LnJpZ2h0IDwgeCB8fCByZWN0LnRvcCA+IHkgfHwgTWF0aC5taW4ocmVjdC5ib3R0b20sIGRvY0JvdHRvbSkgPCB5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4LCB5IH0sIGZhbHNlKTtcbiAgICByZXR1cm4gcG9zID49IGZyb20gJiYgcG9zIDw9IHRvO1xufVxuLyoqXG5TZXQgdXAgYSBob3ZlciB0b29sdGlwLCB3aGljaCBzaG93cyB1cCB3aGVuIHRoZSBwb2ludGVyIGhvdmVyc1xub3ZlciByYW5nZXMgb2YgdGV4dC4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBob3ZlcnNcbm92ZXIgdGhlIGRvY3VtZW50IHRleHQuIEl0IHNob3VsZCwgaWYgdGhlcmUgaXMgYSB0b29sdGlwXG5hc3NvY2lhdGVkIHdpdGggcG9zaXRpb24gYHBvc2AsIHJldHVybiB0aGUgdG9vbHRpcCBkZXNjcmlwdGlvblxuKGVpdGhlciBkaXJlY3RseSBvciBpbiBhIHByb21pc2UpLiBUaGUgYHNpZGVgIGFyZ3VtZW50IGluZGljYXRlc1xub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXPigJRpdCB3aWxsIGJlIC0xIGlmIHRoZVxucG9pbnRlciBpcyBiZWZvcmUgdGhlIHBvc2l0aW9uLCAxIGlmIGFmdGVyIHRoZSBwb3NpdGlvbi5cblxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXG5jb250YWluZXIgZWxlbWVudC4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgdG9vbHRpcHMgb3ZlciB0aGUgc2FtZVxucmFuZ2UgdG8gYmUgXCJtZXJnZWRcIiB0b2dldGhlciB3aXRob3V0IG92ZXJsYXBwaW5nLlxuXG5UaGUgcmV0dXJuIHZhbHVlIGlzIGEgdmFsaWQgW2VkaXRvciBleHRlbnNpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKVxuYnV0IGFsc28gcHJvdmlkZXMgYW4gYGFjdGl2ZWAgcHJvcGVydHkgaG9sZGluZyBhIHN0YXRlIGZpZWxkIHRoYXRcbmNhbiBiZSB1c2VkIHRvIHJlYWQgdGhlIGN1cnJlbnRseSBhY3RpdmUgdG9vbHRpcHMgcHJvZHVjZWQgYnkgdGhpc1xuZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGhvdmVyVG9vbHRpcChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzZXRIb3ZlciA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuICAgIGxldCBob3ZlclN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhpZGVPbkNoYW5nZSAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGlkZU9uKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmZpbHRlcih2ID0+ICFvcHRpb25zLmhpZGVPbih0ciwgdikpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1BvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHRvb2x0aXAucG9zLCAtMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgdG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weS5wb3MgPSBuZXdQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHkuZW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuZW5kID0gdHIuY2hhbmdlcy5tYXBQb3MoY29weS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKGNvcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRIb3ZlcikpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlOiBmID0+IHNob3dIb3ZlclRvb2x0aXAuZnJvbShmKVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZTogaG92ZXJTdGF0ZSxcbiAgICAgICAgZXh0ZW5zaW9uOiBbXG4gICAgICAgICAgICBob3ZlclN0YXRlLFxuICAgICAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiBuZXcgSG92ZXJQbHVnaW4odmlldywgc291cmNlLCBob3ZlclN0YXRlLCBzZXRIb3Zlciwgb3B0aW9ucy5ob3ZlclRpbWUgfHwgMzAwIC8qIEhvdmVyLlRpbWUgKi8pKSxcbiAgICAgICAgICAgIHNob3dIb3ZlclRvb2x0aXBIb3N0XG4gICAgICAgIF1cbiAgICB9O1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSB0b29sdGlwIHZpZXcgZm9yIGEgZ2l2ZW4gdG9vbHRpcCwgaWYgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXAodmlldywgdG9vbHRpcCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAoIXBsdWdpbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kID0gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuaW5kZXhPZih0b29sdGlwKTtcbiAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tmb3VuZF07XG59XG4vKipcblJldHVybnMgdHJ1ZSBpZiBhbnkgaG92ZXIgdG9vbHRpcHMgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4qL1xuZnVuY3Rpb24gaGFzSG92ZXJUb29sdGlwcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKS5zb21lKHggPT4geCk7XG59XG5jb25zdCBjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuVHJhbnNhY3Rpb24gZWZmZWN0IHRoYXQgY2xvc2VzIGFsbCBob3ZlciB0b29sdGlwcy5cbiovXG5jb25zdCBjbG9zZUhvdmVyVG9vbHRpcHMgPSAvKkBfX1BVUkVfXyovY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3Qub2YobnVsbCk7XG4vKipcblRlbGwgdGhlIHRvb2x0aXAgZXh0ZW5zaW9uIHRvIHJlY29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGFjdGl2ZVxudG9vbHRpcHMuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIChzdWNoIGFzIGFcbnJlLXBvc2l0aW9uaW5nIG9yIENTUyBjaGFuZ2UgYWZmZWN0aW5nIHRoZSBlZGl0b3IpIHRoYXQgY291bGRcbmludmFsaWRhdGUgdGhlIGV4aXN0aW5nIHRvb2x0aXAgcG9zaXRpb25zLlxuKi9cbmZ1bmN0aW9uIHJlcG9zaXRpb25Ub29sdGlwcyh2aWV3KSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgIGlmIChwbHVnaW4pXG4gICAgICAgIHBsdWdpbi5tYXliZU1lYXN1cmUoKTtcbn1cblxuY29uc3QgcGFuZWxDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyO1xuICAgICAgICBmb3IgKGxldCBjIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgICAgIHRvcENvbnRhaW5lciA9IHRvcENvbnRhaW5lciB8fCBjLnRvcENvbnRhaW5lcjtcbiAgICAgICAgICAgIGJvdHRvbUNvbnRhaW5lciA9IGJvdHRvbUNvbnRhaW5lciB8fCBjLmJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lciB9O1xuICAgIH1cbn0pO1xuLyoqXG5Db25maWd1cmVzIHRoZSBwYW5lbC1tYW5hZ2luZyBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gcGFuZWxzKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgPyBbcGFuZWxDb25maWcub2YoY29uZmlnKV0gOiBbXTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgcGFuZWwgY3JlYXRlZCBieSB0aGUgZ2l2ZW4gY29uc3RydWN0b3IsIGlmIGFueS5cblRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIGFjY2VzcyB0byB5b3VyIHBhbmVscycgRE9NXG5zdHJ1Y3R1cmUuXG4qL1xuZnVuY3Rpb24gZ2V0UGFuZWwodmlldywgcGFuZWwpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4ocGFuZWxQbHVnaW4pO1xuICAgIGxldCBpbmRleCA9IHBsdWdpbiA/IHBsdWdpbi5zcGVjcy5pbmRleE9mKHBhbmVsKSA6IC0xO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gcGx1Z2luLnBhbmVsc1tpbmRleF0gOiBudWxsO1xufVxuY29uc3QgcGFuZWxQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoc2hvd1BhbmVsKTtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHRoaXMuaW5wdXQuZmlsdGVyKHMgPT4gcyk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gdGhpcy5zcGVjcy5tYXAoc3BlYyA9PiBzcGVjKHZpZXcpKTtcbiAgICAgICAgbGV0IGNvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgdGhpcy50b3AgPSBuZXcgUGFuZWxHcm91cCh2aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodmlldywgZmFsc2UsIGNvbmYuYm90dG9tQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy50b3Auc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiBwLnRvcCkpO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+ICFwLnRvcCkpO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICBwLm1vdW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY29uZiA9IHVwZGF0ZS5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIGlmICh0aGlzLnRvcC5jb250YWluZXIgIT0gY29uZi50b3BDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xuICAgICAgICAgICAgdGhpcy50b3AgPSBuZXcgUGFuZWxHcm91cCh1cGRhdGUudmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvdHRvbS5jb250YWluZXIgIT0gY29uZi5ib3R0b21Db250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBuZXcgUGFuZWxHcm91cCh1cGRhdGUudmlldywgZmFsc2UsIGNvbmYuYm90dG9tQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcC5zeW5jQ2xhc3NlcygpO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jQ2xhc3NlcygpO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc2hvd1BhbmVsKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGxldCBzcGVjcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICAgICAgbGV0IHBhbmVscyA9IFtdLCB0b3AgPSBbXSwgYm90dG9tID0gW10sIG1vdW50ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjIG9mIHNwZWNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gdGhpcy5zcGVjcy5pbmRleE9mKHNwZWMpLCBwYW5lbDtcbiAgICAgICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gc3BlYyh1cGRhdGUudmlldyk7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50LnB1c2gocGFuZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSB0aGlzLnBhbmVsc1trbm93bl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYW5lbC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lbC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFuZWxzLnB1c2gocGFuZWwpO1xuICAgICAgICAgICAgICAgIChwYW5lbC50b3AgPyB0b3AgOiBib3R0b20pLnB1c2gocGFuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zcGVjcyA9IHNwZWNzO1xuICAgICAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKHRvcCk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKGJvdHRvbSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIG1vdW50KSB7XG4gICAgICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgICAgICBwLm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKVxuICAgICAgICAgICAgICAgIGlmIChwLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB7IHRvcDogdmFsdWUudG9wLnNjcm9sbE1hcmdpbigpLCBib3R0b206IHZhbHVlLmJvdHRvbS5zY3JvbGxNYXJnaW4oKSB9O1xuICAgIH0pXG59KTtcbmNsYXNzIFBhbmVsR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHRvcCwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5kb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IFwiXCI7XG4gICAgICAgIHRoaXMucGFuZWxzID0gW107XG4gICAgICAgIHRoaXMuc3luY0NsYXNzZXMoKTtcbiAgICB9XG4gICAgc3luYyhwYW5lbHMpIHtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgIGlmIChwLmRlc3Ryb3kgJiYgcGFuZWxzLmluZGV4T2YocCkgPCAwKVxuICAgICAgICAgICAgICAgIHAuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgdGhpcy5zeW5jRE9NKCk7XG4gICAgfVxuICAgIHN5bmNET00oKSB7XG4gICAgICAgIGlmICh0aGlzLnBhbmVscy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gdGhpcy50b3AgPyBcImNtLXBhbmVscyBjbS1wYW5lbHMtdG9wXCIgOiBcImNtLXBhbmVscyBjbS1wYW5lbHMtYm90dG9tXCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZVt0aGlzLnRvcCA/IFwidG9wXCIgOiBcImJvdHRvbVwiXSA9IFwiMFwiO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuY29udGFpbmVyIHx8IHRoaXMudmlldy5kb207XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCB0aGlzLnRvcCA/IHBhcmVudC5maXJzdENoaWxkIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1ckRPTSA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IHBhbmVsIG9mIHRoaXMucGFuZWxzKSB7XG4gICAgICAgICAgICBpZiAocGFuZWwuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyRE9NICE9IHBhbmVsLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBjdXJET00gPSBjdXJET00ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUocGFuZWwuZG9tLCBjdXJET00pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjdXJET00pXG4gICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgIH1cbiAgICBzY3JvbGxNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kb20gfHwgdGhpcy5jb250YWluZXIgPyAwXG4gICAgICAgICAgICA6IE1hdGgubWF4KDAsIHRoaXMudG9wID9cbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBNYXRoLm1heCgwLCB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgOlxuICAgICAgICAgICAgICAgIE1hdGgubWluKGlubmVySGVpZ2h0LCB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSkgLSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApO1xuICAgIH1cbiAgICBzeW5jQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lciB8fCB0aGlzLmNsYXNzZXMgPT0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgY2xzIG9mIHRoaXMuY2xhc3Nlcy5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgICAgZm9yIChsZXQgY2xzIG9mICh0aGlzLmNsYXNzZXMgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKS5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBybShub2RlKSB7XG4gICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG4vKipcbk9wZW5pbmcgYSBwYW5lbCBpcyBkb25lIGJ5IHByb3ZpZGluZyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvclxudGhlIHBhbmVsIHRocm91Z2ggdGhpcyBmYWNldC4gKFRoZSBwYW5lbCBpcyBjbG9zZWQgYWdhaW4gd2hlbiBpdHNcbmNvbnN0cnVjdG9yIGlzIG5vIGxvbmdlciBwcm92aWRlZC4pIFZhbHVlcyBvZiBgbnVsbGAgYXJlIGlnbm9yZWQuXG4qL1xuY29uc3Qgc2hvd1BhbmVsID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogcGFuZWxQbHVnaW5cbn0pO1xuXG4vKipcblNob3cgYSBwYW5lbCBhYm92ZSBvciBiZWxvdyB0aGUgZWRpdG9yIHRvIHNob3cgdGhlIHVzZXIgYSBtZXNzYWdlXG5vciBwcm9tcHQgdGhlbSBmb3IgaW5wdXQuIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlIGRpc3BhdGNoZWRcbnRvIGNsb3NlIHRoZSBkaWFsb2csIGFuZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBkaWFsb2dcbmlzIGNsb3NlZCBvciBhIGZvcm0gaW5zaWRlIG9mIGl0IGlzIHN1Ym1pdHRlZC5cblxuWW91IGFyZSBlbmNvdXJhZ2VkLCBpZiB5b3VyIGhhbmRsaW5nIG9mIHRoZSByZXN1bHQgb2YgdGhlIHByb21pc2VcbmRpc3BhdGNoZXMgYSB0cmFuc2FjdGlvbiwgdG8gaW5jbHVkZSB0aGUgYGNsb3NlYCBlZmZlY3QgaW4gaXQuIElmXG55b3UgZG9uJ3QsIHRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BhdGNoIGEgc2VwYXJhdGVcbnRyYW5zYWN0aW9uIHJpZ2h0IGFmdGVyLlxuKi9cbmZ1bmN0aW9uIHNob3dEaWFsb2codmlldywgY29uZmlnKSB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyID0+IHJlc29sdmUgPSByKTtcbiAgICBsZXQgcGFuZWxDdG9yID0gKHZpZXcpID0+IGNyZWF0ZURpYWxvZyh2aWV3LCBjb25maWcsIHJlc29sdmUpO1xuICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGRpYWxvZ0ZpZWxkLCBmYWxzZSkpIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG9wZW5EaWFsb2dFZmZlY3Qub2YocGFuZWxDdG9yKSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoZGlhbG9nRmllbGQuaW5pdCgoKSA9PiBbcGFuZWxDdG9yXSkpIH0pO1xuICAgIH1cbiAgICBsZXQgY2xvc2UgPSBjbG9zZURpYWxvZ0VmZmVjdC5vZihwYW5lbEN0b3IpO1xuICAgIHJldHVybiB7IGNsb3NlLCByZXN1bHQ6IHByb21pc2UudGhlbihmb3JtID0+IHtcbiAgICAgICAgICAgIGxldCBxdWV1ZSA9IHZpZXcud2luLnF1ZXVlTWljcm90YXNrIHx8ICgoZikgPT4gdmlldy53aW4uc2V0VGltZW91dChmLCAxMCkpO1xuICAgICAgICAgICAgcXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGRpYWxvZ0ZpZWxkKS5pbmRleE9mKHBhbmVsQ3RvcikgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybTtcbiAgICAgICAgfSkgfTtcbn1cbi8qKlxuRmluZCB0aGUgW2BQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5QYW5lbCkgZm9yIGFuIG9wZW4gZGlhbG9nLCB1c2luZyBhIGNsYXNzXG5uYW1lIGFzIGlkZW50aWZpZXIuXG4qL1xuZnVuY3Rpb24gZ2V0RGlhbG9nKHZpZXcsIGNsYXNzTmFtZSkge1xuICAgIGxldCBkaWFsb2dzID0gdmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCwgZmFsc2UpIHx8IFtdO1xuICAgIGZvciAobGV0IG9wZW4gb2YgZGlhbG9ncykge1xuICAgICAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBvcGVuKTtcbiAgICAgICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSlcbiAgICAgICAgICAgIHJldHVybiBwYW5lbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBkaWFsb2dGaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gW107IH0sXG4gICAgdXBkYXRlKGRpYWxvZ3MsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGUuaXMob3BlbkRpYWxvZ0VmZmVjdCkpXG4gICAgICAgICAgICAgICAgZGlhbG9ncyA9IFtlLnZhbHVlXS5jb25jYXQoZGlhbG9ncyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlLmlzKGNsb3NlRGlhbG9nRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBkaWFsb2dzID0gZGlhbG9ncy5maWx0ZXIoZCA9PiBkICE9IGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWFsb2dzO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuY29tcHV0ZU4oW2ZdLCBzdGF0ZSA9PiBzdGF0ZS5maWVsZChmKSlcbn0pO1xuY29uc3Qgb3BlbkRpYWxvZ0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNsb3NlRGlhbG9nRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuZnVuY3Rpb24gY3JlYXRlRGlhbG9nKHZpZXcsIGNvbmZpZywgcmVzdWx0KSB7XG4gICAgbGV0IGNvbnRlbnQgPSBjb25maWcuY29udGVudCA/IGNvbmZpZy5jb250ZW50KHZpZXcsICgpID0+IGRvbmUobnVsbCkpIDogbnVsbDtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgY29udGVudCA9IGVsdChcImZvcm1cIik7XG4gICAgICAgIGlmIChjb25maWcuaW5wdXQpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGVsdChcImlucHV0XCIsIGNvbmZpZy5pbnB1dCk7XG4gICAgICAgICAgICBpZiAoL14odGV4dHxwYXNzd29yZHxudW1iZXJ8ZW1haWx8dGVsfHVybCkkLy50ZXN0KGlucHV0LnR5cGUpKVxuICAgICAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoXCJjbS10ZXh0ZmllbGRcIik7XG4gICAgICAgICAgICBpZiAoIWlucHV0Lm5hbWUpXG4gICAgICAgICAgICAgICAgaW5wdXQubmFtZSA9IFwiaW5wdXRcIjtcbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwibGFiZWxcIiwgKGNvbmZpZy5sYWJlbCB8fCBcIlwiKSArIFwiOiBcIiwgaW5wdXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29uZmlnLmxhYmVsIHx8IFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSk7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIHR5cGU6IFwic3VibWl0XCIgfSwgY29uZmlnLnN1Ym1pdExhYmVsIHx8IFwiT0tcIikpO1xuICAgIH1cbiAgICBsZXQgZm9ybXMgPSBjb250ZW50Lm5vZGVOYW1lID09IFwiRk9STVwiID8gW2NvbnRlbnRdIDogY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwiZm9ybVwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBmb3JtID0gZm9ybXNbaV07XG4gICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGRvbmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7IC8vIEVudGVyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkb25lKGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGRvbmUoZm9ybSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcGFuZWwgPSBlbHQoXCJkaXZcIiwgY29udGVudCwgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgb25jbGljazogKCkgPT4gZG9uZShudWxsKSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHZpZXcuc3RhdGUucGhyYXNlKFwiY2xvc2VcIiksXG4gICAgICAgIGNsYXNzOiBcImNtLWRpYWxvZy1jbG9zZVwiLFxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgfSwgW1wiw5dcIl0pKTtcbiAgICBpZiAoY29uZmlnLmNsYXNzKVxuICAgICAgICBwYW5lbC5jbGFzc05hbWUgPSBjb25maWcuY2xhc3M7XG4gICAgcGFuZWwuY2xhc3NMaXN0LmFkZChcImNtLWRpYWxvZ1wiKTtcbiAgICBmdW5jdGlvbiBkb25lKGZvcm0pIHtcbiAgICAgICAgaWYgKHBhbmVsLmNvbnRhaW5zKHBhbmVsLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIHJlc3VsdChmb3JtKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZG9tOiBwYW5lbCxcbiAgICAgICAgdG9wOiBjb25maWcudG9wLFxuICAgICAgICBtb3VudDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5mb2N1cykge1xuICAgICAgICAgICAgICAgIGxldCBmb2N1cztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5mb2N1cyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBmb2N1cyA9IGNvbnRlbnQucXVlcnlTZWxlY3Rvcihjb25maWcuZm9jdXMpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKSB8fCBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJidXR0b25cIik7XG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzICYmIFwic2VsZWN0XCIgaW4gZm9jdXMpXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvY3VzICYmIFwiZm9jdXNcIiBpbiBmb2N1cylcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXG5pbiBhIHNwZWNpZmljIGd1dHRlci4gWW91ciBvd24gY3VzdG9tIG1hcmtlcnMgaGF2ZSB0byBleHRlbmQgdGhpc1xuY2xhc3MuXG4qL1xuY2xhc3MgR3V0dGVyTWFya2VyIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENhbGxlZCBpZiB0aGUgbWFya2VyIGhhcyBhIGB0b0RPTWAgbWV0aG9kIGFuZCBpdHMgcmVwcmVzZW50YXRpb25cbiAgICB3YXMgcmVtb3ZlZCBmcm9tIGEgZ3V0dGVyLlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBcIlwiO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS50b0RPTSA9IHVuZGVmaW5lZDtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEd1dHRlck1hcmtlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBmb3IgYSBnaXZlbiBsaW5lLlxuTWFya2VycyBnaXZlbiB0byB0aGlzIGZhY2V0IHNob3VsZCBfb25seV8gZGVmaW5lIGFuXG5bYGVsZW1lbnRjbGFzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIuZWxlbWVudENsYXNzKSwgbm90IGFcbltgdG9ET01gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLnRvRE9NKSAob3IgdGhlIG1hcmtlciB3aWxsIGFwcGVhclxuaW4gYWxsIGd1dHRlcnMgZm9yIHRoZSBsaW5lKS5cbiovXG5jb25zdCBndXR0ZXJMaW5lQ2xhc3MgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBuZXh0IHRvIGEgd2lkZ2V0LlxuU2hvdWxkIG5vdCBwcm92aWRlIHdpZGdldHMgd2l0aCBhIGB0b0RPTWAgbWV0aG9kLlxuKi9cbmNvbnN0IGd1dHRlcldpZGdldENsYXNzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgY2xhc3M6IFwiXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgZWxlbWVudFN0eWxlOiBcIlwiLFxuICAgIG1hcmtlcnM6ICgpID0+IFJhbmdlU2V0LmVtcHR5LFxuICAgIGxpbmVNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgd2lkZ2V0TWFya2VyOiAoKSA9PiBudWxsLFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IG51bGwsXG4gICAgaW5pdGlhbFNwYWNlcjogbnVsbCxcbiAgICB1cGRhdGVTcGFjZXI6IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge30sXG4gICAgc2lkZTogXCJiZWZvcmVcIlxufTtcbmNvbnN0IGFjdGl2ZUd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhbiBlZGl0b3IgZ3V0dGVyLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIGd1dHRlcnMgYXBwZWFyIGlzXG5kZXRlcm1pbmVkIGJ5IHRoZWlyIGV4dGVuc2lvbiBwcmlvcml0eS5cbiovXG5mdW5jdGlvbiBndXR0ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtndXR0ZXJzKCksIGFjdGl2ZUd1dHRlcnMub2YoeyAuLi5kZWZhdWx0cywgLi4uY29uZmlnIH0pXTtcbn1cbmNvbnN0IHVuZml4R3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbi8qKlxuVGhlIGd1dHRlci1kcmF3aW5nIHBsdWdpbiBpcyBhdXRvbWF0aWNhbGx5IGVuYWJsZWQgd2hlbiB5b3UgYWRkIGFcbmd1dHRlciwgYnV0IHlvdSBjYW4gdXNlIHRoaXMgZnVuY3Rpb24gdG8gZXhwbGljaXRseSBjb25maWd1cmUgaXQuXG5cblVubGVzcyBgZml4ZWRgIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGBmYWxzZWAsIHRoZSBndXR0ZXJzIGFyZVxuZml4ZWQsIG1lYW5pbmcgdGhleSBkb24ndCBzY3JvbGwgYWxvbmcgd2l0aCB0aGUgY29udGVudFxuaG9yaXpvbnRhbGx5IChleGNlcHQgb24gSW50ZXJuZXQgRXhwbG9yZXIsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydFxuQ1NTIFtgcG9zaXRpb246XG5zdGlja3lgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvcG9zaXRpb24jc3RpY2t5KSkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVycyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1xuICAgICAgICBndXR0ZXJWaWV3LFxuICAgIF07XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcuZml4ZWQgPT09IGZhbHNlKVxuICAgICAgICByZXN1bHQucHVzaCh1bmZpeEd1dHRlcnMub2YodHJ1ZSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBndXR0ZXJWaWV3ID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZG9tQWZ0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzIGNtLWd1dHRlcnMtYmVmb3JlXCI7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gKHRoaXMudmlldy5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xuICAgICAgICB0aGlzLmZpeGVkID0gIXZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKTtcbiAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycykge1xuICAgICAgICAgICAgaWYgKGd1dHRlci5jb25maWcuc2lkZSA9PSBcImFmdGVyXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRET01BZnRlcigpLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpeGVkKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBJRTExIGZhbGxiYWNrLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgcG9zaXRpb246IHN0aWNreSxcbiAgICAgICAgICAgIC8vIGJ5IHVzaW5nIHBvc2l0aW9uOiByZWxhdGl2ZSArIGV2ZW50IGhhbmRsZXJzIHRoYXQgcmVhbGlnbiB0aGVcbiAgICAgICAgICAgIC8vIGd1dHRlciAob3IganVzdCBmb3JjZSBmaXhlZD1mYWxzZSBvbiBJRTExPylcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJzdGlja3lcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKGZhbHNlKTtcbiAgICAgICAgdmlldy5zY3JvbGxET00uaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCB2aWV3LmNvbnRlbnRET00pO1xuICAgIH1cbiAgICBnZXRET01BZnRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbUFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUFmdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIuY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzIGNtLWd1dHRlcnMtYWZ0ZXJcIjtcbiAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgdGhpcy5kb21BZnRlci5zdHlsZS5taW5IZWlnaHQgPSAodGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZKSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIuc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKHRoaXMuZG9tQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRvbUFmdGVyO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZUd1dHRlcnModXBkYXRlKSkge1xuICAgICAgICAgICAgLy8gRGV0YWNoIGR1cmluZyBzeW5jIHdoZW4gdGhlIHZpZXdwb3J0IGNoYW5nZWQgc2lnbmlmaWNhbnRseVxuICAgICAgICAgICAgLy8gKHN1Y2ggYXMgZHVyaW5nIHNjcm9sbGluZyksIHNpbmNlIGZvciBsYXJnZSB1cGRhdGVzIHRoYXQgaXNcbiAgICAgICAgICAgIC8vIGZhc3Rlci5cbiAgICAgICAgICAgIGxldCB2cEEgPSB0aGlzLnByZXZWaWV3cG9ydCwgdnBCID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgICAgICAgICBsZXQgdnBPdmVybGFwID0gTWF0aC5taW4odnBBLnRvLCB2cEIudG8pIC0gTWF0aC5tYXgodnBBLmZyb20sIHZwQi5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMuc3luY0d1dHRlcnModnBPdmVybGFwIDwgKHZwQi50byAtIHZwQi5mcm9tKSAqIDAuOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGxldCBtaW4gPSAodGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZKSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IG1pbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbUFmdGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKSAhPSAhdGhpcy5maXhlZCkge1xuICAgICAgICAgICAgdGhpcy5maXhlZCA9ICF0aGlzLmZpeGVkO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5kb21BZnRlcilcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUFmdGVyLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaCkge1xuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kb21BZnRlcilcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUFmdGVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lQ2xhc3NlcyA9IFJhbmdlU2V0Lml0ZXIodGhpcy52aWV3LnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHRoaXMudmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgbGV0IGNsYXNzU2V0ID0gW107XG4gICAgICAgIGxldCBjb250ZXh0cyA9IHRoaXMuZ3V0dGVycy5tYXAoZ3V0dGVyID0+IG5ldyBVcGRhdGVDb250ZXh0KGd1dHRlciwgdGhpcy52aWV3LnZpZXdwb3J0LCAtdGhpcy52aWV3LmRvY3VtZW50UGFkZGluZy50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3NTZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNsYXNzU2V0ID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiIG9mIGxpbmUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYi50eXBlID09IEJsb2NrVHlwZS5UZXh0ICYmIGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgYi5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LmxpbmUodGhpcy52aWV3LCBiLCBjbGFzc1NldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC53aWRnZXQodGhpcy52aWV3LCBiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2VDdXJzb3IobGluZUNsYXNzZXMsIGNsYXNzU2V0LCBsaW5lLmZyb20pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgbGluZSwgY2xhc3NTZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS53aWRnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgY3gud2lkZ2V0KHRoaXMudmlldywgbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICBjeC5maW5pc2goKTtcbiAgICAgICAgaWYgKGRldGFjaCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIGFmdGVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbUFmdGVyKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQodGhpcy5kb21BZnRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlR3V0dGVycyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXYgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKSwgY3VyID0gdXBkYXRlLnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpO1xuICAgICAgICBsZXQgY2hhbmdlID0gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmhlaWdodENoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgIVJhbmdlU2V0LmVxKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB1cGRhdGUudmlldy52aWV3cG9ydC5mcm9tLCB1cGRhdGUudmlldy52aWV3cG9ydC50byk7XG4gICAgICAgIGlmIChwcmV2ID09IGN1cikge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVyLnVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBndXR0ZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjb25mIG9mIGN1cikge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHByZXYuaW5kZXhPZihjb25mKTtcbiAgICAgICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcnMucHVzaChuZXcgU2luZ2xlR3V0dGVyVmlldyh0aGlzLnZpZXcsIGNvbmYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3V0dGVyc1trbm93bl0udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGd1dHRlcnMucHVzaCh0aGlzLmd1dHRlcnNba25vd25dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBnIG9mIHRoaXMuZ3V0dGVycykge1xuICAgICAgICAgICAgICAgIGcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChndXR0ZXJzLmluZGV4T2YoZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICBnLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgZ3V0dGVycykge1xuICAgICAgICAgICAgICAgIGlmIChnLmNvbmZpZy5zaWRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRET01BZnRlcigpLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIGlmICh0aGlzLmRvbUFmdGVyKVxuICAgICAgICAgICAgdGhpcy5kb21BZnRlci5yZW1vdmUoKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5ndXR0ZXJzLmxlbmd0aCA9PSAwIHx8ICF2YWx1ZS5maXhlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgYmVmb3JlID0gdmFsdWUuZG9tLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVgsIGFmdGVyID0gdmFsdWUuZG9tQWZ0ZXIgPyB2YWx1ZS5kb21BZnRlci5vZmZzZXRXaWR0aCAqIHZpZXcuc2NhbGVYIDogMDtcbiAgICAgICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSXG4gICAgICAgICAgICA/IHsgbGVmdDogYmVmb3JlLCByaWdodDogYWZ0ZXIgfVxuICAgICAgICAgICAgOiB7IHJpZ2h0OiBiZWZvcmUsIGxlZnQ6IGFmdGVyIH07XG4gICAgfSlcbn0pO1xuZnVuY3Rpb24gYXNBcnJheSh2YWwpIHsgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSk7IH1cbmZ1bmN0aW9uIGFkdmFuY2VDdXJzb3IoY3Vyc29yLCBjb2xsZWN0LCBwb3MpIHtcbiAgICB3aGlsZSAoY3Vyc29yLnZhbHVlICYmIGN1cnNvci5mcm9tIDw9IHBvcykge1xuICAgICAgICBpZiAoY3Vyc29yLmZyb20gPT0gcG9zKVxuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgfVxufVxuY2xhc3MgVXBkYXRlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoZ3V0dGVyLCB2aWV3cG9ydCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZ3V0dGVyID0gZ3V0dGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBSYW5nZVNldC5pdGVyKGd1dHRlci5tYXJrZXJzLCB2aWV3cG9ydC5mcm9tKTtcbiAgICB9XG4gICAgYWRkRWxlbWVudCh2aWV3LCBibG9jaywgbWFya2Vycykge1xuICAgICAgICBsZXQgeyBndXR0ZXIgfSA9IHRoaXMsIGFib3ZlID0gKGJsb2NrLnRvcCAtIHRoaXMuaGVpZ2h0KSAvIHZpZXcuc2NhbGVZLCBoZWlnaHQgPSBibG9jay5oZWlnaHQgLyB2aWV3LnNjYWxlWTtcbiAgICAgICAgaWYgKHRoaXMuaSA9PSBndXR0ZXIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV3RWx0ID0gbmV3IEd1dHRlckVsZW1lbnQodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHMucHVzaChuZXdFbHQpO1xuICAgICAgICAgICAgZ3V0dGVyLmRvbS5hcHBlbmRDaGlsZChuZXdFbHQuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGd1dHRlci5lbGVtZW50c1t0aGlzLmldLnVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlaWdodCA9IGJsb2NrLmJvdHRvbTtcbiAgICAgICAgdGhpcy5pKys7XG4gICAgfVxuICAgIGxpbmUodmlldywgbGluZSwgZXh0cmFNYXJrZXJzKSB7XG4gICAgICAgIGxldCBsb2NhbE1hcmtlcnMgPSBbXTtcbiAgICAgICAgYWR2YW5jZUN1cnNvcih0aGlzLmN1cnNvciwgbG9jYWxNYXJrZXJzLCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoZXh0cmFNYXJrZXJzLmxlbmd0aClcbiAgICAgICAgICAgIGxvY2FsTWFya2VycyA9IGxvY2FsTWFya2Vycy5jb25jYXQoZXh0cmFNYXJrZXJzKTtcbiAgICAgICAgbGV0IGZvckxpbmUgPSB0aGlzLmd1dHRlci5jb25maWcubGluZU1hcmtlcih2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgICAgICBpZiAoZm9yTGluZSlcbiAgICAgICAgICAgIGxvY2FsTWFya2Vycy51bnNoaWZ0KGZvckxpbmUpO1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIGlmIChsb2NhbE1hcmtlcnMubGVuZ3RoID09IDAgJiYgIWd1dHRlci5jb25maWcucmVuZGVyRW1wdHlFbGVtZW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50KHZpZXcsIGxpbmUsIGxvY2FsTWFya2Vycyk7XG4gICAgfVxuICAgIHdpZGdldCh2aWV3LCBibG9jaykge1xuICAgICAgICBsZXQgbWFya2VyID0gdGhpcy5ndXR0ZXIuY29uZmlnLndpZGdldE1hcmtlcih2aWV3LCBibG9jay53aWRnZXQsIGJsb2NrKSwgbWFya2VycyA9IG1hcmtlciA/IFttYXJrZXJdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgY2xzIG9mIHZpZXcuc3RhdGUuZmFjZXQoZ3V0dGVyV2lkZ2V0Q2xhc3MpKSB7XG4gICAgICAgICAgICBsZXQgbWFya2VyID0gY2xzKHZpZXcsIGJsb2NrLndpZGdldCwgYmxvY2spO1xuICAgICAgICAgICAgaWYgKG1hcmtlcilcbiAgICAgICAgICAgICAgICAobWFya2VycyB8fCAobWFya2VycyA9IFtdKSkucHVzaChtYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJzKVxuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KHZpZXcsIGJsb2NrLCBtYXJrZXJzKTtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIHdoaWxlIChndXR0ZXIuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5pKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGd1dHRlci5lbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIGd1dHRlci5kb20ucmVtb3ZlQ2hpbGQobGFzdC5kb20pO1xuICAgICAgICAgICAgbGFzdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVHdXR0ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyXCIgKyAodGhpcy5jb25maWcuY2xhc3MgPyBcIiBcIiArIHRoaXMuY29uZmlnLmNsYXNzIDogXCJcIik7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY29uZmlnLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIocHJvcCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCwgeTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnROb2RlICE9IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXRIZWlnaHQoeSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZG9tRXZlbnRIYW5kbGVyc1twcm9wXSh2aWV3LCBsaW5lLCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KGNvbmZpZy5tYXJrZXJzKHZpZXcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pbml0aWFsU3BhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlciA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIDAsIDAsIFtjb25maWcuaW5pdGlhbFNwYWNlcih2aWV3KV0pO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zcGFjZXIuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyLmRvbS5zdHlsZS5jc3NUZXh0ICs9IFwidmlzaWJpbGl0eTogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZNYXJrZXJzID0gdGhpcy5tYXJrZXJzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KHRoaXMuY29uZmlnLm1hcmtlcnModXBkYXRlLnZpZXcpKTtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VyICYmIHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcikge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIodGhpcy5zcGFjZXIubWFya2Vyc1swXSwgdXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkICE9IHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0pXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXIudXBkYXRlKHVwZGF0ZS52aWV3LCAwLCAwLCBbdXBkYXRlZF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2cCA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICByZXR1cm4gIVJhbmdlU2V0LmVxKHRoaXMubWFya2VycywgcHJldk1hcmtlcnMsIHZwLmZyb20sIHZwLnRvKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UgPyB0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlKHVwZGF0ZSkgOiBmYWxzZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmVsZW1lbnRzKVxuICAgICAgICAgICAgZWx0LmRlc3Ryb3koKTtcbiAgICB9XG59XG5jbGFzcyBHdXR0ZXJFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgICAgIHRoaXMuYWJvdmUgPSAwO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlckVsZW1lbnRcIjtcbiAgICAgICAgdGhpcy51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFib3ZlICE9IGFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWFyZ2luVG9wID0gKHRoaXMuYWJvdmUgPSBhYm92ZSkgPyBhYm92ZSArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgIGlmICghc2FtZU1hcmtlcnModGhpcy5tYXJrZXJzLCBtYXJrZXJzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKTtcbiAgICB9XG4gICAgc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKSB7XG4gICAgICAgIGxldCBjbHMgPSBcImNtLWd1dHRlckVsZW1lbnRcIiwgZG9tUG9zID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgaU5ldyA9IDAsIGlPbGQgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBza2lwVG8gPSBpT2xkLCBtYXJrZXIgPSBpTmV3IDwgbWFya2Vycy5sZW5ndGggPyBtYXJrZXJzW2lOZXcrK10gOiBudWxsLCBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSBtYXJrZXIuZWxlbWVudENsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCIgKyBjO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpT2xkOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2ldLmNvbXBhcmUobWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNraXBUbyA9IHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaU9sZCA8IHNraXBUbykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5tYXJrZXJzW2lPbGQrK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudG9ET00pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZXN0cm95KGRvbVBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBhZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChtYXJrZXIudG9ET00pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci50b0RPTSh2aWV3KSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgIGlPbGQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0TWFya2VycyhudWxsLCBbXSk7IC8vIEZpcnN0IGFyZ3VtZW50IG5vdCB1c2VkIHVubGVzcyBjcmVhdGluZyBtYXJrZXJzXG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcnMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmNvbXBhcmUoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkZhY2V0IHVzZWQgdG8gcHJvdmlkZSBtYXJrZXJzIHRvIHRoZSBsaW5lIG51bWJlciBndXR0ZXIuXG4qL1xuY29uc3QgbGluZU51bWJlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IHVzZWQgdG8gY3JlYXRlIG1hcmtlcnMgaW4gdGhlIGxpbmUgbnVtYmVyIGd1dHRlciBuZXh0IHRvIHdpZGdldHMuXG4qL1xuY29uc3QgbGluZU51bWJlcldpZGdldE1hcmtlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGxpbmVOdW1iZXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIHsgZm9ybWF0TnVtYmVyOiBTdHJpbmcsIGRvbUV2ZW50SGFuZGxlcnM6IHt9IH0sIHtcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnMoYSwgYikge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBhKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBldmVudCBpbiBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBleGlzdHMgPSByZXN1bHRbZXZlbnRdLCBhZGQgPSBiW2V2ZW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2V2ZW50XSA9IGV4aXN0cyA/ICh2aWV3LCBsaW5lLCBldmVudCkgPT4gZXhpc3RzKHZpZXcsIGxpbmUsIGV2ZW50KSB8fCBhZGQodmlldywgbGluZSwgZXZlbnQpIDogYWRkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNsYXNzIE51bWJlck1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IobnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5udW1iZXIgPT0gb3RoZXIubnVtYmVyOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm51bWJlcik7IH1cbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2aWV3LCBudW1iZXIpIHtcbiAgICByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5mb3JtYXROdW1iZXIobnVtYmVyLCB2aWV3LnN0YXRlKTtcbn1cbmNvbnN0IGxpbmVOdW1iZXJHdXR0ZXIgPSAvKkBfX1BVUkVfXyovYWN0aXZlR3V0dGVycy5jb21wdXRlKFtsaW5lTnVtYmVyQ29uZmlnXSwgc3RhdGUgPT4gKHtcbiAgICBjbGFzczogXCJjbS1saW5lTnVtYmVyc1wiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIG1hcmtlcnModmlldykgeyByZXR1cm4gdmlldy5zdGF0ZS5mYWNldChsaW5lTnVtYmVyTWFya2Vycyk7IH0sXG4gICAgbGluZU1hcmtlcih2aWV3LCBsaW5lLCBvdGhlcnMpIHtcbiAgICAgICAgaWYgKG90aGVycy5zb21lKG0gPT4gbS50b0RPTSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIHZpZXcuc3RhdGUuZG9jLmxpbmVBdChsaW5lLmZyb20pLm51bWJlcikpO1xuICAgIH0sXG4gICAgd2lkZ2V0TWFya2VyOiAodmlldywgd2lkZ2V0LCBibG9jaykgPT4ge1xuICAgICAgICBmb3IgKGxldCBtIG9mIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlcldpZGdldE1hcmtlcikpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtKHZpZXcsIHdpZGdldCwgYmxvY2spO1xuICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgbGluZU1hcmtlckNoYW5nZTogdXBkYXRlID0+IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSxcbiAgICBpbml0aWFsU3BhY2VyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJNYXJrZXIoZm9ybWF0TnVtYmVyKHZpZXcsIG1heExpbmVOdW1iZXIodmlldy5zdGF0ZS5kb2MubGluZXMpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVTcGFjZXIoc3BhY2VyLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IG1heCA9IGZvcm1hdE51bWJlcih1cGRhdGUudmlldywgbWF4TGluZU51bWJlcih1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG1heCA9PSBzcGFjZXIubnVtYmVyID8gc3BhY2VyIDogbmV3IE51bWJlck1hcmtlcihtYXgpO1xuICAgIH0sXG4gICAgZG9tRXZlbnRIYW5kbGVyczogc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZG9tRXZlbnRIYW5kbGVycyxcbiAgICBzaWRlOiBcImJlZm9yZVwiXG59KSk7XG4vKipcbkNyZWF0ZSBhIGxpbmUgbnVtYmVyIGd1dHRlciBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gbGluZU51bWJlcnMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBsaW5lTnVtYmVyQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGd1dHRlcnMoKSxcbiAgICAgICAgbGluZU51bWJlckd1dHRlclxuICAgIF07XG59XG5mdW5jdGlvbiBtYXhMaW5lTnVtYmVyKGxpbmVzKSB7XG4gICAgbGV0IGxhc3QgPSA5O1xuICAgIHdoaWxlIChsYXN0IDwgbGluZXMpXG4gICAgICAgIGxhc3QgPSBsYXN0ICogMTAgKyA5O1xuICAgIHJldHVybiBsYXN0O1xufVxuY29uc3QgYWN0aXZlTGluZUd1dHRlck1hcmtlciA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsZW1lbnRDbGFzcyA9IFwiY20tYWN0aXZlTGluZUd1dHRlclwiO1xuICAgIH1cbn07XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovZ3V0dGVyTGluZUNsYXNzLmNvbXB1dGUoW1wic2VsZWN0aW9uXCJdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IG1hcmtzID0gW10sIGxhc3QgPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBsaW5lUG9zID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5oZWFkKS5mcm9tO1xuICAgICAgICBpZiAobGluZVBvcyA+IGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lUG9zO1xuICAgICAgICAgICAgbWFya3MucHVzaChhY3RpdmVMaW5lR3V0dGVyTWFya2VyLnJhbmdlKGxpbmVQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmFuZ2VTZXQub2YobWFya3MpO1xufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS1hY3RpdmVMaW5lR3V0dGVyYCBjbGFzcyB0b1xuYWxsIGd1dHRlciBlbGVtZW50cyBvbiB0aGUgW2FjdGl2ZVxubGluZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlcjtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcihkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiAoe1xuICAgICAgICBkZWNvcmF0aW9uczogZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyksXG4gICAgICAgIHVwZGF0ZSh1KSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdG9yLnVwZGF0ZURlY28odSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgfSksIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pO1xufVxuY29uc3QgdGFiRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1oaWdobGlnaHRUYWJcIiB9KTtcbmNvbnN0IHNwYWNlRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1oaWdobGlnaHRTcGFjZVwiIH0pO1xuY29uc3Qgd2hpdGVzcGFjZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL21hdGNoZXIoLypAX19QVVJFX18qL25ldyBNYXRjaERlY29yYXRvcih7XG4gICAgcmVnZXhwOiAvXFx0fCAvZyxcbiAgICBkZWNvcmF0aW9uOiBtYXRjaCA9PiBtYXRjaFswXSA9PSBcIlxcdFwiID8gdGFiRGVjbyA6IHNwYWNlRGVjbyxcbiAgICBib3VuZGFyeTogL1xcUy8sXG59KSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlnaGxpZ2h0cyB3aGl0ZXNwYWNlLCBhZGRpbmcgYVxuYGNtLWhpZ2hsaWdodFNwYWNlYCBjbGFzcyB0byBzdHJldGNoZXMgb2Ygc3BhY2VzLCBhbmQgYVxuYGNtLWhpZ2hsaWdodFRhYmAgY2xhc3MgdG8gaW5kaXZpZHVhbCB0YWIgY2hhcmFjdGVycy4gQnkgZGVmYXVsdCxcbnRoZSBmb3JtZXIgYXJlIHNob3duIGFzIGZhaW50IGRvdHMsIGFuZCB0aGUgbGF0dGVyIGFzIGFycm93cy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRXaGl0ZXNwYWNlKCkge1xuICAgIHJldHVybiB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCB0cmFpbGluZ0hpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL21hdGNoZXIoLypAX19QVVJFX18qL25ldyBNYXRjaERlY29yYXRvcih7XG4gICAgcmVnZXhwOiAvXFxzKyQvZyxcbiAgICBkZWNvcmF0aW9uOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tdHJhaWxpbmdTcGFjZVwiIH0pXG59KSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS10cmFpbGluZ1NwYWNlYCBjbGFzcyB0byBhbGxcbnRyYWlsaW5nIHdoaXRlc3BhY2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlKCkge1xuICAgIHJldHVybiB0cmFpbGluZ0hpZ2hsaWdodGVyO1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fdGVzdCA9IHsgSGVpZ2h0TWFwLCBIZWlnaHRPcmFjbGUsIE1lYXN1cmVkSGVpZ2h0cywgUXVlcnlUeXBlLCBDaGFuZ2VkUmFuZ2UsIGNvbXB1dGVPcmRlcixcbiAgICBtb3ZlVmlzdWFsbHksIGNsZWFySGVpZ2h0Q2hhbmdlRmxhZywgZ2V0SGVpZ2h0Q2hhbmdlRmxhZzogKCkgPT4gaGVpZ2h0Q2hhbmdlRmxhZyB9O1xuXG5leHBvcnQgeyBCaWRpU3BhbiwgQmxvY2tJbmZvLCBCbG9ja1R5cGUsIERlY29yYXRpb24sIERpcmVjdGlvbiwgRWRpdG9yVmlldywgR3V0dGVyTWFya2VyLCBNYXRjaERlY29yYXRvciwgUmVjdGFuZ2xlTWFya2VyLCBWaWV3UGx1Z2luLCBWaWV3VXBkYXRlLCBXaWRnZXRUeXBlLCBfX3Rlc3QsIGNsb3NlSG92ZXJUb29sdGlwcywgY3Jvc3NoYWlyQ3Vyc29yLCBkcmF3U2VsZWN0aW9uLCBkcm9wQ3Vyc29yLCBnZXREaWFsb2csIGdldERyYXdTZWxlY3Rpb25Db25maWcsIGdldFBhbmVsLCBnZXRUb29sdGlwLCBndXR0ZXIsIGd1dHRlckxpbmVDbGFzcywgZ3V0dGVyV2lkZ2V0Q2xhc3MsIGd1dHRlcnMsIGhhc0hvdmVyVG9vbHRpcHMsIGhpZ2hsaWdodEFjdGl2ZUxpbmUsIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIsIGhpZ2hsaWdodFNwZWNpYWxDaGFycywgaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlLCBoaWdobGlnaHRXaGl0ZXNwYWNlLCBob3ZlclRvb2x0aXAsIGtleW1hcCwgbGF5ZXIsIGxpbmVOdW1iZXJNYXJrZXJzLCBsaW5lTnVtYmVyV2lkZ2V0TWFya2VyLCBsaW5lTnVtYmVycywgbG9nRXhjZXB0aW9uLCBwYW5lbHMsIHBsYWNlaG9sZGVyLCByZWN0YW5ndWxhclNlbGVjdGlvbiwgcmVwb3NpdGlvblRvb2x0aXBzLCBydW5TY29wZUhhbmRsZXJzLCBzY3JvbGxQYXN0RW5kLCBzaG93RGlhbG9nLCBzaG93UGFuZWwsIHNob3dUb29sdGlwLCB0b29sdGlwcyB9O1xuIl0sIm5hbWVzIjpbIlRleHQiLCJSYW5nZVNldCIsIk1hcE1vZGUiLCJSYW5nZVZhbHVlIiwiZmluZENsdXN0ZXJCcmVhayIsIkVkaXRvclNlbGVjdGlvbiIsIkZhY2V0IiwiU3RhdGVFZmZlY3QiLCJDaGFuZ2VTZXQiLCJmaW5kQ29sdW1uIiwiQ2hhckNhdGVnb3J5IiwiRWRpdG9yU3RhdGUiLCJBbm5vdGF0aW9uIiwiVHJhbnNhY3Rpb24iLCJQcmVjIiwiY29kZVBvaW50QXQiLCJjb2RlUG9pbnRTaXplIiwiY29tYmluZUNvbmZpZyIsIlN0YXRlRmllbGQiLCJSYW5nZVNldEJ1aWxkZXIiLCJjb3VudENvbHVtbiIsIlN0eWxlTW9kdWxlIiwia2V5TmFtZSIsImJhc2UiLCJzaGlmdCIsImVsdCIsIm5hdiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInZlbmRvciIsInBsYXRmb3JtIiwiZG9jIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsImllX2VkZ2UiLCJleGVjIiwiaWVfdXB0bzEwIiwidGVzdCIsImllXzExdXAiLCJpZSIsImdlY2tvIiwiY2hyb21lIiwid2Via2l0Iiwic2FmYXJpIiwiaW9zIiwibWF4VG91Y2hQb2ludHMiLCJicm93c2VyIiwibWFjIiwid2luZG93cyIsImxpbnV4IiwiaWVfdmVyc2lvbiIsImRvY3VtZW50TW9kZSIsImdlY2tvX3ZlcnNpb24iLCJjaHJvbWVfdmVyc2lvbiIsImFuZHJvaWQiLCJ3ZWJraXRfdmVyc2lvbiIsInNhZmFyaV92ZXJzaW9uIiwidGFiU2l6ZSIsImdldFNlbGVjdGlvbiIsInJvb3QiLCJ0YXJnZXQiLCJub2RlVHlwZSIsIm93bmVyRG9jdW1lbnQiLCJjb250YWlucyIsImRvbSIsIm5vZGUiLCJwYXJlbnROb2RlIiwiaGFzU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsIl8iLCJjbGllbnRSZWN0c0ZvciIsInRleHRSYW5nZSIsIm5vZGVWYWx1ZSIsImxlbmd0aCIsImdldENsaWVudFJlY3RzIiwiaXNFcXVpdmFsZW50UG9zaXRpb24iLCJvZmYiLCJ0YXJnZXROb2RlIiwidGFyZ2V0T2ZmIiwic2NhbkZvciIsImRvbUluZGV4IiwiaW5kZXgiLCJwcmV2aW91c1NpYmxpbmciLCJpc0Jsb2NrRWxlbWVudCIsIm5vZGVOYW1lIiwiZGlyIiwibWF4T2Zmc2V0IiwicGFyZW50IiwiY2hpbGROb2RlcyIsImNvbnRlbnRFZGl0YWJsZSIsImZsYXR0ZW5SZWN0IiwicmVjdCIsImxlZnQiLCJ4IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJ3aW5kb3dSZWN0Iiwid2luIiwidnAiLCJ2aXN1YWxWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiZ2V0U2NhbGUiLCJzY2FsZVgiLCJvZmZzZXRXaWR0aCIsInNjYWxlWSIsIm9mZnNldEhlaWdodCIsImlzRmluaXRlIiwiTWF0aCIsImFicyIsInNjcm9sbFJlY3RJbnRvVmlldyIsInNpZGUiLCJ5IiwieE1hcmdpbiIsInlNYXJnaW4iLCJsdHIiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImN1ciIsInN0b3AiLCJib3VuZGluZyIsImJvZHkiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwiYXNzaWduZWRTbG90IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibW92ZVgiLCJtb3ZlWSIsInJlY3RIZWlnaHQiLCJib3VuZGluZ0hlaWdodCIsInRhcmdldFRvcCIsInRhcmdldExlZnQiLCJzY3JvbGxCeSIsIm1vdmVkWCIsIm1vdmVkWSIsInN0YXJ0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIm1heCIsIm1pbiIsImhvc3QiLCJzY3JvbGxhYmxlUGFyZW50cyIsIkRPTVNlbGVjdGlvblN0YXRlIiwiY29uc3RydWN0b3IiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImVxIiwiZG9tU2VsIiwic2V0UmFuZ2UiLCJyYW5nZSIsInNldCIsInByZXZlbnRTY3JvbGxTdXBwb3J0ZWQiLCJmb2N1c1ByZXZlbnRTY3JvbGwiLCJzZXRBY3RpdmUiLCJmb2N1cyIsInN0YWNrIiwicHVzaCIsInByZXZlbnRTY3JvbGwiLCJ1bmRlZmluZWQiLCJpIiwic2NyYXRjaFJhbmdlIiwiZnJvbSIsInRvIiwiY3JlYXRlUmFuZ2UiLCJzZXRFbmQiLCJzZXRTdGFydCIsImRpc3BhdGNoS2V5IiwibmFtZSIsImNvZGUiLCJtb2RzIiwib3B0aW9ucyIsImtleSIsImtleUNvZGUiLCJ3aGljaCIsImNhbmNlbGFibGUiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJtZXRhS2V5IiwiZG93biIsIktleWJvYXJkRXZlbnQiLCJzeW50aGV0aWMiLCJkaXNwYXRjaEV2ZW50IiwidXAiLCJkZWZhdWx0UHJldmVudGVkIiwiZ2V0Um9vdCIsImNsZWFyQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRyaWJ1dGVOb2RlIiwiYXRFbGVtZW50U3RhcnQiLCJvZmZzZXQiLCJwcmV2IiwiaXNTY3JvbGxlZFRvQm90dG9tIiwidGV4dE5vZGVCZWZvcmUiLCJzdGFydE5vZGUiLCJzdGFydE9mZnNldCIsInRleHROb2RlQWZ0ZXIiLCJET01Qb3MiLCJwcmVjaXNlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJub0NoaWxkcmVuIiwiQ29udGVudFZpZXciLCJmbGFncyIsIm92ZXJyaWRlRE9NVGV4dCIsInBvc0F0U3RhcnQiLCJwb3NCZWZvcmUiLCJwb3NBdEVuZCIsInZpZXciLCJwb3MiLCJjaGlsZCIsImNoaWxkcmVuIiwiYnJlYWtBZnRlciIsIlJhbmdlRXJyb3IiLCJwb3NBZnRlciIsInN5bmMiLCJ0cmFjayIsIm5leHQiLCJuZXh0U2libGluZyIsImZpcnN0Q2hpbGQiLCJjb250ZW50VmlldyIsImdldCIsImNhblJldXNlRE9NIiwicmV1c2VET00iLCJ3cml0dGVuIiwicm0kMSIsImluc2VydEJlZm9yZSIsIl9kb20iLCJsb2NhbFBvc0Zyb21ET00iLCJiaWFzIiwibGFzdENoaWxkIiwiZG9tQm91bmRzQXJvdW5kIiwiZnJvbUkiLCJmcm9tU3RhcnQiLCJ0b0kiLCJ0b0VuZCIsInByZXZFbmQiLCJlbmQiLCJzdGFydERPTSIsImVuZERPTSIsIm1hcmtEaXJ0eSIsImFuZFBhcmVudCIsIm1hcmtQYXJlbnRzRGlydHkiLCJjaGlsZExpc3QiLCJzZXRQYXJlbnQiLCJzZXRET00iLCJjbVZpZXciLCJyb290VmlldyIsInYiLCJyZXBsYWNlQ2hpbGRyZW4iLCJpbmRleE9mIiwiZGVzdHJveSIsInNwbGljZSIsImNvbmNhdCIsInNsaWNlIiwiaWdub3JlTXV0YXRpb24iLCJfcmVjIiwiaWdub3JlRXZlbnQiLCJfZXZlbnQiLCJjaGlsZEN1cnNvciIsIkNoaWxkQ3Vyc29yIiwiY2hpbGRQb3MiLCJmaW5kUG9zIiwidG9TdHJpbmciLCJyZXBsYWNlIiwiam9pbiIsInRleHQiLCJpc0VkaXRhYmxlIiwiaXNXaWRnZXQiLCJpc0hpZGRlbiIsIm1lcmdlIiwic291cmNlIiwiaGFzU3RhcnQiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwiYmVjb21lIiwib3RoZXIiLCJnZXRTaWRlIiwicHJvdG90eXBlIiwicmVtb3ZlQ2hpbGQiLCJyZXBsYWNlUmFuZ2UiLCJmcm9tT2ZmIiwidG9PZmYiLCJpbnNlcnQiLCJicmVha0F0U3RhcnQiLCJsYXN0IiwiYnJlYWtBdEVuZCIsInNwbGl0IiwicG9wIiwibWVyZ2VDaGlsZHJlbkludG8iLCJkTGVuIiwiTWF4Sm9pbkxlbiIsIlRleHRWaWV3IiwiY3JlYXRlRE9NIiwidGV4dERPTSIsImNyZWF0ZVRleHROb2RlIiwicmVzdWx0IiwiZG9tQXRQb3MiLCJfZnJvbSIsIl90byIsImNvb3Jkc0F0IiwidGV4dENvb3JkcyIsIk1hcmtWaWV3IiwibWFyayIsImNoIiwic2V0QXR0cnMiLCJjbGFzcyIsImNsYXNzTmFtZSIsImF0dHJzIiwic2V0QXR0cmlidXRlIiwidGFnTmFtZSIsInRvVXBwZXJDYXNlIiwiY3JlYXRlRWxlbWVudCIsIl9oYXNTdGFydCIsImRldGFjaEZyb20iLCJpbmxpbmVET01BdFBvcyIsImNvb3Jkc0luQ2hpbGRyZW4iLCJmbGF0dGVuIiwicmVjdHMiLCJBcnJheSIsImZpbmQiLCJjYWxsIiwiciIsIldpZGdldFZpZXciLCJjcmVhdGUiLCJ3aWRnZXQiLCJwcmV2V2lkZ2V0IiwidXBkYXRlRE9NIiwidG9ET00iLCJlZGl0YWJsZSIsImNvbXBhcmUiLCJldmVudCIsImVtcHR5Iiwic3RhdGUiLCJjdXN0b20iLCJmcm9tQmFjayIsIldpZGdldEJ1ZmZlclZpZXciLCJqIiwiam9pbklubGluZUludG8iLCJvcGVuIiwiYmVmb3JlUG9zIiwiYWZ0ZXJQb3MiLCJzY2FuIiwib25TYW1lTGluZSIsImZhbGxiYWNrUmVjdCIsImEiLCJiIiwicG9zQSIsInBvc0IiLCJjb21iaW5lQXR0cnMiLCJub0F0dHJzIiwiT2JqZWN0IiwiYXR0cnNFcSIsImlnbm9yZSIsImtleXNBIiwia2V5cyIsImtleXNCIiwidXBkYXRlQXR0cnMiLCJjaGFuZ2VkIiwiY3NzVGV4dCIsInJlbW92ZUF0dHJpYnV0ZSIsImdldEF0dHJzIiwiYXR0ciIsInZhbHVlIiwiV2lkZ2V0VHlwZSIsImVzdGltYXRlZEhlaWdodCIsImxpbmVCcmVha3MiLCJCbG9ja1R5cGUiLCJEZWNvcmF0aW9uIiwic3RhcnRTaWRlIiwiZW5kU2lkZSIsInNwZWMiLCJoZWlnaHRSZWxldmFudCIsIk1hcmtEZWNvcmF0aW9uIiwiYmxvY2siLCJpbmxpbmVPcmRlciIsIlBvaW50RGVjb3JhdGlvbiIsImlzQmxvY2tHYXAiLCJnZXRJbmNsdXNpdmUiLCJsaW5lIiwiTGluZURlY29yYXRpb24iLCJvZiIsInNvcnQiLCJoYXNIZWlnaHQiLCJub25lIiwiX2EiLCJfYiIsInBvaW50IiwibWFwTW9kZSIsIlRyYWNrQmVmb3JlIiwiaXNSZXBsYWNlIiwiVHJhY2tEZWwiLCJUcmFja0FmdGVyIiwidHlwZSIsIldpZGdldFJhbmdlIiwiV2lkZ2V0QmVmb3JlIiwiV2lkZ2V0QWZ0ZXIiLCJ3aWRnZXRzRXEiLCJpbmNsdXNpdmVTdGFydCIsImluY2x1c2l2ZUVuZCIsImluY2x1c2l2ZSIsImFkZFJhbmdlIiwicmFuZ2VzIiwibWFyZ2luIiwiTGluZVZpZXciLCJhcmd1bWVudHMiLCJwcmV2QXR0cnMiLCJ0cmFuc2ZlckRPTSIsInNldERlY28iLCJhdCIsImFwcGVuZCIsImFkZExpbmVEZWNvIiwiZGVjbyIsImNscyIsImNsYXNzTGlzdCIsImFkZCIsInNvbWUiLCJoYWNrIiwiY21JZ25vcmUiLCJhcHBlbmRDaGlsZCIsIm1lYXN1cmVUZXh0U2l6ZSIsInRvdGFsV2lkdGgiLCJ0ZXh0SGVpZ2h0IiwibGluZUhlaWdodCIsImNoYXJXaWR0aCIsImhlaWdodE9yYWNsZSIsInZpZXdTdGF0ZSIsImRpc3QiLCJjb3ZlcnMiLCJkb2NWaWV3IiwiQmxvY2tXaWRnZXRWaWV3IiwiX3Rha2VEZWNvIiwibGVuIiwiQmxvY2tHYXBXaWRnZXQiLCJDb250ZW50QnVpbGRlciIsImRpc2FsbG93QmxvY2tFZmZlY3RzRm9yIiwiY29udGVudCIsImN1ckxpbmUiLCJwZW5kaW5nQnVmZmVyIiwiYnVmZmVyTWFya3MiLCJhdEN1cnNvclBvcyIsInRleHRPZmYiLCJjdXJzb3IiLCJpdGVyIiwic2tpcCIsInBvc0NvdmVyZWQiLCJsaW5lQXQiLCJnZXRMaW5lIiwiZmx1c2hCdWZmZXIiLCJhY3RpdmUiLCJ3cmFwTWFya3MiLCJhZGRCbG9ja1dpZGdldCIsImZpbmlzaCIsImJ1aWxkVGV4dCIsImxpbmVCcmVhayIsImRvbmUiLCJFcnJvciIsInJlbWFpbmluZyIsInRha2UiLCJzcGFuIiwiTnVsbFdpZGdldCIsImlubGluZSIsImN1cnNvckJlZm9yZSIsImN1cnNvckFmdGVyIiwiYnVpbGQiLCJkZWNvcmF0aW9ucyIsImR5bmFtaWNEZWNvcmF0aW9uTWFwIiwiYnVpbGRlciIsInNwYW5zIiwidGFnIiwidG9Mb3dlckNhc2UiLCJEaXJlY3Rpb24iLCJMVFIiLCJSVEwiLCJkZWMiLCJzdHIiLCJMb3dUeXBlcyIsIkFyYWJpY1R5cGVzIiwiQnJhY2tldHMiLCJCcmFja2V0U3RhY2siLCJwIiwibCIsImNoYXJDb2RlQXQiLCJjaGFyVHlwZSIsIkJpZGlSRSIsIkJpZGlTcGFuIiwibGV2ZWwiLCJmb3J3YXJkIiwib3JkZXIiLCJhc3NvYyIsIm1heWJlIiwiaXNvbGF0ZXNFcSIsImlBIiwiaUIiLCJkaXJlY3Rpb24iLCJpbm5lciIsInR5cGVzIiwiY29tcHV0ZUNoYXJUeXBlcyIsInJGcm9tIiwiclRvIiwiaXNvbGF0ZXMiLCJvdXRlclR5cGUiLCJpSSIsInByZXZUeXBlIiwicHJldlN0cm9uZyIsInByb2Nlc3NCcmFja2V0UGFpcnMiLCJvcHBvc2l0ZVR5cGUiLCJzSSIsImNvbnRleHQiLCJiciIsInNKIiwiZW1iZWQiLCJwcm9jZXNzTmV1dHJhbHMiLCJiZWZvcmVMIiwiYWZ0ZXJMIiwiakkiLCJmcm9tSiIsImVtaXRTcGFucyIsImJhc2VMZXZlbCIsIm91clR5cGUiLCJpQ2giLCJzYW1lRGlyIiwiaXNOdW0iLCJyZWN1cnNlIiwibG9jYWxMZXZlbCIsImlTY2FuIiwicnVuIiwiaXNvIiwidXB0byIsImRpclN3YXAiLCJjb21wdXRlU2VjdGlvbk9yZGVyIiwiY29tcHV0ZU9yZGVyIiwidHJpdmlhbE9yZGVyIiwibW92ZWRPdmVyIiwibW92ZVZpc3VhbGx5Iiwic3RhcnRJbmRleCIsImhlYWQiLCJzcGFuSSIsImJpZGlMZXZlbCIsInNwYW5FbmQiLCJuZXh0SSIsIm5leHRJbmRleCIsIm5leHRTcGFuIiwiYXV0b0RpcmVjdGlvbiIsImNsaWNrQWRkc1NlbGVjdGlvblJhbmdlIiwiZGVmaW5lIiwiZHJhZ01vdmVzU2VsZWN0aW9uJDEiLCJtb3VzZVNlbGVjdGlvblN0eWxlIiwiZXhjZXB0aW9uU2luayIsInVwZGF0ZUxpc3RlbmVyIiwiaW5wdXRIYW5kbGVyIiwiZm9jdXNDaGFuZ2VFZmZlY3QiLCJjbGlwYm9hcmRJbnB1dEZpbHRlciIsImNsaXBib2FyZE91dHB1dEZpbHRlciIsInBlckxpbmVUZXh0RGlyZWN0aW9uIiwiY29tYmluZSIsInZhbHVlcyIsIm5hdGl2ZVNlbGVjdGlvbkhpZGRlbiIsInNjcm9sbEhhbmRsZXIiLCJTY3JvbGxUYXJnZXQiLCJpc1NuYXBzaG90IiwibWFwIiwiY2hhbmdlcyIsImNsaXAiLCJzY3JvbGxJbnRvVmlldyIsInQiLCJzZXRFZGl0Q29udGV4dEZvcm1hdHRpbmciLCJsb2dFeGNlcHRpb24iLCJleGNlcHRpb24iLCJoYW5kbGVyIiwiZmFjZXQiLCJvbmVycm9yIiwiU3RyaW5nIiwiY29uc29sZSIsImVycm9yIiwibmV4dFBsdWdpbklEIiwidmlld1BsdWdpbiIsInBsdWdpbnMiLCJmaWx0ZXIiLCJwbHVnaW4iLCJWaWV3UGx1Z2luIiwiaWQiLCJkb21FdmVudEhhbmRsZXJzIiwiZG9tRXZlbnRPYnNlcnZlcnMiLCJidWlsZEV4dGVuc2lvbnMiLCJiYXNlRXh0ZW5zaW9ucyIsImV4dGVuc2lvbiIsImFyZyIsImV2ZW50SGFuZGxlcnMiLCJldmVudE9ic2VydmVycyIsInByb3ZpZGUiLCJleHQiLCJwbHVnaW5JbnN0IiwiZnJvbUNsYXNzIiwiUGx1Z2luSW5zdGFuY2UiLCJtdXN0VXBkYXRlIiwidXBkYXRlIiwiZSIsImRlYWN0aXZhdGUiLCJlZGl0b3JBdHRyaWJ1dGVzIiwiY29udGVudEF0dHJpYnV0ZXMiLCJvdXRlckRlY29yYXRpb25zIiwiYXRvbWljUmFuZ2VzIiwiYmlkaUlzb2xhdGVkUmFuZ2VzIiwiZ2V0SXNvbGF0ZWRSYW5nZXMiLCJzZXRzIiwiRnVuY3Rpb24iLCJmcm9tRG9jIiwidG9Eb2MiLCJiaWRpSXNvbGF0ZSIsInNjcm9sbE1hcmdpbnMiLCJnZXRTY3JvbGxNYXJnaW5zIiwibSIsInN0eWxlTW9kdWxlIiwiQ2hhbmdlZFJhbmdlIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsInRvQiIsImFkZFRvU2V0IiwibWUiLCJleHRlbmRXaXRoUmFuZ2VzIiwiZGlmZiIsImRJIiwickkiLCJWaWV3VXBkYXRlIiwidHJhbnNhY3Rpb25zIiwic3RhcnRTdGF0ZSIsInRyIiwiY29tcG9zZSIsImNoYW5nZWRSYW5nZXMiLCJpdGVyQ2hhbmdlZFJhbmdlcyIsInZpZXdwb3J0Q2hhbmdlZCIsInZpZXdwb3J0TW92ZWQiLCJoZWlnaHRDaGFuZ2VkIiwiZ2VvbWV0cnlDaGFuZ2VkIiwiZG9jQ2hhbmdlZCIsImZvY3VzQ2hhbmdlZCIsInNlbGVjdGlvblNldCIsIkRvY1ZpZXciLCJkb21DaGFuZ2VkIiwiaGFzQ29tcG9zaXRpb24iLCJtYXJrZWRGb3JDb21wb3NpdGlvbiIsIlNldCIsImVkaXRDb250ZXh0Rm9ybWF0dGluZyIsImxhc3RDb21wb3NpdGlvbkFmdGVyQ3Vyc29yIiwibWluV2lkdGgiLCJtaW5XaWR0aEZyb20iLCJtaW5XaWR0aFRvIiwiaW1wcmVjaXNlQW5jaG9yIiwiaW1wcmVjaXNlSGVhZCIsImZvcmNlU2VsZWN0aW9uIiwibGFzdFVwZGF0ZSIsIkRhdGUiLCJub3ciLCJjb250ZW50RE9NIiwidXBkYXRlRGVjbyIsInVwZGF0ZUlubmVyIiwiZXZlcnkiLCJtYXBQb3MiLCJ1cGRhdGVFZGl0Q29udGV4dEZvcm1hdHRpbmciLCJyZWFkQ29tcG9zaXRpb25BdCIsImlucHV0U3RhdGUiLCJjb21wb3NpbmciLCJvYnNlcnZlciIsImVkaXRDb250ZXh0IiwibmV3U2VsIiwidG91Y2hlc0NvbXBvc2l0aW9uIiwibWFpbiIsImNvbXBvc2l0aW9uIiwiZmluZENvbXBvc2l0aW9uUmFuZ2UiLCJjbGVhciIsImxpbmVzIiwicHJldkRlY28iLCJkZWNvRGlmZiIsImZpbmRDaGFuZ2VkRGVjbyIsIm9sZExlbmd0aCIsIm11c3RNZWFzdXJlQ29udGVudCIsInVwZGF0ZUNoaWxkcmVuIiwiY29udGVudEhlaWdodCIsImZsZXhCYXNpcyIsInNlbGVjdGlvblJhbmdlIiwiZm9yRWFjaCIsImNWaWV3IiwiZ2FwcyIsInZpZXdwb3J0IiwidXBkYXRlR2FwcyIsImNvbXBMaW5lIiwiY29tcG9zaXRpb25WaWV3IiwiZml4Q29tcG9zaXRpb25ET00iLCJlZmZlY3QiLCJlZmZlY3RzIiwiaXMiLCJtYXJrcyIsImZpeCIsImMiLCJ1cGRhdGVTZWxlY3Rpb24iLCJtdXN0UmVhZCIsImZyb21Qb2ludGVyIiwicmVhZFNlbGVjdGlvblJhbmdlIiwiYWN0aXZlRWx0IiwiYWN0aXZlRWxlbWVudCIsImZvY3VzZWQiLCJzZWxlY3Rpb25Ob3RGb2N1cyIsInRhYkluZGV4IiwiZm9yY2UiLCJhbmNob3IiLCJtb3ZlVG9MaW5lIiwiYmV0d2VlblVuZWRpdGFibGUiLCJkdW1teSIsInN1cHByZXNzV2lkZ2V0Q3Vyc29yQ2hhbmdlIiwiaW5VbmVkaXRhYmxlIiwiYmx1ciIsInJhd1NlbCIsIm5leHRUbyIsIm5leHRUb1VuZWRpdGFibGUiLCJjb2xsYXBzZSIsImNhcmV0QmlkaUxldmVsIiwiZXh0ZW5kIiwicmVtb3ZlQWxsUmFuZ2VzIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJzZWwiLCJwb3NGcm9tRE9NIiwiZW5mb3JjZUN1cnNvckFzc29jIiwibW9kaWZ5IiwibGluZVN0YXJ0IiwibmV3UmFuZ2UiLCJuZXdQb3MiLCJuZWFyZXN0IiwiZG9tVmlldyIsImJlc3QiLCJiZXN0UG9zIiwiY29vcmRzRm9yQ2hhciIsImNoaWxkT2ZmIiwibWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyIsImNvbnRlbnRXaWR0aCIsImlzV2lkZXIiLCJzY3JvbGxET00iLCJ3aWRlc3QiLCJ0ZXh0RGlyZWN0aW9uIiwiY2hpbGRSZWN0IiwidGV4dERpcmVjdGlvbkF0IiwibWVhc3VyZSIsInRleHRDb250ZW50IiwicmVtb3ZlIiwiY29tcHV0ZUJsb2NrR2FwRGVjbyIsInZzIiwidmlld3BvcnRzIiwibGluZUJsb2NrQXQiLCJhbGxEZWNvIiwiZCIsImR5bmFtaWMiLCJkeW5hbWljT3V0ZXIiLCJvdXRlckRlY28iLCJsaW5lR2FwRGVjbyIsInJlZiIsIm1hcmdpbnMiLCJ0YXJnZXRSZWN0IiwibGluZUhhc1dpZGdldCIsImZpbmRDb21wb3NpdGlvbk5vZGUiLCJoZWFkUG9zIiwidGV4dEJlZm9yZSIsInRleHRBZnRlciIsInRleHROb2RlIiwiZGVzY0FmdGVyIiwiZGVzY0JlZm9yZSIsImZvdW5kIiwic2xpY2VTdHJpbmciLCJpbnYiLCJpbnZlcnRlZERlc2MiLCJwYXJlbnRWaWV3IiwiRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSIsIkRlY29yYXRpb25Db21wYXJhdG9yIiwiY29tcGFyZVJhbmdlIiwiY29tcGFyZVBvaW50IiwiYm91bmRDaGFuZ2UiLCJjb21wIiwiaW5zaWRlIiwidG91Y2hlZCIsImdyb3VwQXQiLCJjYXRlZ29yaXplIiwiY2hhckNhdGVnb3JpemVyIiwibGluZVBvcyIsImNhdCIsImdldGR4IiwiZ2V0ZHkiLCJ5T3ZlcmxhcCIsInVwVG9wIiwidXBCb3QiLCJkb21Qb3NBdENvb3JkcyIsImNsb3Nlc3QiLCJjbG9zZXN0UmVjdCIsImNsb3Nlc3RYIiwiY2xvc2VzdFkiLCJjbG9zZXN0T3ZlcmxhcCIsImFib3ZlIiwiYmVsb3ciLCJhYm92ZVJlY3QiLCJiZWxvd1JlY3QiLCJkeCIsImR5IiwiZG9tUG9zSW5UZXh0IiwiY2xpcFgiLCJjbG9zZXN0T2Zmc2V0IiwiY2xvc2VzdERZIiwiZ2VuZXJhbFNpZGUiLCJyZWN0QmVmb3JlIiwicG9zQXRDb29yZHMiLCJjb29yZHMiLCJkb2NUb3AiLCJwYWRkaW5nVG9wIiwiZG9jSGVpZ2h0IiwieU9mZnNldCIsImhhbGZMaW5lIiwiYm91bmNlZCIsImVsZW1lbnRBdEhlaWdodCIsInBvc0F0Q29vcmRzSW1wcmVjaXNlIiwiZWxlbWVudEZyb21Qb2ludCIsImVsZW1lbnQiLCJjYXJldFBvc2l0aW9uRnJvbVBvaW50Iiwib2Zmc2V0Tm9kZSIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJzdGFydENvbnRhaW5lciIsImlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0IiwiaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQiLCJjb250ZW50UmVjdCIsImludG8iLCJyb3VuZCIsImRlZmF1bHRDaGFyYWN0ZXJXaWR0aCIsImxpbmVXcmFwcGluZyIsImRlZmF1bHRMaW5lSGVpZ2h0IiwiZmxvb3IiLCJsaW5lTGVuZ3RoIiwic2xpY2VEb2MiLCJpc0VuZE9mTGluZUJlZm9yZSIsImJsb2NrQXQiLCJpc0FycmF5IiwibW92ZVRvTGluZUJvdW5kYXJ5IiwiaW5jbHVkZVdyYXAiLCJ3aWRnZXRMaW5lQnJlYWtzIiwiY29vcmRzQXRQb3MiLCJlZGl0b3JSZWN0IiwibW92ZUJ5Q2hhciIsImJ5IiwiYmlkaVNwYW5zIiwiY2hlY2siLCJjaGFyIiwibnVtYmVyIiwidmlzdWFsTGluZVNpZGUiLCJieUdyb3VwIiwibmV4dENhdCIsIlNwYWNlIiwibW92ZVZlcnRpY2FsbHkiLCJkaXN0YW5jZSIsInN0YXJ0UG9zIiwiZ29hbCIsImdvYWxDb2x1bW4iLCJzdGFydFkiLCJzdGFydENvb3JkcyIsImRvY3VtZW50VG9wIiwicmVzb2x2ZWRHb2FsIiwiZXh0cmEiLCJjdXJZIiwiY2hhclJlY3QiLCJza2lwQXRvbWljUmFuZ2VzIiwiYXRvbXMiLCJtb3ZlZCIsImJldHdlZW4iLCJza2lwQXRvbXNGb3JTZWxlY3Rpb24iLCJ1cGRhdGVkIiwibWFpbkluZGV4Iiwic2tpcEF0b21zIiwib2xkUG9zIiwiZiIsIkxpbmVCcmVha1BsYWNlaG9sZGVyIiwiRE9NUmVhZGVyIiwicG9pbnRzIiwibGluZVNlcGFyYXRvciIsInJlYWRSYW5nZSIsImZpbmRQb2ludEJlZm9yZSIsIm9sZExlbiIsInJlYWROb2RlIiwibmV4dFZpZXciLCJpc0VtcHR5VG9FbmQiLCJyZWFkVGV4dE5vZGUiLCJyZSIsIm5leHRCcmVhayIsImJyZWFrU2l6ZSIsImZyb21WaWV3IiwiZmluZFBvaW50SW5zaWRlIiwiaXNBdEVuZCIsIndpZGdldHMiLCJ3Iiwib3ZlcnJpZGUiLCJET01Qb2ludCIsIkRPTUNoYW5nZSIsInR5cGVPdmVyIiwiYm91bmRzIiwiaUhlYWQiLCJpQW5jaG9yIiwicmVhZE9ubHkiLCJzZWxQb2ludHMiLCJzZWxlY3Rpb25Qb2ludHMiLCJyZWFkZXIiLCJzZWxlY3Rpb25Gcm9tUG9pbnRzIiwib2ZmRnJvbSIsIm9mZlRvIiwic2luZ2xlIiwiYXBwbHlET01DaGFuZ2UiLCJkb21DaGFuZ2UiLCJjaGFuZ2UiLCJsYXN0S2V5IiwibGFzdEtleVRpbWUiLCJsYXN0S2V5Q29kZSIsInByZWZlcnJlZFBvcyIsInByZWZlcnJlZFNpZGUiLCJmaW5kRGlmZiIsImhhc0ZvY3VzIiwiZ2V0QXR0cmlidXRlIiwiaW5zZXJ0aW5nVGV4dEF0IiwidG9UZXh0IiwiaW5zZXJ0aW5nVGV4dCIsImFwcGx5RE9NQ2hhbmdlSW5uZXIiLCJ1c2VyRXZlbnQiLCJsYXN0U2VsZWN0aW9uVGltZSIsImxhc3RTZWxlY3Rpb25PcmlnaW4iLCJkaXNwYXRjaCIsImZsdXNoSU9TS2V5IiwiZGVmYXVsdFRyIiwiZGVmYXVsdEluc2VydCIsImFwcGx5RGVmYXVsdEluc2VydCIsImgiLCJpbkF0b21pYyIsInJlcGxhY2VTZWxlY3Rpb24iLCJtYWluU2VsIiwibmV3TGVuZ3RoIiwicmVwbGFjZWQiLCJjb21wb3NpdGlvblJhbmdlIiwic2l6ZSIsImNoYW5nZUJ5UmFuZ2UiLCJyYW5nZUNoYW5nZXMiLCJzZWxPZmYiLCJjb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UiLCJjb21wb3NpdGlvbkVuZGVkQXQiLCJjb21wb3NpdGlvbkZpcnN0Q2hhbmdlIiwibWluTGVuIiwiYWRqdXN0IiwibW92ZSIsIklucHV0U3RhdGUiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJvcmlnaW4iLCJsYXN0VG91Y2hUaW1lIiwibGFzdEZvY3VzVGltZSIsImxhc3RTY3JvbGxUb3AiLCJsYXN0U2Nyb2xsTGVmdCIsInBlbmRpbmdJT1NLZXkiLCJ0YWJGb2N1c01vZGUiLCJsYXN0Q29udGV4dE1lbnUiLCJzY3JvbGxIYW5kbGVycyIsImhhbmRsZXJzIiwiY29tcG9zaXRpb25QZW5kaW5nS2V5IiwibW91c2VTZWxlY3Rpb24iLCJkcmFnZ2VkQ29udGVudCIsImhhbmRsZUV2ZW50IiwiYmluZCIsIm5vdGlmaWVkRm9jdXNlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmaXJlZm94Q29weUN1dEhhY2siLCJldmVudEJlbG9uZ3NUb0VkaXRvciIsImlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uIiwia2V5ZG93biIsInVwZGF0ZVN0YXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicnVuSGFuZGxlcnMiLCJvYnNlcnZlcnMiLCJwcmV2ZW50RGVmYXVsdCIsImVuc3VyZUhhbmRsZXJzIiwiY29tcHV0ZUhhbmRsZXJzIiwicGFzc2l2ZSIsImV4aXN0cyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtb2RpZmllckNvZGVzIiwiZGVsYXlBbmRyb2lkS2V5IiwicGVuZGluZyIsIlBlbmRpbmdLZXlzIiwiRW1hY3N5UGVuZGluZ0tleXMiLCJzZXRUaW1lb3V0IiwiZm9yY2VGbHVzaCIsInN0YXJ0TW91c2VTZWxlY3Rpb24iLCJiaW5kSGFuZGxlciIsInJlY29yZCIsImlucHV0VHlwZSIsImRyYWdTY3JvbGxNYXJnaW4iLCJkcmFnU2Nyb2xsU3BlZWQiLCJjbGllbnRYIiwiY2xpZW50WSIsIk1vdXNlU2VsZWN0aW9uIiwic3RhcnRFdmVudCIsIm11c3RTZWxlY3QiLCJzY3JvbGxTcGVlZCIsInNjcm9sbGluZyIsImxhc3RFdmVudCIsInNjcm9sbFBhcmVudHMiLCJtdWx0aXBsZSIsImFsbG93TXVsdGlwbGVTZWxlY3Rpb25zIiwiYWRkc1NlbGVjdGlvblJhbmdlIiwiZHJhZ2dpbmciLCJpc0luUHJpbWFyeVNlbGVjdGlvbiIsImdldENsaWNrVHlwZSIsInNlbGVjdCIsImJ1dHRvbnMiLCJzeCIsInN5Iiwic2V0U2Nyb2xsU3BlZWQiLCJzZXRJbnRlcnZhbCIsInNjcm9sbCIsImNsZWFySW50ZXJ2YWwiLCJpc1VzZXJFdmVudCIsImRyYWdNb3Zlc1NlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiYnViYmxlcyIsImJyb2tlbkNsaXBib2FyZEFQSSIsImNhcHR1cmVQYXN0ZSIsImRvUGFzdGUiLCJ0ZXh0RmlsdGVyIiwiaW5wdXQiLCJieUxpbmUiLCJsaW5ld2lzZSIsImxhc3RMaW5ld2lzZUNvcHkiLCJsYXN0TGluZSIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJtb3VzZWRvd24iLCJmbHVzaCIsIm1ha2VTdHlsZSIsImJ1dHRvbiIsImJhc2ljTW91c2VTZWxlY3Rpb24iLCJtdXN0Rm9jdXMiLCJtb3VzZVNlbCIsInJhbmdlRm9yQ2xpY2siLCJ2aXN1YWwiLCJmaW5kUG9zaXRpb25TaWRlIiwicXVlcnlQb3MiLCJCYWRNb3VzZURldGFpbCIsImxhc3RNb3VzZURvd24iLCJsYXN0TW91c2VEb3duQ291bnQiLCJsYXN0TW91c2VEb3duVGltZSIsImRldGFpbCIsImxhc3RUaW1lIiwic3RhcnRTZWwiLCJyZW1vdmVkIiwic3RhcnRSYW5nZSIsInJlbW92ZVJhbmdlQXJvdW5kIiwiZHJhZ3N0YXJ0IiwiZHJhZ2dhYmxlIiwiZGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsImVmZmVjdEFsbG93ZWQiLCJkcmFnZW5kIiwiZHJvcFRleHQiLCJkaXJlY3QiLCJkcm9wUG9zIiwiZGVsIiwiaW5zIiwiZHJvcCIsImZpbGVzIiwicmVhZCIsImZpbmlzaEZpbGUiLCJzIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlYWRBc1RleHQiLCJnZXREYXRhIiwicGFzdGUiLCJkYXRhIiwiY2xpcGJvYXJkRGF0YSIsImNhcHR1cmVDb3B5Iiwic2VsZWN0aW9uRW5kIiwic2VsZWN0aW9uU3RhcnQiLCJjb3BpZWRSYW5nZSIsImNvcHkiLCJjdXQiLCJjbGVhckRhdGEiLCJpc0ZvY3VzQ2hhbmdlIiwiZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbiIsImdldEVmZmVjdCIsImFubm90YXRpb25zIiwidXBkYXRlRm9yRm9jdXNDaGFuZ2UiLCJjbGVhclNlbGVjdGlvblJhbmdlIiwiY29tcG9zaXRpb25zdGFydCIsImNvbXBvc2l0aW9udXBkYXRlIiwiY29tcG9zaXRpb25lbmQiLCJwZW5kaW5nUmVjb3JkcyIsImZsdXNoU29vbiIsImNvbnRleHRtZW51IiwiYmVmb3JlaW5wdXQiLCJnZXRUYXJnZXRSYW5nZXMiLCJwb3NBdERPTSIsImVuZENvbnRhaW5lciIsImVuZE9mZnNldCIsInN0YXJ0Vmlld0hlaWdodCIsImFwcGxpZWRGaXJlZm94SGFjayIsImhhcyIsIndyYXBwaW5nV2hpdGVTcGFjZSIsImhlaWdodENoYW5nZUZsYWciLCJjbGVhckhlaWdodENoYW5nZUZsYWciLCJIZWlnaHRPcmFjbGUiLCJoZWlnaHRTYW1wbGVzIiwiaGVpZ2h0Rm9yR2FwIiwiY2VpbCIsImhlaWdodEZvckxpbmUiLCJzZXREb2MiLCJtdXN0UmVmcmVzaEZvcldyYXBwaW5nIiwid2hpdGVTcGFjZSIsIm11c3RSZWZyZXNoRm9ySGVpZ2h0cyIsImxpbmVIZWlnaHRzIiwibmV3SGVpZ2h0IiwicmVmcmVzaCIsImtub3duSGVpZ2h0cyIsIk1lYXN1cmVkSGVpZ2h0cyIsImhlaWdodHMiLCJtb3JlIiwiQmxvY2tJbmZvIiwiX2NvbnRlbnQiLCJRdWVyeVR5cGUiLCJFcHNpbG9uIiwiSGVpZ2h0TWFwIiwib3V0ZGF0ZWQiLCJzZXRIZWlnaHQiLCJub2RlcyIsImRlY29tcG9zZUxlZnQiLCJkZWNvbXBvc2VSaWdodCIsImFwcGx5Q2hhbmdlcyIsIm9sZERvYyIsIm9yYWNsZSIsIkJ5UG9zTm9IZWlnaHQiLCJOb2RlQnVpbGRlciIsInVwZGF0ZUhlaWdodCIsIkhlaWdodE1hcFRleHQiLCJicmVhayIsImJyayIsIkhlaWdodE1hcEJyYW5jaCIsIm9sZCIsInZhbCIsIkhlaWdodE1hcEJsb2NrIiwiX2hlaWdodCIsIl9vcmFjbGUiLCJfdmFsdWUiLCJfdHlwZSIsImZvckVhY2hMaW5lIiwiX2ZvcmNlIiwibWVhc3VyZWQiLCJjb2xsYXBzZWQiLCJ3aWRnZXRIZWlnaHQiLCJicmVha3MiLCJIZWlnaHRNYXBHYXAiLCJoZWlnaHRNZXRyaWNzIiwiZmlyc3RMaW5lIiwicGVyTGluZSIsInBlckNoYXIiLCJ0b3RhbFBlckxpbmUiLCJndWVzcyIsImxpbmVUb3AiLCJCeUhlaWdodCIsImxpbmVzQWJvdmUiLCJmaXJzdCIsInVuc2hpZnQiLCJzaW5nbGVIZWlnaHQiLCJtaWQiLCJyaWdodFRvcCIsInJpZ2h0T2Zmc2V0Iiwic3ViUXVlcnkiLCJCeVBvcyIsInJpZ2h0U3RhcnQiLCJiYWxhbmNlZCIsIm1lcmdlR2FwcyIsInJlYmFsYW5jZSIsImFyb3VuZCIsInJlbGV2YW50V2lkZ2V0SGVpZ2h0IiwibGluZUVuZCIsImNvdmVyaW5nIiwid3JpdHRlblRvIiwiaXNDb3ZlcmVkIiwiYWRkQmxvY2siLCJlbnRlckxpbmUiLCJibGFua0NvbnRlbnQiLCJnYXAiLCJlbnN1cmVMaW5lIiwiaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyIsInZpc2libGVQaXhlbFJhbmdlIiwib3ZlcmZsb3ciLCJwYXJlbnRSZWN0Iiwib2Zmc2V0UGFyZW50IiwiaW5XaW5kb3ciLCJmdWxsUGl4ZWxSYW5nZSIsIkxpbmVHYXAiLCJkaXNwbGF5U2l6ZSIsInNhbWUiLCJnQSIsImdCIiwiZHJhdyIsIndyYXBwaW5nIiwiTGluZUdhcFdpZGdldCIsInZlcnRpY2FsIiwiZGlzcGxheSIsIlZpZXdTdGF0ZSIsInBpeGVsVmlld3BvcnQiLCJpblZpZXciLCJwYWRkaW5nQm90dG9tIiwiY29udGVudERPTVdpZHRoIiwiY29udGVudERPTUhlaWdodCIsImVkaXRvckhlaWdodCIsImVkaXRvcldpZHRoIiwic2Nyb2xsZWRUb0JvdHRvbSIsInNjcm9sbEFuY2hvclBvcyIsInNjcm9sbEFuY2hvckhlaWdodCIsInNjYWxlciIsIklkU2NhbGVyIiwic2Nyb2xsVGFyZ2V0IiwicHJpbnRpbmciLCJkZWZhdWx0VGV4dERpcmVjdGlvbiIsInZpc2libGVSYW5nZXMiLCJtdXN0RW5mb3JjZUN1cnNvckFzc29jIiwiZ3Vlc3NXcmFwcGluZyIsInN0YXRlRGVjbyIsImhlaWdodE1hcCIsImdldFZpZXdwb3J0IiwidXBkYXRlRm9yVmlld3BvcnQiLCJ1cGRhdGVWaWV3cG9ydExpbmVzIiwibGluZUdhcHMiLCJlbnN1cmVMaW5lR2FwcyIsImNvbXB1dGVWaXNpYmxlUmFuZ2VzIiwiVmlld3BvcnQiLCJ1cGRhdGVTY2FsZXIiLCJCaWdTY2FsZXIiLCJ2aWV3cG9ydExpbmVzIiwic2NhbGVCbG9jayIsImNvbnRlbnRDaGFuZ2VzIiwiaGVpZ2h0Q2hhbmdlcyIsInByZXZIZWlnaHQiLCJzY3JvbGxBbmNob3IiLCJzY3JvbGxBbmNob3JBdCIsIm1hcFZpZXdwb3J0Iiwidmlld3BvcnRJc0FwcHJvcHJpYXRlIiwidmlld3BvcnRDaGFuZ2UiLCJ1cGRhdGVMaW5lR2FwcyIsIm1hcExpbmVHYXBzIiwiZG9tUmVjdCIsIm1lYXN1cmVDb250ZW50IiwicGFyc2VJbnQiLCJkVG9wIiwiZEJvdHRvbSIsInZpc2libGVUb3AiLCJmcm9tRE9NIiwidmlzaWJsZUJvdHRvbSIsIm1hcmdpblRvcCIsInZpZXdIZWlnaHQiLCJ0b3BQb3MiLCJtYXBwZWQiLCJ0b3VjaGVzUmFuZ2UiLCJjdXJyZW50IiwibWF5TWVhc3VyZSIsImhhbGZNYXJnaW4iLCJkb3VibGVNYXJnaW4iLCJhZGRHYXAiLCJzdHJ1Y3R1cmUiLCJhdm9pZCIsImdhcFNpemUiLCJjaGVja0xpbmUiLCJsaW5lU3RydWN0dXJlIiwidG90YWwiLCJ2aWV3RnJvbSIsInZpZXdUbyIsIm1hcmdpbkhlaWdodCIsImJvdCIsInRhcmdldEZyYWMiLCJmaW5kRnJhY3Rpb24iLCJzcGFjZUZyYWMiLCJmaW5kUG9zaXRpb24iLCJtYXJnaW5XaWR0aCIsImhvcml6T2Zmc2V0IiwicHhMZWZ0IiwicHhSaWdodCIsImZyYWN0aW9uIiwibnciLCJsaW5lQmxvY2tBdEhlaWdodCIsInJhdGlvIiwiY291bnRlZCIsImFycmF5IiwibiIsInNjYWxlIiwidnBIZWlnaHQiLCJkb21CYXNlIiwiZG9tVG9wIiwiZG9tQm90dG9tIiwib2JqIiwiYlRvcCIsImJCb3R0b20iLCJ0aGVtZSIsInN0cnMiLCJkYXJrVGhlbWUiLCJiYXNlVGhlbWVJRCIsIm5ld05hbWUiLCJiYXNlTGlnaHRJRCIsImJhc2VEYXJrSUQiLCJsaWdodERhcmtJRHMiLCJidWlsZFRoZW1lIiwic2NvcGVzIiwiYmFzZVRoZW1lJDEiLCJib3hTaXppbmciLCJvdXRsaW5lIiwiZmxleERpcmVjdGlvbiIsImFsaWduSXRlbXMiLCJmb250RmFtaWx5Iiwib3ZlcmZsb3dYIiwiekluZGV4Iiwib3ZlcmZsb3dBbmNob3IiLCJmbGV4R3JvdyIsImZsZXhTaHJpbmsiLCJ3b3JkV3JhcCIsIm1pbkhlaWdodCIsInBhZGRpbmciLCJXZWJraXRVc2VyTW9kaWZ5Iiwid2hpdGVTcGFjZV9mYWxsYmFjayIsIndvcmRCcmVhayIsIm92ZXJmbG93V3JhcCIsImNhcmV0Q29sb3IiLCJjb250YWluIiwiYmFja2dyb3VuZCIsInBvaW50ZXJFdmVudHMiLCJhbmltYXRpb24iLCJvcGFjaXR5IiwiYm9yZGVyTGVmdCIsIm1hcmdpbkxlZnQiLCJib3JkZXJMZWZ0Q29sb3IiLCJ1bmljb2RlQmlkaSIsImJhY2tncm91bmRDb2xvciIsImNvbG9yIiwiaW5zZXRJbmxpbmVTdGFydCIsImluc2V0SW5saW5lRW5kIiwiYm9yZGVyIiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsInRleHRBbGlnbiIsImJvcmRlckJvdHRvbSIsImJvcmRlclRvcCIsImZvbnRTaXplIiwiZm9udCIsInZlcnRpY2FsQWxpZ24iLCJ1c2VyU2VsZWN0IiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYm9yZGVyUmFkaXVzIiwib2JzZXJ2ZU9wdGlvbnMiLCJjaGFyYWN0ZXJEYXRhIiwic3VidHJlZSIsImNoYXJhY3RlckRhdGFPbGRWYWx1ZSIsInVzZUNoYXJEYXRhIiwiRE9NT2JzZXJ2ZXIiLCJzZWxlY3Rpb25DaGFuZ2VkIiwiZGVsYXllZEZsdXNoIiwicmVzaXplVGltZW91dCIsInF1ZXVlIiwiZGVsYXllZEFuZHJvaWRLZXkiLCJmbHVzaGluZ0FuZHJvaWRLZXkiLCJsYXN0Q2hhbmdlIiwic2Nyb2xsVGFyZ2V0cyIsImludGVyc2VjdGlvbiIsInJlc2l6ZVNjcm9sbCIsImludGVyc2VjdGluZyIsImdhcEludGVyc2VjdGlvbiIsInByaW50UXVlcnkiLCJwYXJlbnRDaGVjayIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtdXRhdGlvbnMiLCJtdXQiLCJyZW1vdmVkTm9kZXMiLCJvbGRWYWx1ZSIsIkVkaXRDb250ZXh0IiwiRURJVF9DT05URVhUIiwiRWRpdENvbnRleHRNYW5hZ2VyIiwib25DaGFyRGF0YSIsInByZXZWYWx1ZSIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwib25SZXNpemUiLCJvblByaW50Iiwib25TY3JvbGwiLCJtYXRjaE1lZGlhIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYWRkV2luZG93TGlzdGVuZXJzIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwibGlzdGVuRm9yU2Nyb2xsIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJvblNjcm9sbENoYW5nZWQiLCJjcmVhdGVFdmVudCIsInRocmVzaG9sZCIsInJlcXVlc3RNZWFzdXJlIiwibWVhc3VyZVJlcSIsIm1hdGNoZXMiLCJnIiwiZGlzY29ubmVjdCIsIndhc0NoYW5nZWQiLCJzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2siLCJsb2NhbCIsInByb2Nlc3NSZWNvcmRzIiwiY2xlYXJEZWxheWVkQW5kcm9pZEtleSIsImZsdXNoZWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInRha2VSZWNvcmRzIiwicmVjb3JkcyIsInJlYWRNdXRhdGlvbiIsInJlYWRDaGFuZ2UiLCJyZWFkU2VsZWN0aW9uIiwiaGFuZGxlZCIsInJlYyIsImNoaWxkQmVmb3JlIiwiZmluZENoaWxkIiwiY2hpbGRBZnRlciIsInNldFdpbmRvdyIsInJlbW92ZVdpbmRvd0xpc3RlbmVycyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJfYyIsImNsZWFyVGltZW91dCIsImN1clZpZXciLCJidWlsZFNlbGVjdGlvblJhbmdlRnJvbVJhbmdlIiwiY3VyQW5jaG9yIiwiZ2V0Q29tcG9zZWRSYW5nZXMiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJleGVjQ29tbWFuZCIsInBlbmRpbmdDb250ZXh0Q2hhbmdlIiwicmVzZXRSYW5nZSIsInRvQ29udGV4dFBvcyIsInRleHR1cGRhdGUiLCJ0b0VkaXRvclBvcyIsInVwZGF0ZVJhbmdlU3RhcnQiLCJ1cGRhdGVSYW5nZUVuZCIsImNvbnRleHRCYXNlIiwiZWRpdG9yQmFzZSIsImRyaWZ0ZWQiLCJkZWxldGVzIiwibmV3TGVuIiwicmV2ZXJ0UGVuZGluZyIsInNldFNlbGVjdGlvbiIsImNoYXJhY3RlcmJvdW5kc3VwZGF0ZSIsInJhbmdlU3RhcnQiLCJyYW5nZUVuZCIsIkRPTVJlY3QiLCJ1cGRhdGVDaGFyYWN0ZXJCb3VuZHMiLCJ0ZXh0Zm9ybWF0dXBkYXRlIiwiZm9ybWF0IiwiZ2V0VGV4dEZvcm1hdHMiLCJsaW5lU3R5bGUiLCJ1bmRlcmxpbmVTdHlsZSIsInRoaWNrbmVzcyIsInVuZGVybGluZVRoaWNrbmVzcyIsInJlc2V0IiwidXBkYXRlQ29udHJvbEJvdW5kcyIsInVwZGF0ZVNlbGVjdGlvbkJvdW5kcyIsImFwcGx5RWRpdHMiLCJhYm9ydCIsIml0ZXJDaGFuZ2VzIiwiX2Zyb21CIiwiX3RvQiIsInVwZGF0ZVRleHQiLCJyZXZlcnRlZCIsInJhbmdlSXNWYWxpZCIsImNvbnRleHRQb3MiLCJjbGlwTGVuIiwiZWRpdG9yUG9zIiwiRWRpdG9yVmlldyIsImNvbXBvc2l0aW9uU3RhcnRlZCIsIl9yb290IiwiY29uZmlnIiwicGx1Z2luTWFwIiwiTWFwIiwiZWRpdG9yQXR0cnMiLCJjb250ZW50QXR0cnMiLCJiaWRpQ2FjaGUiLCJkZXN0cm95ZWQiLCJtZWFzdXJlU2NoZWR1bGVkIiwibWVhc3VyZVJlcXVlc3RzIiwiYW5ub3VuY2VET00iLCJkaXNwYXRjaFRyYW5zYWN0aW9ucyIsInRycyIsInNjcm9sbFRvIiwibW91bnRTdHlsZXMiLCJmb250cyIsInJlYWR5IiwicmVkcmF3biIsImF0dHJzQ2hhbmdlZCIsImZvY3VzRmxhZyIsImRpc3BhdGNoRm9jdXMiLCJhbm5vdGF0aW9uIiwicGVuZGluZ0tleSIsInBocmFzZXMiLCJzZXRTdGF0ZSIsIkNhY2hlZE9yZGVyIiwidXBkYXRlUGx1Z2lucyIsInN0eWxlTW9kdWxlcyIsInNob3dBbm5vdW5jZW1lbnRzIiwiZG9jVmlld1VwZGF0ZSIsImxpc3RlbmVyIiwibmV3U3RhdGUiLCJoYWRGb2N1cyIsInByZXZTcGVjcyIsInNwZWNzIiwibmV3UGx1Z2lucyIsInNET00iLCJ3YXJuIiwibWVhc3VyaW5nIiwiQmFkTWVhc3VyZSIsIndyaXRlIiwibmV3QW5jaG9ySGVpZ2h0IiwidGhlbWVDbGFzc2VzIiwiYXR0cnNGcm9tRmFjZXQiLCJzcGVsbGNoZWNrIiwiYXV0b2NvcnJlY3QiLCJhdXRvY2FwaXRhbGl6ZSIsIndyaXRpbmdzdWdnZXN0aW9ucyIsInRyYW5zbGF0ZSIsImNvbnRlbnRlZGl0YWJsZSIsInJvbGUiLCJjaGFuZ2VkQ29udGVudCIsImNoYW5nZWRFZGl0b3IiLCJhbm5vdW5jZSIsImRpdiIsIm5vbmNlIiwiY3NwTm9uY2UiLCJtb3VudCIsInJldmVyc2UiLCJyZWFkTWVhc3VyZWQiLCJyZXF1ZXN0Iiwia25vd24iLCJkb2N1bWVudFBhZGRpbmciLCJ2aWV3cG9ydExpbmVCbG9ja3MiLCJtb3ZlQnlHcm91cCIsImluaXRpYWwiLCJNYXhCaWRpTGluZSIsImVudHJ5IiwiZnJlc2giLCJzZXRSb290Iiwic2Nyb2xsU25hcHNob3QiLCJzZXRUYWJGb2N1c01vZGUiLCJwcmVmaXgiLCJkYXJrIiwiYmFzZVRoZW1lIiwibG93ZXN0IiwiZmluZEZyb21ET00iLCJxdWVyeVNlbGVjdG9yIiwiY2FjaGUiLCJsYXN0RGlyIiwic291cmNlcyIsImN1cnJlbnRQbGF0Zm9ybSIsIm5vcm1hbGl6ZUtleU5hbWUiLCJwYXJ0cyIsImFsdCIsImN0cmwiLCJtZXRhIiwibW9kIiwibW9kaWZpZXJzIiwiaGFuZGxlS2V5RXZlbnRzIiwiZGVmYXVsdCIsImdldEtleW1hcCIsImtleW1hcCIsImVuYWJsZXMiLCJLZXltYXBzIiwiV2Vha01hcCIsImJpbmRpbmdzIiwiYnVpbGRLZXltYXAiLCJyZWR1Y2UiLCJydW5TY29wZUhhbmRsZXJzIiwic2NvcGUiLCJzdG9yZWRQcmVmaXgiLCJQcmVmaXhUaW1lb3V0IiwiYm91bmQiLCJpc1ByZWZpeCIsImNoZWNrUHJlZml4IiwiY29tbWFuZCIsInN0b3BQcm9wYWdhdGlvbiIsInNjb3BlT2JqIiwiayIsIm91ck9iaiIsImZ1bGwiLCJiaW5kaW5nIiwiX2FueSIsImFueSIsImN1cnJlbnRLZXlFdmVudCIsImNoYXJDb2RlIiwiaXNDaGFyIiwicHJldmVudGVkIiwicmFuIiwicnVuRm9yIiwiY21kIiwiYmFzZU5hbWUiLCJzaGlmdE5hbWUiLCJSZWN0YW5nbGVNYXJrZXIiLCJmb3JSYW5nZSIsImdldEJhc2UiLCJyZWN0YW5nbGVzRm9yUmFuZ2UiLCJ3cmFwcGVkTGluZSIsImxpbmVFbHQiLCJsZWZ0U2lkZSIsInBhZGRpbmdMZWZ0IiwidGV4dEluZGVudCIsInJpZ2h0U2lkZSIsInBhZGRpbmdSaWdodCIsInN0YXJ0QmxvY2siLCJlbmRCbG9jayIsInZpc3VhbFN0YXJ0IiwidmlzdWFsRW5kIiwicGllY2VzIiwiZHJhd0ZvckxpbmUiLCJkcmF3Rm9yV2lkZ2V0IiwicGllY2UiLCJob3Jpem9udGFsIiwiYWRkU3BhbiIsImZyb21PcGVuIiwidG9PcGVuIiwiZnJvbUNvb3JkcyIsInRvQ29vcmRzIiwiZW5kUG9zIiwiZG9jTGluZSIsInNwYW5Gcm9tIiwic3BhblRvIiwic2FtZU1hcmtlciIsIkxheWVyVmlldyIsImxheWVyIiwiZHJhd24iLCJzZXRPcmRlciIsImxheWVyT3JkZXIiLCJ1cGRhdGVPbkRvY1ZpZXdVcGRhdGUiLCJtYXJrZXJzIiwidHJhbnNmb3JtIiwib2xkSSIsIm1hcmtlciIsInNlbGVjdGlvbkNvbmZpZyIsImNvbmZpZ3MiLCJjdXJzb3JCbGlua1JhdGUiLCJkcmF3UmFuZ2VDdXJzb3IiLCJkcmF3U2VsZWN0aW9uIiwiY3Vyc29yTGF5ZXIiLCJzZWxlY3Rpb25MYXllciIsImhpZGVOYXRpdmVTZWxlY3Rpb24iLCJnZXREcmF3U2VsZWN0aW9uQ29uZmlnIiwiY29uZmlnQ2hhbmdlZCIsImNvbmYiLCJjdXJzb3JzIiwicHJpbSIsImFuaW1hdGlvbk5hbWUiLCJjb25mQ2hhbmdlIiwic2V0QmxpbmtSYXRlIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJoaWdoZXN0Iiwic2V0RHJvcEN1cnNvclBvcyIsIm1hcHBpbmciLCJkcm9wQ3Vyc29yUG9zIiwiZHJhd0Ryb3BDdXJzb3IiLCJyZWFkUG9zIiwiZHJhd0N1cnNvciIsImN1cnNvclBvcyIsImZpZWxkIiwib3V0ZXIiLCJzZXREcm9wUG9zIiwiZHJhZ292ZXIiLCJkcmFnbGVhdmUiLCJyZWxhdGVkVGFyZ2V0IiwiZHJvcEN1cnNvciIsIml0ZXJNYXRjaGVzIiwibGFzdEluZGV4IiwiaXRlclJhbmdlIiwibWF0Y2hSYW5nZXMiLCJtYXhMZW5ndGgiLCJ2aXNpYmxlIiwiTWF0Y2hEZWNvcmF0b3IiLCJyZWdleHAiLCJkZWNvcmF0aW9uIiwiZGVjb3JhdGUiLCJib3VuZGFyeSIsImdsb2JhbCIsImFkZE1hdGNoIiwibWF0Y2giLCJfdmlldyIsImNyZWF0ZURlY28iLCJjaGFuZ2VGcm9tIiwiY2hhbmdlVG8iLCJfZiIsIl90IiwidXBkYXRlUmFuZ2UiLCJ1cGRhdGVGcm9tIiwidXBkYXRlVG8iLCJmcm9tTGluZSIsInRvTGluZSIsImZpbHRlckZyb20iLCJmaWx0ZXJUbyIsIlVuaWNvZGVSZWdleHBTdXBwb3J0IiwidW5pY29kZSIsIlNwZWNpYWxzIiwiUmVnRXhwIiwiTmFtZXMiLCJfc3VwcG9ydHNUYWJTaXplIiwic3VwcG9ydHNUYWJTaXplIiwic3R5bGVzIiwiTW96VGFiU2l6ZSIsInNwZWNpYWxDaGFyQ29uZmlnIiwicmVuZGVyIiwic3BlY2lhbENoYXJzIiwiYWRkU3BlY2lhbENoYXJzIiwicmVwbGFjZVRhYnMiLCJoaWdobGlnaHRTcGVjaWFsQ2hhcnMiLCJzcGVjaWFsQ2hhclBsdWdpbiIsIl9wbHVnaW4iLCJkZWNvcmF0aW9uQ2FjaGUiLCJkZWNvcmF0b3IiLCJtYWtlRGVjb3JhdG9yIiwiY29sIiwiVGFiV2lkZ2V0IiwiU3BlY2lhbENoYXJXaWRnZXQiLCJEZWZhdWx0UGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlciQxIiwiZnJvbUNoYXJDb2RlIiwicGgiLCJkZXNjIiwicGhyYXNlIiwidGl0bGUiLCJzY3JvbGxQYXN0RW5kIiwiaGlnaGxpZ2h0QWN0aXZlTGluZSIsImFjdGl2ZUxpbmVIaWdobGlnaHRlciIsImxpbmVEZWNvIiwiZ2V0RGVjbyIsImxhc3RMaW5lU3RhcnQiLCJQbGFjZWhvbGRlciIsIndyYXAiLCJjbG9uZU5vZGUiLCJwbGFjZWhvbGRlciIsIk1heE9mZiIsInJlY3RhbmdsZUZvciIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJzdGFydE9mZiIsImVuZE9mZiIsInN0YXJ0Q29sIiwiZW5kQ29sIiwiYWJzb2x1dGVDb2x1bW4iLCJnZXRQb3MiLCJyZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSIsIm5ld1N0YXJ0IiwibmV3TGluZSIsIl9leHRlbmQiLCJyZWN0YW5ndWxhclNlbGVjdGlvbiIsImV2ZW50RmlsdGVyIiwiQWx0IiwiQ29udHJvbCIsIlNoaWZ0IiwiTWV0YSIsInNob3dDcm9zc2hhaXIiLCJjcm9zc2hhaXJDdXJzb3IiLCJnZXR0ZXIiLCJpc0Rvd24iLCJrZXl1cCIsIm1vdXNlbW92ZSIsIk91dHNpZGUiLCJUb29sdGlwVmlld01hbmFnZXIiLCJjcmVhdGVUb29sdGlwVmlldyIsInJlbW92ZVRvb2x0aXBWaWV3IiwidG9vbHRpcHMiLCJ0b29sdGlwVmlld3MiLCJuZXdBYm92ZSIsInRpcCIsInRvb2x0aXBWaWV3IiwidG9vbHRpcENvbmZpZyIsIndpbmRvd1NwYWNlIiwiZG9jRWx0IiwidG9vbHRpcFNwYWNlIiwia25vd25IZWlnaHQiLCJ0b29sdGlwUGx1Z2luIiwibWFkZUFic29sdXRlIiwibGFzdFRyYW5zYWN0aW9uIiwibWVhc3VyZVRpbWVvdXQiLCJjbGFzc2VzIiwiY3JlYXRlQ29udGFpbmVyIiwicmVhZE1lYXN1cmUiLCJ3cml0ZU1lYXN1cmUiLCJyZXNpemVPYnNlcnZlciIsIm1lYXN1cmVTb29uIiwibWFuYWdlciIsInNob3dUb29sdGlwIiwiY3JlYXRlVG9vbHRpcCIsInVub2JzZXJ2ZSIsImludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZUludGVyc2VjdGlvbiIsIm1heWJlTWVhc3VyZSIsImNvbnRhaW5lciIsInRvb2x0aXAiLCJzaG91bGRNZWFzdXJlIiwibmV3Q29uZmlnIiwiYXJyb3ciLCJtYWtlQWJzb2x1dGUiLCJ0diIsImdldENvb3JkcyIsInNwYWNlIiwib3RoZXJzIiwidFZpZXciLCJhcnJvd0hlaWdodCIsIm5vT2Zmc2V0Iiwic3RyaWN0U2lkZSIsInNwYWNlVmVydCIsInJlc2l6ZSIsIm92ZXJsYXAiLCJzZXRMZWZ0U3R5bGUiLCJhcnJvd0xlZnQiLCJ0b2dnbGUiLCJwb3NpdGlvbmVkIiwiaXNOYU4iLCJib3JkZXJSaWdodCIsImJvcmRlclRvcENvbG9yIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJzaG93SG92ZXJUb29sdGlwIiwiaW5wdXRzIiwiSG92ZXJUb29sdGlwSG9zdCIsIm1vdW50ZWQiLCJjcmVhdGVIb3N0ZWRWaWV3IiwiaG9zdGVkVmlldyIsInBhc3NQcm9wIiwiZ2l2ZW4iLCJzaG93SG92ZXJUb29sdGlwSG9zdCIsImNvbXB1dGUiLCJIb3ZlclBsdWdpbiIsInNldEhvdmVyIiwiaG92ZXJUaW1lIiwiaG92ZXJUaW1lb3V0IiwicmVzdGFydFRpbWVvdXQiLCJsYXN0TW92ZSIsInRpbWUiLCJjaGVja0hvdmVyIiwibW91c2VsZWF2ZSIsInN0YXJ0SG92ZXIiLCJob3ZlcmVkIiwicG9zQ29vcmRzIiwiYmlkaSIsInJ0bCIsImZpbmRJbmRleCIsImlzSW5Ub29sdGlwIiwiaXNPdmVyUmFuZ2UiLCJpblRvb2x0aXAiLCJ3YXRjaFRvb2x0aXBMZWF2ZSIsIndhdGNoIiwidG9vbHRpcE1hcmdpbiIsImFycm93UmVjdCIsImRvY0JvdHRvbSIsImhvdmVyVG9vbHRpcCIsImhvdmVyU3RhdGUiLCJoaWRlT25DaGFuZ2UiLCJoaWRlT24iLCJhc3NpZ24iLCJjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCIsImdldFRvb2x0aXAiLCJoYXNIb3ZlclRvb2x0aXBzIiwiY2xvc2VIb3ZlclRvb2x0aXBzIiwicmVwb3NpdGlvblRvb2x0aXBzIiwicGFuZWxDb25maWciLCJ0b3BDb250YWluZXIiLCJib3R0b21Db250YWluZXIiLCJwYW5lbHMiLCJnZXRQYW5lbCIsInBhbmVsIiwicGFuZWxQbHVnaW4iLCJzaG93UGFuZWwiLCJQYW5lbEdyb3VwIiwic3luY0NsYXNzZXMiLCJzY3JvbGxNYXJnaW4iLCJzeW5jRE9NIiwiY3VyRE9NIiwicm0iLCJzaG93RGlhbG9nIiwicHJvbWlzZSIsInBhbmVsQ3RvciIsImNyZWF0ZURpYWxvZyIsImRpYWxvZ0ZpZWxkIiwib3BlbkRpYWxvZ0VmZmVjdCIsImFwcGVuZENvbmZpZyIsImluaXQiLCJjbG9zZSIsImNsb3NlRGlhbG9nRWZmZWN0IiwiZm9ybSIsInF1ZXVlTWljcm90YXNrIiwiZ2V0RGlhbG9nIiwiZGlhbG9ncyIsImNvbXB1dGVOIiwibGFiZWwiLCJzdWJtaXRMYWJlbCIsImZvcm1zIiwicXVlcnlTZWxlY3RvckFsbCIsIm9uY2xpY2siLCJHdXR0ZXJNYXJrZXIiLCJlbGVtZW50Q2xhc3MiLCJndXR0ZXJMaW5lQ2xhc3MiLCJndXR0ZXJXaWRnZXRDbGFzcyIsImRlZmF1bHRzIiwicmVuZGVyRW1wdHlFbGVtZW50cyIsImVsZW1lbnRTdHlsZSIsImxpbmVNYXJrZXIiLCJ3aWRnZXRNYXJrZXIiLCJsaW5lTWFya2VyQ2hhbmdlIiwiaW5pdGlhbFNwYWNlciIsInVwZGF0ZVNwYWNlciIsImFjdGl2ZUd1dHRlcnMiLCJndXR0ZXIiLCJndXR0ZXJzIiwidW5maXhHdXR0ZXJzIiwiZ3V0dGVyVmlldyIsImZpeGVkIiwiZG9tQWZ0ZXIiLCJwcmV2Vmlld3BvcnQiLCJTaW5nbGVHdXR0ZXJWaWV3IiwiZ2V0RE9NQWZ0ZXIiLCJzeW5jR3V0dGVycyIsInVwZGF0ZUd1dHRlcnMiLCJ2cEEiLCJ2cEIiLCJ2cE92ZXJsYXAiLCJkZXRhY2giLCJsaW5lQ2xhc3NlcyIsImNsYXNzU2V0IiwiY29udGV4dHMiLCJVcGRhdGVDb250ZXh0IiwiYWR2YW5jZUN1cnNvciIsImN4IiwiYXNBcnJheSIsImNvbGxlY3QiLCJhZGRFbGVtZW50IiwiZWxlbWVudHMiLCJuZXdFbHQiLCJHdXR0ZXJFbGVtZW50IiwiZXh0cmFNYXJrZXJzIiwibG9jYWxNYXJrZXJzIiwiZm9yTGluZSIsInNwYWNlciIsInByb3AiLCJwcmV2TWFya2VycyIsInNhbWVNYXJrZXJzIiwic2V0TWFya2VycyIsImRvbVBvcyIsImlOZXciLCJpT2xkIiwic2tpcFRvIiwibWF0Y2hlZCIsImxpbmVOdW1iZXJNYXJrZXJzIiwibGluZU51bWJlcldpZGdldE1hcmtlciIsImxpbmVOdW1iZXJDb25maWciLCJmb3JtYXROdW1iZXIiLCJOdW1iZXJNYXJrZXIiLCJsaW5lTnVtYmVyR3V0dGVyIiwibWF4TGluZU51bWJlciIsImxpbmVOdW1iZXJzIiwiYWN0aXZlTGluZUd1dHRlck1hcmtlciIsImFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciIsImhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIiLCJtYXRjaGVyIiwidSIsInRhYkRlY28iLCJzcGFjZURlY28iLCJ3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIiLCJoaWdobGlnaHRXaGl0ZXNwYWNlIiwidHJhaWxpbmdIaWdobGlnaHRlciIsImhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSIsIl9fdGVzdCIsImdldEhlaWdodENoYW5nZUZsYWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/view/dist/index.js\n");

/***/ })

};
;